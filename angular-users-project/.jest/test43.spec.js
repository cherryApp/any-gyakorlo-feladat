(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from2, except, desc) => {
    if (from2 && typeof from2 === "object" || typeof from2 === "function") {
      for (let key of __getOwnPropNames(from2))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __decorateClass = (decorators, target, key, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result)
      __defProp(target, key, result);
    return result;
  };
  var __decorateParam = (index, decorator) => (target, key) => decorator(target, key, index);

  // node_modules/rxjs/node_modules/tslib/tslib.js
  var require_tslib = __commonJS({
    "node_modules/rxjs/node_modules/tslib/tslib.js"(exports, module) {
      var __extends2;
      var __assign2;
      var __rest2;
      var __decorate2;
      var __param2;
      var __metadata2;
      var __awaiter2;
      var __generator2;
      var __exportStar2;
      var __values2;
      var __read2;
      var __spread2;
      var __spreadArrays2;
      var __spreadArray2;
      var __await2;
      var __asyncGenerator2;
      var __asyncDelegator2;
      var __asyncValues2;
      var __makeTemplateObject2;
      var __importStar2;
      var __importDefault2;
      var __classPrivateFieldGet2;
      var __classPrivateFieldSet2;
      var __createBinding2;
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module === "object" && typeof module.exports === "object") {
          factory(createExporter(root, createExporter(module.exports)));
        } else {
          factory(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (Object.prototype.hasOwnProperty.call(b, p))
              d[p] = b[p];
        };
        __extends2 = function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign2 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        __rest2 = function(s, e) {
          var t = {};
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
              t[p] = s[p];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
            }
          return t;
        };
        __decorate2 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param2 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata2 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter2 = function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator2 = function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __exportStar2 = function(m, o) {
          for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
              __createBinding2(o, m, p);
        };
        __createBinding2 = Object.create ? function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          Object.defineProperty(o, k2, { enumerable: true, get: function() {
            return m[k];
          } });
        } : function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        __values2 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read2 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error3) {
            e = { error: error3 };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread2 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read2(arguments[i]));
          return ar;
        };
        __spreadArrays2 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __spreadArray2 = function(to, from2) {
          for (var i = 0, il = from2.length, j = to.length; i < il; i++, j++)
            to[j] = from2[i];
          return to;
        };
        __await2 = function(v) {
          return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
        };
        __asyncGenerator2 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r) {
            r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator2 = function(o) {
          var i, p;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p = !p) ? { value: __await2(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues2 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject2 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        var __setModuleDefault = Object.create ? function(o, v) {
          Object.defineProperty(o, "default", { enumerable: true, value: v });
        } : function(o, v) {
          o["default"] = v;
        };
        __importStar2 = function(mod) {
          if (mod && mod.__esModule)
            return mod;
          var result = {};
          if (mod != null) {
            for (var k in mod)
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                __createBinding2(result, mod, k);
          }
          __setModuleDefault(result, mod);
          return result;
        };
        __importDefault2 = function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        __classPrivateFieldGet2 = function(receiver, privateMap) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
          }
          return privateMap.get(receiver);
        };
        __classPrivateFieldSet2 = function(receiver, privateMap, value) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
          }
          privateMap.set(receiver, value);
          return value;
        };
        exporter("__extends", __extends2);
        exporter("__assign", __assign2);
        exporter("__rest", __rest2);
        exporter("__decorate", __decorate2);
        exporter("__param", __param2);
        exporter("__metadata", __metadata2);
        exporter("__awaiter", __awaiter2);
        exporter("__generator", __generator2);
        exporter("__exportStar", __exportStar2);
        exporter("__createBinding", __createBinding2);
        exporter("__values", __values2);
        exporter("__read", __read2);
        exporter("__spread", __spread2);
        exporter("__spreadArrays", __spreadArrays2);
        exporter("__spreadArray", __spreadArray2);
        exporter("__await", __await2);
        exporter("__asyncGenerator", __asyncGenerator2);
        exporter("__asyncDelegator", __asyncDelegator2);
        exporter("__asyncValues", __asyncValues2);
        exporter("__makeTemplateObject", __makeTemplateObject2);
        exporter("__importStar", __importStar2);
        exporter("__importDefault", __importDefault2);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
      });
    }
  });

  // node_modules/zone.js/fesm2015/zone.js
  (function(global2) {
    const performance = global2["performance"];
    function mark(name) {
      performance && performance["mark"] && performance["mark"](name);
    }
    function performanceMeasure(name, label) {
      performance && performance["measure"] && performance["measure"](name, label);
    }
    mark("Zone");
    const symbolPrefix = global2["__Zone_symbol_prefix"] || "__zone_symbol__";
    function __symbol__(name) {
      return symbolPrefix + name;
    }
    const checkDuplicate = global2[__symbol__("forceDuplicateZoneCheck")] === true;
    if (global2["Zone"]) {
      if (checkDuplicate || typeof global2["Zone"].__symbol__ !== "function") {
        throw new Error("Zone already loaded.");
      } else {
        return global2["Zone"];
      }
    }
    class Zone2 {
      constructor(parent, zoneSpec) {
        this._parent = parent;
        this._name = zoneSpec ? zoneSpec.name || "unnamed" : "<root>";
        this._properties = zoneSpec && zoneSpec.properties || {};
        this._zoneDelegate = new _ZoneDelegate(this, this._parent && this._parent._zoneDelegate, zoneSpec);
      }
      static assertZonePatched() {
        if (global2["Promise"] !== patches["ZoneAwarePromise"]) {
          throw new Error("Zone.js has detected that ZoneAwarePromise `(window|global).Promise` has been overwritten.\nMost likely cause is that a Promise polyfill has been loaded after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. If you must load one, do so before loading zone.js.)");
        }
      }
      static get root() {
        let zone = Zone2.current;
        while (zone.parent) {
          zone = zone.parent;
        }
        return zone;
      }
      static get current() {
        return _currentZoneFrame.zone;
      }
      static get currentTask() {
        return _currentTask;
      }
      static __load_patch(name, fn2, ignoreDuplicate = false) {
        if (patches.hasOwnProperty(name)) {
          if (!ignoreDuplicate && checkDuplicate) {
            throw Error("Already loaded patch: " + name);
          }
        } else if (!global2["__Zone_disable_" + name]) {
          const perfName = "Zone:" + name;
          mark(perfName);
          patches[name] = fn2(global2, Zone2, _api);
          performanceMeasure(perfName, perfName);
        }
      }
      get parent() {
        return this._parent;
      }
      get name() {
        return this._name;
      }
      get(key) {
        const zone = this.getZoneWith(key);
        if (zone)
          return zone._properties[key];
      }
      getZoneWith(key) {
        let current = this;
        while (current) {
          if (current._properties.hasOwnProperty(key)) {
            return current;
          }
          current = current._parent;
        }
        return null;
      }
      fork(zoneSpec) {
        if (!zoneSpec)
          throw new Error("ZoneSpec required!");
        return this._zoneDelegate.fork(this, zoneSpec);
      }
      wrap(callback, source) {
        if (typeof callback !== "function") {
          throw new Error("Expecting function got: " + callback);
        }
        const _callback = this._zoneDelegate.intercept(this, callback, source);
        const zone = this;
        return function() {
          return zone.runGuarded(_callback, this, arguments, source);
        };
      }
      run(callback, applyThis, applyArgs, source) {
        _currentZoneFrame = { parent: _currentZoneFrame, zone: this };
        try {
          return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);
        } finally {
          _currentZoneFrame = _currentZoneFrame.parent;
        }
      }
      runGuarded(callback, applyThis = null, applyArgs, source) {
        _currentZoneFrame = { parent: _currentZoneFrame, zone: this };
        try {
          try {
            return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);
          } catch (error3) {
            if (this._zoneDelegate.handleError(this, error3)) {
              throw error3;
            }
          }
        } finally {
          _currentZoneFrame = _currentZoneFrame.parent;
        }
      }
      runTask(task, applyThis, applyArgs) {
        if (task.zone != this) {
          throw new Error("A task can only be run in the zone of creation! (Creation: " + (task.zone || NO_ZONE).name + "; Execution: " + this.name + ")");
        }
        if (task.state === notScheduled && (task.type === eventTask || task.type === macroTask)) {
          return;
        }
        const reEntryGuard = task.state != running;
        reEntryGuard && task._transitionTo(running, scheduled2);
        task.runCount++;
        const previousTask = _currentTask;
        _currentTask = task;
        _currentZoneFrame = { parent: _currentZoneFrame, zone: this };
        try {
          if (task.type == macroTask && task.data && !task.data.isPeriodic) {
            task.cancelFn = void 0;
          }
          try {
            return this._zoneDelegate.invokeTask(this, task, applyThis, applyArgs);
          } catch (error3) {
            if (this._zoneDelegate.handleError(this, error3)) {
              throw error3;
            }
          }
        } finally {
          if (task.state !== notScheduled && task.state !== unknown) {
            if (task.type == eventTask || task.data && task.data.isPeriodic) {
              reEntryGuard && task._transitionTo(scheduled2, running);
            } else {
              task.runCount = 0;
              this._updateTaskCount(task, -1);
              reEntryGuard && task._transitionTo(notScheduled, running, notScheduled);
            }
          }
          _currentZoneFrame = _currentZoneFrame.parent;
          _currentTask = previousTask;
        }
      }
      scheduleTask(task) {
        if (task.zone && task.zone !== this) {
          let newZone = this;
          while (newZone) {
            if (newZone === task.zone) {
              throw Error(`can not reschedule task to ${this.name} which is descendants of the original zone ${task.zone.name}`);
            }
            newZone = newZone.parent;
          }
        }
        task._transitionTo(scheduling, notScheduled);
        const zoneDelegates = [];
        task._zoneDelegates = zoneDelegates;
        task._zone = this;
        try {
          task = this._zoneDelegate.scheduleTask(this, task);
        } catch (err) {
          task._transitionTo(unknown, scheduling, notScheduled);
          this._zoneDelegate.handleError(this, err);
          throw err;
        }
        if (task._zoneDelegates === zoneDelegates) {
          this._updateTaskCount(task, 1);
        }
        if (task.state == scheduling) {
          task._transitionTo(scheduled2, scheduling);
        }
        return task;
      }
      scheduleMicroTask(source, callback, data, customSchedule) {
        return this.scheduleTask(new ZoneTask(microTask, source, callback, data, customSchedule, void 0));
      }
      scheduleMacroTask(source, callback, data, customSchedule, customCancel) {
        return this.scheduleTask(new ZoneTask(macroTask, source, callback, data, customSchedule, customCancel));
      }
      scheduleEventTask(source, callback, data, customSchedule, customCancel) {
        return this.scheduleTask(new ZoneTask(eventTask, source, callback, data, customSchedule, customCancel));
      }
      cancelTask(task) {
        if (task.zone != this)
          throw new Error("A task can only be cancelled in the zone of creation! (Creation: " + (task.zone || NO_ZONE).name + "; Execution: " + this.name + ")");
        task._transitionTo(canceling, scheduled2, running);
        try {
          this._zoneDelegate.cancelTask(this, task);
        } catch (err) {
          task._transitionTo(unknown, canceling);
          this._zoneDelegate.handleError(this, err);
          throw err;
        }
        this._updateTaskCount(task, -1);
        task._transitionTo(notScheduled, canceling);
        task.runCount = 0;
        return task;
      }
      _updateTaskCount(task, count) {
        const zoneDelegates = task._zoneDelegates;
        if (count == -1) {
          task._zoneDelegates = null;
        }
        for (let i = 0; i < zoneDelegates.length; i++) {
          zoneDelegates[i]._updateTaskCount(task.type, count);
        }
      }
    }
    Zone2.__symbol__ = __symbol__;
    const DELEGATE_ZS = {
      name: "",
      onHasTask: (delegate, _, target, hasTaskState) => delegate.hasTask(target, hasTaskState),
      onScheduleTask: (delegate, _, target, task) => delegate.scheduleTask(target, task),
      onInvokeTask: (delegate, _, target, task, applyThis, applyArgs) => delegate.invokeTask(target, task, applyThis, applyArgs),
      onCancelTask: (delegate, _, target, task) => delegate.cancelTask(target, task)
    };
    class _ZoneDelegate {
      constructor(zone, parentDelegate, zoneSpec) {
        this._taskCounts = { "microTask": 0, "macroTask": 0, "eventTask": 0 };
        this.zone = zone;
        this._parentDelegate = parentDelegate;
        this._forkZS = zoneSpec && (zoneSpec && zoneSpec.onFork ? zoneSpec : parentDelegate._forkZS);
        this._forkDlgt = zoneSpec && (zoneSpec.onFork ? parentDelegate : parentDelegate._forkDlgt);
        this._forkCurrZone = zoneSpec && (zoneSpec.onFork ? this.zone : parentDelegate._forkCurrZone);
        this._interceptZS = zoneSpec && (zoneSpec.onIntercept ? zoneSpec : parentDelegate._interceptZS);
        this._interceptDlgt = zoneSpec && (zoneSpec.onIntercept ? parentDelegate : parentDelegate._interceptDlgt);
        this._interceptCurrZone = zoneSpec && (zoneSpec.onIntercept ? this.zone : parentDelegate._interceptCurrZone);
        this._invokeZS = zoneSpec && (zoneSpec.onInvoke ? zoneSpec : parentDelegate._invokeZS);
        this._invokeDlgt = zoneSpec && (zoneSpec.onInvoke ? parentDelegate : parentDelegate._invokeDlgt);
        this._invokeCurrZone = zoneSpec && (zoneSpec.onInvoke ? this.zone : parentDelegate._invokeCurrZone);
        this._handleErrorZS = zoneSpec && (zoneSpec.onHandleError ? zoneSpec : parentDelegate._handleErrorZS);
        this._handleErrorDlgt = zoneSpec && (zoneSpec.onHandleError ? parentDelegate : parentDelegate._handleErrorDlgt);
        this._handleErrorCurrZone = zoneSpec && (zoneSpec.onHandleError ? this.zone : parentDelegate._handleErrorCurrZone);
        this._scheduleTaskZS = zoneSpec && (zoneSpec.onScheduleTask ? zoneSpec : parentDelegate._scheduleTaskZS);
        this._scheduleTaskDlgt = zoneSpec && (zoneSpec.onScheduleTask ? parentDelegate : parentDelegate._scheduleTaskDlgt);
        this._scheduleTaskCurrZone = zoneSpec && (zoneSpec.onScheduleTask ? this.zone : parentDelegate._scheduleTaskCurrZone);
        this._invokeTaskZS = zoneSpec && (zoneSpec.onInvokeTask ? zoneSpec : parentDelegate._invokeTaskZS);
        this._invokeTaskDlgt = zoneSpec && (zoneSpec.onInvokeTask ? parentDelegate : parentDelegate._invokeTaskDlgt);
        this._invokeTaskCurrZone = zoneSpec && (zoneSpec.onInvokeTask ? this.zone : parentDelegate._invokeTaskCurrZone);
        this._cancelTaskZS = zoneSpec && (zoneSpec.onCancelTask ? zoneSpec : parentDelegate._cancelTaskZS);
        this._cancelTaskDlgt = zoneSpec && (zoneSpec.onCancelTask ? parentDelegate : parentDelegate._cancelTaskDlgt);
        this._cancelTaskCurrZone = zoneSpec && (zoneSpec.onCancelTask ? this.zone : parentDelegate._cancelTaskCurrZone);
        this._hasTaskZS = null;
        this._hasTaskDlgt = null;
        this._hasTaskDlgtOwner = null;
        this._hasTaskCurrZone = null;
        const zoneSpecHasTask = zoneSpec && zoneSpec.onHasTask;
        const parentHasTask = parentDelegate && parentDelegate._hasTaskZS;
        if (zoneSpecHasTask || parentHasTask) {
          this._hasTaskZS = zoneSpecHasTask ? zoneSpec : DELEGATE_ZS;
          this._hasTaskDlgt = parentDelegate;
          this._hasTaskDlgtOwner = this;
          this._hasTaskCurrZone = zone;
          if (!zoneSpec.onScheduleTask) {
            this._scheduleTaskZS = DELEGATE_ZS;
            this._scheduleTaskDlgt = parentDelegate;
            this._scheduleTaskCurrZone = this.zone;
          }
          if (!zoneSpec.onInvokeTask) {
            this._invokeTaskZS = DELEGATE_ZS;
            this._invokeTaskDlgt = parentDelegate;
            this._invokeTaskCurrZone = this.zone;
          }
          if (!zoneSpec.onCancelTask) {
            this._cancelTaskZS = DELEGATE_ZS;
            this._cancelTaskDlgt = parentDelegate;
            this._cancelTaskCurrZone = this.zone;
          }
        }
      }
      fork(targetZone, zoneSpec) {
        return this._forkZS ? this._forkZS.onFork(this._forkDlgt, this.zone, targetZone, zoneSpec) : new Zone2(targetZone, zoneSpec);
      }
      intercept(targetZone, callback, source) {
        return this._interceptZS ? this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, targetZone, callback, source) : callback;
      }
      invoke(targetZone, callback, applyThis, applyArgs, source) {
        return this._invokeZS ? this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, targetZone, callback, applyThis, applyArgs, source) : callback.apply(applyThis, applyArgs);
      }
      handleError(targetZone, error3) {
        return this._handleErrorZS ? this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, targetZone, error3) : true;
      }
      scheduleTask(targetZone, task) {
        let returnTask = task;
        if (this._scheduleTaskZS) {
          if (this._hasTaskZS) {
            returnTask._zoneDelegates.push(this._hasTaskDlgtOwner);
          }
          returnTask = this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, targetZone, task);
          if (!returnTask)
            returnTask = task;
        } else {
          if (task.scheduleFn) {
            task.scheduleFn(task);
          } else if (task.type == microTask) {
            scheduleMicroTask4(task);
          } else {
            throw new Error("Task is missing scheduleFn.");
          }
        }
        return returnTask;
      }
      invokeTask(targetZone, task, applyThis, applyArgs) {
        return this._invokeTaskZS ? this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, targetZone, task, applyThis, applyArgs) : task.callback.apply(applyThis, applyArgs);
      }
      cancelTask(targetZone, task) {
        let value;
        if (this._cancelTaskZS) {
          value = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, targetZone, task);
        } else {
          if (!task.cancelFn) {
            throw Error("Task is not cancelable");
          }
          value = task.cancelFn(task);
        }
        return value;
      }
      hasTask(targetZone, isEmpty) {
        try {
          this._hasTaskZS && this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, targetZone, isEmpty);
        } catch (err) {
          this.handleError(targetZone, err);
        }
      }
      _updateTaskCount(type, count) {
        const counts = this._taskCounts;
        const prev = counts[type];
        const next = counts[type] = prev + count;
        if (next < 0) {
          throw new Error("More tasks executed then were scheduled.");
        }
        if (prev == 0 || next == 0) {
          const isEmpty = {
            microTask: counts["microTask"] > 0,
            macroTask: counts["macroTask"] > 0,
            eventTask: counts["eventTask"] > 0,
            change: type
          };
          this.hasTask(this.zone, isEmpty);
        }
      }
    }
    class ZoneTask {
      constructor(type, source, callback, options, scheduleFn, cancelFn) {
        this._zone = null;
        this.runCount = 0;
        this._zoneDelegates = null;
        this._state = "notScheduled";
        this.type = type;
        this.source = source;
        this.data = options;
        this.scheduleFn = scheduleFn;
        this.cancelFn = cancelFn;
        if (!callback) {
          throw new Error("callback is not defined");
        }
        this.callback = callback;
        const self2 = this;
        if (type === eventTask && options && options.useG) {
          this.invoke = ZoneTask.invokeTask;
        } else {
          this.invoke = function() {
            return ZoneTask.invokeTask.call(global2, self2, this, arguments);
          };
        }
      }
      static invokeTask(task, target, args) {
        if (!task) {
          task = this;
        }
        _numberOfNestedTaskFrames++;
        try {
          task.runCount++;
          return task.zone.runTask(task, target, args);
        } finally {
          if (_numberOfNestedTaskFrames == 1) {
            drainMicroTaskQueue();
          }
          _numberOfNestedTaskFrames--;
        }
      }
      get zone() {
        return this._zone;
      }
      get state() {
        return this._state;
      }
      cancelScheduleRequest() {
        this._transitionTo(notScheduled, scheduling);
      }
      _transitionTo(toState, fromState1, fromState2) {
        if (this._state === fromState1 || this._state === fromState2) {
          this._state = toState;
          if (toState == notScheduled) {
            this._zoneDelegates = null;
          }
        } else {
          throw new Error(`${this.type} '${this.source}': can not transition to '${toState}', expecting state '${fromState1}'${fromState2 ? " or '" + fromState2 + "'" : ""}, was '${this._state}'.`);
        }
      }
      toString() {
        if (this.data && typeof this.data.handleId !== "undefined") {
          return this.data.handleId.toString();
        } else {
          return Object.prototype.toString.call(this);
        }
      }
      toJSON() {
        return {
          type: this.type,
          state: this.state,
          source: this.source,
          zone: this.zone.name,
          runCount: this.runCount
        };
      }
    }
    const symbolSetTimeout = __symbol__("setTimeout");
    const symbolPromise = __symbol__("Promise");
    const symbolThen = __symbol__("then");
    let _microTaskQueue = [];
    let _isDrainingMicrotaskQueue = false;
    let nativeMicroTaskQueuePromise;
    function nativeScheduleMicroTask(func) {
      if (!nativeMicroTaskQueuePromise) {
        if (global2[symbolPromise]) {
          nativeMicroTaskQueuePromise = global2[symbolPromise].resolve(0);
        }
      }
      if (nativeMicroTaskQueuePromise) {
        let nativeThen = nativeMicroTaskQueuePromise[symbolThen];
        if (!nativeThen) {
          nativeThen = nativeMicroTaskQueuePromise["then"];
        }
        nativeThen.call(nativeMicroTaskQueuePromise, func);
      } else {
        global2[symbolSetTimeout](func, 0);
      }
    }
    function scheduleMicroTask4(task) {
      if (_numberOfNestedTaskFrames === 0 && _microTaskQueue.length === 0) {
        nativeScheduleMicroTask(drainMicroTaskQueue);
      }
      task && _microTaskQueue.push(task);
    }
    function drainMicroTaskQueue() {
      if (!_isDrainingMicrotaskQueue) {
        _isDrainingMicrotaskQueue = true;
        while (_microTaskQueue.length) {
          const queue = _microTaskQueue;
          _microTaskQueue = [];
          for (let i = 0; i < queue.length; i++) {
            const task = queue[i];
            try {
              task.zone.runTask(task, null, null);
            } catch (error3) {
              _api.onUnhandledError(error3);
            }
          }
        }
        _api.microtaskDrainDone();
        _isDrainingMicrotaskQueue = false;
      }
    }
    const NO_ZONE = { name: "NO ZONE" };
    const notScheduled = "notScheduled", scheduling = "scheduling", scheduled2 = "scheduled", running = "running", canceling = "canceling", unknown = "unknown";
    const microTask = "microTask", macroTask = "macroTask", eventTask = "eventTask";
    const patches = {};
    const _api = {
      symbol: __symbol__,
      currentZoneFrame: () => _currentZoneFrame,
      onUnhandledError: noop3,
      microtaskDrainDone: noop3,
      scheduleMicroTask: scheduleMicroTask4,
      showUncaughtError: () => !Zone2[__symbol__("ignoreConsoleErrorUncaughtError")],
      patchEventTarget: () => [],
      patchOnProperties: noop3,
      patchMethod: () => noop3,
      bindArguments: () => [],
      patchThen: () => noop3,
      patchMacroTask: () => noop3,
      patchEventPrototype: () => noop3,
      isIEOrEdge: () => false,
      getGlobalObjects: () => void 0,
      ObjectDefineProperty: () => noop3,
      ObjectGetOwnPropertyDescriptor: () => void 0,
      ObjectCreate: () => void 0,
      ArraySlice: () => [],
      patchClass: () => noop3,
      wrapWithCurrentZone: () => noop3,
      filterProperties: () => [],
      attachOriginToPatched: () => noop3,
      _redefineProperty: () => noop3,
      patchCallbacks: () => noop3,
      nativeScheduleMicroTask
    };
    let _currentZoneFrame = { parent: null, zone: new Zone2(null, null) };
    let _currentTask = null;
    let _numberOfNestedTaskFrames = 0;
    function noop3() {
    }
    performanceMeasure("Zone", "Zone");
    return global2["Zone"] = Zone2;
  })(typeof window !== "undefined" && window || typeof self !== "undefined" && self || global);
  var ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var ObjectDefineProperty = Object.defineProperty;
  var ObjectGetPrototypeOf = Object.getPrototypeOf;
  var ObjectCreate = Object.create;
  var ArraySlice = Array.prototype.slice;
  var ADD_EVENT_LISTENER_STR = "addEventListener";
  var REMOVE_EVENT_LISTENER_STR = "removeEventListener";
  var ZONE_SYMBOL_ADD_EVENT_LISTENER = Zone.__symbol__(ADD_EVENT_LISTENER_STR);
  var ZONE_SYMBOL_REMOVE_EVENT_LISTENER = Zone.__symbol__(REMOVE_EVENT_LISTENER_STR);
  var TRUE_STR = "true";
  var FALSE_STR = "false";
  var ZONE_SYMBOL_PREFIX = Zone.__symbol__("");
  function wrapWithCurrentZone(callback, source) {
    return Zone.current.wrap(callback, source);
  }
  function scheduleMacroTaskWithCurrentZone(source, callback, data, customSchedule, customCancel) {
    return Zone.current.scheduleMacroTask(source, callback, data, customSchedule, customCancel);
  }
  var zoneSymbol = Zone.__symbol__;
  var isWindowExists = typeof window !== "undefined";
  var internalWindow = isWindowExists ? window : void 0;
  var _global = isWindowExists && internalWindow || typeof self === "object" && self || global;
  var REMOVE_ATTRIBUTE = "removeAttribute";
  function bindArguments(args, source) {
    for (let i = args.length - 1; i >= 0; i--) {
      if (typeof args[i] === "function") {
        args[i] = wrapWithCurrentZone(args[i], source + "_" + i);
      }
    }
    return args;
  }
  function patchPrototype(prototype, fnNames) {
    const source = prototype.constructor["name"];
    for (let i = 0; i < fnNames.length; i++) {
      const name = fnNames[i];
      const delegate = prototype[name];
      if (delegate) {
        const prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, name);
        if (!isPropertyWritable(prototypeDesc)) {
          continue;
        }
        prototype[name] = ((delegate2) => {
          const patched = function() {
            return delegate2.apply(this, bindArguments(arguments, source + "." + name));
          };
          attachOriginToPatched(patched, delegate2);
          return patched;
        })(delegate);
      }
    }
  }
  function isPropertyWritable(propertyDesc) {
    if (!propertyDesc) {
      return true;
    }
    if (propertyDesc.writable === false) {
      return false;
    }
    return !(typeof propertyDesc.get === "function" && typeof propertyDesc.set === "undefined");
  }
  var isWebWorker = typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
  var isNode = !("nw" in _global) && typeof _global.process !== "undefined" && {}.toString.call(_global.process) === "[object process]";
  var isBrowser = !isNode && !isWebWorker && !!(isWindowExists && internalWindow["HTMLElement"]);
  var isMix = typeof _global.process !== "undefined" && {}.toString.call(_global.process) === "[object process]" && !isWebWorker && !!(isWindowExists && internalWindow["HTMLElement"]);
  var zoneSymbolEventNames$1 = {};
  var wrapFn = function(event) {
    event = event || _global.event;
    if (!event) {
      return;
    }
    let eventNameSymbol = zoneSymbolEventNames$1[event.type];
    if (!eventNameSymbol) {
      eventNameSymbol = zoneSymbolEventNames$1[event.type] = zoneSymbol("ON_PROPERTY" + event.type);
    }
    const target = this || event.target || _global;
    const listener = target[eventNameSymbol];
    let result;
    if (isBrowser && target === internalWindow && event.type === "error") {
      const errorEvent = event;
      result = listener && listener.call(this, errorEvent.message, errorEvent.filename, errorEvent.lineno, errorEvent.colno, errorEvent.error);
      if (result === true) {
        event.preventDefault();
      }
    } else {
      result = listener && listener.apply(this, arguments);
      if (result != void 0 && !result) {
        event.preventDefault();
      }
    }
    return result;
  };
  function patchProperty(obj, prop, prototype) {
    let desc = ObjectGetOwnPropertyDescriptor(obj, prop);
    if (!desc && prototype) {
      const prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, prop);
      if (prototypeDesc) {
        desc = { enumerable: true, configurable: true };
      }
    }
    if (!desc || !desc.configurable) {
      return;
    }
    const onPropPatchedSymbol = zoneSymbol("on" + prop + "patched");
    if (obj.hasOwnProperty(onPropPatchedSymbol) && obj[onPropPatchedSymbol]) {
      return;
    }
    delete desc.writable;
    delete desc.value;
    const originalDescGet = desc.get;
    const originalDescSet = desc.set;
    const eventName = prop.substr(2);
    let eventNameSymbol = zoneSymbolEventNames$1[eventName];
    if (!eventNameSymbol) {
      eventNameSymbol = zoneSymbolEventNames$1[eventName] = zoneSymbol("ON_PROPERTY" + eventName);
    }
    desc.set = function(newValue) {
      let target = this;
      if (!target && obj === _global) {
        target = _global;
      }
      if (!target) {
        return;
      }
      const previousValue = target[eventNameSymbol];
      if (typeof previousValue === "function") {
        target.removeEventListener(eventName, wrapFn);
      }
      originalDescSet && originalDescSet.call(target, null);
      target[eventNameSymbol] = newValue;
      if (typeof newValue === "function") {
        target.addEventListener(eventName, wrapFn, false);
      }
    };
    desc.get = function() {
      let target = this;
      if (!target && obj === _global) {
        target = _global;
      }
      if (!target) {
        return null;
      }
      const listener = target[eventNameSymbol];
      if (listener) {
        return listener;
      } else if (originalDescGet) {
        let value = originalDescGet.call(this);
        if (value) {
          desc.set.call(this, value);
          if (typeof target[REMOVE_ATTRIBUTE] === "function") {
            target.removeAttribute(prop);
          }
          return value;
        }
      }
      return null;
    };
    ObjectDefineProperty(obj, prop, desc);
    obj[onPropPatchedSymbol] = true;
  }
  function patchOnProperties(obj, properties, prototype) {
    if (properties) {
      for (let i = 0; i < properties.length; i++) {
        patchProperty(obj, "on" + properties[i], prototype);
      }
    } else {
      const onProperties = [];
      for (const prop in obj) {
        if (prop.substr(0, 2) == "on") {
          onProperties.push(prop);
        }
      }
      for (let j = 0; j < onProperties.length; j++) {
        patchProperty(obj, onProperties[j], prototype);
      }
    }
  }
  var originalInstanceKey = zoneSymbol("originalInstance");
  function patchClass(className) {
    const OriginalClass = _global[className];
    if (!OriginalClass)
      return;
    _global[zoneSymbol(className)] = OriginalClass;
    _global[className] = function() {
      const a = bindArguments(arguments, className);
      switch (a.length) {
        case 0:
          this[originalInstanceKey] = new OriginalClass();
          break;
        case 1:
          this[originalInstanceKey] = new OriginalClass(a[0]);
          break;
        case 2:
          this[originalInstanceKey] = new OriginalClass(a[0], a[1]);
          break;
        case 3:
          this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2]);
          break;
        case 4:
          this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2], a[3]);
          break;
        default:
          throw new Error("Arg list too long.");
      }
    };
    attachOriginToPatched(_global[className], OriginalClass);
    const instance = new OriginalClass(function() {
    });
    let prop;
    for (prop in instance) {
      if (className === "XMLHttpRequest" && prop === "responseBlob")
        continue;
      (function(prop2) {
        if (typeof instance[prop2] === "function") {
          _global[className].prototype[prop2] = function() {
            return this[originalInstanceKey][prop2].apply(this[originalInstanceKey], arguments);
          };
        } else {
          ObjectDefineProperty(_global[className].prototype, prop2, {
            set: function(fn2) {
              if (typeof fn2 === "function") {
                this[originalInstanceKey][prop2] = wrapWithCurrentZone(fn2, className + "." + prop2);
                attachOriginToPatched(this[originalInstanceKey][prop2], fn2);
              } else {
                this[originalInstanceKey][prop2] = fn2;
              }
            },
            get: function() {
              return this[originalInstanceKey][prop2];
            }
          });
        }
      })(prop);
    }
    for (prop in OriginalClass) {
      if (prop !== "prototype" && OriginalClass.hasOwnProperty(prop)) {
        _global[className][prop] = OriginalClass[prop];
      }
    }
  }
  function patchMethod(target, name, patchFn) {
    let proto = target;
    while (proto && !proto.hasOwnProperty(name)) {
      proto = ObjectGetPrototypeOf(proto);
    }
    if (!proto && target[name]) {
      proto = target;
    }
    const delegateName = zoneSymbol(name);
    let delegate = null;
    if (proto && (!(delegate = proto[delegateName]) || !proto.hasOwnProperty(delegateName))) {
      delegate = proto[delegateName] = proto[name];
      const desc = proto && ObjectGetOwnPropertyDescriptor(proto, name);
      if (isPropertyWritable(desc)) {
        const patchDelegate = patchFn(delegate, delegateName, name);
        proto[name] = function() {
          return patchDelegate(this, arguments);
        };
        attachOriginToPatched(proto[name], delegate);
      }
    }
    return delegate;
  }
  function patchMacroTask(obj, funcName, metaCreator) {
    let setNative = null;
    function scheduleTask(task) {
      const data = task.data;
      data.args[data.cbIdx] = function() {
        task.invoke.apply(this, arguments);
      };
      setNative.apply(data.target, data.args);
      return task;
    }
    setNative = patchMethod(obj, funcName, (delegate) => function(self2, args) {
      const meta = metaCreator(self2, args);
      if (meta.cbIdx >= 0 && typeof args[meta.cbIdx] === "function") {
        return scheduleMacroTaskWithCurrentZone(meta.name, args[meta.cbIdx], meta, scheduleTask);
      } else {
        return delegate.apply(self2, args);
      }
    });
  }
  function attachOriginToPatched(patched, original) {
    patched[zoneSymbol("OriginalDelegate")] = original;
  }
  var isDetectedIEOrEdge = false;
  var ieOrEdge = false;
  function isIE() {
    try {
      const ua = internalWindow.navigator.userAgent;
      if (ua.indexOf("MSIE ") !== -1 || ua.indexOf("Trident/") !== -1) {
        return true;
      }
    } catch (error3) {
    }
    return false;
  }
  function isIEOrEdge() {
    if (isDetectedIEOrEdge) {
      return ieOrEdge;
    }
    isDetectedIEOrEdge = true;
    try {
      const ua = internalWindow.navigator.userAgent;
      if (ua.indexOf("MSIE ") !== -1 || ua.indexOf("Trident/") !== -1 || ua.indexOf("Edge/") !== -1) {
        ieOrEdge = true;
      }
    } catch (error3) {
    }
    return ieOrEdge;
  }
  Zone.__load_patch("ZoneAwarePromise", (global2, Zone2, api) => {
    const ObjectGetOwnPropertyDescriptor2 = Object.getOwnPropertyDescriptor;
    const ObjectDefineProperty2 = Object.defineProperty;
    function readableObjectToString(obj) {
      if (obj && obj.toString === Object.prototype.toString) {
        const className = obj.constructor && obj.constructor.name;
        return (className ? className : "") + ": " + JSON.stringify(obj);
      }
      return obj ? obj.toString() : Object.prototype.toString.call(obj);
    }
    const __symbol__ = api.symbol;
    const _uncaughtPromiseErrors = [];
    const isDisableWrappingUncaughtPromiseRejection = global2[__symbol__("DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION")] === true;
    const symbolPromise = __symbol__("Promise");
    const symbolThen = __symbol__("then");
    const creationTrace2 = "__creationTrace__";
    api.onUnhandledError = (e) => {
      if (api.showUncaughtError()) {
        const rejection = e && e.rejection;
        if (rejection) {
          console.error("Unhandled Promise rejection:", rejection instanceof Error ? rejection.message : rejection, "; Zone:", e.zone.name, "; Task:", e.task && e.task.source, "; Value:", rejection, rejection instanceof Error ? rejection.stack : void 0);
        } else {
          console.error(e);
        }
      }
    };
    api.microtaskDrainDone = () => {
      while (_uncaughtPromiseErrors.length) {
        const uncaughtPromiseError = _uncaughtPromiseErrors.shift();
        try {
          uncaughtPromiseError.zone.runGuarded(() => {
            if (uncaughtPromiseError.throwOriginal) {
              throw uncaughtPromiseError.rejection;
            }
            throw uncaughtPromiseError;
          });
        } catch (error3) {
          handleUnhandledRejection(error3);
        }
      }
    };
    const UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL = __symbol__("unhandledPromiseRejectionHandler");
    function handleUnhandledRejection(e) {
      api.onUnhandledError(e);
      try {
        const handler = Zone2[UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL];
        if (typeof handler === "function") {
          handler.call(this, e);
        }
      } catch (err) {
      }
    }
    function isThenable(value) {
      return value && value.then;
    }
    function forwardResolution(value) {
      return value;
    }
    function forwardRejection(rejection) {
      return ZoneAwarePromise.reject(rejection);
    }
    const symbolState = __symbol__("state");
    const symbolValue = __symbol__("value");
    const symbolFinally = __symbol__("finally");
    const symbolParentPromiseValue = __symbol__("parentPromiseValue");
    const symbolParentPromiseState = __symbol__("parentPromiseState");
    const source = "Promise.then";
    const UNRESOLVED = null;
    const RESOLVED = true;
    const REJECTED = false;
    const REJECTED_NO_CATCH = 0;
    function makeResolver(promise2, state) {
      return (v) => {
        try {
          resolvePromise(promise2, state, v);
        } catch (err) {
          resolvePromise(promise2, false, err);
        }
      };
    }
    const once = function() {
      let wasCalled = false;
      return function wrapper(wrappedFunction) {
        return function() {
          if (wasCalled) {
            return;
          }
          wasCalled = true;
          wrappedFunction.apply(null, arguments);
        };
      };
    };
    const TYPE_ERROR = "Promise resolved with itself";
    const CURRENT_TASK_TRACE_SYMBOL = __symbol__("currentTaskTrace");
    function resolvePromise(promise2, state, value) {
      const onceWrapper = once();
      if (promise2 === value) {
        throw new TypeError(TYPE_ERROR);
      }
      if (promise2[symbolState] === UNRESOLVED) {
        let then = null;
        try {
          if (typeof value === "object" || typeof value === "function") {
            then = value && value.then;
          }
        } catch (err) {
          onceWrapper(() => {
            resolvePromise(promise2, false, err);
          })();
          return promise2;
        }
        if (state !== REJECTED && value instanceof ZoneAwarePromise && value.hasOwnProperty(symbolState) && value.hasOwnProperty(symbolValue) && value[symbolState] !== UNRESOLVED) {
          clearRejectedNoCatch(value);
          resolvePromise(promise2, value[symbolState], value[symbolValue]);
        } else if (state !== REJECTED && typeof then === "function") {
          try {
            then.call(value, onceWrapper(makeResolver(promise2, state)), onceWrapper(makeResolver(promise2, false)));
          } catch (err) {
            onceWrapper(() => {
              resolvePromise(promise2, false, err);
            })();
          }
        } else {
          promise2[symbolState] = state;
          const queue = promise2[symbolValue];
          promise2[symbolValue] = value;
          if (promise2[symbolFinally] === symbolFinally) {
            if (state === RESOLVED) {
              promise2[symbolState] = promise2[symbolParentPromiseState];
              promise2[symbolValue] = promise2[symbolParentPromiseValue];
            }
          }
          if (state === REJECTED && value instanceof Error) {
            const trace = Zone2.currentTask && Zone2.currentTask.data && Zone2.currentTask.data[creationTrace2];
            if (trace) {
              ObjectDefineProperty2(value, CURRENT_TASK_TRACE_SYMBOL, { configurable: true, enumerable: false, writable: true, value: trace });
            }
          }
          for (let i = 0; i < queue.length; ) {
            scheduleResolveOrReject(promise2, queue[i++], queue[i++], queue[i++], queue[i++]);
          }
          if (queue.length == 0 && state == REJECTED) {
            promise2[symbolState] = REJECTED_NO_CATCH;
            let uncaughtPromiseError = value;
            try {
              throw new Error("Uncaught (in promise): " + readableObjectToString(value) + (value && value.stack ? "\n" + value.stack : ""));
            } catch (err) {
              uncaughtPromiseError = err;
            }
            if (isDisableWrappingUncaughtPromiseRejection) {
              uncaughtPromiseError.throwOriginal = true;
            }
            uncaughtPromiseError.rejection = value;
            uncaughtPromiseError.promise = promise2;
            uncaughtPromiseError.zone = Zone2.current;
            uncaughtPromiseError.task = Zone2.currentTask;
            _uncaughtPromiseErrors.push(uncaughtPromiseError);
            api.scheduleMicroTask();
          }
        }
      }
      return promise2;
    }
    const REJECTION_HANDLED_HANDLER = __symbol__("rejectionHandledHandler");
    function clearRejectedNoCatch(promise2) {
      if (promise2[symbolState] === REJECTED_NO_CATCH) {
        try {
          const handler = Zone2[REJECTION_HANDLED_HANDLER];
          if (handler && typeof handler === "function") {
            handler.call(this, { rejection: promise2[symbolValue], promise: promise2 });
          }
        } catch (err) {
        }
        promise2[symbolState] = REJECTED;
        for (let i = 0; i < _uncaughtPromiseErrors.length; i++) {
          if (promise2 === _uncaughtPromiseErrors[i].promise) {
            _uncaughtPromiseErrors.splice(i, 1);
          }
        }
      }
    }
    function scheduleResolveOrReject(promise2, zone, chainPromise, onFulfilled, onRejected) {
      clearRejectedNoCatch(promise2);
      const promiseState = promise2[symbolState];
      const delegate = promiseState ? typeof onFulfilled === "function" ? onFulfilled : forwardResolution : typeof onRejected === "function" ? onRejected : forwardRejection;
      zone.scheduleMicroTask(source, () => {
        try {
          const parentPromiseValue = promise2[symbolValue];
          const isFinallyPromise = !!chainPromise && symbolFinally === chainPromise[symbolFinally];
          if (isFinallyPromise) {
            chainPromise[symbolParentPromiseValue] = parentPromiseValue;
            chainPromise[symbolParentPromiseState] = promiseState;
          }
          const value = zone.run(delegate, void 0, isFinallyPromise && delegate !== forwardRejection && delegate !== forwardResolution ? [] : [parentPromiseValue]);
          resolvePromise(chainPromise, true, value);
        } catch (error3) {
          resolvePromise(chainPromise, false, error3);
        }
      }, chainPromise);
    }
    const ZONE_AWARE_PROMISE_TO_STRING = "function ZoneAwarePromise() { [native code] }";
    const noop3 = function() {
    };
    const AggregateError = global2.AggregateError;
    class ZoneAwarePromise {
      static toString() {
        return ZONE_AWARE_PROMISE_TO_STRING;
      }
      static resolve(value) {
        return resolvePromise(new this(null), RESOLVED, value);
      }
      static reject(error3) {
        return resolvePromise(new this(null), REJECTED, error3);
      }
      static any(values) {
        if (!values || typeof values[Symbol.iterator] !== "function") {
          return Promise.reject(new AggregateError([], "All promises were rejected"));
        }
        const promises = [];
        let count = 0;
        try {
          for (let v of values) {
            count++;
            promises.push(ZoneAwarePromise.resolve(v));
          }
        } catch (err) {
          return Promise.reject(new AggregateError([], "All promises were rejected"));
        }
        if (count === 0) {
          return Promise.reject(new AggregateError([], "All promises were rejected"));
        }
        let finished = false;
        const errors = [];
        return new ZoneAwarePromise((resolve, reject) => {
          for (let i = 0; i < promises.length; i++) {
            promises[i].then((v) => {
              if (finished) {
                return;
              }
              finished = true;
              resolve(v);
            }, (err) => {
              errors.push(err);
              count--;
              if (count === 0) {
                finished = true;
                reject(new AggregateError(errors, "All promises were rejected"));
              }
            });
          }
        });
      }
      static race(values) {
        let resolve;
        let reject;
        let promise2 = new this((res, rej) => {
          resolve = res;
          reject = rej;
        });
        function onResolve(value) {
          resolve(value);
        }
        function onReject(error3) {
          reject(error3);
        }
        for (let value of values) {
          if (!isThenable(value)) {
            value = this.resolve(value);
          }
          value.then(onResolve, onReject);
        }
        return promise2;
      }
      static all(values) {
        return ZoneAwarePromise.allWithCallback(values);
      }
      static allSettled(values) {
        const P = this && this.prototype instanceof ZoneAwarePromise ? this : ZoneAwarePromise;
        return P.allWithCallback(values, {
          thenCallback: (value) => ({ status: "fulfilled", value }),
          errorCallback: (err) => ({ status: "rejected", reason: err })
        });
      }
      static allWithCallback(values, callback) {
        let resolve;
        let reject;
        let promise2 = new this((res, rej) => {
          resolve = res;
          reject = rej;
        });
        let unresolvedCount = 2;
        let valueIndex = 0;
        const resolvedValues = [];
        for (let value of values) {
          if (!isThenable(value)) {
            value = this.resolve(value);
          }
          const curValueIndex = valueIndex;
          try {
            value.then((value2) => {
              resolvedValues[curValueIndex] = callback ? callback.thenCallback(value2) : value2;
              unresolvedCount--;
              if (unresolvedCount === 0) {
                resolve(resolvedValues);
              }
            }, (err) => {
              if (!callback) {
                reject(err);
              } else {
                resolvedValues[curValueIndex] = callback.errorCallback(err);
                unresolvedCount--;
                if (unresolvedCount === 0) {
                  resolve(resolvedValues);
                }
              }
            });
          } catch (thenErr) {
            reject(thenErr);
          }
          unresolvedCount++;
          valueIndex++;
        }
        unresolvedCount -= 2;
        if (unresolvedCount === 0) {
          resolve(resolvedValues);
        }
        return promise2;
      }
      constructor(executor) {
        const promise2 = this;
        if (!(promise2 instanceof ZoneAwarePromise)) {
          throw new Error("Must be an instanceof Promise.");
        }
        promise2[symbolState] = UNRESOLVED;
        promise2[symbolValue] = [];
        try {
          executor && executor(makeResolver(promise2, RESOLVED), makeResolver(promise2, REJECTED));
        } catch (error3) {
          resolvePromise(promise2, false, error3);
        }
      }
      get [Symbol.toStringTag]() {
        return "Promise";
      }
      get [Symbol.species]() {
        return ZoneAwarePromise;
      }
      then(onFulfilled, onRejected) {
        let C = this.constructor[Symbol.species];
        if (!C || typeof C !== "function") {
          C = this.constructor || ZoneAwarePromise;
        }
        const chainPromise = new C(noop3);
        const zone = Zone2.current;
        if (this[symbolState] == UNRESOLVED) {
          this[symbolValue].push(zone, chainPromise, onFulfilled, onRejected);
        } else {
          scheduleResolveOrReject(this, zone, chainPromise, onFulfilled, onRejected);
        }
        return chainPromise;
      }
      catch(onRejected) {
        return this.then(null, onRejected);
      }
      finally(onFinally) {
        let C = this.constructor[Symbol.species];
        if (!C || typeof C !== "function") {
          C = ZoneAwarePromise;
        }
        const chainPromise = new C(noop3);
        chainPromise[symbolFinally] = symbolFinally;
        const zone = Zone2.current;
        if (this[symbolState] == UNRESOLVED) {
          this[symbolValue].push(zone, chainPromise, onFinally, onFinally);
        } else {
          scheduleResolveOrReject(this, zone, chainPromise, onFinally, onFinally);
        }
        return chainPromise;
      }
    }
    ZoneAwarePromise["resolve"] = ZoneAwarePromise.resolve;
    ZoneAwarePromise["reject"] = ZoneAwarePromise.reject;
    ZoneAwarePromise["race"] = ZoneAwarePromise.race;
    ZoneAwarePromise["all"] = ZoneAwarePromise.all;
    const NativePromise = global2[symbolPromise] = global2["Promise"];
    global2["Promise"] = ZoneAwarePromise;
    const symbolThenPatched = __symbol__("thenPatched");
    function patchThen(Ctor) {
      const proto = Ctor.prototype;
      const prop = ObjectGetOwnPropertyDescriptor2(proto, "then");
      if (prop && (prop.writable === false || !prop.configurable)) {
        return;
      }
      const originalThen = proto.then;
      proto[symbolThen] = originalThen;
      Ctor.prototype.then = function(onResolve, onReject) {
        const wrapped = new ZoneAwarePromise((resolve, reject) => {
          originalThen.call(this, resolve, reject);
        });
        return wrapped.then(onResolve, onReject);
      };
      Ctor[symbolThenPatched] = true;
    }
    api.patchThen = patchThen;
    function zoneify(fn2) {
      return function(self2, args) {
        let resultPromise = fn2.apply(self2, args);
        if (resultPromise instanceof ZoneAwarePromise) {
          return resultPromise;
        }
        let ctor = resultPromise.constructor;
        if (!ctor[symbolThenPatched]) {
          patchThen(ctor);
        }
        return resultPromise;
      };
    }
    if (NativePromise) {
      patchThen(NativePromise);
      patchMethod(global2, "fetch", (delegate) => zoneify(delegate));
    }
    Promise[Zone2.__symbol__("uncaughtPromiseErrors")] = _uncaughtPromiseErrors;
    return ZoneAwarePromise;
  });
  Zone.__load_patch("toString", (global2) => {
    const originalFunctionToString = Function.prototype.toString;
    const ORIGINAL_DELEGATE_SYMBOL = zoneSymbol("OriginalDelegate");
    const PROMISE_SYMBOL = zoneSymbol("Promise");
    const ERROR_SYMBOL = zoneSymbol("Error");
    const newFunctionToString = function toString() {
      if (typeof this === "function") {
        const originalDelegate = this[ORIGINAL_DELEGATE_SYMBOL];
        if (originalDelegate) {
          if (typeof originalDelegate === "function") {
            return originalFunctionToString.call(originalDelegate);
          } else {
            return Object.prototype.toString.call(originalDelegate);
          }
        }
        if (this === Promise) {
          const nativePromise = global2[PROMISE_SYMBOL];
          if (nativePromise) {
            return originalFunctionToString.call(nativePromise);
          }
        }
        if (this === Error) {
          const nativeError = global2[ERROR_SYMBOL];
          if (nativeError) {
            return originalFunctionToString.call(nativeError);
          }
        }
      }
      return originalFunctionToString.call(this);
    };
    newFunctionToString[ORIGINAL_DELEGATE_SYMBOL] = originalFunctionToString;
    Function.prototype.toString = newFunctionToString;
    const originalObjectToString = Object.prototype.toString;
    const PROMISE_OBJECT_TO_STRING = "[object Promise]";
    Object.prototype.toString = function() {
      if (typeof Promise === "function" && this instanceof Promise) {
        return PROMISE_OBJECT_TO_STRING;
      }
      return originalObjectToString.call(this);
    };
  });
  var passiveSupported = false;
  if (typeof window !== "undefined") {
    try {
      const options = Object.defineProperty({}, "passive", {
        get: function() {
          passiveSupported = true;
        }
      });
      window.addEventListener("test", options, options);
      window.removeEventListener("test", options, options);
    } catch (err) {
      passiveSupported = false;
    }
  }
  var OPTIMIZED_ZONE_EVENT_TASK_DATA = {
    useG: true
  };
  var zoneSymbolEventNames = {};
  var globalSources = {};
  var EVENT_NAME_SYMBOL_REGX = new RegExp("^" + ZONE_SYMBOL_PREFIX + "(\\w+)(true|false)$");
  var IMMEDIATE_PROPAGATION_SYMBOL = zoneSymbol("propagationStopped");
  function prepareEventNames(eventName, eventNameToString) {
    const falseEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + FALSE_STR;
    const trueEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + TRUE_STR;
    const symbol = ZONE_SYMBOL_PREFIX + falseEventName;
    const symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;
    zoneSymbolEventNames[eventName] = {};
    zoneSymbolEventNames[eventName][FALSE_STR] = symbol;
    zoneSymbolEventNames[eventName][TRUE_STR] = symbolCapture;
  }
  function patchEventTarget(_global5, api, apis, patchOptions) {
    const ADD_EVENT_LISTENER = patchOptions && patchOptions.add || ADD_EVENT_LISTENER_STR;
    const REMOVE_EVENT_LISTENER = patchOptions && patchOptions.rm || REMOVE_EVENT_LISTENER_STR;
    const LISTENERS_EVENT_LISTENER = patchOptions && patchOptions.listeners || "eventListeners";
    const REMOVE_ALL_LISTENERS_EVENT_LISTENER = patchOptions && patchOptions.rmAll || "removeAllListeners";
    const zoneSymbolAddEventListener = zoneSymbol(ADD_EVENT_LISTENER);
    const ADD_EVENT_LISTENER_SOURCE = "." + ADD_EVENT_LISTENER + ":";
    const PREPEND_EVENT_LISTENER = "prependListener";
    const PREPEND_EVENT_LISTENER_SOURCE = "." + PREPEND_EVENT_LISTENER + ":";
    const invokeTask = function(task, target, event) {
      if (task.isRemoved) {
        return;
      }
      const delegate = task.callback;
      if (typeof delegate === "object" && delegate.handleEvent) {
        task.callback = (event2) => delegate.handleEvent(event2);
        task.originalDelegate = delegate;
      }
      let error3;
      try {
        task.invoke(task, target, [event]);
      } catch (err) {
        error3 = err;
      }
      const options = task.options;
      if (options && typeof options === "object" && options.once) {
        const delegate2 = task.originalDelegate ? task.originalDelegate : task.callback;
        target[REMOVE_EVENT_LISTENER].call(target, event.type, delegate2, options);
      }
      return error3;
    };
    function globalCallback(context2, event, isCapture) {
      event = event || _global5.event;
      if (!event) {
        return;
      }
      const target = context2 || event.target || _global5;
      const tasks = target[zoneSymbolEventNames[event.type][isCapture ? TRUE_STR : FALSE_STR]];
      if (tasks) {
        const errors = [];
        if (tasks.length === 1) {
          const err = invokeTask(tasks[0], target, event);
          err && errors.push(err);
        } else {
          const copyTasks = tasks.slice();
          for (let i = 0; i < copyTasks.length; i++) {
            if (event && event[IMMEDIATE_PROPAGATION_SYMBOL] === true) {
              break;
            }
            const err = invokeTask(copyTasks[i], target, event);
            err && errors.push(err);
          }
        }
        if (errors.length === 1) {
          throw errors[0];
        } else {
          for (let i = 0; i < errors.length; i++) {
            const err = errors[i];
            api.nativeScheduleMicroTask(() => {
              throw err;
            });
          }
        }
      }
    }
    const globalZoneAwareCallback = function(event) {
      return globalCallback(this, event, false);
    };
    const globalZoneAwareCaptureCallback = function(event) {
      return globalCallback(this, event, true);
    };
    function patchEventTargetMethods(obj, patchOptions2) {
      if (!obj) {
        return false;
      }
      let useGlobalCallback = true;
      if (patchOptions2 && patchOptions2.useG !== void 0) {
        useGlobalCallback = patchOptions2.useG;
      }
      const validateHandler = patchOptions2 && patchOptions2.vh;
      let checkDuplicate = true;
      if (patchOptions2 && patchOptions2.chkDup !== void 0) {
        checkDuplicate = patchOptions2.chkDup;
      }
      let returnTarget = false;
      if (patchOptions2 && patchOptions2.rt !== void 0) {
        returnTarget = patchOptions2.rt;
      }
      let proto = obj;
      while (proto && !proto.hasOwnProperty(ADD_EVENT_LISTENER)) {
        proto = ObjectGetPrototypeOf(proto);
      }
      if (!proto && obj[ADD_EVENT_LISTENER]) {
        proto = obj;
      }
      if (!proto) {
        return false;
      }
      if (proto[zoneSymbolAddEventListener]) {
        return false;
      }
      const eventNameToString = patchOptions2 && patchOptions2.eventNameToString;
      const taskData = {};
      const nativeAddEventListener = proto[zoneSymbolAddEventListener] = proto[ADD_EVENT_LISTENER];
      const nativeRemoveEventListener = proto[zoneSymbol(REMOVE_EVENT_LISTENER)] = proto[REMOVE_EVENT_LISTENER];
      const nativeListeners = proto[zoneSymbol(LISTENERS_EVENT_LISTENER)] = proto[LISTENERS_EVENT_LISTENER];
      const nativeRemoveAllListeners = proto[zoneSymbol(REMOVE_ALL_LISTENERS_EVENT_LISTENER)] = proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER];
      let nativePrependEventListener;
      if (patchOptions2 && patchOptions2.prepend) {
        nativePrependEventListener = proto[zoneSymbol(patchOptions2.prepend)] = proto[patchOptions2.prepend];
      }
      function buildEventListenerOptions(options, passive) {
        if (!passiveSupported && typeof options === "object" && options) {
          return !!options.capture;
        }
        if (!passiveSupported || !passive) {
          return options;
        }
        if (typeof options === "boolean") {
          return { capture: options, passive: true };
        }
        if (!options) {
          return { passive: true };
        }
        if (typeof options === "object" && options.passive !== false) {
          return Object.assign(Object.assign({}, options), { passive: true });
        }
        return options;
      }
      const customScheduleGlobal = function(task) {
        if (taskData.isExisting) {
          return;
        }
        return nativeAddEventListener.call(taskData.target, taskData.eventName, taskData.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, taskData.options);
      };
      const customCancelGlobal = function(task) {
        if (!task.isRemoved) {
          const symbolEventNames = zoneSymbolEventNames[task.eventName];
          let symbolEventName;
          if (symbolEventNames) {
            symbolEventName = symbolEventNames[task.capture ? TRUE_STR : FALSE_STR];
          }
          const existingTasks = symbolEventName && task.target[symbolEventName];
          if (existingTasks) {
            for (let i = 0; i < existingTasks.length; i++) {
              const existingTask = existingTasks[i];
              if (existingTask === task) {
                existingTasks.splice(i, 1);
                task.isRemoved = true;
                if (existingTasks.length === 0) {
                  task.allRemoved = true;
                  task.target[symbolEventName] = null;
                }
                break;
              }
            }
          }
        }
        if (!task.allRemoved) {
          return;
        }
        return nativeRemoveEventListener.call(task.target, task.eventName, task.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, task.options);
      };
      const customScheduleNonGlobal = function(task) {
        return nativeAddEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);
      };
      const customSchedulePrepend = function(task) {
        return nativePrependEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);
      };
      const customCancelNonGlobal = function(task) {
        return nativeRemoveEventListener.call(task.target, task.eventName, task.invoke, task.options);
      };
      const customSchedule = useGlobalCallback ? customScheduleGlobal : customScheduleNonGlobal;
      const customCancel = useGlobalCallback ? customCancelGlobal : customCancelNonGlobal;
      const compareTaskCallbackVsDelegate = function(task, delegate) {
        const typeOfDelegate = typeof delegate;
        return typeOfDelegate === "function" && task.callback === delegate || typeOfDelegate === "object" && task.originalDelegate === delegate;
      };
      const compare2 = patchOptions2 && patchOptions2.diff ? patchOptions2.diff : compareTaskCallbackVsDelegate;
      const unpatchedEvents = Zone[zoneSymbol("UNPATCHED_EVENTS")];
      const passiveEvents = _global5[zoneSymbol("PASSIVE_EVENTS")];
      const makeAddListener = function(nativeListener, addSource, customScheduleFn, customCancelFn, returnTarget2 = false, prepend = false) {
        return function() {
          const target = this || _global5;
          let eventName = arguments[0];
          if (patchOptions2 && patchOptions2.transferEventName) {
            eventName = patchOptions2.transferEventName(eventName);
          }
          let delegate = arguments[1];
          if (!delegate) {
            return nativeListener.apply(this, arguments);
          }
          if (isNode && eventName === "uncaughtException") {
            return nativeListener.apply(this, arguments);
          }
          let isHandleEvent = false;
          if (typeof delegate !== "function") {
            if (!delegate.handleEvent) {
              return nativeListener.apply(this, arguments);
            }
            isHandleEvent = true;
          }
          if (validateHandler && !validateHandler(nativeListener, delegate, target, arguments)) {
            return;
          }
          const passive = passiveSupported && !!passiveEvents && passiveEvents.indexOf(eventName) !== -1;
          const options = buildEventListenerOptions(arguments[2], passive);
          if (unpatchedEvents) {
            for (let i = 0; i < unpatchedEvents.length; i++) {
              if (eventName === unpatchedEvents[i]) {
                if (passive) {
                  return nativeListener.call(target, eventName, delegate, options);
                } else {
                  return nativeListener.apply(this, arguments);
                }
              }
            }
          }
          const capture = !options ? false : typeof options === "boolean" ? true : options.capture;
          const once = options && typeof options === "object" ? options.once : false;
          const zone = Zone.current;
          let symbolEventNames = zoneSymbolEventNames[eventName];
          if (!symbolEventNames) {
            prepareEventNames(eventName, eventNameToString);
            symbolEventNames = zoneSymbolEventNames[eventName];
          }
          const symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];
          let existingTasks = target[symbolEventName];
          let isExisting = false;
          if (existingTasks) {
            isExisting = true;
            if (checkDuplicate) {
              for (let i = 0; i < existingTasks.length; i++) {
                if (compare2(existingTasks[i], delegate)) {
                  return;
                }
              }
            }
          } else {
            existingTasks = target[symbolEventName] = [];
          }
          let source;
          const constructorName = target.constructor["name"];
          const targetSource = globalSources[constructorName];
          if (targetSource) {
            source = targetSource[eventName];
          }
          if (!source) {
            source = constructorName + addSource + (eventNameToString ? eventNameToString(eventName) : eventName);
          }
          taskData.options = options;
          if (once) {
            taskData.options.once = false;
          }
          taskData.target = target;
          taskData.capture = capture;
          taskData.eventName = eventName;
          taskData.isExisting = isExisting;
          const data = useGlobalCallback ? OPTIMIZED_ZONE_EVENT_TASK_DATA : void 0;
          if (data) {
            data.taskData = taskData;
          }
          const task = zone.scheduleEventTask(source, delegate, data, customScheduleFn, customCancelFn);
          taskData.target = null;
          if (data) {
            data.taskData = null;
          }
          if (once) {
            options.once = true;
          }
          if (!(!passiveSupported && typeof task.options === "boolean")) {
            task.options = options;
          }
          task.target = target;
          task.capture = capture;
          task.eventName = eventName;
          if (isHandleEvent) {
            task.originalDelegate = delegate;
          }
          if (!prepend) {
            existingTasks.push(task);
          } else {
            existingTasks.unshift(task);
          }
          if (returnTarget2) {
            return target;
          }
        };
      };
      proto[ADD_EVENT_LISTENER] = makeAddListener(nativeAddEventListener, ADD_EVENT_LISTENER_SOURCE, customSchedule, customCancel, returnTarget);
      if (nativePrependEventListener) {
        proto[PREPEND_EVENT_LISTENER] = makeAddListener(nativePrependEventListener, PREPEND_EVENT_LISTENER_SOURCE, customSchedulePrepend, customCancel, returnTarget, true);
      }
      proto[REMOVE_EVENT_LISTENER] = function() {
        const target = this || _global5;
        let eventName = arguments[0];
        if (patchOptions2 && patchOptions2.transferEventName) {
          eventName = patchOptions2.transferEventName(eventName);
        }
        const options = arguments[2];
        const capture = !options ? false : typeof options === "boolean" ? true : options.capture;
        const delegate = arguments[1];
        if (!delegate) {
          return nativeRemoveEventListener.apply(this, arguments);
        }
        if (validateHandler && !validateHandler(nativeRemoveEventListener, delegate, target, arguments)) {
          return;
        }
        const symbolEventNames = zoneSymbolEventNames[eventName];
        let symbolEventName;
        if (symbolEventNames) {
          symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];
        }
        const existingTasks = symbolEventName && target[symbolEventName];
        if (existingTasks) {
          for (let i = 0; i < existingTasks.length; i++) {
            const existingTask = existingTasks[i];
            if (compare2(existingTask, delegate)) {
              existingTasks.splice(i, 1);
              existingTask.isRemoved = true;
              if (existingTasks.length === 0) {
                existingTask.allRemoved = true;
                target[symbolEventName] = null;
                if (typeof eventName === "string") {
                  const onPropertySymbol = ZONE_SYMBOL_PREFIX + "ON_PROPERTY" + eventName;
                  target[onPropertySymbol] = null;
                }
              }
              existingTask.zone.cancelTask(existingTask);
              if (returnTarget) {
                return target;
              }
              return;
            }
          }
        }
        return nativeRemoveEventListener.apply(this, arguments);
      };
      proto[LISTENERS_EVENT_LISTENER] = function() {
        const target = this || _global5;
        let eventName = arguments[0];
        if (patchOptions2 && patchOptions2.transferEventName) {
          eventName = patchOptions2.transferEventName(eventName);
        }
        const listeners = [];
        const tasks = findEventTasks(target, eventNameToString ? eventNameToString(eventName) : eventName);
        for (let i = 0; i < tasks.length; i++) {
          const task = tasks[i];
          let delegate = task.originalDelegate ? task.originalDelegate : task.callback;
          listeners.push(delegate);
        }
        return listeners;
      };
      proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER] = function() {
        const target = this || _global5;
        let eventName = arguments[0];
        if (!eventName) {
          const keys = Object.keys(target);
          for (let i = 0; i < keys.length; i++) {
            const prop = keys[i];
            const match2 = EVENT_NAME_SYMBOL_REGX.exec(prop);
            let evtName = match2 && match2[1];
            if (evtName && evtName !== "removeListener") {
              this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, evtName);
            }
          }
          this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, "removeListener");
        } else {
          if (patchOptions2 && patchOptions2.transferEventName) {
            eventName = patchOptions2.transferEventName(eventName);
          }
          const symbolEventNames = zoneSymbolEventNames[eventName];
          if (symbolEventNames) {
            const symbolEventName = symbolEventNames[FALSE_STR];
            const symbolCaptureEventName = symbolEventNames[TRUE_STR];
            const tasks = target[symbolEventName];
            const captureTasks = target[symbolCaptureEventName];
            if (tasks) {
              const removeTasks = tasks.slice();
              for (let i = 0; i < removeTasks.length; i++) {
                const task = removeTasks[i];
                let delegate = task.originalDelegate ? task.originalDelegate : task.callback;
                this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);
              }
            }
            if (captureTasks) {
              const removeTasks = captureTasks.slice();
              for (let i = 0; i < removeTasks.length; i++) {
                const task = removeTasks[i];
                let delegate = task.originalDelegate ? task.originalDelegate : task.callback;
                this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);
              }
            }
          }
        }
        if (returnTarget) {
          return this;
        }
      };
      attachOriginToPatched(proto[ADD_EVENT_LISTENER], nativeAddEventListener);
      attachOriginToPatched(proto[REMOVE_EVENT_LISTENER], nativeRemoveEventListener);
      if (nativeRemoveAllListeners) {
        attachOriginToPatched(proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER], nativeRemoveAllListeners);
      }
      if (nativeListeners) {
        attachOriginToPatched(proto[LISTENERS_EVENT_LISTENER], nativeListeners);
      }
      return true;
    }
    let results = [];
    for (let i = 0; i < apis.length; i++) {
      results[i] = patchEventTargetMethods(apis[i], patchOptions);
    }
    return results;
  }
  function findEventTasks(target, eventName) {
    if (!eventName) {
      const foundTasks = [];
      for (let prop in target) {
        const match2 = EVENT_NAME_SYMBOL_REGX.exec(prop);
        let evtName = match2 && match2[1];
        if (evtName && (!eventName || evtName === eventName)) {
          const tasks = target[prop];
          if (tasks) {
            for (let i = 0; i < tasks.length; i++) {
              foundTasks.push(tasks[i]);
            }
          }
        }
      }
      return foundTasks;
    }
    let symbolEventName = zoneSymbolEventNames[eventName];
    if (!symbolEventName) {
      prepareEventNames(eventName);
      symbolEventName = zoneSymbolEventNames[eventName];
    }
    const captureFalseTasks = target[symbolEventName[FALSE_STR]];
    const captureTrueTasks = target[symbolEventName[TRUE_STR]];
    if (!captureFalseTasks) {
      return captureTrueTasks ? captureTrueTasks.slice() : [];
    } else {
      return captureTrueTasks ? captureFalseTasks.concat(captureTrueTasks) : captureFalseTasks.slice();
    }
  }
  function patchEventPrototype(global2, api) {
    const Event = global2["Event"];
    if (Event && Event.prototype) {
      api.patchMethod(Event.prototype, "stopImmediatePropagation", (delegate) => function(self2, args) {
        self2[IMMEDIATE_PROPAGATION_SYMBOL] = true;
        delegate && delegate.apply(self2, args);
      });
    }
  }
  function patchCallbacks(api, target, targetName, method, callbacks) {
    const symbol = Zone.__symbol__(method);
    if (target[symbol]) {
      return;
    }
    const nativeDelegate = target[symbol] = target[method];
    target[method] = function(name, opts, options) {
      if (opts && opts.prototype) {
        callbacks.forEach(function(callback) {
          const source = `${targetName}.${method}::` + callback;
          const prototype = opts.prototype;
          if (prototype.hasOwnProperty(callback)) {
            const descriptor = api.ObjectGetOwnPropertyDescriptor(prototype, callback);
            if (descriptor && descriptor.value) {
              descriptor.value = api.wrapWithCurrentZone(descriptor.value, source);
              api._redefineProperty(opts.prototype, callback, descriptor);
            } else if (prototype[callback]) {
              prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);
            }
          } else if (prototype[callback]) {
            prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);
          }
        });
      }
      return nativeDelegate.call(target, name, opts, options);
    };
    api.attachOriginToPatched(target[method], nativeDelegate);
  }
  function filterProperties(target, onProperties, ignoreProperties) {
    if (!ignoreProperties || ignoreProperties.length === 0) {
      return onProperties;
    }
    const tip = ignoreProperties.filter((ip) => ip.target === target);
    if (!tip || tip.length === 0) {
      return onProperties;
    }
    const targetIgnoreProperties = tip[0].ignoreProperties;
    return onProperties.filter((op) => targetIgnoreProperties.indexOf(op) === -1);
  }
  function patchFilteredProperties(target, onProperties, ignoreProperties, prototype) {
    if (!target) {
      return;
    }
    const filteredProperties = filterProperties(target, onProperties, ignoreProperties);
    patchOnProperties(target, filteredProperties, prototype);
  }
  function getOnEventNames(target) {
    return Object.getOwnPropertyNames(target).filter((name) => name.startsWith("on") && name.length > 2).map((name) => name.substring(2));
  }
  function propertyDescriptorPatch(api, _global5) {
    if (isNode && !isMix) {
      return;
    }
    if (Zone[api.symbol("patchEvents")]) {
      return;
    }
    const ignoreProperties = _global5["__Zone_ignore_on_properties"];
    let patchTargets = [];
    if (isBrowser) {
      const internalWindow2 = window;
      patchTargets = patchTargets.concat([
        "Document",
        "SVGElement",
        "Element",
        "HTMLElement",
        "HTMLBodyElement",
        "HTMLMediaElement",
        "HTMLFrameSetElement",
        "HTMLFrameElement",
        "HTMLIFrameElement",
        "HTMLMarqueeElement",
        "Worker"
      ]);
      const ignoreErrorProperties = isIE() ? [{ target: internalWindow2, ignoreProperties: ["error"] }] : [];
      patchFilteredProperties(internalWindow2, getOnEventNames(internalWindow2), ignoreProperties ? ignoreProperties.concat(ignoreErrorProperties) : ignoreProperties, ObjectGetPrototypeOf(internalWindow2));
    }
    patchTargets = patchTargets.concat([
      "XMLHttpRequest",
      "XMLHttpRequestEventTarget",
      "IDBIndex",
      "IDBRequest",
      "IDBOpenDBRequest",
      "IDBDatabase",
      "IDBTransaction",
      "IDBCursor",
      "WebSocket"
    ]);
    for (let i = 0; i < patchTargets.length; i++) {
      const target = _global5[patchTargets[i]];
      target && target.prototype && patchFilteredProperties(target.prototype, getOnEventNames(target.prototype), ignoreProperties);
    }
  }
  Zone.__load_patch("util", (global2, Zone2, api) => {
    const eventNames = getOnEventNames(global2);
    api.patchOnProperties = patchOnProperties;
    api.patchMethod = patchMethod;
    api.bindArguments = bindArguments;
    api.patchMacroTask = patchMacroTask;
    const SYMBOL_BLACK_LISTED_EVENTS = Zone2.__symbol__("BLACK_LISTED_EVENTS");
    const SYMBOL_UNPATCHED_EVENTS = Zone2.__symbol__("UNPATCHED_EVENTS");
    if (global2[SYMBOL_UNPATCHED_EVENTS]) {
      global2[SYMBOL_BLACK_LISTED_EVENTS] = global2[SYMBOL_UNPATCHED_EVENTS];
    }
    if (global2[SYMBOL_BLACK_LISTED_EVENTS]) {
      Zone2[SYMBOL_BLACK_LISTED_EVENTS] = Zone2[SYMBOL_UNPATCHED_EVENTS] = global2[SYMBOL_BLACK_LISTED_EVENTS];
    }
    api.patchEventPrototype = patchEventPrototype;
    api.patchEventTarget = patchEventTarget;
    api.isIEOrEdge = isIEOrEdge;
    api.ObjectDefineProperty = ObjectDefineProperty;
    api.ObjectGetOwnPropertyDescriptor = ObjectGetOwnPropertyDescriptor;
    api.ObjectCreate = ObjectCreate;
    api.ArraySlice = ArraySlice;
    api.patchClass = patchClass;
    api.wrapWithCurrentZone = wrapWithCurrentZone;
    api.filterProperties = filterProperties;
    api.attachOriginToPatched = attachOriginToPatched;
    api._redefineProperty = Object.defineProperty;
    api.patchCallbacks = patchCallbacks;
    api.getGlobalObjects = () => ({
      globalSources,
      zoneSymbolEventNames,
      eventNames,
      isBrowser,
      isMix,
      isNode,
      TRUE_STR,
      FALSE_STR,
      ZONE_SYMBOL_PREFIX,
      ADD_EVENT_LISTENER_STR,
      REMOVE_EVENT_LISTENER_STR
    });
  });
  var taskSymbol = zoneSymbol("zoneTask");
  function patchTimer(window2, setName, cancelName, nameSuffix2) {
    let setNative = null;
    let clearNative = null;
    setName += nameSuffix2;
    cancelName += nameSuffix2;
    const tasksByHandleId = {};
    function scheduleTask(task) {
      const data = task.data;
      data.args[0] = function() {
        return task.invoke.apply(this, arguments);
      };
      data.handleId = setNative.apply(window2, data.args);
      return task;
    }
    function clearTask(task) {
      return clearNative.call(window2, task.data.handleId);
    }
    setNative = patchMethod(window2, setName, (delegate) => function(self2, args) {
      if (typeof args[0] === "function") {
        const options = {
          isPeriodic: nameSuffix2 === "Interval",
          delay: nameSuffix2 === "Timeout" || nameSuffix2 === "Interval" ? args[1] || 0 : void 0,
          args
        };
        const callback = args[0];
        args[0] = function timer() {
          try {
            return callback.apply(this, arguments);
          } finally {
            if (!options.isPeriodic) {
              if (typeof options.handleId === "number") {
                delete tasksByHandleId[options.handleId];
              } else if (options.handleId) {
                options.handleId[taskSymbol] = null;
              }
            }
          }
        };
        const task = scheduleMacroTaskWithCurrentZone(setName, args[0], options, scheduleTask, clearTask);
        if (!task) {
          return task;
        }
        const handle = task.data.handleId;
        if (typeof handle === "number") {
          tasksByHandleId[handle] = task;
        } else if (handle) {
          handle[taskSymbol] = task;
        }
        if (handle && handle.ref && handle.unref && typeof handle.ref === "function" && typeof handle.unref === "function") {
          task.ref = handle.ref.bind(handle);
          task.unref = handle.unref.bind(handle);
        }
        if (typeof handle === "number" || handle) {
          return handle;
        }
        return task;
      } else {
        return delegate.apply(window2, args);
      }
    });
    clearNative = patchMethod(window2, cancelName, (delegate) => function(self2, args) {
      const id = args[0];
      let task;
      if (typeof id === "number") {
        task = tasksByHandleId[id];
      } else {
        task = id && id[taskSymbol];
        if (!task) {
          task = id;
        }
      }
      if (task && typeof task.type === "string") {
        if (task.state !== "notScheduled" && (task.cancelFn && task.data.isPeriodic || task.runCount === 0)) {
          if (typeof id === "number") {
            delete tasksByHandleId[id];
          } else if (id) {
            id[taskSymbol] = null;
          }
          task.zone.cancelTask(task);
        }
      } else {
        delegate.apply(window2, args);
      }
    });
  }
  function patchCustomElements(_global5, api) {
    const { isBrowser: isBrowser2, isMix: isMix2 } = api.getGlobalObjects();
    if (!isBrowser2 && !isMix2 || !_global5["customElements"] || !("customElements" in _global5)) {
      return;
    }
    const callbacks = ["connectedCallback", "disconnectedCallback", "adoptedCallback", "attributeChangedCallback"];
    api.patchCallbacks(api, _global5.customElements, "customElements", "define", callbacks);
  }
  function eventTargetPatch(_global5, api) {
    if (Zone[api.symbol("patchEventTarget")]) {
      return;
    }
    const { eventNames, zoneSymbolEventNames: zoneSymbolEventNames2, TRUE_STR: TRUE_STR2, FALSE_STR: FALSE_STR2, ZONE_SYMBOL_PREFIX: ZONE_SYMBOL_PREFIX2 } = api.getGlobalObjects();
    for (let i = 0; i < eventNames.length; i++) {
      const eventName = eventNames[i];
      const falseEventName = eventName + FALSE_STR2;
      const trueEventName = eventName + TRUE_STR2;
      const symbol = ZONE_SYMBOL_PREFIX2 + falseEventName;
      const symbolCapture = ZONE_SYMBOL_PREFIX2 + trueEventName;
      zoneSymbolEventNames2[eventName] = {};
      zoneSymbolEventNames2[eventName][FALSE_STR2] = symbol;
      zoneSymbolEventNames2[eventName][TRUE_STR2] = symbolCapture;
    }
    const EVENT_TARGET = _global5["EventTarget"];
    if (!EVENT_TARGET || !EVENT_TARGET.prototype) {
      return;
    }
    api.patchEventTarget(_global5, api, [EVENT_TARGET && EVENT_TARGET.prototype]);
    return true;
  }
  function patchEvent(global2, api) {
    api.patchEventPrototype(global2, api);
  }
  Zone.__load_patch("legacy", (global2) => {
    const legacyPatch = global2[Zone.__symbol__("legacyPatch")];
    if (legacyPatch) {
      legacyPatch();
    }
  });
  Zone.__load_patch("queueMicrotask", (global2, Zone2, api) => {
    api.patchMethod(global2, "queueMicrotask", (delegate) => {
      return function(self2, args) {
        Zone2.current.scheduleMicroTask("queueMicrotask", args[0]);
      };
    });
  });
  Zone.__load_patch("timers", (global2) => {
    const set = "set";
    const clear = "clear";
    patchTimer(global2, set, clear, "Timeout");
    patchTimer(global2, set, clear, "Interval");
    patchTimer(global2, set, clear, "Immediate");
  });
  Zone.__load_patch("requestAnimationFrame", (global2) => {
    patchTimer(global2, "request", "cancel", "AnimationFrame");
    patchTimer(global2, "mozRequest", "mozCancel", "AnimationFrame");
    patchTimer(global2, "webkitRequest", "webkitCancel", "AnimationFrame");
  });
  Zone.__load_patch("blocking", (global2, Zone2) => {
    const blockingMethods = ["alert", "prompt", "confirm"];
    for (let i = 0; i < blockingMethods.length; i++) {
      const name = blockingMethods[i];
      patchMethod(global2, name, (delegate, symbol, name2) => {
        return function(s, args) {
          return Zone2.current.run(delegate, global2, args, name2);
        };
      });
    }
  });
  Zone.__load_patch("EventTarget", (global2, Zone2, api) => {
    patchEvent(global2, api);
    eventTargetPatch(global2, api);
    const XMLHttpRequestEventTarget = global2["XMLHttpRequestEventTarget"];
    if (XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype) {
      api.patchEventTarget(global2, api, [XMLHttpRequestEventTarget.prototype]);
    }
  });
  Zone.__load_patch("MutationObserver", (global2, Zone2, api) => {
    patchClass("MutationObserver");
    patchClass("WebKitMutationObserver");
  });
  Zone.__load_patch("IntersectionObserver", (global2, Zone2, api) => {
    patchClass("IntersectionObserver");
  });
  Zone.__load_patch("FileReader", (global2, Zone2, api) => {
    patchClass("FileReader");
  });
  Zone.__load_patch("on_property", (global2, Zone2, api) => {
    propertyDescriptorPatch(api, global2);
  });
  Zone.__load_patch("customElements", (global2, Zone2, api) => {
    patchCustomElements(global2, api);
  });
  Zone.__load_patch("XHR", (global2, Zone2) => {
    patchXHR(global2);
    const XHR_TASK = zoneSymbol("xhrTask");
    const XHR_SYNC = zoneSymbol("xhrSync");
    const XHR_LISTENER = zoneSymbol("xhrListener");
    const XHR_SCHEDULED = zoneSymbol("xhrScheduled");
    const XHR_URL = zoneSymbol("xhrURL");
    const XHR_ERROR_BEFORE_SCHEDULED = zoneSymbol("xhrErrorBeforeScheduled");
    function patchXHR(window2) {
      const XMLHttpRequest2 = window2["XMLHttpRequest"];
      if (!XMLHttpRequest2) {
        return;
      }
      const XMLHttpRequestPrototype = XMLHttpRequest2.prototype;
      function findPendingTask(target) {
        return target[XHR_TASK];
      }
      let oriAddListener = XMLHttpRequestPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];
      let oriRemoveListener = XMLHttpRequestPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];
      if (!oriAddListener) {
        const XMLHttpRequestEventTarget = window2["XMLHttpRequestEventTarget"];
        if (XMLHttpRequestEventTarget) {
          const XMLHttpRequestEventTargetPrototype = XMLHttpRequestEventTarget.prototype;
          oriAddListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];
          oriRemoveListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];
        }
      }
      const READY_STATE_CHANGE = "readystatechange";
      const SCHEDULED = "scheduled";
      function scheduleTask(task) {
        const data = task.data;
        const target = data.target;
        target[XHR_SCHEDULED] = false;
        target[XHR_ERROR_BEFORE_SCHEDULED] = false;
        const listener = target[XHR_LISTENER];
        if (!oriAddListener) {
          oriAddListener = target[ZONE_SYMBOL_ADD_EVENT_LISTENER];
          oriRemoveListener = target[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];
        }
        if (listener) {
          oriRemoveListener.call(target, READY_STATE_CHANGE, listener);
        }
        const newListener = target[XHR_LISTENER] = () => {
          if (target.readyState === target.DONE) {
            if (!data.aborted && target[XHR_SCHEDULED] && task.state === SCHEDULED) {
              const loadTasks = target[Zone2.__symbol__("loadfalse")];
              if (target.status !== 0 && loadTasks && loadTasks.length > 0) {
                const oriInvoke = task.invoke;
                task.invoke = function() {
                  const loadTasks2 = target[Zone2.__symbol__("loadfalse")];
                  for (let i = 0; i < loadTasks2.length; i++) {
                    if (loadTasks2[i] === task) {
                      loadTasks2.splice(i, 1);
                    }
                  }
                  if (!data.aborted && task.state === SCHEDULED) {
                    oriInvoke.call(task);
                  }
                };
                loadTasks.push(task);
              } else {
                task.invoke();
              }
            } else if (!data.aborted && target[XHR_SCHEDULED] === false) {
              target[XHR_ERROR_BEFORE_SCHEDULED] = true;
            }
          }
        };
        oriAddListener.call(target, READY_STATE_CHANGE, newListener);
        const storedTask = target[XHR_TASK];
        if (!storedTask) {
          target[XHR_TASK] = task;
        }
        sendNative.apply(target, data.args);
        target[XHR_SCHEDULED] = true;
        return task;
      }
      function placeholderCallback() {
      }
      function clearTask(task) {
        const data = task.data;
        data.aborted = true;
        return abortNative.apply(data.target, data.args);
      }
      const openNative = patchMethod(XMLHttpRequestPrototype, "open", () => function(self2, args) {
        self2[XHR_SYNC] = args[2] == false;
        self2[XHR_URL] = args[1];
        return openNative.apply(self2, args);
      });
      const XMLHTTPREQUEST_SOURCE = "XMLHttpRequest.send";
      const fetchTaskAborting = zoneSymbol("fetchTaskAborting");
      const fetchTaskScheduling = zoneSymbol("fetchTaskScheduling");
      const sendNative = patchMethod(XMLHttpRequestPrototype, "send", () => function(self2, args) {
        if (Zone2.current[fetchTaskScheduling] === true) {
          return sendNative.apply(self2, args);
        }
        if (self2[XHR_SYNC]) {
          return sendNative.apply(self2, args);
        } else {
          const options = { target: self2, url: self2[XHR_URL], isPeriodic: false, args, aborted: false };
          const task = scheduleMacroTaskWithCurrentZone(XMLHTTPREQUEST_SOURCE, placeholderCallback, options, scheduleTask, clearTask);
          if (self2 && self2[XHR_ERROR_BEFORE_SCHEDULED] === true && !options.aborted && task.state === SCHEDULED) {
            task.invoke();
          }
        }
      });
      const abortNative = patchMethod(XMLHttpRequestPrototype, "abort", () => function(self2, args) {
        const task = findPendingTask(self2);
        if (task && typeof task.type == "string") {
          if (task.cancelFn == null || task.data && task.data.aborted) {
            return;
          }
          task.zone.cancelTask(task);
        } else if (Zone2.current[fetchTaskAborting] === true) {
          return abortNative.apply(self2, args);
        }
      });
    }
  });
  Zone.__load_patch("geolocation", (global2) => {
    if (global2["navigator"] && global2["navigator"].geolocation) {
      patchPrototype(global2["navigator"].geolocation, ["getCurrentPosition", "watchPosition"]);
    }
  });
  Zone.__load_patch("PromiseRejectionEvent", (global2, Zone2) => {
    function findPromiseRejectionHandler(evtName) {
      return function(e) {
        const eventTasks = findEventTasks(global2, evtName);
        eventTasks.forEach((eventTask) => {
          const PromiseRejectionEvent = global2["PromiseRejectionEvent"];
          if (PromiseRejectionEvent) {
            const evt = new PromiseRejectionEvent(evtName, { promise: e.promise, reason: e.rejection });
            eventTask.invoke(evt);
          }
        });
      };
    }
    if (global2["PromiseRejectionEvent"]) {
      Zone2[zoneSymbol("unhandledPromiseRejectionHandler")] = findPromiseRejectionHandler("unhandledrejection");
      Zone2[zoneSymbol("rejectionHandledHandler")] = findPromiseRejectionHandler("rejectionhandled");
    }
  });

  // node_modules/zone.js/fesm2015/zone-testing.js
  var NEWLINE = "\n";
  var IGNORE_FRAMES = {};
  var creationTrace = "__creationTrace__";
  var ERROR_TAG = "STACKTRACE TRACKING";
  var SEP_TAG = "__SEP_TAG__";
  var sepTemplate = SEP_TAG + "@[native]";
  var LongStackTrace = class {
    constructor() {
      this.error = getStacktrace();
      this.timestamp = new Date();
    }
  };
  function getStacktraceWithUncaughtError() {
    return new Error(ERROR_TAG);
  }
  function getStacktraceWithCaughtError() {
    try {
      throw getStacktraceWithUncaughtError();
    } catch (err) {
      return err;
    }
  }
  var error = getStacktraceWithUncaughtError();
  var caughtError = getStacktraceWithCaughtError();
  var getStacktrace = error.stack ? getStacktraceWithUncaughtError : caughtError.stack ? getStacktraceWithCaughtError : getStacktraceWithUncaughtError;
  function getFrames(error3) {
    return error3.stack ? error3.stack.split(NEWLINE) : [];
  }
  function addErrorStack(lines, error3) {
    let trace = getFrames(error3);
    for (let i = 0; i < trace.length; i++) {
      const frame = trace[i];
      if (!IGNORE_FRAMES.hasOwnProperty(frame)) {
        lines.push(trace[i]);
      }
    }
  }
  function renderLongStackTrace(frames, stack) {
    const longTrace = [stack ? stack.trim() : ""];
    if (frames) {
      let timestamp = new Date().getTime();
      for (let i = 0; i < frames.length; i++) {
        const traceFrames = frames[i];
        const lastTime = traceFrames.timestamp;
        let separator = `____________________Elapsed ${timestamp - lastTime.getTime()} ms; At: ${lastTime}`;
        separator = separator.replace(/[^\w\d]/g, "_");
        longTrace.push(sepTemplate.replace(SEP_TAG, separator));
        addErrorStack(longTrace, traceFrames.error);
        timestamp = lastTime.getTime();
      }
    }
    return longTrace.join(NEWLINE);
  }
  function stackTracesEnabled() {
    return Error.stackTraceLimit > 0;
  }
  Zone["longStackTraceZoneSpec"] = {
    name: "long-stack-trace",
    longStackTraceLimit: 10,
    getLongStackTrace: function(error3) {
      if (!error3) {
        return void 0;
      }
      const trace = error3[Zone.__symbol__("currentTaskTrace")];
      if (!trace) {
        return error3.stack;
      }
      return renderLongStackTrace(trace, error3.stack);
    },
    onScheduleTask: function(parentZoneDelegate, currentZone, targetZone, task) {
      if (stackTracesEnabled()) {
        const currentTask = Zone.currentTask;
        let trace = currentTask && currentTask.data && currentTask.data[creationTrace] || [];
        trace = [new LongStackTrace()].concat(trace);
        if (trace.length > this.longStackTraceLimit) {
          trace.length = this.longStackTraceLimit;
        }
        if (!task.data)
          task.data = {};
        if (task.type === "eventTask") {
          task.data = Object.assign({}, task.data);
        }
        task.data[creationTrace] = trace;
      }
      return parentZoneDelegate.scheduleTask(targetZone, task);
    },
    onHandleError: function(parentZoneDelegate, currentZone, targetZone, error3) {
      if (stackTracesEnabled()) {
        const parentTask = Zone.currentTask || error3.task;
        if (error3 instanceof Error && parentTask) {
          const longStack = renderLongStackTrace(parentTask.data && parentTask.data[creationTrace], error3.stack);
          try {
            error3.stack = error3.longStack = longStack;
          } catch (err) {
          }
        }
      }
      return parentZoneDelegate.handleError(targetZone, error3);
    }
  };
  function captureStackTraces(stackTraces, count) {
    if (count > 0) {
      stackTraces.push(getFrames(new LongStackTrace().error));
      captureStackTraces(stackTraces, count - 1);
    }
  }
  function computeIgnoreFrames() {
    if (!stackTracesEnabled()) {
      return;
    }
    const frames = [];
    captureStackTraces(frames, 2);
    const frames1 = frames[0];
    const frames2 = frames[1];
    for (let i = 0; i < frames1.length; i++) {
      const frame1 = frames1[i];
      if (frame1.indexOf(ERROR_TAG) == -1) {
        let match2 = frame1.match(/^\s*at\s+/);
        if (match2) {
          sepTemplate = match2[0] + SEP_TAG + " (http://localhost)";
          break;
        }
      }
    }
    for (let i = 0; i < frames1.length; i++) {
      const frame1 = frames1[i];
      const frame2 = frames2[i];
      if (frame1 === frame2) {
        IGNORE_FRAMES[frame1] = true;
      } else {
        break;
      }
    }
  }
  computeIgnoreFrames();
  var ProxyZoneSpec = class {
    constructor(defaultSpecDelegate = null) {
      this.defaultSpecDelegate = defaultSpecDelegate;
      this.name = "ProxyZone";
      this._delegateSpec = null;
      this.properties = { "ProxyZoneSpec": this };
      this.propertyKeys = null;
      this.lastTaskState = null;
      this.isNeedToTriggerHasTask = false;
      this.tasks = [];
      this.setDelegate(defaultSpecDelegate);
    }
    static get() {
      return Zone.current.get("ProxyZoneSpec");
    }
    static isLoaded() {
      return ProxyZoneSpec.get() instanceof ProxyZoneSpec;
    }
    static assertPresent() {
      if (!ProxyZoneSpec.isLoaded()) {
        throw new Error(`Expected to be running in 'ProxyZone', but it was not found.`);
      }
      return ProxyZoneSpec.get();
    }
    setDelegate(delegateSpec) {
      const isNewDelegate = this._delegateSpec !== delegateSpec;
      this._delegateSpec = delegateSpec;
      this.propertyKeys && this.propertyKeys.forEach((key) => delete this.properties[key]);
      this.propertyKeys = null;
      if (delegateSpec && delegateSpec.properties) {
        this.propertyKeys = Object.keys(delegateSpec.properties);
        this.propertyKeys.forEach((k) => this.properties[k] = delegateSpec.properties[k]);
      }
      if (isNewDelegate && this.lastTaskState && (this.lastTaskState.macroTask || this.lastTaskState.microTask)) {
        this.isNeedToTriggerHasTask = true;
      }
    }
    getDelegate() {
      return this._delegateSpec;
    }
    resetDelegate() {
      this.getDelegate();
      this.setDelegate(this.defaultSpecDelegate);
    }
    tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone) {
      if (this.isNeedToTriggerHasTask && this.lastTaskState) {
        this.isNeedToTriggerHasTask = false;
        this.onHasTask(parentZoneDelegate, currentZone, targetZone, this.lastTaskState);
      }
    }
    removeFromTasks(task) {
      if (!this.tasks) {
        return;
      }
      for (let i = 0; i < this.tasks.length; i++) {
        if (this.tasks[i] === task) {
          this.tasks.splice(i, 1);
          return;
        }
      }
    }
    getAndClearPendingTasksInfo() {
      if (this.tasks.length === 0) {
        return "";
      }
      const taskInfo = this.tasks.map((task) => {
        const dataInfo = task.data && Object.keys(task.data).map((key) => {
          return key + ":" + task.data[key];
        }).join(",");
        return `type: ${task.type}, source: ${task.source}, args: {${dataInfo}}`;
      });
      const pendingTasksInfo = "--Pending async tasks are: [" + taskInfo + "]";
      this.tasks = [];
      return pendingTasksInfo;
    }
    onFork(parentZoneDelegate, currentZone, targetZone, zoneSpec) {
      if (this._delegateSpec && this._delegateSpec.onFork) {
        return this._delegateSpec.onFork(parentZoneDelegate, currentZone, targetZone, zoneSpec);
      } else {
        return parentZoneDelegate.fork(targetZone, zoneSpec);
      }
    }
    onIntercept(parentZoneDelegate, currentZone, targetZone, delegate, source) {
      if (this._delegateSpec && this._delegateSpec.onIntercept) {
        return this._delegateSpec.onIntercept(parentZoneDelegate, currentZone, targetZone, delegate, source);
      } else {
        return parentZoneDelegate.intercept(targetZone, delegate, source);
      }
    }
    onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {
      this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);
      if (this._delegateSpec && this._delegateSpec.onInvoke) {
        return this._delegateSpec.onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source);
      } else {
        return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);
      }
    }
    onHandleError(parentZoneDelegate, currentZone, targetZone, error3) {
      if (this._delegateSpec && this._delegateSpec.onHandleError) {
        return this._delegateSpec.onHandleError(parentZoneDelegate, currentZone, targetZone, error3);
      } else {
        return parentZoneDelegate.handleError(targetZone, error3);
      }
    }
    onScheduleTask(parentZoneDelegate, currentZone, targetZone, task) {
      if (task.type !== "eventTask") {
        this.tasks.push(task);
      }
      if (this._delegateSpec && this._delegateSpec.onScheduleTask) {
        return this._delegateSpec.onScheduleTask(parentZoneDelegate, currentZone, targetZone, task);
      } else {
        return parentZoneDelegate.scheduleTask(targetZone, task);
      }
    }
    onInvokeTask(parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs) {
      if (task.type !== "eventTask") {
        this.removeFromTasks(task);
      }
      this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);
      if (this._delegateSpec && this._delegateSpec.onInvokeTask) {
        return this._delegateSpec.onInvokeTask(parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs);
      } else {
        return parentZoneDelegate.invokeTask(targetZone, task, applyThis, applyArgs);
      }
    }
    onCancelTask(parentZoneDelegate, currentZone, targetZone, task) {
      if (task.type !== "eventTask") {
        this.removeFromTasks(task);
      }
      this.tryTriggerHasTask(parentZoneDelegate, currentZone, targetZone);
      if (this._delegateSpec && this._delegateSpec.onCancelTask) {
        return this._delegateSpec.onCancelTask(parentZoneDelegate, currentZone, targetZone, task);
      } else {
        return parentZoneDelegate.cancelTask(targetZone, task);
      }
    }
    onHasTask(delegate, current, target, hasTaskState) {
      this.lastTaskState = hasTaskState;
      if (this._delegateSpec && this._delegateSpec.onHasTask) {
        this._delegateSpec.onHasTask(delegate, current, target, hasTaskState);
      } else {
        delegate.hasTask(target, hasTaskState);
      }
    }
  };
  Zone["ProxyZoneSpec"] = ProxyZoneSpec;
  var SyncTestZoneSpec = class {
    constructor(namePrefix) {
      this.runZone = Zone.current;
      this.name = "syncTestZone for " + namePrefix;
    }
    onScheduleTask(delegate, current, target, task) {
      switch (task.type) {
        case "microTask":
        case "macroTask":
          throw new Error(`Cannot call ${task.source} from within a sync test.`);
        case "eventTask":
          task = delegate.scheduleTask(target, task);
          break;
      }
      return task;
    }
  };
  Zone["SyncTestZoneSpec"] = SyncTestZoneSpec;
  Zone.__load_patch("jasmine", (global2, Zone2, api) => {
    const __extends2 = function(d, b) {
      for (const p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    if (!Zone2)
      throw new Error("Missing: zone.js");
    if (typeof jest !== "undefined") {
      return;
    }
    if (typeof jasmine == "undefined" || jasmine["__zone_patch__"]) {
      return;
    }
    jasmine["__zone_patch__"] = true;
    const SyncTestZoneSpec2 = Zone2["SyncTestZoneSpec"];
    const ProxyZoneSpec2 = Zone2["ProxyZoneSpec"];
    if (!SyncTestZoneSpec2)
      throw new Error("Missing: SyncTestZoneSpec");
    if (!ProxyZoneSpec2)
      throw new Error("Missing: ProxyZoneSpec");
    const ambientZone = Zone2.current;
    const syncZone = ambientZone.fork(new SyncTestZoneSpec2("jasmine.describe"));
    const symbol = Zone2.__symbol__;
    const disablePatchingJasmineClock = global2[symbol("fakeAsyncDisablePatchingClock")] === true;
    const enableAutoFakeAsyncWhenClockPatched = !disablePatchingJasmineClock && (global2[symbol("fakeAsyncPatchLock")] === true || global2[symbol("fakeAsyncAutoFakeAsyncWhenClockPatched")] === true);
    const ignoreUnhandledRejection = global2[symbol("ignoreUnhandledRejection")] === true;
    if (!ignoreUnhandledRejection) {
      const globalErrors = jasmine.GlobalErrors;
      if (globalErrors && !jasmine[symbol("GlobalErrors")]) {
        jasmine[symbol("GlobalErrors")] = globalErrors;
        jasmine.GlobalErrors = function() {
          const instance = new globalErrors();
          const originalInstall = instance.install;
          if (originalInstall && !instance[symbol("install")]) {
            instance[symbol("install")] = originalInstall;
            instance.install = function() {
              const originalHandlers = process.listeners("unhandledRejection");
              const r = originalInstall.apply(this, arguments);
              process.removeAllListeners("unhandledRejection");
              if (originalHandlers) {
                originalHandlers.forEach((h) => process.on("unhandledRejection", h));
              }
              return r;
            };
          }
          return instance;
        };
      }
    }
    const jasmineEnv = jasmine.getEnv();
    ["describe", "xdescribe", "fdescribe"].forEach((methodName) => {
      let originalJasmineFn = jasmineEnv[methodName];
      jasmineEnv[methodName] = function(description, specDefinitions) {
        return originalJasmineFn.call(this, description, wrapDescribeInZone(specDefinitions));
      };
    });
    ["it", "xit", "fit"].forEach((methodName) => {
      let originalJasmineFn = jasmineEnv[methodName];
      jasmineEnv[symbol(methodName)] = originalJasmineFn;
      jasmineEnv[methodName] = function(description, specDefinitions, timeout) {
        arguments[1] = wrapTestInZone(specDefinitions);
        return originalJasmineFn.apply(this, arguments);
      };
    });
    ["beforeEach", "afterEach", "beforeAll", "afterAll"].forEach((methodName) => {
      let originalJasmineFn = jasmineEnv[methodName];
      jasmineEnv[symbol(methodName)] = originalJasmineFn;
      jasmineEnv[methodName] = function(specDefinitions, timeout) {
        arguments[0] = wrapTestInZone(specDefinitions);
        return originalJasmineFn.apply(this, arguments);
      };
    });
    if (!disablePatchingJasmineClock) {
      const originalClockFn = jasmine[symbol("clock")] = jasmine["clock"];
      jasmine["clock"] = function() {
        const clock = originalClockFn.apply(this, arguments);
        if (!clock[symbol("patched")]) {
          clock[symbol("patched")] = symbol("patched");
          const originalTick = clock[symbol("tick")] = clock.tick;
          clock.tick = function() {
            const fakeAsyncZoneSpec = Zone2.current.get("FakeAsyncTestZoneSpec");
            if (fakeAsyncZoneSpec) {
              return fakeAsyncZoneSpec.tick.apply(fakeAsyncZoneSpec, arguments);
            }
            return originalTick.apply(this, arguments);
          };
          const originalMockDate = clock[symbol("mockDate")] = clock.mockDate;
          clock.mockDate = function() {
            const fakeAsyncZoneSpec = Zone2.current.get("FakeAsyncTestZoneSpec");
            if (fakeAsyncZoneSpec) {
              const dateTime = arguments.length > 0 ? arguments[0] : new Date();
              return fakeAsyncZoneSpec.setFakeBaseSystemTime.apply(fakeAsyncZoneSpec, dateTime && typeof dateTime.getTime === "function" ? [dateTime.getTime()] : arguments);
            }
            return originalMockDate.apply(this, arguments);
          };
          if (enableAutoFakeAsyncWhenClockPatched) {
            ["install", "uninstall"].forEach((methodName) => {
              const originalClockFn2 = clock[symbol(methodName)] = clock[methodName];
              clock[methodName] = function() {
                const FakeAsyncTestZoneSpec = Zone2["FakeAsyncTestZoneSpec"];
                if (FakeAsyncTestZoneSpec) {
                  jasmine[symbol("clockInstalled")] = methodName === "install";
                  return;
                }
                return originalClockFn2.apply(this, arguments);
              };
            });
          }
        }
        return clock;
      };
    }
    if (!jasmine[Zone2.__symbol__("createSpyObj")]) {
      const originalCreateSpyObj = jasmine.createSpyObj;
      jasmine[Zone2.__symbol__("createSpyObj")] = originalCreateSpyObj;
      jasmine.createSpyObj = function() {
        const args = Array.prototype.slice.call(arguments);
        const propertyNames = args.length >= 3 ? args[2] : null;
        let spyObj;
        if (propertyNames) {
          const defineProperty = Object.defineProperty;
          Object.defineProperty = function(obj, p, attributes) {
            return defineProperty.call(this, obj, p, Object.assign(Object.assign({}, attributes), { configurable: true, enumerable: true }));
          };
          try {
            spyObj = originalCreateSpyObj.apply(this, args);
          } finally {
            Object.defineProperty = defineProperty;
          }
        } else {
          spyObj = originalCreateSpyObj.apply(this, args);
        }
        return spyObj;
      };
    }
    function wrapDescribeInZone(describeBody) {
      return function() {
        return syncZone.run(describeBody, this, arguments);
      };
    }
    function runInTestZone(testBody, applyThis, queueRunner, done) {
      const isClockInstalled = !!jasmine[symbol("clockInstalled")];
      queueRunner.testProxyZoneSpec;
      const testProxyZone = queueRunner.testProxyZone;
      if (isClockInstalled && enableAutoFakeAsyncWhenClockPatched) {
        const fakeAsyncModule = Zone2[Zone2.__symbol__("fakeAsyncTest")];
        if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === "function") {
          testBody = fakeAsyncModule.fakeAsync(testBody);
        }
      }
      if (done) {
        return testProxyZone.run(testBody, applyThis, [done]);
      } else {
        return testProxyZone.run(testBody, applyThis);
      }
    }
    function wrapTestInZone(testBody) {
      return testBody && (testBody.length ? function(done) {
        return runInTestZone(testBody, this, this.queueRunner, done);
      } : function() {
        return runInTestZone(testBody, this, this.queueRunner);
      });
    }
    const QueueRunner = jasmine.QueueRunner;
    jasmine.QueueRunner = function(_super) {
      __extends2(ZoneQueueRunner, _super);
      function ZoneQueueRunner(attrs) {
        if (attrs.onComplete) {
          attrs.onComplete = ((fn2) => () => {
            this.testProxyZone = null;
            this.testProxyZoneSpec = null;
            ambientZone.scheduleMicroTask("jasmine.onComplete", fn2);
          })(attrs.onComplete);
        }
        const nativeSetTimeout = global2[Zone2.__symbol__("setTimeout")];
        const nativeClearTimeout = global2[Zone2.__symbol__("clearTimeout")];
        if (nativeSetTimeout) {
          attrs.timeout = {
            setTimeout: nativeSetTimeout ? nativeSetTimeout : global2.setTimeout,
            clearTimeout: nativeClearTimeout ? nativeClearTimeout : global2.clearTimeout
          };
        }
        if (jasmine.UserContext) {
          if (!attrs.userContext) {
            attrs.userContext = new jasmine.UserContext();
          }
          attrs.userContext.queueRunner = this;
        } else {
          if (!attrs.userContext) {
            attrs.userContext = {};
          }
          attrs.userContext.queueRunner = this;
        }
        const onException = attrs.onException;
        attrs.onException = function(error3) {
          if (error3 && error3.message === "Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.") {
            const proxyZoneSpec = this && this.testProxyZoneSpec;
            if (proxyZoneSpec) {
              const pendingTasksInfo = proxyZoneSpec.getAndClearPendingTasksInfo();
              try {
                error3.message += pendingTasksInfo;
              } catch (err) {
              }
            }
          }
          if (onException) {
            onException.call(this, error3);
          }
        };
        _super.call(this, attrs);
      }
      ZoneQueueRunner.prototype.execute = function() {
        let zone = Zone2.current;
        let isChildOfAmbientZone = false;
        while (zone) {
          if (zone === ambientZone) {
            isChildOfAmbientZone = true;
            break;
          }
          zone = zone.parent;
        }
        if (!isChildOfAmbientZone)
          throw new Error("Unexpected Zone: " + Zone2.current.name);
        this.testProxyZoneSpec = new ProxyZoneSpec2();
        this.testProxyZone = ambientZone.fork(this.testProxyZoneSpec);
        if (!Zone2.currentTask) {
          Zone2.current.scheduleMicroTask("jasmine.execute().forceTask", () => QueueRunner.prototype.execute.call(this));
        } else {
          _super.prototype.execute.call(this);
        }
      };
      return ZoneQueueRunner;
    }(QueueRunner);
  });
  Zone.__load_patch("jest", (context2, Zone2, api) => {
    if (typeof jest === "undefined" || jest["__zone_patch__"]) {
      return;
    }
    jest["__zone_patch__"] = true;
    const ProxyZoneSpec2 = Zone2["ProxyZoneSpec"];
    const SyncTestZoneSpec2 = Zone2["SyncTestZoneSpec"];
    if (!ProxyZoneSpec2) {
      throw new Error("Missing ProxyZoneSpec");
    }
    const rootZone = Zone2.current;
    const syncZone = rootZone.fork(new SyncTestZoneSpec2("jest.describe"));
    const proxyZoneSpec = new ProxyZoneSpec2();
    const proxyZone = rootZone.fork(proxyZoneSpec);
    function wrapDescribeFactoryInZone(originalJestFn) {
      return function(...tableArgs) {
        const originalDescribeFn = originalJestFn.apply(this, tableArgs);
        return function(...args) {
          args[1] = wrapDescribeInZone(args[1]);
          return originalDescribeFn.apply(this, args);
        };
      };
    }
    function wrapTestFactoryInZone(originalJestFn) {
      return function(...tableArgs) {
        return function(...args) {
          args[1] = wrapTestInZone(args[1]);
          return originalJestFn.apply(this, tableArgs).apply(this, args);
        };
      };
    }
    function wrapDescribeInZone(describeBody) {
      return function(...args) {
        return syncZone.run(describeBody, this, args);
      };
    }
    function wrapTestInZone(testBody, isTestFunc = false) {
      if (typeof testBody !== "function") {
        return testBody;
      }
      const wrappedFunc = function() {
        if (Zone2[api.symbol("useFakeTimersCalled")] === true && testBody && !testBody.isFakeAsync) {
          const fakeAsyncModule = Zone2[Zone2.__symbol__("fakeAsyncTest")];
          if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === "function") {
            testBody = fakeAsyncModule.fakeAsync(testBody);
          }
        }
        proxyZoneSpec.isTestFunc = isTestFunc;
        return proxyZone.run(testBody, null, arguments);
      };
      Object.defineProperty(wrappedFunc, "length", { configurable: true, writable: true, enumerable: false });
      wrappedFunc.length = testBody.length;
      return wrappedFunc;
    }
    ["describe", "xdescribe", "fdescribe"].forEach((methodName) => {
      let originalJestFn = context2[methodName];
      if (context2[Zone2.__symbol__(methodName)]) {
        return;
      }
      context2[Zone2.__symbol__(methodName)] = originalJestFn;
      context2[methodName] = function(...args) {
        args[1] = wrapDescribeInZone(args[1]);
        return originalJestFn.apply(this, args);
      };
      context2[methodName].each = wrapDescribeFactoryInZone(originalJestFn.each);
    });
    context2.describe.only = context2.fdescribe;
    context2.describe.skip = context2.xdescribe;
    ["it", "xit", "fit", "test", "xtest"].forEach((methodName) => {
      let originalJestFn = context2[methodName];
      if (context2[Zone2.__symbol__(methodName)]) {
        return;
      }
      context2[Zone2.__symbol__(methodName)] = originalJestFn;
      context2[methodName] = function(...args) {
        args[1] = wrapTestInZone(args[1], true);
        return originalJestFn.apply(this, args);
      };
      context2[methodName].each = wrapTestFactoryInZone(originalJestFn.each);
      context2[methodName].todo = originalJestFn.todo;
    });
    context2.it.only = context2.fit;
    context2.it.skip = context2.xit;
    context2.test.only = context2.fit;
    context2.test.skip = context2.xit;
    ["beforeEach", "afterEach", "beforeAll", "afterAll"].forEach((methodName) => {
      let originalJestFn = context2[methodName];
      if (context2[Zone2.__symbol__(methodName)]) {
        return;
      }
      context2[Zone2.__symbol__(methodName)] = originalJestFn;
      context2[methodName] = function(...args) {
        args[0] = wrapTestInZone(args[0]);
        return originalJestFn.apply(this, args);
      };
    });
    Zone2.patchJestObject = function patchJestObject(Timer, isModern = false) {
      function isPatchingFakeTimer() {
        const fakeAsyncZoneSpec = Zone2.current.get("FakeAsyncTestZoneSpec");
        return !!fakeAsyncZoneSpec;
      }
      function isInTestFunc() {
        const proxyZoneSpec2 = Zone2.current.get("ProxyZoneSpec");
        return proxyZoneSpec2 && proxyZoneSpec2.isTestFunc;
      }
      if (Timer[api.symbol("fakeTimers")]) {
        return;
      }
      Timer[api.symbol("fakeTimers")] = true;
      api.patchMethod(Timer, "_checkFakeTimers", (delegate) => {
        return function(self2, args) {
          if (isPatchingFakeTimer()) {
            return true;
          } else {
            return delegate.apply(self2, args);
          }
        };
      });
      api.patchMethod(Timer, "useFakeTimers", (delegate) => {
        return function(self2, args) {
          Zone2[api.symbol("useFakeTimersCalled")] = true;
          if (isModern || isInTestFunc()) {
            return delegate.apply(self2, args);
          }
          return self2;
        };
      });
      api.patchMethod(Timer, "useRealTimers", (delegate) => {
        return function(self2, args) {
          Zone2[api.symbol("useFakeTimersCalled")] = false;
          if (isModern || isInTestFunc()) {
            return delegate.apply(self2, args);
          }
          return self2;
        };
      });
      api.patchMethod(Timer, "setSystemTime", (delegate) => {
        return function(self2, args) {
          const fakeAsyncZoneSpec = Zone2.current.get("FakeAsyncTestZoneSpec");
          if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {
            fakeAsyncZoneSpec.setFakeBaseSystemTime(args[0]);
          } else {
            return delegate.apply(self2, args);
          }
        };
      });
      api.patchMethod(Timer, "getRealSystemTime", (delegate) => {
        return function(self2, args) {
          const fakeAsyncZoneSpec = Zone2.current.get("FakeAsyncTestZoneSpec");
          if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {
            return fakeAsyncZoneSpec.getRealSystemTime();
          } else {
            return delegate.apply(self2, args);
          }
        };
      });
      api.patchMethod(Timer, "runAllTicks", (delegate) => {
        return function(self2, args) {
          const fakeAsyncZoneSpec = Zone2.current.get("FakeAsyncTestZoneSpec");
          if (fakeAsyncZoneSpec) {
            fakeAsyncZoneSpec.flushMicrotasks();
          } else {
            return delegate.apply(self2, args);
          }
        };
      });
      api.patchMethod(Timer, "runAllTimers", (delegate) => {
        return function(self2, args) {
          const fakeAsyncZoneSpec = Zone2.current.get("FakeAsyncTestZoneSpec");
          if (fakeAsyncZoneSpec) {
            fakeAsyncZoneSpec.flush(100, true);
          } else {
            return delegate.apply(self2, args);
          }
        };
      });
      api.patchMethod(Timer, "advanceTimersByTime", (delegate) => {
        return function(self2, args) {
          const fakeAsyncZoneSpec = Zone2.current.get("FakeAsyncTestZoneSpec");
          if (fakeAsyncZoneSpec) {
            fakeAsyncZoneSpec.tick(args[0]);
          } else {
            return delegate.apply(self2, args);
          }
        };
      });
      api.patchMethod(Timer, "runOnlyPendingTimers", (delegate) => {
        return function(self2, args) {
          const fakeAsyncZoneSpec = Zone2.current.get("FakeAsyncTestZoneSpec");
          if (fakeAsyncZoneSpec) {
            fakeAsyncZoneSpec.flushOnlyPendingTimers();
          } else {
            return delegate.apply(self2, args);
          }
        };
      });
      api.patchMethod(Timer, "advanceTimersToNextTimer", (delegate) => {
        return function(self2, args) {
          const fakeAsyncZoneSpec = Zone2.current.get("FakeAsyncTestZoneSpec");
          if (fakeAsyncZoneSpec) {
            fakeAsyncZoneSpec.tickToNext(args[0]);
          } else {
            return delegate.apply(self2, args);
          }
        };
      });
      api.patchMethod(Timer, "clearAllTimers", (delegate) => {
        return function(self2, args) {
          const fakeAsyncZoneSpec = Zone2.current.get("FakeAsyncTestZoneSpec");
          if (fakeAsyncZoneSpec) {
            fakeAsyncZoneSpec.removeAllTimers();
          } else {
            return delegate.apply(self2, args);
          }
        };
      });
      api.patchMethod(Timer, "getTimerCount", (delegate) => {
        return function(self2, args) {
          const fakeAsyncZoneSpec = Zone2.current.get("FakeAsyncTestZoneSpec");
          if (fakeAsyncZoneSpec) {
            return fakeAsyncZoneSpec.getTimerCount();
          } else {
            return delegate.apply(self2, args);
          }
        };
      });
    };
  });
  Zone.__load_patch("mocha", (global2, Zone2) => {
    const Mocha = global2.Mocha;
    if (typeof Mocha === "undefined") {
      return;
    }
    if (typeof Zone2 === "undefined") {
      throw new Error("Missing Zone.js");
    }
    const ProxyZoneSpec2 = Zone2["ProxyZoneSpec"];
    const SyncTestZoneSpec2 = Zone2["SyncTestZoneSpec"];
    if (!ProxyZoneSpec2) {
      throw new Error("Missing ProxyZoneSpec");
    }
    if (Mocha["__zone_patch__"]) {
      throw new Error('"Mocha" has already been patched with "Zone".');
    }
    Mocha["__zone_patch__"] = true;
    const rootZone = Zone2.current;
    const syncZone = rootZone.fork(new SyncTestZoneSpec2("Mocha.describe"));
    let testZone = null;
    const suiteZone = rootZone.fork(new ProxyZoneSpec2());
    const mochaOriginal = {
      after: global2.after,
      afterEach: global2.afterEach,
      before: global2.before,
      beforeEach: global2.beforeEach,
      describe: global2.describe,
      it: global2.it
    };
    function modifyArguments(args, syncTest, asyncTest) {
      for (let i = 0; i < args.length; i++) {
        let arg = args[i];
        if (typeof arg === "function") {
          args[i] = arg.length === 0 ? syncTest(arg) : asyncTest(arg);
          args[i].toString = function() {
            return arg.toString();
          };
        }
      }
      return args;
    }
    function wrapDescribeInZone(args) {
      const syncTest = function(fn2) {
        return function() {
          return syncZone.run(fn2, this, arguments);
        };
      };
      return modifyArguments(args, syncTest);
    }
    function wrapTestInZone(args) {
      const asyncTest = function(fn2) {
        return function(done) {
          return testZone.run(fn2, this, [done]);
        };
      };
      const syncTest = function(fn2) {
        return function() {
          return testZone.run(fn2, this);
        };
      };
      return modifyArguments(args, syncTest, asyncTest);
    }
    function wrapSuiteInZone(args) {
      const asyncTest = function(fn2) {
        return function(done) {
          return suiteZone.run(fn2, this, [done]);
        };
      };
      const syncTest = function(fn2) {
        return function() {
          return suiteZone.run(fn2, this);
        };
      };
      return modifyArguments(args, syncTest, asyncTest);
    }
    global2.describe = global2.suite = function() {
      return mochaOriginal.describe.apply(this, wrapDescribeInZone(arguments));
    };
    global2.xdescribe = global2.suite.skip = function() {
      return mochaOriginal.describe.skip.apply(this, wrapDescribeInZone(arguments));
    };
    global2.describe.only = global2.suite.only = function() {
      return mochaOriginal.describe.only.apply(this, wrapDescribeInZone(arguments));
    };
    global2.it = global2.specify = global2.test = function() {
      return mochaOriginal.it.apply(this, wrapTestInZone(arguments));
    };
    global2.xit = global2.xspecify = function() {
      return mochaOriginal.it.skip.apply(this, wrapTestInZone(arguments));
    };
    global2.it.only = global2.test.only = function() {
      return mochaOriginal.it.only.apply(this, wrapTestInZone(arguments));
    };
    global2.after = global2.suiteTeardown = function() {
      return mochaOriginal.after.apply(this, wrapSuiteInZone(arguments));
    };
    global2.afterEach = global2.teardown = function() {
      return mochaOriginal.afterEach.apply(this, wrapTestInZone(arguments));
    };
    global2.before = global2.suiteSetup = function() {
      return mochaOriginal.before.apply(this, wrapSuiteInZone(arguments));
    };
    global2.beforeEach = global2.setup = function() {
      return mochaOriginal.beforeEach.apply(this, wrapTestInZone(arguments));
    };
    ((originalRunTest, originalRun) => {
      Mocha.Runner.prototype.runTest = function(fn2) {
        Zone2.current.scheduleMicroTask("mocha.forceTask", () => {
          originalRunTest.call(this, fn2);
        });
      };
      Mocha.Runner.prototype.run = function(fn2) {
        this.on("test", (e) => {
          testZone = rootZone.fork(new ProxyZoneSpec2());
        });
        this.on("fail", (test, err) => {
          const proxyZoneSpec = testZone && testZone.get("ProxyZoneSpec");
          if (proxyZoneSpec && err) {
            try {
              err.message += proxyZoneSpec.getAndClearPendingTasksInfo();
            } catch (error3) {
            }
          }
        });
        return originalRun.call(this, fn2);
      };
    })(Mocha.Runner.prototype.runTest, Mocha.Runner.prototype.run);
  });
  (function(_global5) {
    class AsyncTestZoneSpec {
      constructor(finishCallback, failCallback, namePrefix) {
        this.finishCallback = finishCallback;
        this.failCallback = failCallback;
        this._pendingMicroTasks = false;
        this._pendingMacroTasks = false;
        this._alreadyErrored = false;
        this._isSync = false;
        this.entryFunction = null;
        this.runZone = Zone.current;
        this.unresolvedChainedPromiseCount = 0;
        this.supportWaitUnresolvedChainedPromise = false;
        this.name = "asyncTestZone for " + namePrefix;
        this.properties = { "AsyncTestZoneSpec": this };
        this.supportWaitUnresolvedChainedPromise = _global5[Zone.__symbol__("supportWaitUnResolvedChainedPromise")] === true;
      }
      isUnresolvedChainedPromisePending() {
        return this.unresolvedChainedPromiseCount > 0;
      }
      _finishCallbackIfDone() {
        if (!(this._pendingMicroTasks || this._pendingMacroTasks || this.supportWaitUnresolvedChainedPromise && this.isUnresolvedChainedPromisePending())) {
          this.runZone.run(() => {
            setTimeout(() => {
              if (!this._alreadyErrored && !(this._pendingMicroTasks || this._pendingMacroTasks)) {
                this.finishCallback();
              }
            }, 0);
          });
        }
      }
      patchPromiseForTest() {
        if (!this.supportWaitUnresolvedChainedPromise) {
          return;
        }
        const patchPromiseForTest = Promise[Zone.__symbol__("patchPromiseForTest")];
        if (patchPromiseForTest) {
          patchPromiseForTest();
        }
      }
      unPatchPromiseForTest() {
        if (!this.supportWaitUnresolvedChainedPromise) {
          return;
        }
        const unPatchPromiseForTest = Promise[Zone.__symbol__("unPatchPromiseForTest")];
        if (unPatchPromiseForTest) {
          unPatchPromiseForTest();
        }
      }
      onScheduleTask(delegate, current, target, task) {
        if (task.type !== "eventTask") {
          this._isSync = false;
        }
        if (task.type === "microTask" && task.data && task.data instanceof Promise) {
          if (task.data[AsyncTestZoneSpec.symbolParentUnresolved] === true) {
            this.unresolvedChainedPromiseCount--;
          }
        }
        return delegate.scheduleTask(target, task);
      }
      onInvokeTask(delegate, current, target, task, applyThis, applyArgs) {
        if (task.type !== "eventTask") {
          this._isSync = false;
        }
        return delegate.invokeTask(target, task, applyThis, applyArgs);
      }
      onCancelTask(delegate, current, target, task) {
        if (task.type !== "eventTask") {
          this._isSync = false;
        }
        return delegate.cancelTask(target, task);
      }
      onInvoke(parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {
        if (!this.entryFunction) {
          this.entryFunction = delegate;
        }
        try {
          this._isSync = true;
          return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);
        } finally {
          parentZoneDelegate._taskCounts;
          if (this._isSync && this.entryFunction === delegate) {
            this._finishCallbackIfDone();
          }
        }
      }
      onHandleError(parentZoneDelegate, currentZone, targetZone, error3) {
        const result = parentZoneDelegate.handleError(targetZone, error3);
        if (result) {
          this.failCallback(error3);
          this._alreadyErrored = true;
        }
        return false;
      }
      onHasTask(delegate, current, target, hasTaskState) {
        delegate.hasTask(target, hasTaskState);
        if (current !== target) {
          return;
        }
        if (hasTaskState.change == "microTask") {
          this._pendingMicroTasks = hasTaskState.microTask;
          this._finishCallbackIfDone();
        } else if (hasTaskState.change == "macroTask") {
          this._pendingMacroTasks = hasTaskState.macroTask;
          this._finishCallbackIfDone();
        }
      }
    }
    AsyncTestZoneSpec.symbolParentUnresolved = Zone.__symbol__("parentUnresolved");
    Zone["AsyncTestZoneSpec"] = AsyncTestZoneSpec;
  })(typeof window !== "undefined" && window || typeof self !== "undefined" && self || global);
  Zone.__load_patch("asynctest", (global2, Zone2, api) => {
    Zone2[api.symbol("asyncTest")] = function asyncTest(fn2) {
      if (global2.jasmine) {
        return function(done) {
          if (!done) {
            done = function() {
            };
            done.fail = function(e) {
              throw e;
            };
          }
          runInTestZone(fn2, this, done, (err) => {
            if (typeof err === "string") {
              return done.fail(new Error(err));
            } else {
              done.fail(err);
            }
          });
        };
      }
      return function() {
        return new Promise((finishCallback, failCallback) => {
          runInTestZone(fn2, this, finishCallback, failCallback);
        });
      };
    };
    function runInTestZone(fn2, context2, finishCallback, failCallback) {
      const currentZone = Zone2.current;
      const AsyncTestZoneSpec = Zone2["AsyncTestZoneSpec"];
      if (AsyncTestZoneSpec === void 0) {
        throw new Error("AsyncTestZoneSpec is needed for the async() test helper but could not be found. Please make sure that your environment includes zone.js/plugins/async-test");
      }
      const ProxyZoneSpec2 = Zone2["ProxyZoneSpec"];
      if (!ProxyZoneSpec2) {
        throw new Error("ProxyZoneSpec is needed for the async() test helper but could not be found. Please make sure that your environment includes zone.js/plugins/proxy");
      }
      const proxyZoneSpec = ProxyZoneSpec2.get();
      ProxyZoneSpec2.assertPresent();
      const proxyZone = Zone2.current.getZoneWith("ProxyZoneSpec");
      const previousDelegate = proxyZoneSpec.getDelegate();
      proxyZone.parent.run(() => {
        const testZoneSpec = new AsyncTestZoneSpec(() => {
          if (proxyZoneSpec.getDelegate() == testZoneSpec) {
            proxyZoneSpec.setDelegate(previousDelegate);
          }
          testZoneSpec.unPatchPromiseForTest();
          currentZone.run(() => {
            finishCallback();
          });
        }, (error3) => {
          if (proxyZoneSpec.getDelegate() == testZoneSpec) {
            proxyZoneSpec.setDelegate(previousDelegate);
          }
          testZoneSpec.unPatchPromiseForTest();
          currentZone.run(() => {
            failCallback(error3);
          });
        }, "test");
        proxyZoneSpec.setDelegate(testZoneSpec);
        testZoneSpec.patchPromiseForTest();
      });
      return Zone2.current.runGuarded(fn2, context2);
    }
  });
  (function(global2) {
    const OriginalDate = global2.Date;
    function FakeDate() {
      if (arguments.length === 0) {
        const d = new OriginalDate();
        d.setTime(FakeDate.now());
        return d;
      } else {
        const args = Array.prototype.slice.call(arguments);
        return new OriginalDate(...args);
      }
    }
    FakeDate.now = function() {
      const fakeAsyncTestZoneSpec = Zone.current.get("FakeAsyncTestZoneSpec");
      if (fakeAsyncTestZoneSpec) {
        return fakeAsyncTestZoneSpec.getFakeSystemTime();
      }
      return OriginalDate.now.apply(this, arguments);
    };
    FakeDate.UTC = OriginalDate.UTC;
    FakeDate.parse = OriginalDate.parse;
    const timers = {
      setTimeout: global2.setTimeout,
      setInterval: global2.setInterval,
      clearTimeout: global2.clearTimeout,
      clearInterval: global2.clearInterval
    };
    class Scheduler {
      constructor() {
        this._schedulerQueue = [];
        this._currentTickTime = 0;
        this._currentFakeBaseSystemTime = OriginalDate.now();
        this._currentTickRequeuePeriodicEntries = [];
      }
      getCurrentTickTime() {
        return this._currentTickTime;
      }
      getFakeSystemTime() {
        return this._currentFakeBaseSystemTime + this._currentTickTime;
      }
      setFakeBaseSystemTime(fakeBaseSystemTime) {
        this._currentFakeBaseSystemTime = fakeBaseSystemTime;
      }
      getRealSystemTime() {
        return OriginalDate.now();
      }
      scheduleFunction(cb, delay, options) {
        options = Object.assign({
          args: [],
          isPeriodic: false,
          isRequestAnimationFrame: false,
          id: -1,
          isRequeuePeriodic: false
        }, options);
        let currentId = options.id < 0 ? Scheduler.nextId++ : options.id;
        let endTime = this._currentTickTime + delay;
        let newEntry = {
          endTime,
          id: currentId,
          func: cb,
          args: options.args,
          delay,
          isPeriodic: options.isPeriodic,
          isRequestAnimationFrame: options.isRequestAnimationFrame
        };
        if (options.isRequeuePeriodic) {
          this._currentTickRequeuePeriodicEntries.push(newEntry);
        }
        let i = 0;
        for (; i < this._schedulerQueue.length; i++) {
          let currentEntry = this._schedulerQueue[i];
          if (newEntry.endTime < currentEntry.endTime) {
            break;
          }
        }
        this._schedulerQueue.splice(i, 0, newEntry);
        return currentId;
      }
      removeScheduledFunctionWithId(id) {
        for (let i = 0; i < this._schedulerQueue.length; i++) {
          if (this._schedulerQueue[i].id == id) {
            this._schedulerQueue.splice(i, 1);
            break;
          }
        }
      }
      removeAll() {
        this._schedulerQueue = [];
      }
      getTimerCount() {
        return this._schedulerQueue.length;
      }
      tickToNext(step = 1, doTick, tickOptions) {
        if (this._schedulerQueue.length < step) {
          return;
        }
        const startTime = this._currentTickTime;
        const targetTask = this._schedulerQueue[step - 1];
        this.tick(targetTask.endTime - startTime, doTick, tickOptions);
      }
      tick(millis = 0, doTick, tickOptions) {
        let finalTime = this._currentTickTime + millis;
        let lastCurrentTime = 0;
        tickOptions = Object.assign({ processNewMacroTasksSynchronously: true }, tickOptions);
        const schedulerQueue = tickOptions.processNewMacroTasksSynchronously ? this._schedulerQueue : this._schedulerQueue.slice();
        if (schedulerQueue.length === 0 && doTick) {
          doTick(millis);
          return;
        }
        while (schedulerQueue.length > 0) {
          this._currentTickRequeuePeriodicEntries = [];
          let current = schedulerQueue[0];
          if (finalTime < current.endTime) {
            break;
          } else {
            let current2 = schedulerQueue.shift();
            if (!tickOptions.processNewMacroTasksSynchronously) {
              const idx = this._schedulerQueue.indexOf(current2);
              if (idx >= 0) {
                this._schedulerQueue.splice(idx, 1);
              }
            }
            lastCurrentTime = this._currentTickTime;
            this._currentTickTime = current2.endTime;
            if (doTick) {
              doTick(this._currentTickTime - lastCurrentTime);
            }
            let retval = current2.func.apply(global2, current2.isRequestAnimationFrame ? [this._currentTickTime] : current2.args);
            if (!retval) {
              break;
            }
            if (!tickOptions.processNewMacroTasksSynchronously) {
              this._currentTickRequeuePeriodicEntries.forEach((newEntry) => {
                let i = 0;
                for (; i < schedulerQueue.length; i++) {
                  const currentEntry = schedulerQueue[i];
                  if (newEntry.endTime < currentEntry.endTime) {
                    break;
                  }
                }
                schedulerQueue.splice(i, 0, newEntry);
              });
            }
          }
        }
        lastCurrentTime = this._currentTickTime;
        this._currentTickTime = finalTime;
        if (doTick) {
          doTick(this._currentTickTime - lastCurrentTime);
        }
      }
      flushOnlyPendingTimers(doTick) {
        if (this._schedulerQueue.length === 0) {
          return 0;
        }
        const startTime = this._currentTickTime;
        const lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];
        this.tick(lastTask.endTime - startTime, doTick, { processNewMacroTasksSynchronously: false });
        return this._currentTickTime - startTime;
      }
      flush(limit = 20, flushPeriodic = false, doTick) {
        if (flushPeriodic) {
          return this.flushPeriodic(doTick);
        } else {
          return this.flushNonPeriodic(limit, doTick);
        }
      }
      flushPeriodic(doTick) {
        if (this._schedulerQueue.length === 0) {
          return 0;
        }
        const startTime = this._currentTickTime;
        const lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];
        this.tick(lastTask.endTime - startTime, doTick);
        return this._currentTickTime - startTime;
      }
      flushNonPeriodic(limit, doTick) {
        const startTime = this._currentTickTime;
        let lastCurrentTime = 0;
        let count = 0;
        while (this._schedulerQueue.length > 0) {
          count++;
          if (count > limit) {
            throw new Error("flush failed after reaching the limit of " + limit + " tasks. Does your code use a polling timeout?");
          }
          if (this._schedulerQueue.filter((task) => !task.isPeriodic && !task.isRequestAnimationFrame).length === 0) {
            break;
          }
          const current = this._schedulerQueue.shift();
          lastCurrentTime = this._currentTickTime;
          this._currentTickTime = current.endTime;
          if (doTick) {
            doTick(this._currentTickTime - lastCurrentTime);
          }
          const retval = current.func.apply(global2, current.args);
          if (!retval) {
            break;
          }
        }
        return this._currentTickTime - startTime;
      }
    }
    Scheduler.nextId = 1;
    class FakeAsyncTestZoneSpec {
      constructor(namePrefix, trackPendingRequestAnimationFrame = false, macroTaskOptions) {
        this.trackPendingRequestAnimationFrame = trackPendingRequestAnimationFrame;
        this.macroTaskOptions = macroTaskOptions;
        this._scheduler = new Scheduler();
        this._microtasks = [];
        this._lastError = null;
        this._uncaughtPromiseErrors = Promise[Zone.__symbol__("uncaughtPromiseErrors")];
        this.pendingPeriodicTimers = [];
        this.pendingTimers = [];
        this.patchDateLocked = false;
        this.properties = { "FakeAsyncTestZoneSpec": this };
        this.name = "fakeAsyncTestZone for " + namePrefix;
        if (!this.macroTaskOptions) {
          this.macroTaskOptions = global2[Zone.__symbol__("FakeAsyncTestMacroTask")];
        }
      }
      static assertInZone() {
        if (Zone.current.get("FakeAsyncTestZoneSpec") == null) {
          throw new Error("The code should be running in the fakeAsync zone to call this function");
        }
      }
      _fnAndFlush(fn2, completers) {
        return (...args) => {
          fn2.apply(global2, args);
          if (this._lastError === null) {
            if (completers.onSuccess != null) {
              completers.onSuccess.apply(global2);
            }
            this.flushMicrotasks();
          } else {
            if (completers.onError != null) {
              completers.onError.apply(global2);
            }
          }
          return this._lastError === null;
        };
      }
      static _removeTimer(timers2, id) {
        let index = timers2.indexOf(id);
        if (index > -1) {
          timers2.splice(index, 1);
        }
      }
      _dequeueTimer(id) {
        return () => {
          FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);
        };
      }
      _requeuePeriodicTimer(fn2, interval, args, id) {
        return () => {
          if (this.pendingPeriodicTimers.indexOf(id) !== -1) {
            this._scheduler.scheduleFunction(fn2, interval, { args, isPeriodic: true, id, isRequeuePeriodic: true });
          }
        };
      }
      _dequeuePeriodicTimer(id) {
        return () => {
          FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);
        };
      }
      _setTimeout(fn2, delay, args, isTimer = true) {
        let removeTimerFn = this._dequeueTimer(Scheduler.nextId);
        let cb = this._fnAndFlush(fn2, { onSuccess: removeTimerFn, onError: removeTimerFn });
        let id = this._scheduler.scheduleFunction(cb, delay, { args, isRequestAnimationFrame: !isTimer });
        if (isTimer) {
          this.pendingTimers.push(id);
        }
        return id;
      }
      _clearTimeout(id) {
        FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);
        this._scheduler.removeScheduledFunctionWithId(id);
      }
      _setInterval(fn2, interval, args) {
        let id = Scheduler.nextId;
        let completers = { onSuccess: null, onError: this._dequeuePeriodicTimer(id) };
        let cb = this._fnAndFlush(fn2, completers);
        completers.onSuccess = this._requeuePeriodicTimer(cb, interval, args, id);
        this._scheduler.scheduleFunction(cb, interval, { args, isPeriodic: true });
        this.pendingPeriodicTimers.push(id);
        return id;
      }
      _clearInterval(id) {
        FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);
        this._scheduler.removeScheduledFunctionWithId(id);
      }
      _resetLastErrorAndThrow() {
        let error3 = this._lastError || this._uncaughtPromiseErrors[0];
        this._uncaughtPromiseErrors.length = 0;
        this._lastError = null;
        throw error3;
      }
      getCurrentTickTime() {
        return this._scheduler.getCurrentTickTime();
      }
      getFakeSystemTime() {
        return this._scheduler.getFakeSystemTime();
      }
      setFakeBaseSystemTime(realTime) {
        this._scheduler.setFakeBaseSystemTime(realTime);
      }
      getRealSystemTime() {
        return this._scheduler.getRealSystemTime();
      }
      static patchDate() {
        if (!!global2[Zone.__symbol__("disableDatePatching")]) {
          return;
        }
        if (global2["Date"] === FakeDate) {
          return;
        }
        global2["Date"] = FakeDate;
        FakeDate.prototype = OriginalDate.prototype;
        FakeAsyncTestZoneSpec.checkTimerPatch();
      }
      static resetDate() {
        if (global2["Date"] === FakeDate) {
          global2["Date"] = OriginalDate;
        }
      }
      static checkTimerPatch() {
        if (global2.setTimeout !== timers.setTimeout) {
          global2.setTimeout = timers.setTimeout;
          global2.clearTimeout = timers.clearTimeout;
        }
        if (global2.setInterval !== timers.setInterval) {
          global2.setInterval = timers.setInterval;
          global2.clearInterval = timers.clearInterval;
        }
      }
      lockDatePatch() {
        this.patchDateLocked = true;
        FakeAsyncTestZoneSpec.patchDate();
      }
      unlockDatePatch() {
        this.patchDateLocked = false;
        FakeAsyncTestZoneSpec.resetDate();
      }
      tickToNext(steps = 1, doTick, tickOptions = { processNewMacroTasksSynchronously: true }) {
        if (steps <= 0) {
          return;
        }
        FakeAsyncTestZoneSpec.assertInZone();
        this.flushMicrotasks();
        this._scheduler.tickToNext(steps, doTick, tickOptions);
        if (this._lastError !== null) {
          this._resetLastErrorAndThrow();
        }
      }
      tick(millis = 0, doTick, tickOptions = { processNewMacroTasksSynchronously: true }) {
        FakeAsyncTestZoneSpec.assertInZone();
        this.flushMicrotasks();
        this._scheduler.tick(millis, doTick, tickOptions);
        if (this._lastError !== null) {
          this._resetLastErrorAndThrow();
        }
      }
      flushMicrotasks() {
        FakeAsyncTestZoneSpec.assertInZone();
        const flushErrors = () => {
          if (this._lastError !== null || this._uncaughtPromiseErrors.length) {
            this._resetLastErrorAndThrow();
          }
        };
        while (this._microtasks.length > 0) {
          let microtask = this._microtasks.shift();
          microtask.func.apply(microtask.target, microtask.args);
        }
        flushErrors();
      }
      flush(limit, flushPeriodic, doTick) {
        FakeAsyncTestZoneSpec.assertInZone();
        this.flushMicrotasks();
        const elapsed = this._scheduler.flush(limit, flushPeriodic, doTick);
        if (this._lastError !== null) {
          this._resetLastErrorAndThrow();
        }
        return elapsed;
      }
      flushOnlyPendingTimers(doTick) {
        FakeAsyncTestZoneSpec.assertInZone();
        this.flushMicrotasks();
        const elapsed = this._scheduler.flushOnlyPendingTimers(doTick);
        if (this._lastError !== null) {
          this._resetLastErrorAndThrow();
        }
        return elapsed;
      }
      removeAllTimers() {
        FakeAsyncTestZoneSpec.assertInZone();
        this._scheduler.removeAll();
        this.pendingPeriodicTimers = [];
        this.pendingTimers = [];
      }
      getTimerCount() {
        return this._scheduler.getTimerCount() + this._microtasks.length;
      }
      onScheduleTask(delegate, current, target, task) {
        switch (task.type) {
          case "microTask":
            let args = task.data && task.data.args;
            let additionalArgs;
            if (args) {
              let callbackIndex = task.data.cbIdx;
              if (typeof args.length === "number" && args.length > callbackIndex + 1) {
                additionalArgs = Array.prototype.slice.call(args, callbackIndex + 1);
              }
            }
            this._microtasks.push({
              func: task.invoke,
              args: additionalArgs,
              target: task.data && task.data.target
            });
            break;
          case "macroTask":
            switch (task.source) {
              case "setTimeout":
                task.data["handleId"] = this._setTimeout(task.invoke, task.data["delay"], Array.prototype.slice.call(task.data["args"], 2));
                break;
              case "setImmediate":
                task.data["handleId"] = this._setTimeout(task.invoke, 0, Array.prototype.slice.call(task.data["args"], 1));
                break;
              case "setInterval":
                task.data["handleId"] = this._setInterval(task.invoke, task.data["delay"], Array.prototype.slice.call(task.data["args"], 2));
                break;
              case "XMLHttpRequest.send":
                throw new Error("Cannot make XHRs from within a fake async test. Request URL: " + task.data["url"]);
              case "requestAnimationFrame":
              case "webkitRequestAnimationFrame":
              case "mozRequestAnimationFrame":
                task.data["handleId"] = this._setTimeout(task.invoke, 16, task.data["args"], this.trackPendingRequestAnimationFrame);
                break;
              default:
                const macroTaskOption = this.findMacroTaskOption(task);
                if (macroTaskOption) {
                  const args2 = task.data && task.data["args"];
                  const delay = args2 && args2.length > 1 ? args2[1] : 0;
                  let callbackArgs = macroTaskOption.callbackArgs ? macroTaskOption.callbackArgs : args2;
                  if (!!macroTaskOption.isPeriodic) {
                    task.data["handleId"] = this._setInterval(task.invoke, delay, callbackArgs);
                    task.data.isPeriodic = true;
                  } else {
                    task.data["handleId"] = this._setTimeout(task.invoke, delay, callbackArgs);
                  }
                  break;
                }
                throw new Error("Unknown macroTask scheduled in fake async test: " + task.source);
            }
            break;
          case "eventTask":
            task = delegate.scheduleTask(target, task);
            break;
        }
        return task;
      }
      onCancelTask(delegate, current, target, task) {
        switch (task.source) {
          case "setTimeout":
          case "requestAnimationFrame":
          case "webkitRequestAnimationFrame":
          case "mozRequestAnimationFrame":
            return this._clearTimeout(task.data["handleId"]);
          case "setInterval":
            return this._clearInterval(task.data["handleId"]);
          default:
            const macroTaskOption = this.findMacroTaskOption(task);
            if (macroTaskOption) {
              const handleId = task.data["handleId"];
              return macroTaskOption.isPeriodic ? this._clearInterval(handleId) : this._clearTimeout(handleId);
            }
            return delegate.cancelTask(target, task);
        }
      }
      onInvoke(delegate, current, target, callback, applyThis, applyArgs, source) {
        try {
          FakeAsyncTestZoneSpec.patchDate();
          return delegate.invoke(target, callback, applyThis, applyArgs, source);
        } finally {
          if (!this.patchDateLocked) {
            FakeAsyncTestZoneSpec.resetDate();
          }
        }
      }
      findMacroTaskOption(task) {
        if (!this.macroTaskOptions) {
          return null;
        }
        for (let i = 0; i < this.macroTaskOptions.length; i++) {
          const macroTaskOption = this.macroTaskOptions[i];
          if (macroTaskOption.source === task.source) {
            return macroTaskOption;
          }
        }
        return null;
      }
      onHandleError(parentZoneDelegate, currentZone, targetZone, error3) {
        this._lastError = error3;
        return false;
      }
    }
    Zone["FakeAsyncTestZoneSpec"] = FakeAsyncTestZoneSpec;
  })(typeof window === "object" && window || typeof self === "object" && self || global);
  Zone.__load_patch("fakeasync", (global2, Zone2, api) => {
    const FakeAsyncTestZoneSpec = Zone2 && Zone2["FakeAsyncTestZoneSpec"];
    function getProxyZoneSpec() {
      return Zone2 && Zone2["ProxyZoneSpec"];
    }
    let _fakeAsyncTestZoneSpec = null;
    function resetFakeAsyncZone2() {
      if (_fakeAsyncTestZoneSpec) {
        _fakeAsyncTestZoneSpec.unlockDatePatch();
      }
      _fakeAsyncTestZoneSpec = null;
      getProxyZoneSpec() && getProxyZoneSpec().assertPresent().resetDelegate();
    }
    function fakeAsync(fn2) {
      const fakeAsyncFn = function(...args) {
        const ProxyZoneSpec2 = getProxyZoneSpec();
        if (!ProxyZoneSpec2) {
          throw new Error("ProxyZoneSpec is needed for the async() test helper but could not be found. Please make sure that your environment includes zone.js/plugins/proxy");
        }
        const proxyZoneSpec = ProxyZoneSpec2.assertPresent();
        if (Zone2.current.get("FakeAsyncTestZoneSpec")) {
          throw new Error("fakeAsync() calls can not be nested");
        }
        try {
          if (!_fakeAsyncTestZoneSpec) {
            if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {
              throw new Error("fakeAsync() calls can not be nested");
            }
            _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();
          }
          let res;
          const lastProxyZoneSpec = proxyZoneSpec.getDelegate();
          proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);
          _fakeAsyncTestZoneSpec.lockDatePatch();
          try {
            res = fn2.apply(this, args);
            flushMicrotasks();
          } finally {
            proxyZoneSpec.setDelegate(lastProxyZoneSpec);
          }
          if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {
            throw new Error(`${_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length} periodic timer(s) still in the queue.`);
          }
          if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {
            throw new Error(`${_fakeAsyncTestZoneSpec.pendingTimers.length} timer(s) still in the queue.`);
          }
          return res;
        } finally {
          resetFakeAsyncZone2();
        }
      };
      fakeAsyncFn.isFakeAsync = true;
      return fakeAsyncFn;
    }
    function _getFakeAsyncZoneSpec() {
      if (_fakeAsyncTestZoneSpec == null) {
        _fakeAsyncTestZoneSpec = Zone2.current.get("FakeAsyncTestZoneSpec");
        if (_fakeAsyncTestZoneSpec == null) {
          throw new Error("The code should be running in the fakeAsync zone to call this function");
        }
      }
      return _fakeAsyncTestZoneSpec;
    }
    function tick(millis = 0, ignoreNestedTimeout = false) {
      _getFakeAsyncZoneSpec().tick(millis, null, ignoreNestedTimeout);
    }
    function flush(maxTurns) {
      return _getFakeAsyncZoneSpec().flush(maxTurns);
    }
    function discardPeriodicTasks() {
      const zoneSpec = _getFakeAsyncZoneSpec();
      zoneSpec.pendingPeriodicTimers;
      zoneSpec.pendingPeriodicTimers.length = 0;
    }
    function flushMicrotasks() {
      _getFakeAsyncZoneSpec().flushMicrotasks();
    }
    Zone2[api.symbol("fakeAsyncTest")] = { resetFakeAsyncZone: resetFakeAsyncZone2, flushMicrotasks, discardPeriodicTasks, tick, flush, fakeAsync };
  }, true);
  Zone.__load_patch("promisefortest", (global2, Zone2, api) => {
    const symbolState = api.symbol("state");
    const UNRESOLVED = null;
    const symbolParentUnresolved = api.symbol("parentUnresolved");
    Promise[api.symbol("patchPromiseForTest")] = function patchPromiseForTest() {
      let oriThen = Promise[Zone2.__symbol__("ZonePromiseThen")];
      if (oriThen) {
        return;
      }
      oriThen = Promise[Zone2.__symbol__("ZonePromiseThen")] = Promise.prototype.then;
      Promise.prototype.then = function() {
        const chained = oriThen.apply(this, arguments);
        if (this[symbolState] === UNRESOLVED) {
          const asyncTestZoneSpec = Zone2.current.get("AsyncTestZoneSpec");
          if (asyncTestZoneSpec) {
            asyncTestZoneSpec.unresolvedChainedPromiseCount++;
            chained[symbolParentUnresolved] = true;
          }
        }
        return chained;
      };
    };
    Promise[api.symbol("unPatchPromiseForTest")] = function unpatchPromiseForTest() {
      const oriThen = Promise[Zone2.__symbol__("ZonePromiseThen")];
      if (oriThen) {
        Promise.prototype.then = oriThen;
        Promise[Zone2.__symbol__("ZonePromiseThen")] = void 0;
      }
    };
  });

  // node_modules/@angular/core/fesm2020/core.mjs
  var core_exports = {};
  __export(core_exports, {
    ANALYZE_FOR_ENTRY_COMPONENTS: () => ANALYZE_FOR_ENTRY_COMPONENTS,
    APP_BOOTSTRAP_LISTENER: () => APP_BOOTSTRAP_LISTENER,
    APP_ID: () => APP_ID,
    APP_INITIALIZER: () => APP_INITIALIZER,
    ApplicationInitStatus: () => ApplicationInitStatus,
    ApplicationModule: () => ApplicationModule,
    ApplicationRef: () => ApplicationRef,
    Attribute: () => Attribute,
    COMPILER_OPTIONS: () => COMPILER_OPTIONS,
    CUSTOM_ELEMENTS_SCHEMA: () => CUSTOM_ELEMENTS_SCHEMA,
    ChangeDetectionStrategy: () => ChangeDetectionStrategy,
    ChangeDetectorRef: () => ChangeDetectorRef,
    Compiler: () => Compiler,
    CompilerFactory: () => CompilerFactory,
    Component: () => Component,
    ComponentFactory: () => ComponentFactory$1,
    ComponentFactoryResolver: () => ComponentFactoryResolver$1,
    ComponentRef: () => ComponentRef$1,
    ContentChild: () => ContentChild,
    ContentChildren: () => ContentChildren,
    DEFAULT_CURRENCY_CODE: () => DEFAULT_CURRENCY_CODE,
    DebugElement: () => DebugElement,
    DebugEventListener: () => DebugEventListener,
    DebugNode: () => DebugNode,
    DefaultIterableDiffer: () => DefaultIterableDiffer,
    Directive: () => Directive,
    ElementRef: () => ElementRef,
    EmbeddedViewRef: () => EmbeddedViewRef,
    ErrorHandler: () => ErrorHandler,
    EventEmitter: () => EventEmitter,
    Host: () => Host,
    HostBinding: () => HostBinding,
    HostListener: () => HostListener,
    INJECTOR: () => INJECTOR,
    Inject: () => Inject,
    InjectFlags: () => InjectFlags,
    Injectable: () => Injectable,
    InjectionToken: () => InjectionToken,
    Injector: () => Injector,
    Input: () => Input,
    IterableDiffers: () => IterableDiffers,
    KeyValueDiffers: () => KeyValueDiffers,
    LOCALE_ID: () => LOCALE_ID,
    MissingTranslationStrategy: () => MissingTranslationStrategy,
    ModuleWithComponentFactories: () => ModuleWithComponentFactories,
    NO_ERRORS_SCHEMA: () => NO_ERRORS_SCHEMA,
    NgModule: () => NgModule,
    NgModuleFactory: () => NgModuleFactory$1,
    NgModuleRef: () => NgModuleRef$1,
    NgProbeToken: () => NgProbeToken,
    NgZone: () => NgZone,
    Optional: () => Optional,
    Output: () => Output,
    PACKAGE_ROOT_URL: () => PACKAGE_ROOT_URL,
    PLATFORM_ID: () => PLATFORM_ID,
    PLATFORM_INITIALIZER: () => PLATFORM_INITIALIZER,
    Pipe: () => Pipe,
    PlatformRef: () => PlatformRef,
    Query: () => Query,
    QueryList: () => QueryList,
    ReflectiveInjector: () => ReflectiveInjector,
    ReflectiveKey: () => ReflectiveKey,
    Renderer2: () => Renderer2,
    RendererFactory2: () => RendererFactory2,
    RendererStyleFlags2: () => RendererStyleFlags2,
    ResolvedReflectiveFactory: () => ResolvedReflectiveFactory,
    Sanitizer: () => Sanitizer,
    SecurityContext: () => SecurityContext,
    Self: () => Self,
    SimpleChange: () => SimpleChange,
    SkipSelf: () => SkipSelf,
    TRANSLATIONS: () => TRANSLATIONS,
    TRANSLATIONS_FORMAT: () => TRANSLATIONS_FORMAT,
    TemplateRef: () => TemplateRef,
    Testability: () => Testability,
    TestabilityRegistry: () => TestabilityRegistry,
    Type: () => Type,
    VERSION: () => VERSION,
    Version: () => Version,
    ViewChild: () => ViewChild,
    ViewChildren: () => ViewChildren,
    ViewContainerRef: () => ViewContainerRef,
    ViewEncapsulation: () => ViewEncapsulation$1,
    ViewRef: () => ViewRef,
    asNativeElements: () => asNativeElements,
    assertPlatform: () => assertPlatform,
    createNgModuleRef: () => createNgModuleRef,
    createPlatform: () => createPlatform,
    createPlatformFactory: () => createPlatformFactory,
    defineInjectable: () => defineInjectable,
    destroyPlatform: () => destroyPlatform,
    enableProdMode: () => enableProdMode,
    forwardRef: () => forwardRef,
    getDebugNode: () => getDebugNode,
    getModuleFactory: () => getModuleFactory,
    getNgModuleById: () => getNgModuleById,
    getPlatform: () => getPlatform,
    inject: () => inject,
    isDevMode: () => isDevMode,
    platformCore: () => platformCore,
    resolveForwardRef: () => resolveForwardRef,
    setTestabilityGetter: () => setTestabilityGetter,
    \u0275ALLOW_MULTIPLE_PLATFORMS: () => ALLOW_MULTIPLE_PLATFORMS,
    \u0275APP_ID_RANDOM_PROVIDER: () => APP_ID_RANDOM_PROVIDER,
    \u0275ChangeDetectorStatus: () => ChangeDetectorStatus,
    \u0275ComponentFactory: () => ComponentFactory$1,
    \u0275Console: () => Console,
    \u0275DEFAULT_LOCALE_ID: () => DEFAULT_LOCALE_ID,
    \u0275INJECTOR_SCOPE: () => INJECTOR_SCOPE,
    \u0275LifecycleHooksFeature: () => LifecycleHooksFeature,
    \u0275LocaleDataIndex: () => LocaleDataIndex,
    \u0275NG_COMP_DEF: () => NG_COMP_DEF,
    \u0275NG_DIR_DEF: () => NG_DIR_DEF,
    \u0275NG_ELEMENT_ID: () => NG_ELEMENT_ID,
    \u0275NG_INJ_DEF: () => NG_INJ_DEF,
    \u0275NG_MOD_DEF: () => NG_MOD_DEF,
    \u0275NG_PIPE_DEF: () => NG_PIPE_DEF,
    \u0275NG_PROV_DEF: () => NG_PROV_DEF,
    \u0275NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR: () => NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR,
    \u0275NO_CHANGE: () => NO_CHANGE,
    \u0275NgModuleFactory: () => NgModuleFactory,
    \u0275NoopNgZone: () => NoopNgZone,
    \u0275ReflectionCapabilities: () => ReflectionCapabilities,
    \u0275Render3ComponentFactory: () => ComponentFactory,
    \u0275Render3ComponentRef: () => ComponentRef,
    \u0275Render3NgModuleRef: () => NgModuleRef,
    \u0275RuntimeError: () => RuntimeError,
    \u0275ViewRef: () => ViewRef$1,
    \u0275_sanitizeHtml: () => _sanitizeHtml,
    \u0275_sanitizeUrl: () => _sanitizeUrl,
    \u0275allowSanitizationBypassAndThrow: () => allowSanitizationBypassAndThrow,
    \u0275bypassSanitizationTrustHtml: () => bypassSanitizationTrustHtml,
    \u0275bypassSanitizationTrustResourceUrl: () => bypassSanitizationTrustResourceUrl,
    \u0275bypassSanitizationTrustScript: () => bypassSanitizationTrustScript,
    \u0275bypassSanitizationTrustStyle: () => bypassSanitizationTrustStyle,
    \u0275bypassSanitizationTrustUrl: () => bypassSanitizationTrustUrl,
    \u0275clearResolutionOfComponentResourcesQueue: () => clearResolutionOfComponentResourcesQueue,
    \u0275compileComponent: () => compileComponent,
    \u0275compileDirective: () => compileDirective,
    \u0275compileNgModule: () => compileNgModule,
    \u0275compileNgModuleDefs: () => compileNgModuleDefs,
    \u0275compileNgModuleFactory: () => compileNgModuleFactory,
    \u0275compilePipe: () => compilePipe,
    \u0275createInjector: () => createInjector,
    \u0275defaultIterableDiffers: () => defaultIterableDiffers,
    \u0275defaultKeyValueDiffers: () => defaultKeyValueDiffers,
    \u0275detectChanges: () => detectChanges,
    \u0275devModeEqual: () => devModeEqual,
    \u0275findLocaleData: () => findLocaleData,
    \u0275flushModuleScopingQueueAsMuchAsPossible: () => flushModuleScopingQueueAsMuchAsPossible,
    \u0275getDebugNode: () => getDebugNode,
    \u0275getDebugNodeR2: () => getDebugNodeR2,
    \u0275getDirectives: () => getDirectives,
    \u0275getHostElement: () => getHostElement,
    \u0275getInjectableDef: () => getInjectableDef,
    \u0275getLContext: () => getLContext,
    \u0275getLocaleCurrencyCode: () => getLocaleCurrencyCode,
    \u0275getLocalePluralCase: () => getLocalePluralCase,
    \u0275getSanitizationBypassType: () => getSanitizationBypassType,
    \u0275global: () => _global2,
    \u0275injectChangeDetectorRef: () => injectChangeDetectorRef,
    \u0275isBoundToModule: () => isBoundToModule,
    \u0275isDefaultChangeDetectionStrategy: () => isDefaultChangeDetectionStrategy,
    \u0275isListLikeIterable: () => isListLikeIterable,
    \u0275isObservable: () => isObservable,
    \u0275isPromise: () => isPromise2,
    \u0275isSubscribable: () => isSubscribable,
    \u0275ivyEnabled: () => \u0275ivyEnabled,
    \u0275makeDecorator: () => makeDecorator,
    \u0275markDirty: () => markDirty,
    \u0275noSideEffects: () => noSideEffects,
    \u0275patchComponentDefWithScope: () => patchComponentDefWithScope,
    \u0275publishDefaultGlobalUtils: () => publishDefaultGlobalUtils$1,
    \u0275publishGlobalUtil: () => publishGlobalUtil,
    \u0275registerLocaleData: () => registerLocaleData,
    \u0275registerNgModuleType: () => registerNgModuleType,
    \u0275renderComponent: () => renderComponent,
    \u0275resetCompiledComponents: () => resetCompiledComponents,
    \u0275resetJitOptions: () => resetJitOptions,
    \u0275resolveComponentResources: () => resolveComponentResources,
    \u0275setClassMetadata: () => setClassMetadata,
    \u0275setCurrentInjector: () => setCurrentInjector,
    \u0275setDocument: () => setDocument,
    \u0275setLocaleId: () => setLocaleId,
    \u0275store: () => store,
    \u0275stringify: () => stringify,
    \u0275transitiveScopesFor: () => transitiveScopesFor,
    \u0275unregisterLocaleData: () => unregisterAllLocaleData,
    \u0275unwrapSafeValue: () => unwrapSafeValue,
    \u0275whenRendered: () => whenRendered,
    \u0275\u0275CopyDefinitionFeature: () => \u0275\u0275CopyDefinitionFeature,
    \u0275\u0275FactoryTarget: () => FactoryTarget,
    \u0275\u0275InheritDefinitionFeature: () => \u0275\u0275InheritDefinitionFeature,
    \u0275\u0275NgOnChangesFeature: () => \u0275\u0275NgOnChangesFeature,
    \u0275\u0275ProvidersFeature: () => \u0275\u0275ProvidersFeature,
    \u0275\u0275advance: () => \u0275\u0275advance,
    \u0275\u0275attribute: () => \u0275\u0275attribute,
    \u0275\u0275attributeInterpolate1: () => \u0275\u0275attributeInterpolate1,
    \u0275\u0275attributeInterpolate2: () => \u0275\u0275attributeInterpolate2,
    \u0275\u0275attributeInterpolate3: () => \u0275\u0275attributeInterpolate3,
    \u0275\u0275attributeInterpolate4: () => \u0275\u0275attributeInterpolate4,
    \u0275\u0275attributeInterpolate5: () => \u0275\u0275attributeInterpolate5,
    \u0275\u0275attributeInterpolate6: () => \u0275\u0275attributeInterpolate6,
    \u0275\u0275attributeInterpolate7: () => \u0275\u0275attributeInterpolate7,
    \u0275\u0275attributeInterpolate8: () => \u0275\u0275attributeInterpolate8,
    \u0275\u0275attributeInterpolateV: () => \u0275\u0275attributeInterpolateV,
    \u0275\u0275classMap: () => \u0275\u0275classMap,
    \u0275\u0275classMapInterpolate1: () => \u0275\u0275classMapInterpolate1,
    \u0275\u0275classMapInterpolate2: () => \u0275\u0275classMapInterpolate2,
    \u0275\u0275classMapInterpolate3: () => \u0275\u0275classMapInterpolate3,
    \u0275\u0275classMapInterpolate4: () => \u0275\u0275classMapInterpolate4,
    \u0275\u0275classMapInterpolate5: () => \u0275\u0275classMapInterpolate5,
    \u0275\u0275classMapInterpolate6: () => \u0275\u0275classMapInterpolate6,
    \u0275\u0275classMapInterpolate7: () => \u0275\u0275classMapInterpolate7,
    \u0275\u0275classMapInterpolate8: () => \u0275\u0275classMapInterpolate8,
    \u0275\u0275classMapInterpolateV: () => \u0275\u0275classMapInterpolateV,
    \u0275\u0275classProp: () => \u0275\u0275classProp,
    \u0275\u0275contentQuery: () => \u0275\u0275contentQuery,
    \u0275\u0275defineComponent: () => \u0275\u0275defineComponent,
    \u0275\u0275defineDirective: () => \u0275\u0275defineDirective,
    \u0275\u0275defineInjectable: () => \u0275\u0275defineInjectable,
    \u0275\u0275defineInjector: () => \u0275\u0275defineInjector,
    \u0275\u0275defineNgModule: () => \u0275\u0275defineNgModule,
    \u0275\u0275definePipe: () => \u0275\u0275definePipe,
    \u0275\u0275directiveInject: () => \u0275\u0275directiveInject,
    \u0275\u0275disableBindings: () => \u0275\u0275disableBindings,
    \u0275\u0275element: () => \u0275\u0275element,
    \u0275\u0275elementContainer: () => \u0275\u0275elementContainer,
    \u0275\u0275elementContainerEnd: () => \u0275\u0275elementContainerEnd,
    \u0275\u0275elementContainerStart: () => \u0275\u0275elementContainerStart,
    \u0275\u0275elementEnd: () => \u0275\u0275elementEnd,
    \u0275\u0275elementStart: () => \u0275\u0275elementStart,
    \u0275\u0275enableBindings: () => \u0275\u0275enableBindings,
    \u0275\u0275getCurrentView: () => \u0275\u0275getCurrentView,
    \u0275\u0275getInheritedFactory: () => \u0275\u0275getInheritedFactory,
    \u0275\u0275hostProperty: () => \u0275\u0275hostProperty,
    \u0275\u0275i18n: () => \u0275\u0275i18n,
    \u0275\u0275i18nApply: () => \u0275\u0275i18nApply,
    \u0275\u0275i18nAttributes: () => \u0275\u0275i18nAttributes,
    \u0275\u0275i18nEnd: () => \u0275\u0275i18nEnd,
    \u0275\u0275i18nExp: () => \u0275\u0275i18nExp,
    \u0275\u0275i18nPostprocess: () => \u0275\u0275i18nPostprocess,
    \u0275\u0275i18nStart: () => \u0275\u0275i18nStart,
    \u0275\u0275inject: () => \u0275\u0275inject,
    \u0275\u0275injectAttribute: () => \u0275\u0275injectAttribute,
    \u0275\u0275invalidFactory: () => \u0275\u0275invalidFactory,
    \u0275\u0275invalidFactoryDep: () => \u0275\u0275invalidFactoryDep,
    \u0275\u0275listener: () => \u0275\u0275listener,
    \u0275\u0275loadQuery: () => \u0275\u0275loadQuery,
    \u0275\u0275namespaceHTML: () => \u0275\u0275namespaceHTML,
    \u0275\u0275namespaceMathML: () => \u0275\u0275namespaceMathML,
    \u0275\u0275namespaceSVG: () => \u0275\u0275namespaceSVG,
    \u0275\u0275nextContext: () => \u0275\u0275nextContext,
    \u0275\u0275ngDeclareClassMetadata: () => \u0275\u0275ngDeclareClassMetadata,
    \u0275\u0275ngDeclareComponent: () => \u0275\u0275ngDeclareComponent,
    \u0275\u0275ngDeclareDirective: () => \u0275\u0275ngDeclareDirective,
    \u0275\u0275ngDeclareFactory: () => \u0275\u0275ngDeclareFactory,
    \u0275\u0275ngDeclareInjectable: () => \u0275\u0275ngDeclareInjectable,
    \u0275\u0275ngDeclareInjector: () => \u0275\u0275ngDeclareInjector,
    \u0275\u0275ngDeclareNgModule: () => \u0275\u0275ngDeclareNgModule,
    \u0275\u0275ngDeclarePipe: () => \u0275\u0275ngDeclarePipe,
    \u0275\u0275pipe: () => \u0275\u0275pipe,
    \u0275\u0275pipeBind1: () => \u0275\u0275pipeBind1,
    \u0275\u0275pipeBind2: () => \u0275\u0275pipeBind2,
    \u0275\u0275pipeBind3: () => \u0275\u0275pipeBind3,
    \u0275\u0275pipeBind4: () => \u0275\u0275pipeBind4,
    \u0275\u0275pipeBindV: () => \u0275\u0275pipeBindV,
    \u0275\u0275projection: () => \u0275\u0275projection,
    \u0275\u0275projectionDef: () => \u0275\u0275projectionDef,
    \u0275\u0275property: () => \u0275\u0275property,
    \u0275\u0275propertyInterpolate: () => \u0275\u0275propertyInterpolate,
    \u0275\u0275propertyInterpolate1: () => \u0275\u0275propertyInterpolate1,
    \u0275\u0275propertyInterpolate2: () => \u0275\u0275propertyInterpolate2,
    \u0275\u0275propertyInterpolate3: () => \u0275\u0275propertyInterpolate3,
    \u0275\u0275propertyInterpolate4: () => \u0275\u0275propertyInterpolate4,
    \u0275\u0275propertyInterpolate5: () => \u0275\u0275propertyInterpolate5,
    \u0275\u0275propertyInterpolate6: () => \u0275\u0275propertyInterpolate6,
    \u0275\u0275propertyInterpolate7: () => \u0275\u0275propertyInterpolate7,
    \u0275\u0275propertyInterpolate8: () => \u0275\u0275propertyInterpolate8,
    \u0275\u0275propertyInterpolateV: () => \u0275\u0275propertyInterpolateV,
    \u0275\u0275pureFunction0: () => \u0275\u0275pureFunction0,
    \u0275\u0275pureFunction1: () => \u0275\u0275pureFunction1,
    \u0275\u0275pureFunction2: () => \u0275\u0275pureFunction2,
    \u0275\u0275pureFunction3: () => \u0275\u0275pureFunction3,
    \u0275\u0275pureFunction4: () => \u0275\u0275pureFunction4,
    \u0275\u0275pureFunction5: () => \u0275\u0275pureFunction5,
    \u0275\u0275pureFunction6: () => \u0275\u0275pureFunction6,
    \u0275\u0275pureFunction7: () => \u0275\u0275pureFunction7,
    \u0275\u0275pureFunction8: () => \u0275\u0275pureFunction8,
    \u0275\u0275pureFunctionV: () => \u0275\u0275pureFunctionV,
    \u0275\u0275queryRefresh: () => \u0275\u0275queryRefresh,
    \u0275\u0275reference: () => \u0275\u0275reference,
    \u0275\u0275resolveBody: () => \u0275\u0275resolveBody,
    \u0275\u0275resolveDocument: () => \u0275\u0275resolveDocument,
    \u0275\u0275resolveWindow: () => \u0275\u0275resolveWindow,
    \u0275\u0275restoreView: () => \u0275\u0275restoreView,
    \u0275\u0275sanitizeHtml: () => \u0275\u0275sanitizeHtml,
    \u0275\u0275sanitizeResourceUrl: () => \u0275\u0275sanitizeResourceUrl,
    \u0275\u0275sanitizeScript: () => \u0275\u0275sanitizeScript,
    \u0275\u0275sanitizeStyle: () => \u0275\u0275sanitizeStyle,
    \u0275\u0275sanitizeUrl: () => \u0275\u0275sanitizeUrl,
    \u0275\u0275sanitizeUrlOrResourceUrl: () => \u0275\u0275sanitizeUrlOrResourceUrl,
    \u0275\u0275setComponentScope: () => \u0275\u0275setComponentScope,
    \u0275\u0275setNgModuleScope: () => \u0275\u0275setNgModuleScope,
    \u0275\u0275styleMap: () => \u0275\u0275styleMap,
    \u0275\u0275styleMapInterpolate1: () => \u0275\u0275styleMapInterpolate1,
    \u0275\u0275styleMapInterpolate2: () => \u0275\u0275styleMapInterpolate2,
    \u0275\u0275styleMapInterpolate3: () => \u0275\u0275styleMapInterpolate3,
    \u0275\u0275styleMapInterpolate4: () => \u0275\u0275styleMapInterpolate4,
    \u0275\u0275styleMapInterpolate5: () => \u0275\u0275styleMapInterpolate5,
    \u0275\u0275styleMapInterpolate6: () => \u0275\u0275styleMapInterpolate6,
    \u0275\u0275styleMapInterpolate7: () => \u0275\u0275styleMapInterpolate7,
    \u0275\u0275styleMapInterpolate8: () => \u0275\u0275styleMapInterpolate8,
    \u0275\u0275styleMapInterpolateV: () => \u0275\u0275styleMapInterpolateV,
    \u0275\u0275styleProp: () => \u0275\u0275styleProp,
    \u0275\u0275stylePropInterpolate1: () => \u0275\u0275stylePropInterpolate1,
    \u0275\u0275stylePropInterpolate2: () => \u0275\u0275stylePropInterpolate2,
    \u0275\u0275stylePropInterpolate3: () => \u0275\u0275stylePropInterpolate3,
    \u0275\u0275stylePropInterpolate4: () => \u0275\u0275stylePropInterpolate4,
    \u0275\u0275stylePropInterpolate5: () => \u0275\u0275stylePropInterpolate5,
    \u0275\u0275stylePropInterpolate6: () => \u0275\u0275stylePropInterpolate6,
    \u0275\u0275stylePropInterpolate7: () => \u0275\u0275stylePropInterpolate7,
    \u0275\u0275stylePropInterpolate8: () => \u0275\u0275stylePropInterpolate8,
    \u0275\u0275stylePropInterpolateV: () => \u0275\u0275stylePropInterpolateV,
    \u0275\u0275syntheticHostListener: () => \u0275\u0275syntheticHostListener,
    \u0275\u0275syntheticHostProperty: () => \u0275\u0275syntheticHostProperty,
    \u0275\u0275template: () => \u0275\u0275template,
    \u0275\u0275templateRefExtractor: () => \u0275\u0275templateRefExtractor,
    \u0275\u0275text: () => \u0275\u0275text,
    \u0275\u0275textInterpolate: () => \u0275\u0275textInterpolate,
    \u0275\u0275textInterpolate1: () => \u0275\u0275textInterpolate1,
    \u0275\u0275textInterpolate2: () => \u0275\u0275textInterpolate2,
    \u0275\u0275textInterpolate3: () => \u0275\u0275textInterpolate3,
    \u0275\u0275textInterpolate4: () => \u0275\u0275textInterpolate4,
    \u0275\u0275textInterpolate5: () => \u0275\u0275textInterpolate5,
    \u0275\u0275textInterpolate6: () => \u0275\u0275textInterpolate6,
    \u0275\u0275textInterpolate7: () => \u0275\u0275textInterpolate7,
    \u0275\u0275textInterpolate8: () => \u0275\u0275textInterpolate8,
    \u0275\u0275textInterpolateV: () => \u0275\u0275textInterpolateV,
    \u0275\u0275trustConstantHtml: () => \u0275\u0275trustConstantHtml,
    \u0275\u0275trustConstantResourceUrl: () => \u0275\u0275trustConstantResourceUrl,
    \u0275\u0275viewQuery: () => \u0275\u0275viewQuery
  });

  // node_modules/rxjs/node_modules/tslib/modules/index.js
  var import_tslib = __toESM(require_tslib(), 1);
  var {
    __extends,
    __assign,
    __rest,
    __decorate,
    __param,
    __metadata,
    __awaiter,
    __generator,
    __exportStar,
    __createBinding,
    __values,
    __read,
    __spread,
    __spreadArrays,
    __spreadArray,
    __await,
    __asyncGenerator,
    __asyncDelegator,
    __asyncValues,
    __makeTemplateObject,
    __importStar,
    __importDefault,
    __classPrivateFieldGet,
    __classPrivateFieldSet
  } = import_tslib.default;

  // node_modules/rxjs/dist/esm5/internal/util/isFunction.js
  function isFunction(value) {
    return typeof value === "function";
  }

  // node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
  function createErrorClass(createImpl) {
    var _super = function(instance) {
      Error.call(instance);
      instance.stack = new Error().stack;
    };
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
  }

  // node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
  var UnsubscriptionError = createErrorClass(function(_super) {
    return function UnsubscriptionErrorImpl(errors) {
      _super(this);
      this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
        return i + 1 + ") " + err.toString();
      }).join("\n  ") : "";
      this.name = "UnsubscriptionError";
      this.errors = errors;
    };
  });

  // node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
  function arrRemove(arr, item) {
    if (arr) {
      var index = arr.indexOf(item);
      0 <= index && arr.splice(index, 1);
    }
  }

  // node_modules/rxjs/dist/esm5/internal/Subscription.js
  var Subscription = function() {
    function Subscription2(initialTeardown) {
      this.initialTeardown = initialTeardown;
      this.closed = false;
      this._parentage = null;
      this._teardowns = null;
    }
    Subscription2.prototype.unsubscribe = function() {
      var e_1, _a, e_2, _b;
      var errors;
      if (!this.closed) {
        this.closed = true;
        var _parentage = this._parentage;
        if (_parentage) {
          this._parentage = null;
          if (Array.isArray(_parentage)) {
            try {
              for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                var parent_1 = _parentage_1_1.value;
                parent_1.remove(this);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                  _a.call(_parentage_1);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          } else {
            _parentage.remove(this);
          }
        }
        var initialTeardown = this.initialTeardown;
        if (isFunction(initialTeardown)) {
          try {
            initialTeardown();
          } catch (e) {
            errors = e instanceof UnsubscriptionError ? e.errors : [e];
          }
        }
        var _teardowns = this._teardowns;
        if (_teardowns) {
          this._teardowns = null;
          try {
            for (var _teardowns_1 = __values(_teardowns), _teardowns_1_1 = _teardowns_1.next(); !_teardowns_1_1.done; _teardowns_1_1 = _teardowns_1.next()) {
              var teardown_1 = _teardowns_1_1.value;
              try {
                execTeardown(teardown_1);
              } catch (err) {
                errors = errors !== null && errors !== void 0 ? errors : [];
                if (err instanceof UnsubscriptionError) {
                  errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
                } else {
                  errors.push(err);
                }
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_teardowns_1_1 && !_teardowns_1_1.done && (_b = _teardowns_1.return))
                _b.call(_teardowns_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
        if (errors) {
          throw new UnsubscriptionError(errors);
        }
      }
    };
    Subscription2.prototype.add = function(teardown) {
      var _a;
      if (teardown && teardown !== this) {
        if (this.closed) {
          execTeardown(teardown);
        } else {
          if (teardown instanceof Subscription2) {
            if (teardown.closed || teardown._hasParent(this)) {
              return;
            }
            teardown._addParent(this);
          }
          (this._teardowns = (_a = this._teardowns) !== null && _a !== void 0 ? _a : []).push(teardown);
        }
      }
    };
    Subscription2.prototype._hasParent = function(parent) {
      var _parentage = this._parentage;
      return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
    };
    Subscription2.prototype._addParent = function(parent) {
      var _parentage = this._parentage;
      this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
    };
    Subscription2.prototype._removeParent = function(parent) {
      var _parentage = this._parentage;
      if (_parentage === parent) {
        this._parentage = null;
      } else if (Array.isArray(_parentage)) {
        arrRemove(_parentage, parent);
      }
    };
    Subscription2.prototype.remove = function(teardown) {
      var _teardowns = this._teardowns;
      _teardowns && arrRemove(_teardowns, teardown);
      if (teardown instanceof Subscription2) {
        teardown._removeParent(this);
      }
    };
    Subscription2.EMPTY = function() {
      var empty = new Subscription2();
      empty.closed = true;
      return empty;
    }();
    return Subscription2;
  }();
  var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
  function isSubscription(value) {
    return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
  }
  function execTeardown(teardown) {
    if (isFunction(teardown)) {
      teardown();
    } else {
      teardown.unsubscribe();
    }
  }

  // node_modules/rxjs/dist/esm5/internal/config.js
  var config = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: void 0,
    useDeprecatedSynchronousErrorHandling: false,
    useDeprecatedNextContext: false
  };

  // node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
  var timeoutProvider = {
    setTimeout: function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var delegate = timeoutProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) || setTimeout).apply(void 0, __spreadArray([], __read(args)));
    },
    clearTimeout: function(handle) {
      var delegate = timeoutProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
    },
    delegate: void 0
  };

  // node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
  function reportUnhandledError(err) {
    timeoutProvider.setTimeout(function() {
      var onUnhandledError = config.onUnhandledError;
      if (onUnhandledError) {
        onUnhandledError(err);
      } else {
        throw err;
      }
    });
  }

  // node_modules/rxjs/dist/esm5/internal/util/noop.js
  function noop() {
  }

  // node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
  var COMPLETE_NOTIFICATION = function() {
    return createNotification("C", void 0, void 0);
  }();
  function errorNotification(error3) {
    return createNotification("E", void 0, error3);
  }
  function nextNotification(value) {
    return createNotification("N", value, void 0);
  }
  function createNotification(kind, value, error3) {
    return {
      kind,
      value,
      error: error3
    };
  }

  // node_modules/rxjs/dist/esm5/internal/util/errorContext.js
  var context = null;
  function errorContext(cb) {
    if (config.useDeprecatedSynchronousErrorHandling) {
      var isRoot = !context;
      if (isRoot) {
        context = { errorThrown: false, error: null };
      }
      cb();
      if (isRoot) {
        var _a = context, errorThrown = _a.errorThrown, error3 = _a.error;
        context = null;
        if (errorThrown) {
          throw error3;
        }
      }
    } else {
      cb();
    }
  }
  function captureError(err) {
    if (config.useDeprecatedSynchronousErrorHandling && context) {
      context.errorThrown = true;
      context.error = err;
    }
  }

  // node_modules/rxjs/dist/esm5/internal/Subscriber.js
  var Subscriber = function(_super) {
    __extends(Subscriber2, _super);
    function Subscriber2(destination) {
      var _this = _super.call(this) || this;
      _this.isStopped = false;
      if (destination) {
        _this.destination = destination;
        if (isSubscription(destination)) {
          destination.add(_this);
        }
      } else {
        _this.destination = EMPTY_OBSERVER;
      }
      return _this;
    }
    Subscriber2.create = function(next, error3, complete) {
      return new SafeSubscriber(next, error3, complete);
    };
    Subscriber2.prototype.next = function(value) {
      if (this.isStopped) {
        handleStoppedNotification(nextNotification(value), this);
      } else {
        this._next(value);
      }
    };
    Subscriber2.prototype.error = function(err) {
      if (this.isStopped) {
        handleStoppedNotification(errorNotification(err), this);
      } else {
        this.isStopped = true;
        this._error(err);
      }
    };
    Subscriber2.prototype.complete = function() {
      if (this.isStopped) {
        handleStoppedNotification(COMPLETE_NOTIFICATION, this);
      } else {
        this.isStopped = true;
        this._complete();
      }
    };
    Subscriber2.prototype.unsubscribe = function() {
      if (!this.closed) {
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
        this.destination = null;
      }
    };
    Subscriber2.prototype._next = function(value) {
      this.destination.next(value);
    };
    Subscriber2.prototype._error = function(err) {
      try {
        this.destination.error(err);
      } finally {
        this.unsubscribe();
      }
    };
    Subscriber2.prototype._complete = function() {
      try {
        this.destination.complete();
      } finally {
        this.unsubscribe();
      }
    };
    return Subscriber2;
  }(Subscription);
  var SafeSubscriber = function(_super) {
    __extends(SafeSubscriber2, _super);
    function SafeSubscriber2(observerOrNext, error3, complete) {
      var _this = _super.call(this) || this;
      var next;
      if (isFunction(observerOrNext)) {
        next = observerOrNext;
      } else if (observerOrNext) {
        next = observerOrNext.next, error3 = observerOrNext.error, complete = observerOrNext.complete;
        var context_1;
        if (_this && config.useDeprecatedNextContext) {
          context_1 = Object.create(observerOrNext);
          context_1.unsubscribe = function() {
            return _this.unsubscribe();
          };
        } else {
          context_1 = observerOrNext;
        }
        next = next === null || next === void 0 ? void 0 : next.bind(context_1);
        error3 = error3 === null || error3 === void 0 ? void 0 : error3.bind(context_1);
        complete = complete === null || complete === void 0 ? void 0 : complete.bind(context_1);
      }
      _this.destination = {
        next: next ? wrapForErrorHandling(next, _this) : noop,
        error: wrapForErrorHandling(error3 !== null && error3 !== void 0 ? error3 : defaultErrorHandler, _this),
        complete: complete ? wrapForErrorHandling(complete, _this) : noop
      };
      return _this;
    }
    return SafeSubscriber2;
  }(Subscriber);
  function wrapForErrorHandling(handler, instance) {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      try {
        handler.apply(void 0, __spreadArray([], __read(args)));
      } catch (err) {
        if (config.useDeprecatedSynchronousErrorHandling) {
          captureError(err);
        } else {
          reportUnhandledError(err);
        }
      }
    };
  }
  function defaultErrorHandler(err) {
    throw err;
  }
  function handleStoppedNotification(notification, subscriber) {
    var onStoppedNotification = config.onStoppedNotification;
    onStoppedNotification && timeoutProvider.setTimeout(function() {
      return onStoppedNotification(notification, subscriber);
    });
  }
  var EMPTY_OBSERVER = {
    closed: true,
    next: noop,
    error: defaultErrorHandler,
    complete: noop
  };

  // node_modules/rxjs/dist/esm5/internal/symbol/observable.js
  var observable = function() {
    return typeof Symbol === "function" && Symbol.observable || "@@observable";
  }();

  // node_modules/rxjs/dist/esm5/internal/util/identity.js
  function identity(x) {
    return x;
  }

  // node_modules/rxjs/dist/esm5/internal/util/pipe.js
  function pipeFromArray(fns) {
    if (fns.length === 0) {
      return identity;
    }
    if (fns.length === 1) {
      return fns[0];
    }
    return function piped(input) {
      return fns.reduce(function(prev, fn2) {
        return fn2(prev);
      }, input);
    };
  }

  // node_modules/rxjs/dist/esm5/internal/Observable.js
  var Observable = function() {
    function Observable3(subscribe) {
      if (subscribe) {
        this._subscribe = subscribe;
      }
    }
    Observable3.prototype.lift = function(operator) {
      var observable2 = new Observable3();
      observable2.source = this;
      observable2.operator = operator;
      return observable2;
    };
    Observable3.prototype.subscribe = function(observerOrNext, error3, complete) {
      var _this = this;
      var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error3, complete);
      errorContext(function() {
        var _a = _this, operator = _a.operator, source = _a.source;
        subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
      });
      return subscriber;
    };
    Observable3.prototype._trySubscribe = function(sink) {
      try {
        return this._subscribe(sink);
      } catch (err) {
        sink.error(err);
      }
    };
    Observable3.prototype.forEach = function(next, promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var subscription;
        subscription = _this.subscribe(function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscription === null || subscription === void 0 ? void 0 : subscription.unsubscribe();
          }
        }, reject, resolve);
      });
    };
    Observable3.prototype._subscribe = function(subscriber) {
      var _a;
      return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
    };
    Observable3.prototype[observable] = function() {
      return this;
    };
    Observable3.prototype.pipe = function() {
      var operations = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        operations[_i] = arguments[_i];
      }
      return pipeFromArray(operations)(this);
    };
    Observable3.prototype.toPromise = function(promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var value;
        _this.subscribe(function(x) {
          return value = x;
        }, function(err) {
          return reject(err);
        }, function() {
          return resolve(value);
        });
      });
    };
    Observable3.create = function(subscribe) {
      return new Observable3(subscribe);
    };
    return Observable3;
  }();
  function getPromiseCtor(promiseCtor) {
    var _a;
    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
  }
  function isObserver(value) {
    return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
  }
  function isSubscriber(value) {
    return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
  }

  // node_modules/rxjs/dist/esm5/internal/util/lift.js
  function hasLift(source) {
    return isFunction(source === null || source === void 0 ? void 0 : source.lift);
  }
  function operate(init) {
    return function(source) {
      if (hasLift(source)) {
        return source.lift(function(liftedSource) {
          try {
            return init(liftedSource, this);
          } catch (err) {
            this.error(err);
          }
        });
      }
      throw new TypeError("Unable to lift unknown Observable type");
    };
  }

  // node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
  var OperatorSubscriber = function(_super) {
    __extends(OperatorSubscriber2, _super);
    function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize) {
      var _this = _super.call(this, destination) || this;
      _this.onFinalize = onFinalize;
      _this._next = onNext ? function(value) {
        try {
          onNext(value);
        } catch (err) {
          destination.error(err);
        }
      } : _super.prototype._next;
      _this._error = onError ? function(err) {
        try {
          onError(err);
        } catch (err2) {
          destination.error(err2);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._error;
      _this._complete = onComplete ? function() {
        try {
          onComplete();
        } catch (err) {
          destination.error(err);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._complete;
      return _this;
    }
    OperatorSubscriber2.prototype.unsubscribe = function() {
      var _a;
      var closed = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    };
    return OperatorSubscriber2;
  }(Subscriber);

  // node_modules/rxjs/dist/esm5/internal/operators/refCount.js
  function refCount() {
    return operate(function(source, subscriber) {
      var connection = null;
      source._refCount++;
      var refCounter = new OperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
        if (!source || source._refCount <= 0 || 0 < --source._refCount) {
          connection = null;
          return;
        }
        var sharedConnection = source._connection;
        var conn = connection;
        connection = null;
        if (sharedConnection && (!conn || sharedConnection === conn)) {
          sharedConnection.unsubscribe();
        }
        subscriber.unsubscribe();
      });
      source.subscribe(refCounter);
      if (!refCounter.closed) {
        connection = source.connect();
      }
    });
  }

  // node_modules/rxjs/dist/esm5/internal/observable/ConnectableObservable.js
  var ConnectableObservable = function(_super) {
    __extends(ConnectableObservable2, _super);
    function ConnectableObservable2(source, subjectFactory) {
      var _this = _super.call(this) || this;
      _this.source = source;
      _this.subjectFactory = subjectFactory;
      _this._subject = null;
      _this._refCount = 0;
      _this._connection = null;
      if (hasLift(source)) {
        _this.lift = source.lift;
      }
      return _this;
    }
    ConnectableObservable2.prototype._subscribe = function(subscriber) {
      return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable2.prototype.getSubject = function() {
      var subject = this._subject;
      if (!subject || subject.isStopped) {
        this._subject = this.subjectFactory();
      }
      return this._subject;
    };
    ConnectableObservable2.prototype._teardown = function() {
      this._refCount = 0;
      var _connection = this._connection;
      this._subject = this._connection = null;
      _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
    };
    ConnectableObservable2.prototype.connect = function() {
      var _this = this;
      var connection = this._connection;
      if (!connection) {
        connection = this._connection = new Subscription();
        var subject_1 = this.getSubject();
        connection.add(this.source.subscribe(new OperatorSubscriber(subject_1, void 0, function() {
          _this._teardown();
          subject_1.complete();
        }, function(err) {
          _this._teardown();
          subject_1.error(err);
        }, function() {
          return _this._teardown();
        })));
        if (connection.closed) {
          this._connection = null;
          connection = Subscription.EMPTY;
        }
      }
      return connection;
    };
    ConnectableObservable2.prototype.refCount = function() {
      return refCount()(this);
    };
    return ConnectableObservable2;
  }(Observable);

  // node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
  var ObjectUnsubscribedError = createErrorClass(function(_super) {
    return function ObjectUnsubscribedErrorImpl() {
      _super(this);
      this.name = "ObjectUnsubscribedError";
      this.message = "object unsubscribed";
    };
  });

  // node_modules/rxjs/dist/esm5/internal/Subject.js
  var Subject = function(_super) {
    __extends(Subject2, _super);
    function Subject2() {
      var _this = _super.call(this) || this;
      _this.closed = false;
      _this.observers = [];
      _this.isStopped = false;
      _this.hasError = false;
      _this.thrownError = null;
      return _this;
    }
    Subject2.prototype.lift = function(operator) {
      var subject = new AnonymousSubject(this, this);
      subject.operator = operator;
      return subject;
    };
    Subject2.prototype._throwIfClosed = function() {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      }
    };
    Subject2.prototype.next = function(value) {
      var _this = this;
      errorContext(function() {
        var e_1, _a;
        _this._throwIfClosed();
        if (!_this.isStopped) {
          var copy = _this.observers.slice();
          try {
            for (var copy_1 = __values(copy), copy_1_1 = copy_1.next(); !copy_1_1.done; copy_1_1 = copy_1.next()) {
              var observer = copy_1_1.value;
              observer.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (copy_1_1 && !copy_1_1.done && (_a = copy_1.return))
                _a.call(copy_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }
      });
    };
    Subject2.prototype.error = function(err) {
      var _this = this;
      errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.hasError = _this.isStopped = true;
          _this.thrownError = err;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().error(err);
          }
        }
      });
    };
    Subject2.prototype.complete = function() {
      var _this = this;
      errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.isStopped = true;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().complete();
          }
        }
      });
    };
    Subject2.prototype.unsubscribe = function() {
      this.isStopped = this.closed = true;
      this.observers = null;
    };
    Object.defineProperty(Subject2.prototype, "observed", {
      get: function() {
        var _a;
        return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
      },
      enumerable: false,
      configurable: true
    });
    Subject2.prototype._trySubscribe = function(subscriber) {
      this._throwIfClosed();
      return _super.prototype._trySubscribe.call(this, subscriber);
    };
    Subject2.prototype._subscribe = function(subscriber) {
      this._throwIfClosed();
      this._checkFinalizedStatuses(subscriber);
      return this._innerSubscribe(subscriber);
    };
    Subject2.prototype._innerSubscribe = function(subscriber) {
      var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
      return hasError || isStopped ? EMPTY_SUBSCRIPTION : (observers.push(subscriber), new Subscription(function() {
        return arrRemove(observers, subscriber);
      }));
    };
    Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
      var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
      if (hasError) {
        subscriber.error(thrownError);
      } else if (isStopped) {
        subscriber.complete();
      }
    };
    Subject2.prototype.asObservable = function() {
      var observable2 = new Observable();
      observable2.source = this;
      return observable2;
    };
    Subject2.create = function(destination, source) {
      return new AnonymousSubject(destination, source);
    };
    return Subject2;
  }(Observable);
  var AnonymousSubject = function(_super) {
    __extends(AnonymousSubject2, _super);
    function AnonymousSubject2(destination, source) {
      var _this = _super.call(this) || this;
      _this.destination = destination;
      _this.source = source;
      return _this;
    }
    AnonymousSubject2.prototype.next = function(value) {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
    };
    AnonymousSubject2.prototype.error = function(err) {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
    };
    AnonymousSubject2.prototype.complete = function() {
      var _a, _b;
      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    AnonymousSubject2.prototype._subscribe = function(subscriber) {
      var _a, _b;
      return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
    };
    return AnonymousSubject2;
  }(Subject);

  // node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js
  var BehaviorSubject = function(_super) {
    __extends(BehaviorSubject2, _super);
    function BehaviorSubject2(_value) {
      var _this = _super.call(this) || this;
      _this._value = _value;
      return _this;
    }
    Object.defineProperty(BehaviorSubject2.prototype, "value", {
      get: function() {
        return this.getValue();
      },
      enumerable: false,
      configurable: true
    });
    BehaviorSubject2.prototype._subscribe = function(subscriber) {
      var subscription = _super.prototype._subscribe.call(this, subscriber);
      !subscription.closed && subscriber.next(this._value);
      return subscription;
    };
    BehaviorSubject2.prototype.getValue = function() {
      var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
      if (hasError) {
        throw thrownError;
      }
      this._throwIfClosed();
      return _value;
    };
    BehaviorSubject2.prototype.next = function(value) {
      _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject2;
  }(Subject);

  // node_modules/rxjs/dist/esm5/internal/observable/empty.js
  var EMPTY = new Observable(function(subscriber) {
    return subscriber.complete();
  });

  // node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
  function isScheduler(value) {
    return value && isFunction(value.schedule);
  }

  // node_modules/rxjs/dist/esm5/internal/util/args.js
  function last(arr) {
    return arr[arr.length - 1];
  }
  function popResultSelector(args) {
    return isFunction(last(args)) ? args.pop() : void 0;
  }
  function popScheduler(args) {
    return isScheduler(last(args)) ? args.pop() : void 0;
  }
  function popNumber(args, defaultValue) {
    return typeof last(args) === "number" ? args.pop() : defaultValue;
  }

  // node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
  var isArrayLike = function(x) {
    return x && typeof x.length === "number" && typeof x !== "function";
  };

  // node_modules/rxjs/dist/esm5/internal/util/isPromise.js
  function isPromise(value) {
    return isFunction(value === null || value === void 0 ? void 0 : value.then);
  }

  // node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
  function isInteropObservable(input) {
    return isFunction(input[observable]);
  }

  // node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
  function isAsyncIterable(obj) {
    return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
  }

  // node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
  function createInvalidObservableTypeError(input) {
    return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
  }

  // node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
  function getSymbolIterator() {
    if (typeof Symbol !== "function" || !Symbol.iterator) {
      return "@@iterator";
    }
    return Symbol.iterator;
  }
  var iterator = getSymbolIterator();

  // node_modules/rxjs/dist/esm5/internal/util/isIterable.js
  function isIterable(input) {
    return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
  }

  // node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
  function readableStreamLikeToAsyncGenerator(readableStream) {
    return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
      var reader, _a, value, done;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            reader = readableStream.getReader();
            _b.label = 1;
          case 1:
            _b.trys.push([1, , 9, 10]);
            _b.label = 2;
          case 2:
            if (false)
              return [3, 8];
            return [4, __await(reader.read())];
          case 3:
            _a = _b.sent(), value = _a.value, done = _a.done;
            if (!done)
              return [3, 5];
            return [4, __await(void 0)];
          case 4:
            return [2, _b.sent()];
          case 5:
            return [4, __await(value)];
          case 6:
            return [4, _b.sent()];
          case 7:
            _b.sent();
            return [3, 2];
          case 8:
            return [3, 10];
          case 9:
            reader.releaseLock();
            return [7];
          case 10:
            return [2];
        }
      });
    });
  }
  function isReadableStreamLike(obj) {
    return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
  }

  // node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
  function innerFrom(input) {
    if (input instanceof Observable) {
      return input;
    }
    if (input != null) {
      if (isInteropObservable(input)) {
        return fromInteropObservable(input);
      }
      if (isArrayLike(input)) {
        return fromArrayLike(input);
      }
      if (isPromise(input)) {
        return fromPromise(input);
      }
      if (isAsyncIterable(input)) {
        return fromAsyncIterable(input);
      }
      if (isIterable(input)) {
        return fromIterable(input);
      }
      if (isReadableStreamLike(input)) {
        return fromReadableStreamLike(input);
      }
    }
    throw createInvalidObservableTypeError(input);
  }
  function fromInteropObservable(obj) {
    return new Observable(function(subscriber) {
      var obs = obj[observable]();
      if (isFunction(obs.subscribe)) {
        return obs.subscribe(subscriber);
      }
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    });
  }
  function fromArrayLike(array) {
    return new Observable(function(subscriber) {
      for (var i = 0; i < array.length && !subscriber.closed; i++) {
        subscriber.next(array[i]);
      }
      subscriber.complete();
    });
  }
  function fromPromise(promise2) {
    return new Observable(function(subscriber) {
      promise2.then(function(value) {
        if (!subscriber.closed) {
          subscriber.next(value);
          subscriber.complete();
        }
      }, function(err) {
        return subscriber.error(err);
      }).then(null, reportUnhandledError);
    });
  }
  function fromIterable(iterable) {
    return new Observable(function(subscriber) {
      var e_1, _a;
      try {
        for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
          var value = iterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
            _a.call(iterable_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      subscriber.complete();
    });
  }
  function fromAsyncIterable(asyncIterable) {
    return new Observable(function(subscriber) {
      process2(asyncIterable, subscriber).catch(function(err) {
        return subscriber.error(err);
      });
    });
  }
  function fromReadableStreamLike(readableStream) {
    return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
  }
  function process2(asyncIterable, subscriber) {
    var asyncIterable_1, asyncIterable_1_1;
    var e_2, _a;
    return __awaiter(this, void 0, void 0, function() {
      var value, e_2_1;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _b.trys.push([0, 5, 6, 11]);
            asyncIterable_1 = __asyncValues(asyncIterable);
            _b.label = 1;
          case 1:
            return [4, asyncIterable_1.next()];
          case 2:
            if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
              return [3, 4];
            value = asyncIterable_1_1.value;
            subscriber.next(value);
            if (subscriber.closed) {
              return [2];
            }
            _b.label = 3;
          case 3:
            return [3, 1];
          case 4:
            return [3, 11];
          case 5:
            e_2_1 = _b.sent();
            e_2 = { error: e_2_1 };
            return [3, 11];
          case 6:
            _b.trys.push([6, , 9, 10]);
            if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
              return [3, 8];
            return [4, _a.call(asyncIterable_1)];
          case 7:
            _b.sent();
            _b.label = 8;
          case 8:
            return [3, 10];
          case 9:
            if (e_2)
              throw e_2.error;
            return [7];
          case 10:
            return [7];
          case 11:
            subscriber.complete();
            return [2];
        }
      });
    });
  }

  // node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js
  function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
    if (delay === void 0) {
      delay = 0;
    }
    if (repeat === void 0) {
      repeat = false;
    }
    var scheduleSubscription = scheduler.schedule(function() {
      work();
      if (repeat) {
        parentSubscription.add(this.schedule(null, delay));
      } else {
        this.unsubscribe();
      }
    }, delay);
    parentSubscription.add(scheduleSubscription);
    if (!repeat) {
      return scheduleSubscription;
    }
  }

  // node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
  function observeOn(scheduler, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    return operate(function(source, subscriber) {
      source.subscribe(new OperatorSubscriber(subscriber, function(value) {
        return executeSchedule(subscriber, scheduler, function() {
          return subscriber.next(value);
        }, delay);
      }, function() {
        return executeSchedule(subscriber, scheduler, function() {
          return subscriber.complete();
        }, delay);
      }, function(err) {
        return executeSchedule(subscriber, scheduler, function() {
          return subscriber.error(err);
        }, delay);
      }));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js
  function subscribeOn(scheduler, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    return operate(function(source, subscriber) {
      subscriber.add(scheduler.schedule(function() {
        return source.subscribe(subscriber);
      }, delay));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
  function scheduleObservable(input, scheduler) {
    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
  }

  // node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js
  function schedulePromise(input, scheduler) {
    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
  }

  // node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js
  function scheduleArray(input, scheduler) {
    return new Observable(function(subscriber) {
      var i = 0;
      return scheduler.schedule(function() {
        if (i === input.length) {
          subscriber.complete();
        } else {
          subscriber.next(input[i++]);
          if (!subscriber.closed) {
            this.schedule();
          }
        }
      });
    });
  }

  // node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js
  function scheduleIterable(input, scheduler) {
    return new Observable(function(subscriber) {
      var iterator2;
      executeSchedule(subscriber, scheduler, function() {
        iterator2 = input[iterator]();
        executeSchedule(subscriber, scheduler, function() {
          var _a;
          var value;
          var done;
          try {
            _a = iterator2.next(), value = _a.value, done = _a.done;
          } catch (err) {
            subscriber.error(err);
            return;
          }
          if (done) {
            subscriber.complete();
          } else {
            subscriber.next(value);
          }
        }, 0, true);
      });
      return function() {
        return isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
      };
    });
  }

  // node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js
  function scheduleAsyncIterable(input, scheduler) {
    if (!input) {
      throw new Error("Iterable cannot be null");
    }
    return new Observable(function(subscriber) {
      executeSchedule(subscriber, scheduler, function() {
        var iterator2 = input[Symbol.asyncIterator]();
        executeSchedule(subscriber, scheduler, function() {
          iterator2.next().then(function(result) {
            if (result.done) {
              subscriber.complete();
            } else {
              subscriber.next(result.value);
            }
          });
        }, 0, true);
      });
    });
  }

  // node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js
  function scheduleReadableStreamLike(input, scheduler) {
    return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
  }

  // node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
  function scheduled(input, scheduler) {
    if (input != null) {
      if (isInteropObservable(input)) {
        return scheduleObservable(input, scheduler);
      }
      if (isArrayLike(input)) {
        return scheduleArray(input, scheduler);
      }
      if (isPromise(input)) {
        return schedulePromise(input, scheduler);
      }
      if (isAsyncIterable(input)) {
        return scheduleAsyncIterable(input, scheduler);
      }
      if (isIterable(input)) {
        return scheduleIterable(input, scheduler);
      }
      if (isReadableStreamLike(input)) {
        return scheduleReadableStreamLike(input, scheduler);
      }
    }
    throw createInvalidObservableTypeError(input);
  }

  // node_modules/rxjs/dist/esm5/internal/observable/from.js
  function from(input, scheduler) {
    return scheduler ? scheduled(input, scheduler) : innerFrom(input);
  }

  // node_modules/rxjs/dist/esm5/internal/observable/of.js
  function of() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = popScheduler(args);
    return from(args, scheduler);
  }

  // node_modules/rxjs/dist/esm5/internal/util/EmptyError.js
  var EmptyError = createErrorClass(function(_super) {
    return function EmptyErrorImpl() {
      _super(this);
      this.name = "EmptyError";
      this.message = "no elements in sequence";
    };
  });

  // node_modules/rxjs/dist/esm5/internal/operators/map.js
  function map(project, thisArg) {
    return operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(new OperatorSubscriber(subscriber, function(value) {
        subscriber.next(project.call(thisArg, value, index++));
      }));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js
  var isArray = Array.isArray;
  function callOrApply(fn2, args) {
    return isArray(args) ? fn2.apply(void 0, __spreadArray([], __read(args))) : fn2(args);
  }
  function mapOneOrManyArgs(fn2) {
    return map(function(args) {
      return callOrApply(fn2, args);
    });
  }

  // node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js
  var isArray2 = Array.isArray;
  var getPrototypeOf = Object.getPrototypeOf;
  var objectProto = Object.prototype;
  var getKeys = Object.keys;
  function argsArgArrayOrObject(args) {
    if (args.length === 1) {
      var first_1 = args[0];
      if (isArray2(first_1)) {
        return { args: first_1, keys: null };
      }
      if (isPOJO(first_1)) {
        var keys = getKeys(first_1);
        return {
          args: keys.map(function(key) {
            return first_1[key];
          }),
          keys
        };
      }
    }
    return { args, keys: null };
  }
  function isPOJO(obj) {
    return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
  }

  // node_modules/rxjs/dist/esm5/internal/util/createObject.js
  function createObject(keys, values) {
    return keys.reduce(function(result, key, i) {
      return result[key] = values[i], result;
    }, {});
  }

  // node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js
  function combineLatest() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = popScheduler(args);
    var resultSelector = popResultSelector(args);
    var _a = argsArgArrayOrObject(args), observables = _a.args, keys = _a.keys;
    if (observables.length === 0) {
      return from([], scheduler);
    }
    var result = new Observable(combineLatestInit(observables, scheduler, keys ? function(values) {
      return createObject(keys, values);
    } : identity));
    return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
  }
  function combineLatestInit(observables, scheduler, valueTransform) {
    if (valueTransform === void 0) {
      valueTransform = identity;
    }
    return function(subscriber) {
      maybeSchedule(scheduler, function() {
        var length = observables.length;
        var values = new Array(length);
        var active = length;
        var remainingFirstValues = length;
        var _loop_1 = function(i2) {
          maybeSchedule(scheduler, function() {
            var source = from(observables[i2], scheduler);
            var hasFirstValue = false;
            source.subscribe(new OperatorSubscriber(subscriber, function(value) {
              values[i2] = value;
              if (!hasFirstValue) {
                hasFirstValue = true;
                remainingFirstValues--;
              }
              if (!remainingFirstValues) {
                subscriber.next(valueTransform(values.slice()));
              }
            }, function() {
              if (!--active) {
                subscriber.complete();
              }
            }));
          }, subscriber);
        };
        for (var i = 0; i < length; i++) {
          _loop_1(i);
        }
      }, subscriber);
    };
  }
  function maybeSchedule(scheduler, execute, subscription) {
    if (scheduler) {
      executeSchedule(subscription, scheduler, execute);
    } else {
      execute();
    }
  }

  // node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js
  function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalTeardown) {
    var buffer = [];
    var active = 0;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      if (isComplete && !buffer.length && !active) {
        subscriber.complete();
      }
    };
    var outerNext = function(value) {
      return active < concurrent ? doInnerSub(value) : buffer.push(value);
    };
    var doInnerSub = function(value) {
      expand && subscriber.next(value);
      active++;
      var innerComplete = false;
      innerFrom(project(value, index++)).subscribe(new OperatorSubscriber(subscriber, function(innerValue) {
        onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
        if (expand) {
          outerNext(innerValue);
        } else {
          subscriber.next(innerValue);
        }
      }, function() {
        innerComplete = true;
      }, void 0, function() {
        if (innerComplete) {
          try {
            active--;
            var _loop_1 = function() {
              var bufferedValue = buffer.shift();
              if (innerSubScheduler) {
                executeSchedule(subscriber, innerSubScheduler, function() {
                  return doInnerSub(bufferedValue);
                });
              } else {
                doInnerSub(bufferedValue);
              }
            };
            while (buffer.length && active < concurrent) {
              _loop_1();
            }
            checkComplete();
          } catch (err) {
            subscriber.error(err);
          }
        }
      }));
    };
    source.subscribe(new OperatorSubscriber(subscriber, outerNext, function() {
      isComplete = true;
      checkComplete();
    }));
    return function() {
      additionalTeardown === null || additionalTeardown === void 0 ? void 0 : additionalTeardown();
    };
  }

  // node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js
  function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }
    if (isFunction(resultSelector)) {
      return mergeMap(function(a, i) {
        return map(function(b, ii) {
          return resultSelector(a, b, i, ii);
        })(innerFrom(project(a, i)));
      }, concurrent);
    } else if (typeof resultSelector === "number") {
      concurrent = resultSelector;
    }
    return operate(function(source, subscriber) {
      return mergeInternals(source, subscriber, project, concurrent);
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js
  function mergeAll(concurrent) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }
    return mergeMap(identity, concurrent);
  }

  // node_modules/rxjs/dist/esm5/internal/operators/concatAll.js
  function concatAll() {
    return mergeAll(1);
  }

  // node_modules/rxjs/dist/esm5/internal/observable/concat.js
  function concat() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return concatAll()(from(args, popScheduler(args)));
  }

  // node_modules/rxjs/dist/esm5/internal/observable/defer.js
  function defer(observableFactory) {
    return new Observable(function(subscriber) {
      innerFrom(observableFactory()).subscribe(subscriber);
    });
  }

  // node_modules/rxjs/dist/esm5/internal/observable/merge.js
  function merge() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = popScheduler(args);
    var concurrent = popNumber(args, Infinity);
    var sources = args;
    return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from(sources, scheduler));
  }

  // node_modules/rxjs/dist/esm5/internal/operators/filter.js
  function filter(predicate, thisArg) {
    return operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(new OperatorSubscriber(subscriber, function(value) {
        return predicate.call(thisArg, value, index++) && subscriber.next(value);
      }));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/catchError.js
  function catchError(selector) {
    return operate(function(source, subscriber) {
      var innerSub = null;
      var syncUnsub = false;
      var handledResult;
      innerSub = source.subscribe(new OperatorSubscriber(subscriber, void 0, void 0, function(err) {
        handledResult = innerFrom(selector(err, catchError(selector)(source)));
        if (innerSub) {
          innerSub.unsubscribe();
          innerSub = null;
          handledResult.subscribe(subscriber);
        } else {
          syncUnsub = true;
        }
      }));
      if (syncUnsub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      }
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/scanInternals.js
  function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
    return function(source, subscriber) {
      var hasState = hasSeed;
      var state = seed;
      var index = 0;
      source.subscribe(new OperatorSubscriber(subscriber, function(value) {
        var i = index++;
        state = hasState ? accumulator(state, value, i) : (hasState = true, value);
        emitOnNext && subscriber.next(state);
      }, emitBeforeComplete && function() {
        hasState && subscriber.next(state);
        subscriber.complete();
      }));
    };
  }

  // node_modules/rxjs/dist/esm5/internal/operators/concatMap.js
  function concatMap(project, resultSelector) {
    return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);
  }

  // node_modules/rxjs/dist/esm5/internal/operators/defaultIfEmpty.js
  function defaultIfEmpty(defaultValue) {
    return operate(function(source, subscriber) {
      var hasValue = false;
      source.subscribe(new OperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        subscriber.next(value);
      }, function() {
        if (!hasValue) {
          subscriber.next(defaultValue);
        }
        subscriber.complete();
      }));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/take.js
  function take(count) {
    return count <= 0 ? function() {
      return EMPTY;
    } : operate(function(source, subscriber) {
      var seen = 0;
      source.subscribe(new OperatorSubscriber(subscriber, function(value) {
        if (++seen <= count) {
          subscriber.next(value);
          if (count <= seen) {
            subscriber.complete();
          }
        }
      }));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/throwIfEmpty.js
  function throwIfEmpty(errorFactory) {
    if (errorFactory === void 0) {
      errorFactory = defaultErrorFactory;
    }
    return operate(function(source, subscriber) {
      var hasValue = false;
      source.subscribe(new OperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        subscriber.next(value);
      }, function() {
        return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
      }));
    });
  }
  function defaultErrorFactory() {
    return new EmptyError();
  }

  // node_modules/rxjs/dist/esm5/internal/operators/finalize.js
  function finalize(callback) {
    return operate(function(source, subscriber) {
      try {
        source.subscribe(subscriber);
      } finally {
        subscriber.add(callback);
      }
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/first.js
  function first(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
      return source.pipe(predicate ? filter(function(v, i) {
        return predicate(v, i, source);
      }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
        return new EmptyError();
      }));
    };
  }

  // node_modules/rxjs/dist/esm5/internal/operators/takeLast.js
  function takeLast(count) {
    return count <= 0 ? function() {
      return EMPTY;
    } : operate(function(source, subscriber) {
      var buffer = [];
      source.subscribe(new OperatorSubscriber(subscriber, function(value) {
        buffer.push(value);
        count < buffer.length && buffer.shift();
      }, function() {
        var e_1, _a;
        try {
          for (var buffer_1 = __values(buffer), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
            var value = buffer_1_1.value;
            subscriber.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return))
              _a.call(buffer_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        subscriber.complete();
      }, void 0, function() {
        buffer = null;
      }));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/last.js
  function last2(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
      return source.pipe(predicate ? filter(function(v, i) {
        return predicate(v, i, source);
      }) : identity, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
        return new EmptyError();
      }));
    };
  }

  // node_modules/rxjs/dist/esm5/internal/operators/scan.js
  function scan(accumulator, seed) {
    return operate(scanInternals(accumulator, seed, arguments.length >= 2, true));
  }

  // node_modules/rxjs/dist/esm5/internal/operators/share.js
  function share(options) {
    if (options === void 0) {
      options = {};
    }
    var _a = options.connector, connector = _a === void 0 ? function() {
      return new Subject();
    } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
    return function(wrapperSource) {
      var connection = null;
      var resetConnection = null;
      var subject = null;
      var refCount2 = 0;
      var hasCompleted = false;
      var hasErrored = false;
      var cancelReset = function() {
        resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
        resetConnection = null;
      };
      var reset = function() {
        cancelReset();
        connection = subject = null;
        hasCompleted = hasErrored = false;
      };
      var resetAndUnsubscribe = function() {
        var conn = connection;
        reset();
        conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
      };
      return operate(function(source, subscriber) {
        refCount2++;
        if (!hasErrored && !hasCompleted) {
          cancelReset();
        }
        var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
        subscriber.add(function() {
          refCount2--;
          if (refCount2 === 0 && !hasErrored && !hasCompleted) {
            resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
          }
        });
        dest.subscribe(subscriber);
        if (!connection) {
          connection = new SafeSubscriber({
            next: function(value) {
              return dest.next(value);
            },
            error: function(err) {
              hasErrored = true;
              cancelReset();
              resetConnection = handleReset(reset, resetOnError, err);
              dest.error(err);
            },
            complete: function() {
              hasCompleted = true;
              cancelReset();
              resetConnection = handleReset(reset, resetOnComplete);
              dest.complete();
            }
          });
          from(source).subscribe(connection);
        }
      })(wrapperSource);
    };
  }
  function handleReset(reset, on) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    if (on === true) {
      reset();
      return null;
    }
    if (on === false) {
      return null;
    }
    return on.apply(void 0, __spreadArray([], __read(args))).pipe(take(1)).subscribe(function() {
      return reset();
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/startWith.js
  function startWith() {
    var values = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      values[_i] = arguments[_i];
    }
    var scheduler = popScheduler(values);
    return operate(function(source, subscriber) {
      (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/switchMap.js
  function switchMap(project, resultSelector) {
    return operate(function(source, subscriber) {
      var innerSubscriber = null;
      var index = 0;
      var isComplete = false;
      var checkComplete = function() {
        return isComplete && !innerSubscriber && subscriber.complete();
      };
      source.subscribe(new OperatorSubscriber(subscriber, function(value) {
        innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
        var innerIndex = 0;
        var outerIndex = index++;
        innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = new OperatorSubscriber(subscriber, function(innerValue) {
          return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
        }, function() {
          innerSubscriber = null;
          checkComplete();
        }));
      }, function() {
        isComplete = true;
        checkComplete();
      }));
    });
  }

  // node_modules/rxjs/dist/esm5/internal/operators/tap.js
  function tap(observerOrNext, error3, complete) {
    var tapObserver = isFunction(observerOrNext) || error3 || complete ? { next: observerOrNext, error: error3, complete } : observerOrNext;
    return tapObserver ? operate(function(source, subscriber) {
      var _a;
      (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
      var isUnsub = true;
      source.subscribe(new OperatorSubscriber(subscriber, function(value) {
        var _a2;
        (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
        subscriber.next(value);
      }, function() {
        var _a2;
        isUnsub = false;
        (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
        subscriber.complete();
      }, function(err) {
        var _a2;
        isUnsub = false;
        (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
        subscriber.error(err);
      }, function() {
        var _a2, _b;
        if (isUnsub) {
          (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
        }
        (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
      }));
    }) : identity;
  }

  // node_modules/@angular/core/fesm2020/core.mjs
  function getClosureSafeProperty(objWithPropertyToExtract) {
    for (let key in objWithPropertyToExtract) {
      if (objWithPropertyToExtract[key] === getClosureSafeProperty) {
        return key;
      }
    }
    throw Error("Could not find renamed property on target object.");
  }
  function fillProperties(target, source) {
    for (const key in source) {
      if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {
        target[key] = source[key];
      }
    }
  }
  function stringify(token) {
    if (typeof token === "string") {
      return token;
    }
    if (Array.isArray(token)) {
      return "[" + token.map(stringify).join(", ") + "]";
    }
    if (token == null) {
      return "" + token;
    }
    if (token.overriddenName) {
      return `${token.overriddenName}`;
    }
    if (token.name) {
      return `${token.name}`;
    }
    const res = token.toString();
    if (res == null) {
      return "" + res;
    }
    const newLineIndex = res.indexOf("\n");
    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
  }
  function concatStringsWithSpace(before, after) {
    return before == null || before === "" ? after === null ? "" : after : after == null || after === "" ? before : before + " " + after;
  }
  var __forward_ref__ = getClosureSafeProperty({ __forward_ref__: getClosureSafeProperty });
  function forwardRef(forwardRefFn) {
    forwardRefFn.__forward_ref__ = forwardRef;
    forwardRefFn.toString = function() {
      return stringify(this());
    };
    return forwardRefFn;
  }
  function resolveForwardRef(type) {
    return isForwardRef(type) ? type() : type;
  }
  function isForwardRef(fn2) {
    return typeof fn2 === "function" && fn2.hasOwnProperty(__forward_ref__) && fn2.__forward_ref__ === forwardRef;
  }
  var ERROR_DETAILS_PAGE_BASE_URL = "https://angular.io/errors";
  var RuntimeError = class extends Error {
    constructor(code, message) {
      super(formatRuntimeError(code, message));
      this.code = code;
    }
  };
  var RUNTIME_ERRORS_WITH_GUIDES = /* @__PURE__ */ new Set([
    "100",
    "200",
    "201",
    "300",
    "301",
    "302"
  ]);
  function formatRuntimeError(code, message) {
    const fullCode = code ? `NG0${code}: ` : "";
    let errorMessage = `${fullCode}${message}`;
    if (ngDevMode && RUNTIME_ERRORS_WITH_GUIDES.has(code)) {
      errorMessage = `${errorMessage}. Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/NG0${code}`;
    }
    return errorMessage;
  }
  function renderStringify(value) {
    if (typeof value === "string")
      return value;
    if (value == null)
      return "";
    return String(value);
  }
  function stringifyForError(value) {
    if (typeof value === "function")
      return value.name || value.toString();
    if (typeof value === "object" && value != null && typeof value.type === "function") {
      return value.type.name || value.type.toString();
    }
    return renderStringify(value);
  }
  function throwCyclicDependencyError(token, path) {
    const depPath = path ? `. Dependency path: ${path.join(" > ")} > ${token}` : "";
    throw new RuntimeError("200", `Circular dependency in DI detected for ${token}${depPath}`);
  }
  function throwMixedMultiProviderError() {
    throw new Error(`Cannot mix multi providers and regular providers`);
  }
  function throwInvalidProviderError(ngModuleType, providers, provider) {
    let ngModuleDetail = "";
    if (ngModuleType && providers) {
      const providerDetail = providers.map((v) => v == provider ? "?" + provider + "?" : "...");
      ngModuleDetail = ` - only instances of Provider and Type are allowed, got: [${providerDetail.join(", ")}]`;
    }
    throw new Error(`Invalid provider for the NgModule '${stringify(ngModuleType)}'` + ngModuleDetail);
  }
  function throwProviderNotFoundError(token, injectorName) {
    const injectorDetails = injectorName ? ` in ${injectorName}` : "";
    throw new RuntimeError("201", `No provider for ${stringifyForError(token)} found${injectorDetails}`);
  }
  function assertNumber(actual, msg) {
    if (!(typeof actual === "number")) {
      throwError(msg, typeof actual, "number", "===");
    }
  }
  function assertNumberInRange(actual, minInclusive, maxInclusive) {
    assertNumber(actual, "Expected a number");
    assertLessThanOrEqual(actual, maxInclusive, "Expected number to be less than or equal to");
    assertGreaterThanOrEqual(actual, minInclusive, "Expected number to be greater than or equal to");
  }
  function assertString(actual, msg) {
    if (!(typeof actual === "string")) {
      throwError(msg, actual === null ? "null" : typeof actual, "string", "===");
    }
  }
  function assertFunction(actual, msg) {
    if (!(typeof actual === "function")) {
      throwError(msg, actual === null ? "null" : typeof actual, "function", "===");
    }
  }
  function assertEqual(actual, expected, msg) {
    if (!(actual == expected)) {
      throwError(msg, actual, expected, "==");
    }
  }
  function assertNotEqual(actual, expected, msg) {
    if (!(actual != expected)) {
      throwError(msg, actual, expected, "!=");
    }
  }
  function assertSame(actual, expected, msg) {
    if (!(actual === expected)) {
      throwError(msg, actual, expected, "===");
    }
  }
  function assertNotSame(actual, expected, msg) {
    if (!(actual !== expected)) {
      throwError(msg, actual, expected, "!==");
    }
  }
  function assertLessThan(actual, expected, msg) {
    if (!(actual < expected)) {
      throwError(msg, actual, expected, "<");
    }
  }
  function assertLessThanOrEqual(actual, expected, msg) {
    if (!(actual <= expected)) {
      throwError(msg, actual, expected, "<=");
    }
  }
  function assertGreaterThan(actual, expected, msg) {
    if (!(actual > expected)) {
      throwError(msg, actual, expected, ">");
    }
  }
  function assertGreaterThanOrEqual(actual, expected, msg) {
    if (!(actual >= expected)) {
      throwError(msg, actual, expected, ">=");
    }
  }
  function assertDefined(actual, msg) {
    if (actual == null) {
      throwError(msg, actual, null, "!=");
    }
  }
  function throwError(msg, actual, expected, comparison) {
    throw new Error(`ASSERTION ERROR: ${msg}` + (comparison == null ? "" : ` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`));
  }
  function assertDomNode(node) {
    if (!(typeof Node !== "undefined" && node instanceof Node) && !(typeof node === "object" && node != null && node.constructor.name === "WebWorkerRenderNode")) {
      throwError(`The provided value must be an instance of a DOM Node but got ${stringify(node)}`);
    }
  }
  function assertIndexInRange(arr, index) {
    assertDefined(arr, "Array must be defined.");
    const maxLen = arr.length;
    if (index < 0 || index >= maxLen) {
      throwError(`Index expected to be less than ${maxLen} but got ${index}`);
    }
  }
  function assertOneOf(value, ...validValues) {
    if (validValues.indexOf(value) !== -1)
      return true;
    throwError(`Expected value to be one of ${JSON.stringify(validValues)} but was ${JSON.stringify(value)}.`);
  }
  function \u0275\u0275defineInjectable(opts) {
    return {
      token: opts.token,
      providedIn: opts.providedIn || null,
      factory: opts.factory,
      value: void 0
    };
  }
  var defineInjectable = \u0275\u0275defineInjectable;
  function \u0275\u0275defineInjector(options) {
    return { providers: options.providers || [], imports: options.imports || [] };
  }
  function getInjectableDef(type) {
    return getOwnDefinition(type, NG_PROV_DEF) || getOwnDefinition(type, NG_INJECTABLE_DEF);
  }
  function getOwnDefinition(type, field) {
    return type.hasOwnProperty(field) ? type[field] : null;
  }
  function getInheritedInjectableDef(type) {
    const def = type && (type[NG_PROV_DEF] || type[NG_INJECTABLE_DEF]);
    if (def) {
      const typeName = getTypeName(type);
      console.warn(`DEPRECATED: DI is instantiating a token "${typeName}" that inherits its @Injectable decorator but does not provide one itself.
This will become an error in a future version of Angular. Please add @Injectable() to the "${typeName}" class.`);
      return def;
    } else {
      return null;
    }
  }
  function getTypeName(type) {
    if (type.hasOwnProperty("name")) {
      return type.name;
    }
    const match2 = ("" + type).match(/^function\s*([^\s(]+)/);
    return match2 === null ? "" : match2[1];
  }
  function getInjectorDef(type) {
    return type && (type.hasOwnProperty(NG_INJ_DEF) || type.hasOwnProperty(NG_INJECTOR_DEF)) ? type[NG_INJ_DEF] : null;
  }
  var NG_PROV_DEF = getClosureSafeProperty({ \u0275prov: getClosureSafeProperty });
  var NG_INJ_DEF = getClosureSafeProperty({ \u0275inj: getClosureSafeProperty });
  var NG_INJECTABLE_DEF = getClosureSafeProperty({ ngInjectableDef: getClosureSafeProperty });
  var NG_INJECTOR_DEF = getClosureSafeProperty({ ngInjectorDef: getClosureSafeProperty });
  var InjectFlags;
  (function(InjectFlags2) {
    InjectFlags2[InjectFlags2["Default"] = 0] = "Default";
    InjectFlags2[InjectFlags2["Host"] = 1] = "Host";
    InjectFlags2[InjectFlags2["Self"] = 2] = "Self";
    InjectFlags2[InjectFlags2["SkipSelf"] = 4] = "SkipSelf";
    InjectFlags2[InjectFlags2["Optional"] = 8] = "Optional";
  })(InjectFlags || (InjectFlags = {}));
  var _injectImplementation;
  function getInjectImplementation() {
    return _injectImplementation;
  }
  function setInjectImplementation(impl) {
    const previous = _injectImplementation;
    _injectImplementation = impl;
    return previous;
  }
  function injectRootLimpMode(token, notFoundValue, flags) {
    const injectableDef = getInjectableDef(token);
    if (injectableDef && injectableDef.providedIn == "root") {
      return injectableDef.value === void 0 ? injectableDef.value = injectableDef.factory() : injectableDef.value;
    }
    if (flags & InjectFlags.Optional)
      return null;
    if (notFoundValue !== void 0)
      return notFoundValue;
    throwProviderNotFoundError(stringify(token), "Injector");
  }
  function assertInjectImplementationNotEqual(fn2) {
    ngDevMode && assertNotEqual(_injectImplementation, fn2, "Calling \u0275\u0275inject would cause infinite recursion");
  }
  function noSideEffects(fn2) {
    return { toString: fn2 }.toString();
  }
  var ChangeDetectionStrategy;
  (function(ChangeDetectionStrategy3) {
    ChangeDetectionStrategy3[ChangeDetectionStrategy3["OnPush"] = 0] = "OnPush";
    ChangeDetectionStrategy3[ChangeDetectionStrategy3["Default"] = 1] = "Default";
  })(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));
  var ChangeDetectorStatus;
  (function(ChangeDetectorStatus2) {
    ChangeDetectorStatus2[ChangeDetectorStatus2["CheckOnce"] = 0] = "CheckOnce";
    ChangeDetectorStatus2[ChangeDetectorStatus2["Checked"] = 1] = "Checked";
    ChangeDetectorStatus2[ChangeDetectorStatus2["CheckAlways"] = 2] = "CheckAlways";
    ChangeDetectorStatus2[ChangeDetectorStatus2["Detached"] = 3] = "Detached";
    ChangeDetectorStatus2[ChangeDetectorStatus2["Errored"] = 4] = "Errored";
    ChangeDetectorStatus2[ChangeDetectorStatus2["Destroyed"] = 5] = "Destroyed";
  })(ChangeDetectorStatus || (ChangeDetectorStatus = {}));
  function isDefaultChangeDetectionStrategy(changeDetectionStrategy) {
    return changeDetectionStrategy == null || changeDetectionStrategy === ChangeDetectionStrategy.Default;
  }
  var ViewEncapsulation$1;
  (function(ViewEncapsulation3) {
    ViewEncapsulation3[ViewEncapsulation3["Emulated"] = 0] = "Emulated";
    ViewEncapsulation3[ViewEncapsulation3["None"] = 2] = "None";
    ViewEncapsulation3[ViewEncapsulation3["ShadowDom"] = 3] = "ShadowDom";
  })(ViewEncapsulation$1 || (ViewEncapsulation$1 = {}));
  var __globalThis = typeof globalThis !== "undefined" && globalThis;
  var __window = typeof window !== "undefined" && window;
  var __self = typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope && self;
  var __global = typeof global !== "undefined" && global;
  var _global2 = __globalThis || __global || __window || __self;
  function ngDevModeResetPerfCounters() {
    const locationString = typeof location !== "undefined" ? location.toString() : "";
    const newCounters = {
      namedConstructors: locationString.indexOf("ngDevMode=namedConstructors") != -1,
      firstCreatePass: 0,
      tNode: 0,
      tView: 0,
      rendererCreateTextNode: 0,
      rendererSetText: 0,
      rendererCreateElement: 0,
      rendererAddEventListener: 0,
      rendererSetAttribute: 0,
      rendererRemoveAttribute: 0,
      rendererSetProperty: 0,
      rendererSetClassName: 0,
      rendererAddClass: 0,
      rendererRemoveClass: 0,
      rendererSetStyle: 0,
      rendererRemoveStyle: 0,
      rendererDestroy: 0,
      rendererDestroyNode: 0,
      rendererMoveNode: 0,
      rendererRemoveNode: 0,
      rendererAppendChild: 0,
      rendererInsertBefore: 0,
      rendererCreateComment: 0
    };
    const allowNgDevModeTrue = locationString.indexOf("ngDevMode=false") === -1;
    _global2["ngDevMode"] = allowNgDevModeTrue && newCounters;
    return newCounters;
  }
  function initNgDevMode() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (typeof ngDevMode !== "object") {
        ngDevModeResetPerfCounters();
      }
      return typeof ngDevMode !== "undefined" && !!ngDevMode;
    }
    return false;
  }
  var EMPTY_OBJ = {};
  var EMPTY_ARRAY = [];
  if ((typeof ngDevMode === "undefined" || ngDevMode) && initNgDevMode()) {
    Object.freeze(EMPTY_OBJ);
    Object.freeze(EMPTY_ARRAY);
  }
  var NG_COMP_DEF = getClosureSafeProperty({ \u0275cmp: getClosureSafeProperty });
  var NG_DIR_DEF = getClosureSafeProperty({ \u0275dir: getClosureSafeProperty });
  var NG_PIPE_DEF = getClosureSafeProperty({ \u0275pipe: getClosureSafeProperty });
  var NG_MOD_DEF = getClosureSafeProperty({ \u0275mod: getClosureSafeProperty });
  var NG_FACTORY_DEF = getClosureSafeProperty({ \u0275fac: getClosureSafeProperty });
  var NG_ELEMENT_ID = getClosureSafeProperty({ __NG_ELEMENT_ID__: getClosureSafeProperty });
  var _renderCompCount = 0;
  function \u0275\u0275defineComponent(componentDefinition) {
    return noSideEffects(() => {
      (typeof ngDevMode === "undefined" || ngDevMode) && initNgDevMode();
      const type = componentDefinition.type;
      const declaredInputs = {};
      const def = {
        type,
        providersResolver: null,
        decls: componentDefinition.decls,
        vars: componentDefinition.vars,
        factory: null,
        template: componentDefinition.template || null,
        consts: componentDefinition.consts || null,
        ngContentSelectors: componentDefinition.ngContentSelectors,
        hostBindings: componentDefinition.hostBindings || null,
        hostVars: componentDefinition.hostVars || 0,
        hostAttrs: componentDefinition.hostAttrs || null,
        contentQueries: componentDefinition.contentQueries || null,
        declaredInputs,
        inputs: null,
        outputs: null,
        exportAs: componentDefinition.exportAs || null,
        onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,
        directiveDefs: null,
        pipeDefs: null,
        selectors: componentDefinition.selectors || EMPTY_ARRAY,
        viewQuery: componentDefinition.viewQuery || null,
        features: componentDefinition.features || null,
        data: componentDefinition.data || {},
        encapsulation: componentDefinition.encapsulation || ViewEncapsulation$1.Emulated,
        id: "c",
        styles: componentDefinition.styles || EMPTY_ARRAY,
        _: null,
        setInput: null,
        schemas: componentDefinition.schemas || null,
        tView: null
      };
      const directiveTypes = componentDefinition.directives;
      const feature = componentDefinition.features;
      const pipeTypes = componentDefinition.pipes;
      def.id += _renderCompCount++;
      def.inputs = invertObject(componentDefinition.inputs, declaredInputs), def.outputs = invertObject(componentDefinition.outputs), feature && feature.forEach((fn2) => fn2(def));
      def.directiveDefs = directiveTypes ? () => (typeof directiveTypes === "function" ? directiveTypes() : directiveTypes).map(extractDirectiveDef) : null;
      def.pipeDefs = pipeTypes ? () => (typeof pipeTypes === "function" ? pipeTypes() : pipeTypes).map(extractPipeDef) : null;
      return def;
    });
  }
  function \u0275\u0275setComponentScope(type, directives, pipes) {
    const def = type.\u0275cmp;
    def.directiveDefs = () => directives.map(extractDirectiveDef);
    def.pipeDefs = () => pipes.map(extractPipeDef);
  }
  function extractDirectiveDef(type) {
    const def = getComponentDef(type) || getDirectiveDef(type);
    if (ngDevMode && !def) {
      throw new Error(`'${type.name}' is neither 'ComponentType' or 'DirectiveType'.`);
    }
    return def;
  }
  function extractPipeDef(type) {
    const def = getPipeDef$1(type);
    if (ngDevMode && !def) {
      throw new Error(`'${type.name}' is not a 'PipeType'.`);
    }
    return def;
  }
  var autoRegisterModuleById = {};
  function \u0275\u0275defineNgModule(def) {
    return noSideEffects(() => {
      const res = {
        type: def.type,
        bootstrap: def.bootstrap || EMPTY_ARRAY,
        declarations: def.declarations || EMPTY_ARRAY,
        imports: def.imports || EMPTY_ARRAY,
        exports: def.exports || EMPTY_ARRAY,
        transitiveCompileScopes: null,
        schemas: def.schemas || null,
        id: def.id || null
      };
      if (def.id != null) {
        autoRegisterModuleById[def.id] = def.type;
      }
      return res;
    });
  }
  function \u0275\u0275setNgModuleScope(type, scope) {
    return noSideEffects(() => {
      const ngModuleDef = getNgModuleDef(type, true);
      ngModuleDef.declarations = scope.declarations || EMPTY_ARRAY;
      ngModuleDef.imports = scope.imports || EMPTY_ARRAY;
      ngModuleDef.exports = scope.exports || EMPTY_ARRAY;
    });
  }
  function invertObject(obj, secondary) {
    if (obj == null)
      return EMPTY_OBJ;
    const newLookup = {};
    for (const minifiedKey in obj) {
      if (obj.hasOwnProperty(minifiedKey)) {
        let publicName = obj[minifiedKey];
        let declaredName = publicName;
        if (Array.isArray(publicName)) {
          declaredName = publicName[1];
          publicName = publicName[0];
        }
        newLookup[publicName] = minifiedKey;
        if (secondary) {
          secondary[publicName] = declaredName;
        }
      }
    }
    return newLookup;
  }
  var \u0275\u0275defineDirective = \u0275\u0275defineComponent;
  function \u0275\u0275definePipe(pipeDef) {
    return {
      type: pipeDef.type,
      name: pipeDef.name,
      factory: null,
      pure: pipeDef.pure !== false,
      onDestroy: pipeDef.type.prototype.ngOnDestroy || null
    };
  }
  function getComponentDef(type) {
    return type[NG_COMP_DEF] || null;
  }
  function getDirectiveDef(type) {
    return type[NG_DIR_DEF] || null;
  }
  function getPipeDef$1(type) {
    return type[NG_PIPE_DEF] || null;
  }
  function getNgModuleDef(type, throwNotFound) {
    const ngModuleDef = type[NG_MOD_DEF] || null;
    if (!ngModuleDef && throwNotFound === true) {
      throw new Error(`Type ${stringify(type)} does not have '\u0275mod' property.`);
    }
    return ngModuleDef;
  }
  var HOST = 0;
  var TVIEW = 1;
  var FLAGS = 2;
  var PARENT = 3;
  var NEXT = 4;
  var TRANSPLANTED_VIEWS_TO_REFRESH = 5;
  var T_HOST = 6;
  var CLEANUP = 7;
  var CONTEXT = 8;
  var INJECTOR$1 = 9;
  var RENDERER_FACTORY = 10;
  var RENDERER = 11;
  var SANITIZER = 12;
  var CHILD_HEAD = 13;
  var CHILD_TAIL = 14;
  var DECLARATION_VIEW = 15;
  var DECLARATION_COMPONENT_VIEW = 16;
  var DECLARATION_LCONTAINER = 17;
  var PREORDER_HOOK_FLAGS = 18;
  var QUERIES = 19;
  var HEADER_OFFSET = 20;
  var TViewTypeAsString = [
    "Root",
    "Component",
    "Embedded"
  ];
  var unusedValueExportToPlacateAjd$8 = 1;
  var TYPE = 1;
  var HAS_TRANSPLANTED_VIEWS = 2;
  var NATIVE = 7;
  var VIEW_REFS = 8;
  var MOVED_VIEWS = 9;
  var CONTAINER_HEADER_OFFSET = 10;
  var unusedValueExportToPlacateAjd$7 = 1;
  function isLView(value) {
    return Array.isArray(value) && typeof value[TYPE] === "object";
  }
  function isLContainer(value) {
    return Array.isArray(value) && value[TYPE] === true;
  }
  function isContentQueryHost(tNode) {
    return (tNode.flags & 8) !== 0;
  }
  function isComponentHost(tNode) {
    return (tNode.flags & 2) === 2;
  }
  function isDirectiveHost(tNode) {
    return (tNode.flags & 1) === 1;
  }
  function isComponentDef(def) {
    return def.template !== null;
  }
  function isRootView(target) {
    return (target[FLAGS] & 512) !== 0;
  }
  function assertTNodeForLView(tNode, lView) {
    assertTNodeForTView(tNode, lView[TVIEW]);
  }
  function assertTNodeForTView(tNode, tView) {
    assertTNode(tNode);
    tNode.hasOwnProperty("tView_") && assertEqual(tNode.tView_, tView, "This TNode does not belong to this TView.");
  }
  function assertTNode(tNode) {
    assertDefined(tNode, "TNode must be defined");
    if (!(tNode && typeof tNode === "object" && tNode.hasOwnProperty("directiveStylingLast"))) {
      throwError("Not of type TNode, got: " + tNode);
    }
  }
  function assertTIcu(tIcu) {
    assertDefined(tIcu, "Expected TIcu to be defined");
    if (!(typeof tIcu.currentCaseLViewIndex === "number")) {
      throwError("Object is not of TIcu type.");
    }
  }
  function assertComponentType(actual, msg = "Type passed in is not ComponentType, it does not have '\u0275cmp' property.") {
    if (!getComponentDef(actual)) {
      throwError(msg);
    }
  }
  function assertNgModuleType(actual, msg = "Type passed in is not NgModuleType, it does not have '\u0275mod' property.") {
    if (!getNgModuleDef(actual)) {
      throwError(msg);
    }
  }
  function assertHasParent(tNode) {
    assertDefined(tNode, "currentTNode should exist!");
    assertDefined(tNode.parent, "currentTNode should have a parent");
  }
  function assertLContainer(value) {
    assertDefined(value, "LContainer must be defined");
    assertEqual(isLContainer(value), true, "Expecting LContainer");
  }
  function assertLViewOrUndefined(value) {
    value && assertEqual(isLView(value), true, "Expecting LView or undefined or null");
  }
  function assertLView(value) {
    assertDefined(value, "LView must be defined");
    assertEqual(isLView(value), true, "Expecting LView");
  }
  function assertFirstCreatePass(tView, errMessage) {
    assertEqual(tView.firstCreatePass, true, errMessage || "Should only be called in first create pass.");
  }
  function assertFirstUpdatePass(tView, errMessage) {
    assertEqual(tView.firstUpdatePass, true, errMessage || "Should only be called in first update pass.");
  }
  function assertDirectiveDef(obj) {
    if (obj.type === void 0 || obj.selectors == void 0 || obj.inputs === void 0) {
      throwError(`Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);
    }
  }
  function assertIndexInDeclRange(lView, index) {
    const tView = lView[1];
    assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index);
  }
  function assertIndexInExpandoRange(lView, index) {
    const tView = lView[1];
    assertBetween(tView.expandoStartIndex, lView.length, index);
  }
  function assertBetween(lower, upper, index) {
    if (!(lower <= index && index < upper)) {
      throwError(`Index out of range (expecting ${lower} <= ${index} < ${upper})`);
    }
  }
  function assertProjectionSlots(lView, errMessage) {
    assertDefined(lView[DECLARATION_COMPONENT_VIEW], "Component views should exist.");
    assertDefined(lView[DECLARATION_COMPONENT_VIEW][T_HOST].projection, errMessage || "Components with projection nodes (<ng-content>) must have projection slots defined.");
  }
  function assertParentView(lView, errMessage) {
    assertDefined(lView, errMessage || "Component views should always have a parent view (component's host view)");
  }
  function assertNodeInjector(lView, injectorIndex) {
    assertIndexInExpandoRange(lView, injectorIndex);
    assertIndexInExpandoRange(lView, injectorIndex + 8);
    assertNumber(lView[injectorIndex + 0], "injectorIndex should point to a bloom filter");
    assertNumber(lView[injectorIndex + 1], "injectorIndex should point to a bloom filter");
    assertNumber(lView[injectorIndex + 2], "injectorIndex should point to a bloom filter");
    assertNumber(lView[injectorIndex + 3], "injectorIndex should point to a bloom filter");
    assertNumber(lView[injectorIndex + 4], "injectorIndex should point to a bloom filter");
    assertNumber(lView[injectorIndex + 5], "injectorIndex should point to a bloom filter");
    assertNumber(lView[injectorIndex + 6], "injectorIndex should point to a bloom filter");
    assertNumber(lView[injectorIndex + 7], "injectorIndex should point to a bloom filter");
    assertNumber(lView[injectorIndex + 8], "injectorIndex should point to parent injector");
  }
  function getFactoryDef(type, throwNotFound) {
    const hasFactoryDef = type.hasOwnProperty(NG_FACTORY_DEF);
    if (!hasFactoryDef && throwNotFound === true && ngDevMode) {
      throw new Error(`Type ${stringify(type)} does not have '\u0275fac' property.`);
    }
    return hasFactoryDef ? type[NG_FACTORY_DEF] : null;
  }
  var SimpleChange = class {
    constructor(previousValue, currentValue, firstChange) {
      this.previousValue = previousValue;
      this.currentValue = currentValue;
      this.firstChange = firstChange;
    }
    isFirstChange() {
      return this.firstChange;
    }
  };
  function \u0275\u0275NgOnChangesFeature() {
    return NgOnChangesFeatureImpl;
  }
  function NgOnChangesFeatureImpl(definition) {
    if (definition.type.prototype.ngOnChanges) {
      definition.setInput = ngOnChangesSetInput;
    }
    return rememberChangeHistoryAndInvokeOnChangesHook;
  }
  \u0275\u0275NgOnChangesFeature.ngInherit = true;
  function rememberChangeHistoryAndInvokeOnChangesHook() {
    const simpleChangesStore = getSimpleChangesStore(this);
    const current = simpleChangesStore?.current;
    if (current) {
      const previous = simpleChangesStore.previous;
      if (previous === EMPTY_OBJ) {
        simpleChangesStore.previous = current;
      } else {
        for (let key in current) {
          previous[key] = current[key];
        }
      }
      simpleChangesStore.current = null;
      this.ngOnChanges(current);
    }
  }
  function ngOnChangesSetInput(instance, value, publicName, privateName) {
    const simpleChangesStore = getSimpleChangesStore(instance) || setSimpleChangesStore(instance, { previous: EMPTY_OBJ, current: null });
    const current = simpleChangesStore.current || (simpleChangesStore.current = {});
    const previous = simpleChangesStore.previous;
    const declaredName = this.declaredInputs[publicName];
    const previousChange = previous[declaredName];
    current[declaredName] = new SimpleChange(previousChange && previousChange.currentValue, value, previous === EMPTY_OBJ);
    instance[privateName] = value;
  }
  var SIMPLE_CHANGES_STORE = "__ngSimpleChanges__";
  function getSimpleChangesStore(instance) {
    return instance[SIMPLE_CHANGES_STORE] || null;
  }
  function setSimpleChangesStore(instance, store2) {
    return instance[SIMPLE_CHANGES_STORE] = store2;
  }
  var profilerCallback = null;
  var setProfiler = (profiler2) => {
    profilerCallback = profiler2;
  };
  var profiler = function(event, instance, hookOrListener) {
    if (profilerCallback != null) {
      profilerCallback(event, instance, hookOrListener);
    }
  };
  var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
  var MATH_ML_NAMESPACE = "http://www.w3.org/1998/MathML/";
  var DOCUMENT = void 0;
  function setDocument(document2) {
    DOCUMENT = document2;
  }
  function getDocument() {
    if (DOCUMENT !== void 0) {
      return DOCUMENT;
    } else if (typeof document !== "undefined") {
      return document;
    }
    return void 0;
  }
  var RendererStyleFlags3;
  (function(RendererStyleFlags32) {
    RendererStyleFlags32[RendererStyleFlags32["Important"] = 1] = "Important";
    RendererStyleFlags32[RendererStyleFlags32["DashCase"] = 2] = "DashCase";
  })(RendererStyleFlags3 || (RendererStyleFlags3 = {}));
  function isProceduralRenderer(renderer) {
    return !!renderer.listen;
  }
  var domRendererFactory3 = {
    createRenderer: (hostElement, rendererType) => {
      return getDocument();
    }
  };
  var unusedValueExportToPlacateAjd$6 = 1;
  function unwrapRNode(value) {
    while (Array.isArray(value)) {
      value = value[HOST];
    }
    return value;
  }
  function unwrapLView(value) {
    while (Array.isArray(value)) {
      if (typeof value[TYPE] === "object")
        return value;
      value = value[HOST];
    }
    return null;
  }
  function getNativeByIndex(index, lView) {
    ngDevMode && assertIndexInRange(lView, index);
    ngDevMode && assertGreaterThanOrEqual(index, HEADER_OFFSET, "Expected to be past HEADER_OFFSET");
    return unwrapRNode(lView[index]);
  }
  function getNativeByTNode(tNode, lView) {
    ngDevMode && assertTNodeForLView(tNode, lView);
    ngDevMode && assertIndexInRange(lView, tNode.index);
    const node = unwrapRNode(lView[tNode.index]);
    ngDevMode && !isProceduralRenderer(lView[RENDERER]) && assertDomNode(node);
    return node;
  }
  function getNativeByTNodeOrNull(tNode, lView) {
    const index = tNode === null ? -1 : tNode.index;
    if (index !== -1) {
      ngDevMode && assertTNodeForLView(tNode, lView);
      const node = unwrapRNode(lView[index]);
      ngDevMode && node !== null && !isProceduralRenderer(lView[RENDERER]) && assertDomNode(node);
      return node;
    }
    return null;
  }
  function getTNode(tView, index) {
    ngDevMode && assertGreaterThan(index, -1, "wrong index for TNode");
    ngDevMode && assertLessThan(index, tView.data.length, "wrong index for TNode");
    const tNode = tView.data[index];
    ngDevMode && tNode !== null && assertTNode(tNode);
    return tNode;
  }
  function load(view, index) {
    ngDevMode && assertIndexInRange(view, index);
    return view[index];
  }
  function getComponentLViewByIndex(nodeIndex, hostView) {
    ngDevMode && assertIndexInRange(hostView, nodeIndex);
    const slotValue = hostView[nodeIndex];
    const lView = isLView(slotValue) ? slotValue : slotValue[HOST];
    return lView;
  }
  function isCreationMode(view) {
    return (view[FLAGS] & 4) === 4;
  }
  function viewAttachedToChangeDetector(view) {
    return (view[FLAGS] & 128) === 128;
  }
  function viewAttachedToContainer(view) {
    return isLContainer(view[PARENT]);
  }
  function getConstant(consts, index) {
    if (index === null || index === void 0)
      return null;
    ngDevMode && assertIndexInRange(consts, index);
    return consts[index];
  }
  function resetPreOrderHookFlags(lView) {
    lView[PREORDER_HOOK_FLAGS] = 0;
  }
  function updateTransplantedViewCount(lContainer, amount) {
    lContainer[TRANSPLANTED_VIEWS_TO_REFRESH] += amount;
    let viewOrContainer = lContainer;
    let parent = lContainer[PARENT];
    while (parent !== null && (amount === 1 && viewOrContainer[TRANSPLANTED_VIEWS_TO_REFRESH] === 1 || amount === -1 && viewOrContainer[TRANSPLANTED_VIEWS_TO_REFRESH] === 0)) {
      parent[TRANSPLANTED_VIEWS_TO_REFRESH] += amount;
      viewOrContainer = parent;
      parent = parent[PARENT];
    }
  }
  var instructionState = {
    lFrame: createLFrame(null),
    bindingsEnabled: true,
    isInCheckNoChangesMode: false
  };
  function getElementDepthCount() {
    return instructionState.lFrame.elementDepthCount;
  }
  function increaseElementDepthCount() {
    instructionState.lFrame.elementDepthCount++;
  }
  function decreaseElementDepthCount() {
    instructionState.lFrame.elementDepthCount--;
  }
  function getBindingsEnabled() {
    return instructionState.bindingsEnabled;
  }
  function \u0275\u0275enableBindings() {
    instructionState.bindingsEnabled = true;
  }
  function \u0275\u0275disableBindings() {
    instructionState.bindingsEnabled = false;
  }
  function getLView() {
    return instructionState.lFrame.lView;
  }
  function getTView() {
    return instructionState.lFrame.tView;
  }
  function \u0275\u0275restoreView(viewToRestore) {
    instructionState.lFrame.contextLView = viewToRestore;
    return viewToRestore[CONTEXT];
  }
  function getCurrentTNode() {
    let currentTNode = getCurrentTNodePlaceholderOk();
    while (currentTNode !== null && currentTNode.type === 64) {
      currentTNode = currentTNode.parent;
    }
    return currentTNode;
  }
  function getCurrentTNodePlaceholderOk() {
    return instructionState.lFrame.currentTNode;
  }
  function getCurrentParentTNode() {
    const lFrame = instructionState.lFrame;
    const currentTNode = lFrame.currentTNode;
    return lFrame.isParent ? currentTNode : currentTNode.parent;
  }
  function setCurrentTNode(tNode, isParent) {
    ngDevMode && tNode && assertTNodeForTView(tNode, instructionState.lFrame.tView);
    const lFrame = instructionState.lFrame;
    lFrame.currentTNode = tNode;
    lFrame.isParent = isParent;
  }
  function isCurrentTNodeParent() {
    return instructionState.lFrame.isParent;
  }
  function setCurrentTNodeAsNotParent() {
    instructionState.lFrame.isParent = false;
  }
  function getContextLView() {
    return instructionState.lFrame.contextLView;
  }
  function isInCheckNoChangesMode() {
    return instructionState.isInCheckNoChangesMode;
  }
  function setIsInCheckNoChangesMode(mode) {
    instructionState.isInCheckNoChangesMode = mode;
  }
  function getBindingRoot() {
    const lFrame = instructionState.lFrame;
    let index = lFrame.bindingRootIndex;
    if (index === -1) {
      index = lFrame.bindingRootIndex = lFrame.tView.bindingStartIndex;
    }
    return index;
  }
  function getBindingIndex() {
    return instructionState.lFrame.bindingIndex;
  }
  function setBindingIndex(value) {
    return instructionState.lFrame.bindingIndex = value;
  }
  function nextBindingIndex() {
    return instructionState.lFrame.bindingIndex++;
  }
  function incrementBindingIndex(count) {
    const lFrame = instructionState.lFrame;
    const index = lFrame.bindingIndex;
    lFrame.bindingIndex = lFrame.bindingIndex + count;
    return index;
  }
  function isInI18nBlock() {
    return instructionState.lFrame.inI18n;
  }
  function setInI18nBlock(isInI18nBlock2) {
    instructionState.lFrame.inI18n = isInI18nBlock2;
  }
  function setBindingRootForHostBindings(bindingRootIndex, currentDirectiveIndex) {
    const lFrame = instructionState.lFrame;
    lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex;
    setCurrentDirectiveIndex(currentDirectiveIndex);
  }
  function getCurrentDirectiveIndex() {
    return instructionState.lFrame.currentDirectiveIndex;
  }
  function setCurrentDirectiveIndex(currentDirectiveIndex) {
    instructionState.lFrame.currentDirectiveIndex = currentDirectiveIndex;
  }
  function getCurrentDirectiveDef(tData) {
    const currentDirectiveIndex = instructionState.lFrame.currentDirectiveIndex;
    return currentDirectiveIndex === -1 ? null : tData[currentDirectiveIndex];
  }
  function getCurrentQueryIndex() {
    return instructionState.lFrame.currentQueryIndex;
  }
  function setCurrentQueryIndex(value) {
    instructionState.lFrame.currentQueryIndex = value;
  }
  function getDeclarationTNode(lView) {
    const tView = lView[TVIEW];
    if (tView.type === 2) {
      ngDevMode && assertDefined(tView.declTNode, "Embedded TNodes should have declaration parents.");
      return tView.declTNode;
    }
    if (tView.type === 1) {
      return lView[T_HOST];
    }
    return null;
  }
  function enterDI(lView, tNode, flags) {
    ngDevMode && assertLViewOrUndefined(lView);
    if (flags & InjectFlags.SkipSelf) {
      ngDevMode && assertTNodeForTView(tNode, lView[TVIEW]);
      let parentTNode = tNode;
      let parentLView = lView;
      while (true) {
        ngDevMode && assertDefined(parentTNode, "Parent TNode should be defined");
        parentTNode = parentTNode.parent;
        if (parentTNode === null && !(flags & InjectFlags.Host)) {
          parentTNode = getDeclarationTNode(parentLView);
          if (parentTNode === null)
            break;
          ngDevMode && assertDefined(parentLView, "Parent LView should be defined");
          parentLView = parentLView[DECLARATION_VIEW];
          if (parentTNode.type & (2 | 8)) {
            break;
          }
        } else {
          break;
        }
      }
      if (parentTNode === null) {
        return false;
      } else {
        tNode = parentTNode;
        lView = parentLView;
      }
    }
    ngDevMode && assertTNodeForLView(tNode, lView);
    const lFrame = instructionState.lFrame = allocLFrame();
    lFrame.currentTNode = tNode;
    lFrame.lView = lView;
    return true;
  }
  function enterView(newView) {
    ngDevMode && assertNotEqual(newView[0], newView[1], "????");
    ngDevMode && assertLViewOrUndefined(newView);
    const newLFrame = allocLFrame();
    if (ngDevMode) {
      assertEqual(newLFrame.isParent, true, "Expected clean LFrame");
      assertEqual(newLFrame.lView, null, "Expected clean LFrame");
      assertEqual(newLFrame.tView, null, "Expected clean LFrame");
      assertEqual(newLFrame.selectedIndex, -1, "Expected clean LFrame");
      assertEqual(newLFrame.elementDepthCount, 0, "Expected clean LFrame");
      assertEqual(newLFrame.currentDirectiveIndex, -1, "Expected clean LFrame");
      assertEqual(newLFrame.currentNamespace, null, "Expected clean LFrame");
      assertEqual(newLFrame.bindingRootIndex, -1, "Expected clean LFrame");
      assertEqual(newLFrame.currentQueryIndex, 0, "Expected clean LFrame");
    }
    const tView = newView[TVIEW];
    instructionState.lFrame = newLFrame;
    ngDevMode && tView.firstChild && assertTNodeForTView(tView.firstChild, tView);
    newLFrame.currentTNode = tView.firstChild;
    newLFrame.lView = newView;
    newLFrame.tView = tView;
    newLFrame.contextLView = newView;
    newLFrame.bindingIndex = tView.bindingStartIndex;
    newLFrame.inI18n = false;
  }
  function allocLFrame() {
    const currentLFrame = instructionState.lFrame;
    const childLFrame = currentLFrame === null ? null : currentLFrame.child;
    const newLFrame = childLFrame === null ? createLFrame(currentLFrame) : childLFrame;
    return newLFrame;
  }
  function createLFrame(parent) {
    const lFrame = {
      currentTNode: null,
      isParent: true,
      lView: null,
      tView: null,
      selectedIndex: -1,
      contextLView: null,
      elementDepthCount: 0,
      currentNamespace: null,
      currentDirectiveIndex: -1,
      bindingRootIndex: -1,
      bindingIndex: -1,
      currentQueryIndex: 0,
      parent,
      child: null,
      inI18n: false
    };
    parent !== null && (parent.child = lFrame);
    return lFrame;
  }
  function leaveViewLight() {
    const oldLFrame = instructionState.lFrame;
    instructionState.lFrame = oldLFrame.parent;
    oldLFrame.currentTNode = null;
    oldLFrame.lView = null;
    return oldLFrame;
  }
  var leaveDI = leaveViewLight;
  function leaveView() {
    const oldLFrame = leaveViewLight();
    oldLFrame.isParent = true;
    oldLFrame.tView = null;
    oldLFrame.selectedIndex = -1;
    oldLFrame.contextLView = null;
    oldLFrame.elementDepthCount = 0;
    oldLFrame.currentDirectiveIndex = -1;
    oldLFrame.currentNamespace = null;
    oldLFrame.bindingRootIndex = -1;
    oldLFrame.bindingIndex = -1;
    oldLFrame.currentQueryIndex = 0;
  }
  function nextContextImpl(level) {
    const contextLView = instructionState.lFrame.contextLView = walkUpViews(level, instructionState.lFrame.contextLView);
    return contextLView[CONTEXT];
  }
  function walkUpViews(nestingLevel, currentView) {
    while (nestingLevel > 0) {
      ngDevMode && assertDefined(currentView[DECLARATION_VIEW], "Declaration view should be defined if nesting level is greater than 0.");
      currentView = currentView[DECLARATION_VIEW];
      nestingLevel--;
    }
    return currentView;
  }
  function getSelectedIndex() {
    return instructionState.lFrame.selectedIndex;
  }
  function setSelectedIndex(index) {
    ngDevMode && index !== -1 && assertGreaterThanOrEqual(index, HEADER_OFFSET, "Index must be past HEADER_OFFSET (or -1).");
    ngDevMode && assertLessThan(index, instructionState.lFrame.lView.length, "Can't set index passed end of LView");
    instructionState.lFrame.selectedIndex = index;
  }
  function getSelectedTNode() {
    const lFrame = instructionState.lFrame;
    return getTNode(lFrame.tView, lFrame.selectedIndex);
  }
  function \u0275\u0275namespaceSVG() {
    instructionState.lFrame.currentNamespace = SVG_NAMESPACE;
  }
  function \u0275\u0275namespaceMathML() {
    instructionState.lFrame.currentNamespace = MATH_ML_NAMESPACE;
  }
  function \u0275\u0275namespaceHTML() {
    namespaceHTMLInternal();
  }
  function namespaceHTMLInternal() {
    instructionState.lFrame.currentNamespace = null;
  }
  function getNamespace$1() {
    return instructionState.lFrame.currentNamespace;
  }
  function registerPreOrderHooks(directiveIndex, directiveDef, tView) {
    ngDevMode && assertFirstCreatePass(tView);
    const { ngOnChanges, ngOnInit, ngDoCheck } = directiveDef.type.prototype;
    if (ngOnChanges) {
      const wrappedOnChanges = NgOnChangesFeatureImpl(directiveDef);
      (tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, wrappedOnChanges);
      (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(directiveIndex, wrappedOnChanges);
    }
    if (ngOnInit) {
      (tView.preOrderHooks || (tView.preOrderHooks = [])).push(0 - directiveIndex, ngOnInit);
    }
    if (ngDoCheck) {
      (tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, ngDoCheck);
      (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(directiveIndex, ngDoCheck);
    }
  }
  function registerPostOrderHooks(tView, tNode) {
    ngDevMode && assertFirstCreatePass(tView);
    for (let i = tNode.directiveStart, end = tNode.directiveEnd; i < end; i++) {
      const directiveDef = tView.data[i];
      ngDevMode && assertDefined(directiveDef, "Expecting DirectiveDef");
      const lifecycleHooks = directiveDef.type.prototype;
      const { ngAfterContentInit, ngAfterContentChecked, ngAfterViewInit, ngAfterViewChecked, ngOnDestroy } = lifecycleHooks;
      if (ngAfterContentInit) {
        (tView.contentHooks || (tView.contentHooks = [])).push(-i, ngAfterContentInit);
      }
      if (ngAfterContentChecked) {
        (tView.contentHooks || (tView.contentHooks = [])).push(i, ngAfterContentChecked);
        (tView.contentCheckHooks || (tView.contentCheckHooks = [])).push(i, ngAfterContentChecked);
      }
      if (ngAfterViewInit) {
        (tView.viewHooks || (tView.viewHooks = [])).push(-i, ngAfterViewInit);
      }
      if (ngAfterViewChecked) {
        (tView.viewHooks || (tView.viewHooks = [])).push(i, ngAfterViewChecked);
        (tView.viewCheckHooks || (tView.viewCheckHooks = [])).push(i, ngAfterViewChecked);
      }
      if (ngOnDestroy != null) {
        (tView.destroyHooks || (tView.destroyHooks = [])).push(i, ngOnDestroy);
      }
    }
  }
  function executeCheckHooks(lView, hooks, nodeIndex) {
    callHooks(lView, hooks, 3, nodeIndex);
  }
  function executeInitAndCheckHooks(lView, hooks, initPhase, nodeIndex) {
    ngDevMode && assertNotEqual(initPhase, 3, "Init pre-order hooks should not be called more than once");
    if ((lView[FLAGS] & 3) === initPhase) {
      callHooks(lView, hooks, initPhase, nodeIndex);
    }
  }
  function incrementInitPhaseFlags(lView, initPhase) {
    ngDevMode && assertNotEqual(initPhase, 3, "Init hooks phase should not be incremented after all init hooks have been run.");
    let flags = lView[FLAGS];
    if ((flags & 3) === initPhase) {
      flags &= 2047;
      flags += 1;
      lView[FLAGS] = flags;
    }
  }
  function callHooks(currentView, arr, initPhase, currentNodeIndex) {
    ngDevMode && assertEqual(isInCheckNoChangesMode(), false, "Hooks should never be run when in check no changes mode.");
    const startIndex = currentNodeIndex !== void 0 ? currentView[PREORDER_HOOK_FLAGS] & 65535 : 0;
    const nodeIndexLimit = currentNodeIndex != null ? currentNodeIndex : -1;
    const max = arr.length - 1;
    let lastNodeIndexFound = 0;
    for (let i = startIndex; i < max; i++) {
      const hook = arr[i + 1];
      if (typeof hook === "number") {
        lastNodeIndexFound = arr[i];
        if (currentNodeIndex != null && lastNodeIndexFound >= currentNodeIndex) {
          break;
        }
      } else {
        const isInitHook = arr[i] < 0;
        if (isInitHook)
          currentView[PREORDER_HOOK_FLAGS] += 65536;
        if (lastNodeIndexFound < nodeIndexLimit || nodeIndexLimit == -1) {
          callHook(currentView, initPhase, arr, i);
          currentView[PREORDER_HOOK_FLAGS] = (currentView[PREORDER_HOOK_FLAGS] & 4294901760) + i + 2;
        }
        i++;
      }
    }
  }
  function callHook(currentView, initPhase, arr, i) {
    const isInitHook = arr[i] < 0;
    const hook = arr[i + 1];
    const directiveIndex = isInitHook ? -arr[i] : arr[i];
    const directive = currentView[directiveIndex];
    if (isInitHook) {
      const indexWithintInitPhase = currentView[FLAGS] >> 11;
      if (indexWithintInitPhase < currentView[PREORDER_HOOK_FLAGS] >> 16 && (currentView[FLAGS] & 3) === initPhase) {
        currentView[FLAGS] += 2048;
        profiler(4, directive, hook);
        try {
          hook.call(directive);
        } finally {
          profiler(5, directive, hook);
        }
      }
    } else {
      profiler(4, directive, hook);
      try {
        hook.call(directive);
      } finally {
        profiler(5, directive, hook);
      }
    }
  }
  var NO_PARENT_INJECTOR = -1;
  var NodeInjectorFactory = class {
    constructor(factory, isViewProvider, injectImplementation) {
      this.factory = factory;
      this.resolving = false;
      ngDevMode && assertDefined(factory, "Factory not specified");
      ngDevMode && assertEqual(typeof factory, "function", "Expected factory function.");
      this.canSeeViewProviders = isViewProvider;
      this.injectImpl = injectImplementation;
    }
  };
  function isFactory(obj) {
    return obj instanceof NodeInjectorFactory;
  }
  var unusedValueExportToPlacateAjd$5 = 1;
  function toTNodeTypeAsString(tNodeType) {
    let text = "";
    tNodeType & 1 && (text += "|Text");
    tNodeType & 2 && (text += "|Element");
    tNodeType & 4 && (text += "|Container");
    tNodeType & 8 && (text += "|ElementContainer");
    tNodeType & 16 && (text += "|Projection");
    tNodeType & 32 && (text += "|IcuContainer");
    tNodeType & 64 && (text += "|Placeholder");
    return text.length > 0 ? text.substring(1) : text;
  }
  var unusedValueExportToPlacateAjd$4 = 1;
  function hasClassInput(tNode) {
    return (tNode.flags & 16) !== 0;
  }
  function hasStyleInput(tNode) {
    return (tNode.flags & 32) !== 0;
  }
  function assertTNodeType(tNode, expectedTypes, message) {
    assertDefined(tNode, "should be called with a TNode");
    if ((tNode.type & expectedTypes) === 0) {
      throwError(message || `Expected [${toTNodeTypeAsString(expectedTypes)}] but got ${toTNodeTypeAsString(tNode.type)}.`);
    }
  }
  function assertPureTNodeType(type) {
    if (!(type === 2 || type === 1 || type === 4 || type === 8 || type === 32 || type === 16 || type === 64)) {
      throwError(`Expected TNodeType to have only a single type selected, but got ${toTNodeTypeAsString(type)}.`);
    }
  }
  function setUpAttributes(renderer, native, attrs) {
    const isProc = isProceduralRenderer(renderer);
    let i = 0;
    while (i < attrs.length) {
      const value = attrs[i];
      if (typeof value === "number") {
        if (value !== 0) {
          break;
        }
        i++;
        const namespaceURI = attrs[i++];
        const attrName = attrs[i++];
        const attrVal = attrs[i++];
        ngDevMode && ngDevMode.rendererSetAttribute++;
        isProc ? renderer.setAttribute(native, attrName, attrVal, namespaceURI) : native.setAttributeNS(namespaceURI, attrName, attrVal);
      } else {
        const attrName = value;
        const attrVal = attrs[++i];
        ngDevMode && ngDevMode.rendererSetAttribute++;
        if (isAnimationProp(attrName)) {
          if (isProc) {
            renderer.setProperty(native, attrName, attrVal);
          }
        } else {
          isProc ? renderer.setAttribute(native, attrName, attrVal) : native.setAttribute(attrName, attrVal);
        }
        i++;
      }
    }
    return i;
  }
  function isNameOnlyAttributeMarker(marker) {
    return marker === 3 || marker === 4 || marker === 6;
  }
  function isAnimationProp(name) {
    return name.charCodeAt(0) === 64;
  }
  function mergeHostAttrs(dst, src) {
    if (src === null || src.length === 0) {
    } else if (dst === null || dst.length === 0) {
      dst = src.slice();
    } else {
      let srcMarker = -1;
      for (let i = 0; i < src.length; i++) {
        const item = src[i];
        if (typeof item === "number") {
          srcMarker = item;
        } else {
          if (srcMarker === 0) {
          } else if (srcMarker === -1 || srcMarker === 2) {
            mergeHostAttribute(dst, srcMarker, item, null, src[++i]);
          } else {
            mergeHostAttribute(dst, srcMarker, item, null, null);
          }
        }
      }
    }
    return dst;
  }
  function mergeHostAttribute(dst, marker, key1, key2, value) {
    let i = 0;
    let markerInsertPosition = dst.length;
    if (marker === -1) {
      markerInsertPosition = -1;
    } else {
      while (i < dst.length) {
        const dstValue = dst[i++];
        if (typeof dstValue === "number") {
          if (dstValue === marker) {
            markerInsertPosition = -1;
            break;
          } else if (dstValue > marker) {
            markerInsertPosition = i - 1;
            break;
          }
        }
      }
    }
    while (i < dst.length) {
      const item = dst[i];
      if (typeof item === "number") {
        break;
      } else if (item === key1) {
        if (key2 === null) {
          if (value !== null) {
            dst[i + 1] = value;
          }
          return;
        } else if (key2 === dst[i + 1]) {
          dst[i + 2] = value;
          return;
        }
      }
      i++;
      if (key2 !== null)
        i++;
      if (value !== null)
        i++;
    }
    if (markerInsertPosition !== -1) {
      dst.splice(markerInsertPosition, 0, marker);
      i = markerInsertPosition + 1;
    }
    dst.splice(i++, 0, key1);
    if (key2 !== null) {
      dst.splice(i++, 0, key2);
    }
    if (value !== null) {
      dst.splice(i++, 0, value);
    }
  }
  function hasParentInjector(parentLocation) {
    return parentLocation !== NO_PARENT_INJECTOR;
  }
  function getParentInjectorIndex(parentLocation) {
    ngDevMode && assertNumber(parentLocation, "Number expected");
    ngDevMode && assertNotEqual(parentLocation, -1, "Not a valid state.");
    const parentInjectorIndex = parentLocation & 32767;
    ngDevMode && assertGreaterThan(parentInjectorIndex, HEADER_OFFSET, "Parent injector must be pointing past HEADER_OFFSET.");
    return parentLocation & 32767;
  }
  function getParentInjectorViewOffset(parentLocation) {
    return parentLocation >> 16;
  }
  function getParentInjectorView(location2, startView) {
    let viewOffset = getParentInjectorViewOffset(location2);
    let parentView = startView;
    while (viewOffset > 0) {
      parentView = parentView[DECLARATION_VIEW];
      viewOffset--;
    }
    return parentView;
  }
  var includeViewProviders = true;
  function setIncludeViewProviders(v) {
    const oldValue = includeViewProviders;
    includeViewProviders = v;
    return oldValue;
  }
  var BLOOM_SIZE = 256;
  var BLOOM_MASK = BLOOM_SIZE - 1;
  var BLOOM_BUCKET_BITS = 5;
  var nextNgElementId = 0;
  function bloomAdd(injectorIndex, tView, type) {
    ngDevMode && assertEqual(tView.firstCreatePass, true, "expected firstCreatePass to be true");
    let id;
    if (typeof type === "string") {
      id = type.charCodeAt(0) || 0;
    } else if (type.hasOwnProperty(NG_ELEMENT_ID)) {
      id = type[NG_ELEMENT_ID];
    }
    if (id == null) {
      id = type[NG_ELEMENT_ID] = nextNgElementId++;
    }
    const bloomHash = id & BLOOM_MASK;
    const mask = 1 << bloomHash;
    tView.data[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)] |= mask;
  }
  function getOrCreateNodeInjectorForNode(tNode, lView) {
    const existingInjectorIndex = getInjectorIndex(tNode, lView);
    if (existingInjectorIndex !== -1) {
      return existingInjectorIndex;
    }
    const tView = lView[TVIEW];
    if (tView.firstCreatePass) {
      tNode.injectorIndex = lView.length;
      insertBloom(tView.data, tNode);
      insertBloom(lView, null);
      insertBloom(tView.blueprint, null);
    }
    const parentLoc = getParentInjectorLocation(tNode, lView);
    const injectorIndex = tNode.injectorIndex;
    if (hasParentInjector(parentLoc)) {
      const parentIndex = getParentInjectorIndex(parentLoc);
      const parentLView = getParentInjectorView(parentLoc, lView);
      const parentData = parentLView[TVIEW].data;
      for (let i = 0; i < 8; i++) {
        lView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];
      }
    }
    lView[injectorIndex + 8] = parentLoc;
    return injectorIndex;
  }
  function insertBloom(arr, footer) {
    arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);
  }
  function getInjectorIndex(tNode, lView) {
    if (tNode.injectorIndex === -1 || tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex || lView[tNode.injectorIndex + 8] === null) {
      return -1;
    } else {
      ngDevMode && assertIndexInRange(lView, tNode.injectorIndex);
      return tNode.injectorIndex;
    }
  }
  function getParentInjectorLocation(tNode, lView) {
    if (tNode.parent && tNode.parent.injectorIndex !== -1) {
      return tNode.parent.injectorIndex;
    }
    let declarationViewOffset = 0;
    let parentTNode = null;
    let lViewCursor = lView;
    while (lViewCursor !== null) {
      const tView = lViewCursor[TVIEW];
      const tViewType = tView.type;
      if (tViewType === 2) {
        ngDevMode && assertDefined(tView.declTNode, "Embedded TNodes should have declaration parents.");
        parentTNode = tView.declTNode;
      } else if (tViewType === 1) {
        parentTNode = lViewCursor[T_HOST];
      } else {
        ngDevMode && assertEqual(tView.type, 0, "Root type expected");
        parentTNode = null;
      }
      if (parentTNode === null) {
        return NO_PARENT_INJECTOR;
      }
      ngDevMode && parentTNode && assertTNodeForLView(parentTNode, lViewCursor[DECLARATION_VIEW]);
      declarationViewOffset++;
      lViewCursor = lViewCursor[DECLARATION_VIEW];
      if (parentTNode.injectorIndex !== -1) {
        return parentTNode.injectorIndex | declarationViewOffset << 16;
      }
    }
    return NO_PARENT_INJECTOR;
  }
  function diPublicInInjector(injectorIndex, tView, token) {
    bloomAdd(injectorIndex, tView, token);
  }
  function injectAttributeImpl(tNode, attrNameToInject) {
    ngDevMode && assertTNodeType(tNode, 12 | 3);
    ngDevMode && assertDefined(tNode, "expecting tNode");
    if (attrNameToInject === "class") {
      return tNode.classes;
    }
    if (attrNameToInject === "style") {
      return tNode.styles;
    }
    const attrs = tNode.attrs;
    if (attrs) {
      const attrsLength = attrs.length;
      let i = 0;
      while (i < attrsLength) {
        const value = attrs[i];
        if (isNameOnlyAttributeMarker(value))
          break;
        if (value === 0) {
          i = i + 2;
        } else if (typeof value === "number") {
          i++;
          while (i < attrsLength && typeof attrs[i] === "string") {
            i++;
          }
        } else if (value === attrNameToInject) {
          return attrs[i + 1];
        } else {
          i = i + 2;
        }
      }
    }
    return null;
  }
  function notFoundValueOrThrow(notFoundValue, token, flags) {
    if (flags & InjectFlags.Optional) {
      return notFoundValue;
    } else {
      throwProviderNotFoundError(token, "NodeInjector");
    }
  }
  function lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue) {
    if (flags & InjectFlags.Optional && notFoundValue === void 0) {
      notFoundValue = null;
    }
    if ((flags & (InjectFlags.Self | InjectFlags.Host)) === 0) {
      const moduleInjector = lView[INJECTOR$1];
      const previousInjectImplementation = setInjectImplementation(void 0);
      try {
        if (moduleInjector) {
          return moduleInjector.get(token, notFoundValue, flags & InjectFlags.Optional);
        } else {
          return injectRootLimpMode(token, notFoundValue, flags & InjectFlags.Optional);
        }
      } finally {
        setInjectImplementation(previousInjectImplementation);
      }
    }
    return notFoundValueOrThrow(notFoundValue, token, flags);
  }
  function getOrCreateInjectable(tNode, lView, token, flags = InjectFlags.Default, notFoundValue) {
    if (tNode !== null) {
      const bloomHash = bloomHashBitOrFactory(token);
      if (typeof bloomHash === "function") {
        if (!enterDI(lView, tNode, flags)) {
          return flags & InjectFlags.Host ? notFoundValueOrThrow(notFoundValue, token, flags) : lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
        }
        try {
          const value = bloomHash(flags);
          if (value == null && !(flags & InjectFlags.Optional)) {
            throwProviderNotFoundError(token);
          } else {
            return value;
          }
        } finally {
          leaveDI();
        }
      } else if (typeof bloomHash === "number") {
        let previousTView = null;
        let injectorIndex = getInjectorIndex(tNode, lView);
        let parentLocation = NO_PARENT_INJECTOR;
        let hostTElementNode = flags & InjectFlags.Host ? lView[DECLARATION_COMPONENT_VIEW][T_HOST] : null;
        if (injectorIndex === -1 || flags & InjectFlags.SkipSelf) {
          parentLocation = injectorIndex === -1 ? getParentInjectorLocation(tNode, lView) : lView[injectorIndex + 8];
          if (parentLocation === NO_PARENT_INJECTOR || !shouldSearchParent(flags, false)) {
            injectorIndex = -1;
          } else {
            previousTView = lView[TVIEW];
            injectorIndex = getParentInjectorIndex(parentLocation);
            lView = getParentInjectorView(parentLocation, lView);
          }
        }
        while (injectorIndex !== -1) {
          ngDevMode && assertNodeInjector(lView, injectorIndex);
          const tView = lView[TVIEW];
          ngDevMode && assertTNodeForLView(tView.data[injectorIndex + 8], lView);
          if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {
            const instance = searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode);
            if (instance !== NOT_FOUND) {
              return instance;
            }
          }
          parentLocation = lView[injectorIndex + 8];
          if (parentLocation !== NO_PARENT_INJECTOR && shouldSearchParent(flags, lView[TVIEW].data[injectorIndex + 8] === hostTElementNode) && bloomHasToken(bloomHash, injectorIndex, lView)) {
            previousTView = tView;
            injectorIndex = getParentInjectorIndex(parentLocation);
            lView = getParentInjectorView(parentLocation, lView);
          } else {
            injectorIndex = -1;
          }
        }
      }
    }
    return lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
  }
  var NOT_FOUND = {};
  function createNodeInjector() {
    return new NodeInjector(getCurrentTNode(), getLView());
  }
  function searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode) {
    const currentTView = lView[TVIEW];
    const tNode = currentTView.data[injectorIndex + 8];
    const canAccessViewProviders = previousTView == null ? isComponentHost(tNode) && includeViewProviders : previousTView != currentTView && (tNode.type & 3) !== 0;
    const isHostSpecialCase = flags & InjectFlags.Host && hostTElementNode === tNode;
    const injectableIdx = locateDirectiveOrProvider(tNode, currentTView, token, canAccessViewProviders, isHostSpecialCase);
    if (injectableIdx !== null) {
      return getNodeInjectable(lView, currentTView, injectableIdx, tNode);
    } else {
      return NOT_FOUND;
    }
  }
  function locateDirectiveOrProvider(tNode, tView, token, canAccessViewProviders, isHostSpecialCase) {
    const nodeProviderIndexes = tNode.providerIndexes;
    const tInjectables = tView.data;
    const injectablesStart = nodeProviderIndexes & 1048575;
    const directivesStart = tNode.directiveStart;
    const directiveEnd = tNode.directiveEnd;
    const cptViewProvidersCount = nodeProviderIndexes >> 20;
    const startingIndex = canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount;
    const endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;
    for (let i = startingIndex; i < endIndex; i++) {
      const providerTokenOrDef = tInjectables[i];
      if (i < directivesStart && token === providerTokenOrDef || i >= directivesStart && providerTokenOrDef.type === token) {
        return i;
      }
    }
    if (isHostSpecialCase) {
      const dirDef = tInjectables[directivesStart];
      if (dirDef && isComponentDef(dirDef) && dirDef.type === token) {
        return directivesStart;
      }
    }
    return null;
  }
  function getNodeInjectable(lView, tView, index, tNode) {
    let value = lView[index];
    const tData = tView.data;
    if (isFactory(value)) {
      const factory = value;
      if (factory.resolving) {
        throwCyclicDependencyError(stringifyForError(tData[index]));
      }
      const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);
      factory.resolving = true;
      const previousInjectImplementation = factory.injectImpl ? setInjectImplementation(factory.injectImpl) : null;
      const success = enterDI(lView, tNode, InjectFlags.Default);
      ngDevMode && assertEqual(success, true, "Because flags do not contain `SkipSelf' we expect this to always succeed.");
      try {
        value = lView[index] = factory.factory(void 0, tData, lView, tNode);
        if (tView.firstCreatePass && index >= tNode.directiveStart) {
          ngDevMode && assertDirectiveDef(tData[index]);
          registerPreOrderHooks(index, tData[index], tView);
        }
      } finally {
        previousInjectImplementation !== null && setInjectImplementation(previousInjectImplementation);
        setIncludeViewProviders(previousIncludeViewProviders);
        factory.resolving = false;
        leaveDI();
      }
    }
    return value;
  }
  function bloomHashBitOrFactory(token) {
    ngDevMode && assertDefined(token, "token must be defined");
    if (typeof token === "string") {
      return token.charCodeAt(0) || 0;
    }
    const tokenId = token.hasOwnProperty(NG_ELEMENT_ID) ? token[NG_ELEMENT_ID] : void 0;
    if (typeof tokenId === "number") {
      if (tokenId >= 0) {
        return tokenId & BLOOM_MASK;
      } else {
        ngDevMode && assertEqual(tokenId, -1, "Expecting to get Special Injector Id");
        return createNodeInjector;
      }
    } else {
      return tokenId;
    }
  }
  function bloomHasToken(bloomHash, injectorIndex, injectorView) {
    const mask = 1 << bloomHash;
    const value = injectorView[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)];
    return !!(value & mask);
  }
  function shouldSearchParent(flags, isFirstHostTNode) {
    return !(flags & InjectFlags.Self) && !(flags & InjectFlags.Host && isFirstHostTNode);
  }
  var NodeInjector = class {
    constructor(_tNode, _lView) {
      this._tNode = _tNode;
      this._lView = _lView;
    }
    get(token, notFoundValue, flags) {
      return getOrCreateInjectable(this._tNode, this._lView, token, flags, notFoundValue);
    }
  };
  function \u0275\u0275getInheritedFactory(type) {
    return noSideEffects(() => {
      const ownConstructor = type.prototype.constructor;
      const ownFactory = ownConstructor[NG_FACTORY_DEF] || getFactoryOf(ownConstructor);
      const objectPrototype = Object.prototype;
      let parent = Object.getPrototypeOf(type.prototype).constructor;
      while (parent && parent !== objectPrototype) {
        const factory = parent[NG_FACTORY_DEF] || getFactoryOf(parent);
        if (factory && factory !== ownFactory) {
          return factory;
        }
        parent = Object.getPrototypeOf(parent);
      }
      return (t) => new t();
    });
  }
  function getFactoryOf(type) {
    if (isForwardRef(type)) {
      return () => {
        const factory = getFactoryOf(resolveForwardRef(type));
        return factory && factory();
      };
    }
    return getFactoryDef(type);
  }
  function \u0275\u0275injectAttribute(attrNameToInject) {
    return injectAttributeImpl(getCurrentTNode(), attrNameToInject);
  }
  var ANNOTATIONS = "__annotations__";
  var PARAMETERS = "__parameters__";
  var PROP_METADATA = "__prop__metadata__";
  function makeDecorator(name, props, parentClass, additionalProcessing, typeFn) {
    return noSideEffects(() => {
      const metaCtor = makeMetadataCtor(props);
      function DecoratorFactory(...args) {
        if (this instanceof DecoratorFactory) {
          metaCtor.call(this, ...args);
          return this;
        }
        const annotationInstance = new DecoratorFactory(...args);
        return function TypeDecorator(cls) {
          if (typeFn)
            typeFn(cls, ...args);
          const annotations = cls.hasOwnProperty(ANNOTATIONS) ? cls[ANNOTATIONS] : Object.defineProperty(cls, ANNOTATIONS, { value: [] })[ANNOTATIONS];
          annotations.push(annotationInstance);
          if (additionalProcessing)
            additionalProcessing(cls);
          return cls;
        };
      }
      if (parentClass) {
        DecoratorFactory.prototype = Object.create(parentClass.prototype);
      }
      DecoratorFactory.prototype.ngMetadataName = name;
      DecoratorFactory.annotationCls = DecoratorFactory;
      return DecoratorFactory;
    });
  }
  function makeMetadataCtor(props) {
    return function ctor(...args) {
      if (props) {
        const values = props(...args);
        for (const propName in values) {
          this[propName] = values[propName];
        }
      }
    };
  }
  function makeParamDecorator(name, props, parentClass) {
    return noSideEffects(() => {
      const metaCtor = makeMetadataCtor(props);
      function ParamDecoratorFactory(...args) {
        if (this instanceof ParamDecoratorFactory) {
          metaCtor.apply(this, args);
          return this;
        }
        const annotationInstance = new ParamDecoratorFactory(...args);
        ParamDecorator.annotation = annotationInstance;
        return ParamDecorator;
        function ParamDecorator(cls, unusedKey, index) {
          const parameters = cls.hasOwnProperty(PARAMETERS) ? cls[PARAMETERS] : Object.defineProperty(cls, PARAMETERS, { value: [] })[PARAMETERS];
          while (parameters.length <= index) {
            parameters.push(null);
          }
          (parameters[index] = parameters[index] || []).push(annotationInstance);
          return cls;
        }
      }
      if (parentClass) {
        ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);
      }
      ParamDecoratorFactory.prototype.ngMetadataName = name;
      ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;
      return ParamDecoratorFactory;
    });
  }
  function makePropDecorator(name, props, parentClass, additionalProcessing) {
    return noSideEffects(() => {
      const metaCtor = makeMetadataCtor(props);
      function PropDecoratorFactory(...args) {
        if (this instanceof PropDecoratorFactory) {
          metaCtor.apply(this, args);
          return this;
        }
        const decoratorInstance = new PropDecoratorFactory(...args);
        function PropDecorator(target, name2) {
          const constructor = target.constructor;
          const meta = constructor.hasOwnProperty(PROP_METADATA) ? constructor[PROP_METADATA] : Object.defineProperty(constructor, PROP_METADATA, { value: {} })[PROP_METADATA];
          meta[name2] = meta.hasOwnProperty(name2) && meta[name2] || [];
          meta[name2].unshift(decoratorInstance);
          if (additionalProcessing)
            additionalProcessing(target, name2, ...args);
        }
        return PropDecorator;
      }
      if (parentClass) {
        PropDecoratorFactory.prototype = Object.create(parentClass.prototype);
      }
      PropDecoratorFactory.prototype.ngMetadataName = name;
      PropDecoratorFactory.annotationCls = PropDecoratorFactory;
      return PropDecoratorFactory;
    });
  }
  var Attribute = makeParamDecorator("Attribute", (attributeName) => ({ attributeName, __NG_ELEMENT_ID__: () => \u0275\u0275injectAttribute(attributeName) }));
  var InjectionToken = class {
    constructor(_desc, options) {
      this._desc = _desc;
      this.ngMetadataName = "InjectionToken";
      this.\u0275prov = void 0;
      if (typeof options == "number") {
        (typeof ngDevMode === "undefined" || ngDevMode) && assertLessThan(options, 0, "Only negative numbers are supported here");
        this.__NG_ELEMENT_ID__ = options;
      } else if (options !== void 0) {
        this.\u0275prov = \u0275\u0275defineInjectable({
          token: this,
          providedIn: options.providedIn || "root",
          factory: options.factory
        });
      }
    }
    toString() {
      return `InjectionToken ${this._desc}`;
    }
  };
  var ANALYZE_FOR_ENTRY_COMPONENTS = new InjectionToken("AnalyzeForEntryComponents");
  var emitDistinctChangesOnlyDefaultValue = true;
  var Query = class {
  };
  var ContentChildren = makePropDecorator("ContentChildren", (selector, data = {}) => ({
    selector,
    first: false,
    isViewQuery: false,
    descendants: false,
    emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue,
    ...data
  }), Query);
  var ContentChild = makePropDecorator("ContentChild", (selector, data = {}) => ({ selector, first: true, isViewQuery: false, descendants: true, ...data }), Query);
  var ViewChildren = makePropDecorator("ViewChildren", (selector, data = {}) => ({
    selector,
    first: false,
    isViewQuery: true,
    descendants: true,
    emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue,
    ...data
  }), Query);
  var ViewChild = makePropDecorator("ViewChild", (selector, data) => ({ selector, first: true, isViewQuery: true, descendants: true, ...data }), Query);
  var FactoryTarget;
  (function(FactoryTarget3) {
    FactoryTarget3[FactoryTarget3["Directive"] = 0] = "Directive";
    FactoryTarget3[FactoryTarget3["Component"] = 1] = "Component";
    FactoryTarget3[FactoryTarget3["Injectable"] = 2] = "Injectable";
    FactoryTarget3[FactoryTarget3["Pipe"] = 3] = "Pipe";
    FactoryTarget3[FactoryTarget3["NgModule"] = 4] = "NgModule";
  })(FactoryTarget || (FactoryTarget = {}));
  var ViewEncapsulation;
  (function(ViewEncapsulation3) {
    ViewEncapsulation3[ViewEncapsulation3["Emulated"] = 0] = "Emulated";
    ViewEncapsulation3[ViewEncapsulation3["None"] = 2] = "None";
    ViewEncapsulation3[ViewEncapsulation3["ShadowDom"] = 3] = "ShadowDom";
  })(ViewEncapsulation || (ViewEncapsulation = {}));
  function getCompilerFacade(request) {
    const globalNg = _global2["ng"];
    if (globalNg && globalNg.\u0275compilerFacade) {
      return globalNg.\u0275compilerFacade;
    }
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      console.error(`JIT compilation failed for ${request.kind}`, request.type);
      let message = `The ${request.kind} '${request.type.name}' needs to be compiled using the JIT compiler, but '@angular/compiler' is not available.

`;
      if (request.usage === 1) {
        message += `The ${request.kind} is part of a library that has been partially compiled.
`;
        message += `However, the Angular Linker has not processed the library such that JIT compilation is used as fallback.
`;
        message += "\n";
        message += `Ideally, the library is processed using the Angular Linker to become fully AOT compiled.
`;
      } else {
        message += `JIT compilation is discouraged for production use-cases! Consider using AOT mode instead.
`;
      }
      message += `Alternatively, the JIT compiler should be loaded by bootstrapping using '@angular/platform-browser-dynamic' or '@angular/platform-server',
`;
      message += `or manually provide the compiler with 'import "@angular/compiler";' before bootstrapping.`;
      throw new Error(message);
    } else {
      throw new Error("JIT compiler unavailable");
    }
  }
  var Type = Function;
  function isType(v) {
    return typeof v === "function";
  }
  function arrayEquals(a, b, identityAccessor) {
    if (a.length !== b.length)
      return false;
    for (let i = 0; i < a.length; i++) {
      let valueA = a[i];
      let valueB = b[i];
      if (identityAccessor) {
        valueA = identityAccessor(valueA);
        valueB = identityAccessor(valueB);
      }
      if (valueB !== valueA) {
        return false;
      }
    }
    return true;
  }
  function flatten(list, dst) {
    if (dst === void 0)
      dst = list;
    for (let i = 0; i < list.length; i++) {
      let item = list[i];
      if (Array.isArray(item)) {
        if (dst === list) {
          dst = list.slice(0, i);
        }
        flatten(item, dst);
      } else if (dst !== list) {
        dst.push(item);
      }
    }
    return dst;
  }
  function deepForEach(input, fn2) {
    input.forEach((value) => Array.isArray(value) ? deepForEach(value, fn2) : fn2(value));
  }
  function addToArray(arr, index, value) {
    if (index >= arr.length) {
      arr.push(value);
    } else {
      arr.splice(index, 0, value);
    }
  }
  function removeFromArray(arr, index) {
    if (index >= arr.length - 1) {
      return arr.pop();
    } else {
      return arr.splice(index, 1)[0];
    }
  }
  function newArray(size, value) {
    const list = [];
    for (let i = 0; i < size; i++) {
      list.push(value);
    }
    return list;
  }
  function arrayInsert2(array, index, value1, value2) {
    ngDevMode && assertLessThanOrEqual(index, array.length, "Can't insert past array end.");
    let end = array.length;
    if (end == index) {
      array.push(value1, value2);
    } else if (end === 1) {
      array.push(value2, array[0]);
      array[0] = value1;
    } else {
      end--;
      array.push(array[end - 1], array[end]);
      while (end > index) {
        const previousEnd = end - 2;
        array[end] = array[previousEnd];
        end--;
      }
      array[index] = value1;
      array[index + 1] = value2;
    }
  }
  function keyValueArraySet(keyValueArray, key, value) {
    let index = keyValueArrayIndexOf(keyValueArray, key);
    if (index >= 0) {
      keyValueArray[index | 1] = value;
    } else {
      index = ~index;
      arrayInsert2(keyValueArray, index, key, value);
    }
    return index;
  }
  function keyValueArrayGet(keyValueArray, key) {
    const index = keyValueArrayIndexOf(keyValueArray, key);
    if (index >= 0) {
      return keyValueArray[index | 1];
    }
    return void 0;
  }
  function keyValueArrayIndexOf(keyValueArray, key) {
    return _arrayIndexOfSorted(keyValueArray, key, 1);
  }
  function _arrayIndexOfSorted(array, value, shift) {
    ngDevMode && assertEqual(Array.isArray(array), true, "Expecting an array");
    let start = 0;
    let end = array.length >> shift;
    while (end !== start) {
      const middle = start + (end - start >> 1);
      const current = array[middle << shift];
      if (value === current) {
        return middle << shift;
      } else if (current > value) {
        end = middle;
      } else {
        start = middle + 1;
      }
    }
    return ~(end << shift);
  }
  var ES5_DELEGATE_CTOR = /^function\s+\S+\(\)\s*{[\s\S]+\.apply\(this,\s*(arguments|(?:[^()]+\(\[\],)?[^()]+\(arguments\).*)\)/;
  var ES2015_INHERITED_CLASS = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{/;
  var ES2015_INHERITED_CLASS_WITH_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(/;
  var ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(\)\s*{\s*super\(\.\.\.arguments\)/;
  function isDelegateCtor(typeStr) {
    return ES5_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS.test(typeStr) && !ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr);
  }
  var ReflectionCapabilities = class {
    constructor(reflect) {
      this._reflect = reflect || _global2["Reflect"];
    }
    isReflectionEnabled() {
      return true;
    }
    factory(t) {
      return (...args) => new t(...args);
    }
    _zipTypesAndAnnotations(paramTypes, paramAnnotations) {
      let result;
      if (typeof paramTypes === "undefined") {
        result = newArray(paramAnnotations.length);
      } else {
        result = newArray(paramTypes.length);
      }
      for (let i = 0; i < result.length; i++) {
        if (typeof paramTypes === "undefined") {
          result[i] = [];
        } else if (paramTypes[i] && paramTypes[i] != Object) {
          result[i] = [paramTypes[i]];
        } else {
          result[i] = [];
        }
        if (paramAnnotations && paramAnnotations[i] != null) {
          result[i] = result[i].concat(paramAnnotations[i]);
        }
      }
      return result;
    }
    _ownParameters(type, parentCtor) {
      const typeStr = type.toString();
      if (isDelegateCtor(typeStr)) {
        return null;
      }
      if (type.parameters && type.parameters !== parentCtor.parameters) {
        return type.parameters;
      }
      const tsickleCtorParams = type.ctorParameters;
      if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {
        const ctorParameters = typeof tsickleCtorParams === "function" ? tsickleCtorParams() : tsickleCtorParams;
        const paramTypes2 = ctorParameters.map((ctorParam) => ctorParam && ctorParam.type);
        const paramAnnotations2 = ctorParameters.map((ctorParam) => ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));
        return this._zipTypesAndAnnotations(paramTypes2, paramAnnotations2);
      }
      const paramAnnotations = type.hasOwnProperty(PARAMETERS) && type[PARAMETERS];
      const paramTypes = this._reflect && this._reflect.getOwnMetadata && this._reflect.getOwnMetadata("design:paramtypes", type);
      if (paramTypes || paramAnnotations) {
        return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
      }
      return newArray(type.length);
    }
    parameters(type) {
      if (!isType(type)) {
        return [];
      }
      const parentCtor = getParentCtor(type);
      let parameters = this._ownParameters(type, parentCtor);
      if (!parameters && parentCtor !== Object) {
        parameters = this.parameters(parentCtor);
      }
      return parameters || [];
    }
    _ownAnnotations(typeOrFunc, parentCtor) {
      if (typeOrFunc.annotations && typeOrFunc.annotations !== parentCtor.annotations) {
        let annotations = typeOrFunc.annotations;
        if (typeof annotations === "function" && annotations.annotations) {
          annotations = annotations.annotations;
        }
        return annotations;
      }
      if (typeOrFunc.decorators && typeOrFunc.decorators !== parentCtor.decorators) {
        return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);
      }
      if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {
        return typeOrFunc[ANNOTATIONS];
      }
      return null;
    }
    annotations(typeOrFunc) {
      if (!isType(typeOrFunc)) {
        return [];
      }
      const parentCtor = getParentCtor(typeOrFunc);
      const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];
      const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];
      return parentAnnotations.concat(ownAnnotations);
    }
    _ownPropMetadata(typeOrFunc, parentCtor) {
      if (typeOrFunc.propMetadata && typeOrFunc.propMetadata !== parentCtor.propMetadata) {
        let propMetadata = typeOrFunc.propMetadata;
        if (typeof propMetadata === "function" && propMetadata.propMetadata) {
          propMetadata = propMetadata.propMetadata;
        }
        return propMetadata;
      }
      if (typeOrFunc.propDecorators && typeOrFunc.propDecorators !== parentCtor.propDecorators) {
        const propDecorators = typeOrFunc.propDecorators;
        const propMetadata = {};
        Object.keys(propDecorators).forEach((prop) => {
          propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);
        });
        return propMetadata;
      }
      if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {
        return typeOrFunc[PROP_METADATA];
      }
      return null;
    }
    propMetadata(typeOrFunc) {
      if (!isType(typeOrFunc)) {
        return {};
      }
      const parentCtor = getParentCtor(typeOrFunc);
      const propMetadata = {};
      if (parentCtor !== Object) {
        const parentPropMetadata = this.propMetadata(parentCtor);
        Object.keys(parentPropMetadata).forEach((propName) => {
          propMetadata[propName] = parentPropMetadata[propName];
        });
      }
      const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);
      if (ownPropMetadata) {
        Object.keys(ownPropMetadata).forEach((propName) => {
          const decorators = [];
          if (propMetadata.hasOwnProperty(propName)) {
            decorators.push(...propMetadata[propName]);
          }
          decorators.push(...ownPropMetadata[propName]);
          propMetadata[propName] = decorators;
        });
      }
      return propMetadata;
    }
    ownPropMetadata(typeOrFunc) {
      if (!isType(typeOrFunc)) {
        return {};
      }
      return this._ownPropMetadata(typeOrFunc, getParentCtor(typeOrFunc)) || {};
    }
    hasLifecycleHook(type, lcProperty) {
      return type instanceof Type && lcProperty in type.prototype;
    }
    guards(type) {
      return {};
    }
    getter(name) {
      return new Function("o", "return o." + name + ";");
    }
    setter(name) {
      return new Function("o", "v", "return o." + name + " = v;");
    }
    method(name) {
      const functionBody = `if (!o.${name}) throw new Error('"${name}" is undefined');
        return o.${name}.apply(o, args);`;
      return new Function("o", "args", functionBody);
    }
    importUri(type) {
      if (typeof type === "object" && type["filePath"]) {
        return type["filePath"];
      }
      return `./${stringify(type)}`;
    }
    resourceUri(type) {
      return `./${stringify(type)}`;
    }
    resolveIdentifier(name, moduleUrl, members, runtime) {
      return runtime;
    }
    resolveEnum(enumIdentifier, name) {
      return enumIdentifier[name];
    }
  };
  function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
    if (!decoratorInvocations) {
      return [];
    }
    return decoratorInvocations.map((decoratorInvocation) => {
      const decoratorType = decoratorInvocation.type;
      const annotationCls = decoratorType.annotationCls;
      const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];
      return new annotationCls(...annotationArgs);
    });
  }
  function getParentCtor(ctor) {
    const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;
    const parentCtor = parentProto ? parentProto.constructor : null;
    return parentCtor || Object;
  }
  var _THROW_IF_NOT_FOUND = {};
  var THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
  var DI_DECORATOR_FLAG = "__NG_DI_FLAG__";
  var NG_TEMP_TOKEN_PATH = "ngTempTokenPath";
  var NG_TOKEN_PATH = "ngTokenPath";
  var NEW_LINE = /\n/gm;
  var NO_NEW_LINE = "\u0275";
  var SOURCE = "__source";
  var USE_VALUE$1 = getClosureSafeProperty({ provide: String, useValue: getClosureSafeProperty });
  var _currentInjector = void 0;
  function setCurrentInjector(injector) {
    const former = _currentInjector;
    _currentInjector = injector;
    return former;
  }
  function injectInjectorOnly(token, flags = InjectFlags.Default) {
    if (_currentInjector === void 0) {
      throw new Error(`inject() must be called from an injection context`);
    } else if (_currentInjector === null) {
      return injectRootLimpMode(token, void 0, flags);
    } else {
      return _currentInjector.get(token, flags & InjectFlags.Optional ? null : void 0, flags);
    }
  }
  function \u0275\u0275inject(token, flags = InjectFlags.Default) {
    return (getInjectImplementation() || injectInjectorOnly)(resolveForwardRef(token), flags);
  }
  function \u0275\u0275invalidFactoryDep(index) {
    const msg = ngDevMode ? `This constructor is not compatible with Angular Dependency Injection because its dependency at index ${index} of the parameter list is invalid.
This can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.

Please check that 1) the type for the parameter at index ${index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.` : "invalid";
    throw new Error(msg);
  }
  var inject = \u0275\u0275inject;
  function injectArgs(types) {
    const args = [];
    for (let i = 0; i < types.length; i++) {
      const arg = resolveForwardRef(types[i]);
      if (Array.isArray(arg)) {
        if (arg.length === 0) {
          throw new Error("Arguments array must have arguments.");
        }
        let type = void 0;
        let flags = InjectFlags.Default;
        for (let j = 0; j < arg.length; j++) {
          const meta = arg[j];
          const flag = getInjectFlag(meta);
          if (typeof flag === "number") {
            if (flag === -1) {
              type = meta.token;
            } else {
              flags |= flag;
            }
          } else {
            type = meta;
          }
        }
        args.push(\u0275\u0275inject(type, flags));
      } else {
        args.push(\u0275\u0275inject(arg));
      }
    }
    return args;
  }
  function attachInjectFlag(decorator, flag) {
    decorator[DI_DECORATOR_FLAG] = flag;
    decorator.prototype[DI_DECORATOR_FLAG] = flag;
    return decorator;
  }
  function getInjectFlag(token) {
    return token[DI_DECORATOR_FLAG];
  }
  function catchInjectorError(e, token, injectorErrorName, source) {
    const tokenPath = e[NG_TEMP_TOKEN_PATH];
    if (token[SOURCE]) {
      tokenPath.unshift(token[SOURCE]);
    }
    e.message = formatError("\n" + e.message, tokenPath, injectorErrorName, source);
    e[NG_TOKEN_PATH] = tokenPath;
    e[NG_TEMP_TOKEN_PATH] = null;
    throw e;
  }
  function formatError(text, obj, injectorErrorName, source = null) {
    text = text && text.charAt(0) === "\n" && text.charAt(1) == NO_NEW_LINE ? text.substr(2) : text;
    let context2 = stringify(obj);
    if (Array.isArray(obj)) {
      context2 = obj.map(stringify).join(" -> ");
    } else if (typeof obj === "object") {
      let parts = [];
      for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
          let value = obj[key];
          parts.push(key + ":" + (typeof value === "string" ? JSON.stringify(value) : stringify(value)));
        }
      }
      context2 = `{${parts.join(", ")}}`;
    }
    return `${injectorErrorName}${source ? "(" + source + ")" : ""}[${context2}]: ${text.replace(NEW_LINE, "\n  ")}`;
  }
  var Inject = attachInjectFlag(makeParamDecorator("Inject", (token) => ({ token })), -1);
  var Optional = attachInjectFlag(makeParamDecorator("Optional"), 8);
  var Self = attachInjectFlag(makeParamDecorator("Self"), 2);
  var SkipSelf = attachInjectFlag(makeParamDecorator("SkipSelf"), 4);
  var Host = attachInjectFlag(makeParamDecorator("Host"), 1);
  var _reflect = null;
  function getReflect() {
    return _reflect = _reflect || new ReflectionCapabilities();
  }
  function reflectDependencies(type) {
    return convertDependencies(getReflect().parameters(type));
  }
  function convertDependencies(deps) {
    return deps.map((dep) => reflectDependency(dep));
  }
  function reflectDependency(dep) {
    const meta = {
      token: null,
      attribute: null,
      host: false,
      optional: false,
      self: false,
      skipSelf: false
    };
    if (Array.isArray(dep) && dep.length > 0) {
      for (let j = 0; j < dep.length; j++) {
        const param = dep[j];
        if (param === void 0) {
          continue;
        }
        const proto = Object.getPrototypeOf(param);
        if (param instanceof Optional || proto.ngMetadataName === "Optional") {
          meta.optional = true;
        } else if (param instanceof SkipSelf || proto.ngMetadataName === "SkipSelf") {
          meta.skipSelf = true;
        } else if (param instanceof Self || proto.ngMetadataName === "Self") {
          meta.self = true;
        } else if (param instanceof Host || proto.ngMetadataName === "Host") {
          meta.host = true;
        } else if (param instanceof Inject) {
          meta.token = param.token;
        } else if (param instanceof Attribute) {
          if (param.attributeName === void 0) {
            throw new Error(`Attribute name must be defined.`);
          }
          meta.attribute = param.attributeName;
        } else {
          meta.token = param;
        }
      }
    } else if (dep === void 0 || Array.isArray(dep) && dep.length === 0) {
      meta.token = null;
    } else {
      meta.token = dep;
    }
    return meta;
  }
  function resolveComponentResources(resourceResolver) {
    const componentResolved = [];
    const urlMap = /* @__PURE__ */ new Map();
    function cachedResourceResolve(url) {
      let promise2 = urlMap.get(url);
      if (!promise2) {
        const resp = resourceResolver(url);
        urlMap.set(url, promise2 = resp.then(unwrapResponse));
      }
      return promise2;
    }
    componentResourceResolutionQueue.forEach((component, type) => {
      const promises = [];
      if (component.templateUrl) {
        promises.push(cachedResourceResolve(component.templateUrl).then((template) => {
          component.template = template;
        }));
      }
      const styleUrls = component.styleUrls;
      const styles = component.styles || (component.styles = []);
      const styleOffset = component.styles.length;
      styleUrls && styleUrls.forEach((styleUrl, index) => {
        styles.push("");
        promises.push(cachedResourceResolve(styleUrl).then((style) => {
          styles[styleOffset + index] = style;
          styleUrls.splice(styleUrls.indexOf(styleUrl), 1);
          if (styleUrls.length == 0) {
            component.styleUrls = void 0;
          }
        }));
      });
      const fullyResolved = Promise.all(promises).then(() => componentDefResolved(type));
      componentResolved.push(fullyResolved);
    });
    clearResolutionOfComponentResourcesQueue();
    return Promise.all(componentResolved).then(() => void 0);
  }
  var componentResourceResolutionQueue = /* @__PURE__ */ new Map();
  var componentDefPendingResolution = /* @__PURE__ */ new Set();
  function maybeQueueResolutionOfComponentResources(type, metadata) {
    if (componentNeedsResolution(metadata)) {
      componentResourceResolutionQueue.set(type, metadata);
      componentDefPendingResolution.add(type);
    }
  }
  function componentNeedsResolution(component) {
    return !!(component.templateUrl && !component.hasOwnProperty("template") || component.styleUrls && component.styleUrls.length);
  }
  function clearResolutionOfComponentResourcesQueue() {
    const old = componentResourceResolutionQueue;
    componentResourceResolutionQueue = /* @__PURE__ */ new Map();
    return old;
  }
  function isComponentResourceResolutionQueueEmpty() {
    return componentResourceResolutionQueue.size === 0;
  }
  function unwrapResponse(response) {
    return typeof response == "string" ? response : response.text();
  }
  function componentDefResolved(type) {
    componentDefPendingResolution.delete(type);
  }
  var policy$1;
  function getPolicy$1() {
    if (policy$1 === void 0) {
      policy$1 = null;
      if (_global2.trustedTypes) {
        try {
          policy$1 = _global2.trustedTypes.createPolicy("angular", {
            createHTML: (s) => s,
            createScript: (s) => s,
            createScriptURL: (s) => s
          });
        } catch {
        }
      }
    }
    return policy$1;
  }
  function trustedHTMLFromString(html) {
    return getPolicy$1()?.createHTML(html) || html;
  }
  function trustedScriptFromString(script) {
    return getPolicy$1()?.createScript(script) || script;
  }
  function trustedScriptURLFromString(url) {
    return getPolicy$1()?.createScriptURL(url) || url;
  }
  function newTrustedFunctionForDev(...args) {
    if (typeof ngDevMode === "undefined") {
      throw new Error("newTrustedFunctionForDev should never be called in production");
    }
    if (!_global2.trustedTypes) {
      return new Function(...args);
    }
    const fnArgs = args.slice(0, -1).join(",");
    const fnBody = args[args.length - 1];
    const body = `(function anonymous(${fnArgs}
) { ${fnBody}
})`;
    const fn2 = _global2["eval"](trustedScriptFromString(body));
    if (fn2.bind === void 0) {
      return new Function(...args);
    }
    fn2.toString = () => body;
    return fn2.bind(_global2);
  }
  var policy;
  function getPolicy() {
    if (policy === void 0) {
      policy = null;
      if (_global2.trustedTypes) {
        try {
          policy = _global2.trustedTypes.createPolicy("angular#unsafe-bypass", {
            createHTML: (s) => s,
            createScript: (s) => s,
            createScriptURL: (s) => s
          });
        } catch {
        }
      }
    }
    return policy;
  }
  function trustedHTMLFromStringBypass(html) {
    return getPolicy()?.createHTML(html) || html;
  }
  function trustedScriptFromStringBypass(script) {
    return getPolicy()?.createScript(script) || script;
  }
  function trustedScriptURLFromStringBypass(url) {
    return getPolicy()?.createScriptURL(url) || url;
  }
  var SafeValueImpl = class {
    constructor(changingThisBreaksApplicationSecurity) {
      this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
    }
    toString() {
      return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`;
    }
  };
  var SafeHtmlImpl = class extends SafeValueImpl {
    getTypeName() {
      return "HTML";
    }
  };
  var SafeStyleImpl = class extends SafeValueImpl {
    getTypeName() {
      return "Style";
    }
  };
  var SafeScriptImpl = class extends SafeValueImpl {
    getTypeName() {
      return "Script";
    }
  };
  var SafeUrlImpl = class extends SafeValueImpl {
    getTypeName() {
      return "URL";
    }
  };
  var SafeResourceUrlImpl = class extends SafeValueImpl {
    getTypeName() {
      return "ResourceURL";
    }
  };
  function unwrapSafeValue(value) {
    return value instanceof SafeValueImpl ? value.changingThisBreaksApplicationSecurity : value;
  }
  function allowSanitizationBypassAndThrow(value, type) {
    const actualType = getSanitizationBypassType(value);
    if (actualType != null && actualType !== type) {
      if (actualType === "ResourceURL" && type === "URL")
        return true;
      throw new Error(`Required a safe ${type}, got a ${actualType} (see https://g.co/ng/security#xss)`);
    }
    return actualType === type;
  }
  function getSanitizationBypassType(value) {
    return value instanceof SafeValueImpl && value.getTypeName() || null;
  }
  function bypassSanitizationTrustHtml(trustedHtml) {
    return new SafeHtmlImpl(trustedHtml);
  }
  function bypassSanitizationTrustStyle(trustedStyle) {
    return new SafeStyleImpl(trustedStyle);
  }
  function bypassSanitizationTrustScript(trustedScript) {
    return new SafeScriptImpl(trustedScript);
  }
  function bypassSanitizationTrustUrl(trustedUrl) {
    return new SafeUrlImpl(trustedUrl);
  }
  function bypassSanitizationTrustResourceUrl(trustedResourceUrl) {
    return new SafeResourceUrlImpl(trustedResourceUrl);
  }
  function getInertBodyHelper(defaultDoc) {
    const inertDocumentHelper = new InertDocumentHelper(defaultDoc);
    return isDOMParserAvailable() ? new DOMParserHelper(inertDocumentHelper) : inertDocumentHelper;
  }
  var DOMParserHelper = class {
    constructor(inertDocumentHelper) {
      this.inertDocumentHelper = inertDocumentHelper;
    }
    getInertBodyElement(html) {
      html = "<body><remove></remove>" + html;
      try {
        const body = new window.DOMParser().parseFromString(trustedHTMLFromString(html), "text/html").body;
        if (body === null) {
          return this.inertDocumentHelper.getInertBodyElement(html);
        }
        body.removeChild(body.firstChild);
        return body;
      } catch {
        return null;
      }
    }
  };
  var InertDocumentHelper = class {
    constructor(defaultDoc) {
      this.defaultDoc = defaultDoc;
      this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert");
      if (this.inertDocument.body == null) {
        const inertHtml = this.inertDocument.createElement("html");
        this.inertDocument.appendChild(inertHtml);
        const inertBodyElement = this.inertDocument.createElement("body");
        inertHtml.appendChild(inertBodyElement);
      }
    }
    getInertBodyElement(html) {
      const templateEl = this.inertDocument.createElement("template");
      if ("content" in templateEl) {
        templateEl.innerHTML = trustedHTMLFromString(html);
        return templateEl;
      }
      const inertBody = this.inertDocument.createElement("body");
      inertBody.innerHTML = trustedHTMLFromString(html);
      if (this.defaultDoc.documentMode) {
        this.stripCustomNsAttrs(inertBody);
      }
      return inertBody;
    }
    stripCustomNsAttrs(el) {
      const elAttrs = el.attributes;
      for (let i = elAttrs.length - 1; 0 < i; i--) {
        const attrib = elAttrs.item(i);
        const attrName = attrib.name;
        if (attrName === "xmlns:ns1" || attrName.indexOf("ns1:") === 0) {
          el.removeAttribute(attrName);
        }
      }
      let childNode = el.firstChild;
      while (childNode) {
        if (childNode.nodeType === Node.ELEMENT_NODE)
          this.stripCustomNsAttrs(childNode);
        childNode = childNode.nextSibling;
      }
    }
  };
  function isDOMParserAvailable() {
    try {
      return !!new window.DOMParser().parseFromString(trustedHTMLFromString(""), "text/html");
    } catch {
      return false;
    }
  }
  var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi;
  var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;
  function _sanitizeUrl(url) {
    url = String(url);
    if (url.match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN))
      return url;
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      console.warn(`WARNING: sanitizing unsafe URL value ${url} (see https://g.co/ng/security#xss)`);
    }
    return "unsafe:" + url;
  }
  function sanitizeSrcset(srcset) {
    srcset = String(srcset);
    return srcset.split(",").map((srcset2) => _sanitizeUrl(srcset2.trim())).join(", ");
  }
  function tagSet(tags) {
    const res = {};
    for (const t of tags.split(","))
      res[t] = true;
    return res;
  }
  function merge2(...sets) {
    const res = {};
    for (const s of sets) {
      for (const v in s) {
        if (s.hasOwnProperty(v))
          res[v] = true;
      }
    }
    return res;
  }
  var VOID_ELEMENTS = tagSet("area,br,col,hr,img,wbr");
  var OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr");
  var OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet("rp,rt");
  var OPTIONAL_END_TAG_ELEMENTS = merge2(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);
  var BLOCK_ELEMENTS = merge2(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul"));
  var INLINE_ELEMENTS = merge2(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video"));
  var VALID_ELEMENTS = merge2(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);
  var URI_ATTRS = tagSet("background,cite,href,itemtype,longdesc,poster,src,xlink:href");
  var SRCSET_ATTRS = tagSet("srcset");
  var HTML_ATTRS = tagSet("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width");
  var ARIA_ATTRS = tagSet("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext");
  var VALID_ATTRS = merge2(URI_ATTRS, SRCSET_ATTRS, HTML_ATTRS, ARIA_ATTRS);
  var SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet("script,style,template");
  var SanitizingHtmlSerializer = class {
    constructor() {
      this.sanitizedSomething = false;
      this.buf = [];
    }
    sanitizeChildren(el) {
      let current = el.firstChild;
      let traverseContent = true;
      while (current) {
        if (current.nodeType === Node.ELEMENT_NODE) {
          traverseContent = this.startElement(current);
        } else if (current.nodeType === Node.TEXT_NODE) {
          this.chars(current.nodeValue);
        } else {
          this.sanitizedSomething = true;
        }
        if (traverseContent && current.firstChild) {
          current = current.firstChild;
          continue;
        }
        while (current) {
          if (current.nodeType === Node.ELEMENT_NODE) {
            this.endElement(current);
          }
          let next = this.checkClobberedElement(current, current.nextSibling);
          if (next) {
            current = next;
            break;
          }
          current = this.checkClobberedElement(current, current.parentNode);
        }
      }
      return this.buf.join("");
    }
    startElement(element) {
      const tagName = element.nodeName.toLowerCase();
      if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {
        this.sanitizedSomething = true;
        return !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);
      }
      this.buf.push("<");
      this.buf.push(tagName);
      const elAttrs = element.attributes;
      for (let i = 0; i < elAttrs.length; i++) {
        const elAttr = elAttrs.item(i);
        const attrName = elAttr.name;
        const lower = attrName.toLowerCase();
        if (!VALID_ATTRS.hasOwnProperty(lower)) {
          this.sanitizedSomething = true;
          continue;
        }
        let value = elAttr.value;
        if (URI_ATTRS[lower])
          value = _sanitizeUrl(value);
        if (SRCSET_ATTRS[lower])
          value = sanitizeSrcset(value);
        this.buf.push(" ", attrName, '="', encodeEntities(value), '"');
      }
      this.buf.push(">");
      return true;
    }
    endElement(current) {
      const tagName = current.nodeName.toLowerCase();
      if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {
        this.buf.push("</");
        this.buf.push(tagName);
        this.buf.push(">");
      }
    }
    chars(chars) {
      this.buf.push(encodeEntities(chars));
    }
    checkClobberedElement(node, nextNode) {
      if (nextNode && (node.compareDocumentPosition(nextNode) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) {
        throw new Error(`Failed to sanitize html because the element is clobbered: ${node.outerHTML}`);
      }
      return nextNode;
    }
  };
  var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
  function encodeEntities(value) {
    return value.replace(/&/g, "&amp;").replace(SURROGATE_PAIR_REGEXP, function(match2) {
      const hi = match2.charCodeAt(0);
      const low = match2.charCodeAt(1);
      return "&#" + ((hi - 55296) * 1024 + (low - 56320) + 65536) + ";";
    }).replace(NON_ALPHANUMERIC_REGEXP, function(match2) {
      return "&#" + match2.charCodeAt(0) + ";";
    }).replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }
  var inertBodyHelper;
  function _sanitizeHtml(defaultDoc, unsafeHtmlInput) {
    let inertBodyElement = null;
    try {
      inertBodyHelper = inertBodyHelper || getInertBodyHelper(defaultDoc);
      let unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : "";
      inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
      let mXSSAttempts = 5;
      let parsedHtml = unsafeHtml;
      do {
        if (mXSSAttempts === 0) {
          throw new Error("Failed to sanitize html because the input is unstable");
        }
        mXSSAttempts--;
        unsafeHtml = parsedHtml;
        parsedHtml = inertBodyElement.innerHTML;
        inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
      } while (unsafeHtml !== parsedHtml);
      const sanitizer = new SanitizingHtmlSerializer();
      const safeHtml = sanitizer.sanitizeChildren(getTemplateContent(inertBodyElement) || inertBodyElement);
      if ((typeof ngDevMode === "undefined" || ngDevMode) && sanitizer.sanitizedSomething) {
        console.warn("WARNING: sanitizing HTML stripped some content, see https://g.co/ng/security#xss");
      }
      return trustedHTMLFromString(safeHtml);
    } finally {
      if (inertBodyElement) {
        const parent = getTemplateContent(inertBodyElement) || inertBodyElement;
        while (parent.firstChild) {
          parent.removeChild(parent.firstChild);
        }
      }
    }
  }
  function getTemplateContent(el) {
    return "content" in el && isTemplateElement(el) ? el.content : null;
  }
  function isTemplateElement(el) {
    return el.nodeType === Node.ELEMENT_NODE && el.nodeName === "TEMPLATE";
  }
  var SecurityContext;
  (function(SecurityContext3) {
    SecurityContext3[SecurityContext3["NONE"] = 0] = "NONE";
    SecurityContext3[SecurityContext3["HTML"] = 1] = "HTML";
    SecurityContext3[SecurityContext3["STYLE"] = 2] = "STYLE";
    SecurityContext3[SecurityContext3["SCRIPT"] = 3] = "SCRIPT";
    SecurityContext3[SecurityContext3["URL"] = 4] = "URL";
    SecurityContext3[SecurityContext3["RESOURCE_URL"] = 5] = "RESOURCE_URL";
  })(SecurityContext || (SecurityContext = {}));
  function \u0275\u0275sanitizeHtml(unsafeHtml) {
    const sanitizer = getSanitizer();
    if (sanitizer) {
      return trustedHTMLFromStringBypass(sanitizer.sanitize(SecurityContext.HTML, unsafeHtml) || "");
    }
    if (allowSanitizationBypassAndThrow(unsafeHtml, "HTML")) {
      return trustedHTMLFromStringBypass(unwrapSafeValue(unsafeHtml));
    }
    return _sanitizeHtml(getDocument(), renderStringify(unsafeHtml));
  }
  function \u0275\u0275sanitizeStyle(unsafeStyle) {
    const sanitizer = getSanitizer();
    if (sanitizer) {
      return sanitizer.sanitize(SecurityContext.STYLE, unsafeStyle) || "";
    }
    if (allowSanitizationBypassAndThrow(unsafeStyle, "Style")) {
      return unwrapSafeValue(unsafeStyle);
    }
    return renderStringify(unsafeStyle);
  }
  function \u0275\u0275sanitizeUrl(unsafeUrl) {
    const sanitizer = getSanitizer();
    if (sanitizer) {
      return sanitizer.sanitize(SecurityContext.URL, unsafeUrl) || "";
    }
    if (allowSanitizationBypassAndThrow(unsafeUrl, "URL")) {
      return unwrapSafeValue(unsafeUrl);
    }
    return _sanitizeUrl(renderStringify(unsafeUrl));
  }
  function \u0275\u0275sanitizeResourceUrl(unsafeResourceUrl) {
    const sanitizer = getSanitizer();
    if (sanitizer) {
      return trustedScriptURLFromStringBypass(sanitizer.sanitize(SecurityContext.RESOURCE_URL, unsafeResourceUrl) || "");
    }
    if (allowSanitizationBypassAndThrow(unsafeResourceUrl, "ResourceURL")) {
      return trustedScriptURLFromStringBypass(unwrapSafeValue(unsafeResourceUrl));
    }
    throw new Error("unsafe value used in a resource URL context (see https://g.co/ng/security#xss)");
  }
  function \u0275\u0275sanitizeScript(unsafeScript) {
    const sanitizer = getSanitizer();
    if (sanitizer) {
      return trustedScriptFromStringBypass(sanitizer.sanitize(SecurityContext.SCRIPT, unsafeScript) || "");
    }
    if (allowSanitizationBypassAndThrow(unsafeScript, "Script")) {
      return trustedScriptFromStringBypass(unwrapSafeValue(unsafeScript));
    }
    throw new Error("unsafe value used in a script context");
  }
  function \u0275\u0275trustConstantHtml(html) {
    if (ngDevMode && (!Array.isArray(html) || !Array.isArray(html.raw) || html.length !== 1)) {
      throw new Error(`Unexpected interpolation in trusted HTML constant: ${html.join("?")}`);
    }
    return trustedHTMLFromString(html[0]);
  }
  function \u0275\u0275trustConstantResourceUrl(url) {
    if (ngDevMode && (!Array.isArray(url) || !Array.isArray(url.raw) || url.length !== 1)) {
      throw new Error(`Unexpected interpolation in trusted URL constant: ${url.join("?")}`);
    }
    return trustedScriptURLFromString(url[0]);
  }
  function getUrlSanitizer(tag, prop) {
    if (prop === "src" && (tag === "embed" || tag === "frame" || tag === "iframe" || tag === "media" || tag === "script") || prop === "href" && (tag === "base" || tag === "link")) {
      return \u0275\u0275sanitizeResourceUrl;
    }
    return \u0275\u0275sanitizeUrl;
  }
  function \u0275\u0275sanitizeUrlOrResourceUrl(unsafeUrl, tag, prop) {
    return getUrlSanitizer(tag, prop)(unsafeUrl);
  }
  function validateAgainstEventProperties(name) {
    if (name.toLowerCase().startsWith("on")) {
      const msg = `Binding to event property '${name}' is disallowed for security reasons, please use (${name.slice(2)})=...
If '${name}' is a directive input, make sure the directive is imported by the current module.`;
      throw new Error(msg);
    }
  }
  function validateAgainstEventAttributes(name) {
    if (name.toLowerCase().startsWith("on")) {
      const msg = `Binding to event attribute '${name}' is disallowed for security reasons, please use (${name.slice(2)})=...`;
      throw new Error(msg);
    }
  }
  function getSanitizer() {
    const lView = getLView();
    return lView && lView[SANITIZER];
  }
  function getLContext(target) {
    let mpValue = readPatchedData(target);
    if (mpValue) {
      if (Array.isArray(mpValue)) {
        const lView = mpValue;
        let nodeIndex;
        let component = void 0;
        let directives = void 0;
        if (isComponentInstance(target)) {
          nodeIndex = findViaComponent(lView, target);
          if (nodeIndex == -1) {
            throw new Error("The provided component was not found in the application");
          }
          component = target;
        } else if (isDirectiveInstance(target)) {
          nodeIndex = findViaDirective(lView, target);
          if (nodeIndex == -1) {
            throw new Error("The provided directive was not found in the application");
          }
          directives = getDirectivesAtNodeIndex(nodeIndex, lView, false);
        } else {
          nodeIndex = findViaNativeElement(lView, target);
          if (nodeIndex == -1) {
            return null;
          }
        }
        const native = unwrapRNode(lView[nodeIndex]);
        const existingCtx = readPatchedData(native);
        const context2 = existingCtx && !Array.isArray(existingCtx) ? existingCtx : createLContext(lView, nodeIndex, native);
        if (component && context2.component === void 0) {
          context2.component = component;
          attachPatchData(context2.component, context2);
        }
        if (directives && context2.directives === void 0) {
          context2.directives = directives;
          for (let i = 0; i < directives.length; i++) {
            attachPatchData(directives[i], context2);
          }
        }
        attachPatchData(context2.native, context2);
        mpValue = context2;
      }
    } else {
      const rElement = target;
      ngDevMode && assertDomNode(rElement);
      let parent = rElement;
      while (parent = parent.parentNode) {
        const parentContext = readPatchedData(parent);
        if (parentContext) {
          let lView;
          if (Array.isArray(parentContext)) {
            lView = parentContext;
          } else {
            lView = parentContext.lView;
          }
          if (!lView) {
            return null;
          }
          const index = findViaNativeElement(lView, rElement);
          if (index >= 0) {
            const native = unwrapRNode(lView[index]);
            const context2 = createLContext(lView, index, native);
            attachPatchData(native, context2);
            mpValue = context2;
            break;
          }
        }
      }
    }
    return mpValue || null;
  }
  function createLContext(lView, nodeIndex, native) {
    return {
      lView,
      nodeIndex,
      native,
      component: void 0,
      directives: void 0,
      localRefs: void 0
    };
  }
  function getComponentViewByInstance(componentInstance) {
    let lView = readPatchedData(componentInstance);
    let view;
    if (Array.isArray(lView)) {
      const nodeIndex = findViaComponent(lView, componentInstance);
      view = getComponentLViewByIndex(nodeIndex, lView);
      const context2 = createLContext(lView, nodeIndex, view[HOST]);
      context2.component = componentInstance;
      attachPatchData(componentInstance, context2);
      attachPatchData(context2.native, context2);
    } else {
      const context2 = lView;
      view = getComponentLViewByIndex(context2.nodeIndex, context2.lView);
    }
    return view;
  }
  var MONKEY_PATCH_KEY_NAME = "__ngContext__";
  function attachPatchData(target, data) {
    ngDevMode && assertDefined(target, "Target expected");
    target[MONKEY_PATCH_KEY_NAME] = data;
  }
  function readPatchedData(target) {
    ngDevMode && assertDefined(target, "Target expected");
    return target[MONKEY_PATCH_KEY_NAME] || null;
  }
  function readPatchedLView(target) {
    const value = readPatchedData(target);
    if (value) {
      return Array.isArray(value) ? value : value.lView;
    }
    return null;
  }
  function isComponentInstance(instance) {
    return instance && instance.constructor && instance.constructor.\u0275cmp;
  }
  function isDirectiveInstance(instance) {
    return instance && instance.constructor && instance.constructor.\u0275dir;
  }
  function findViaNativeElement(lView, target) {
    const tView = lView[TVIEW];
    for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {
      if (unwrapRNode(lView[i]) === target) {
        return i;
      }
    }
    return -1;
  }
  function traverseNextElement(tNode) {
    if (tNode.child) {
      return tNode.child;
    } else if (tNode.next) {
      return tNode.next;
    } else {
      while (tNode.parent && !tNode.parent.next) {
        tNode = tNode.parent;
      }
      return tNode.parent && tNode.parent.next;
    }
  }
  function findViaComponent(lView, componentInstance) {
    const componentIndices = lView[TVIEW].components;
    if (componentIndices) {
      for (let i = 0; i < componentIndices.length; i++) {
        const elementComponentIndex = componentIndices[i];
        const componentView = getComponentLViewByIndex(elementComponentIndex, lView);
        if (componentView[CONTEXT] === componentInstance) {
          return elementComponentIndex;
        }
      }
    } else {
      const rootComponentView = getComponentLViewByIndex(HEADER_OFFSET, lView);
      const rootComponent = rootComponentView[CONTEXT];
      if (rootComponent === componentInstance) {
        return HEADER_OFFSET;
      }
    }
    return -1;
  }
  function findViaDirective(lView, directiveInstance) {
    let tNode = lView[TVIEW].firstChild;
    while (tNode) {
      const directiveIndexStart = tNode.directiveStart;
      const directiveIndexEnd = tNode.directiveEnd;
      for (let i = directiveIndexStart; i < directiveIndexEnd; i++) {
        if (lView[i] === directiveInstance) {
          return tNode.index;
        }
      }
      tNode = traverseNextElement(tNode);
    }
    return -1;
  }
  function getDirectivesAtNodeIndex(nodeIndex, lView, includeComponents) {
    const tNode = lView[TVIEW].data[nodeIndex];
    let directiveStartIndex = tNode.directiveStart;
    if (directiveStartIndex == 0)
      return EMPTY_ARRAY;
    const directiveEndIndex = tNode.directiveEnd;
    if (!includeComponents && tNode.flags & 2)
      directiveStartIndex++;
    return lView.slice(directiveStartIndex, directiveEndIndex);
  }
  function getComponentAtNodeIndex(nodeIndex, lView) {
    const tNode = lView[TVIEW].data[nodeIndex];
    let directiveStartIndex = tNode.directiveStart;
    return tNode.flags & 2 ? lView[directiveStartIndex] : null;
  }
  function discoverLocalRefs(lView, nodeIndex) {
    const tNode = lView[TVIEW].data[nodeIndex];
    if (tNode && tNode.localNames) {
      const result = {};
      let localIndex = tNode.index + 1;
      for (let i = 0; i < tNode.localNames.length; i += 2) {
        result[tNode.localNames[i]] = lView[localIndex];
        localIndex++;
      }
      return result;
    }
    return null;
  }
  var ERROR_ORIGINAL_ERROR = "ngOriginalError";
  var ERROR_LOGGER = "ngErrorLogger";
  function wrappedError(message, originalError) {
    const msg = `${message} caused by: ${originalError instanceof Error ? originalError.message : originalError}`;
    const error3 = Error(msg);
    error3[ERROR_ORIGINAL_ERROR] = originalError;
    return error3;
  }
  function getOriginalError(error3) {
    return error3[ERROR_ORIGINAL_ERROR];
  }
  function getErrorLogger(error3) {
    return error3 && error3[ERROR_LOGGER] || defaultErrorLogger;
  }
  function defaultErrorLogger(console2, ...values) {
    console2.error(...values);
  }
  var ErrorHandler = class {
    constructor() {
      this._console = console;
    }
    handleError(error3) {
      const originalError = this._findOriginalError(error3);
      const errorLogger = getErrorLogger(error3);
      errorLogger(this._console, `ERROR`, error3);
      if (originalError) {
        errorLogger(this._console, `ORIGINAL ERROR`, originalError);
      }
    }
    _findOriginalError(error3) {
      let e = error3 && getOriginalError(error3);
      while (e && getOriginalError(e)) {
        e = getOriginalError(e);
      }
      return e || null;
    }
  };
  var CUSTOM_ELEMENTS_SCHEMA = {
    name: "custom-elements"
  };
  var NO_ERRORS_SCHEMA = {
    name: "no-errors-schema"
  };
  var COMMENT_DISALLOWED = /^>|^->|<!--|-->|--!>|<!-$/g;
  var COMMENT_DELIMITER = /(<|>)/;
  var COMMENT_DELIMITER_ESCAPED = "\u200B$1\u200B";
  function escapeCommentText(value) {
    return value.replace(COMMENT_DISALLOWED, (text) => text.replace(COMMENT_DELIMITER, COMMENT_DELIMITER_ESCAPED));
  }
  function normalizeDebugBindingName(name) {
    name = camelCaseToDashCase(name.replace(/[$@]/g, "_"));
    return `ng-reflect-${name}`;
  }
  var CAMEL_CASE_REGEXP = /([A-Z])/g;
  function camelCaseToDashCase(input) {
    return input.replace(CAMEL_CASE_REGEXP, (...m) => "-" + m[1].toLowerCase());
  }
  function normalizeDebugBindingValue(value) {
    try {
      return value != null ? value.toString().slice(0, 30) : value;
    } catch (e) {
      return "[ERROR] Exception while trying to serialize the value";
    }
  }
  var defaultScheduler = (() => (typeof requestAnimationFrame !== "undefined" && requestAnimationFrame || setTimeout).bind(_global2))();
  function \u0275\u0275resolveWindow(element) {
    return element.ownerDocument.defaultView;
  }
  function \u0275\u0275resolveDocument(element) {
    return element.ownerDocument;
  }
  function \u0275\u0275resolveBody(element) {
    return element.ownerDocument.body;
  }
  var INTERPOLATION_DELIMITER = `\uFFFD`;
  function maybeUnwrapFn(value) {
    if (value instanceof Function) {
      return value();
    } else {
      return value;
    }
  }
  function throwMultipleComponentError(tNode) {
    throw new RuntimeError("300", `Multiple components match node with tagname ${tNode.value}`);
  }
  function throwErrorIfNoChangesMode(creationMode, oldValue, currValue, propName) {
    const field = propName ? ` for '${propName}'` : "";
    let msg = `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value${field}: '${oldValue}'. Current value: '${currValue}'.`;
    if (creationMode) {
      msg += ` It seems like the view has been created after its parent and its children have been dirty checked. Has it been created in a change detection hook?`;
    }
    throw new RuntimeError("100", msg);
  }
  function constructDetailsForInterpolation(lView, rootIndex, expressionIndex, meta, changedValue) {
    const [propName, prefix, ...chunks] = meta.split(INTERPOLATION_DELIMITER);
    let oldValue = prefix, newValue = prefix;
    for (let i = 0; i < chunks.length; i++) {
      const slotIdx = rootIndex + i;
      oldValue += `${lView[slotIdx]}${chunks[i]}`;
      newValue += `${slotIdx === expressionIndex ? changedValue : lView[slotIdx]}${chunks[i]}`;
    }
    return { propName, oldValue, newValue };
  }
  function getExpressionChangedErrorDetails(lView, bindingIndex, oldValue, newValue) {
    const tData = lView[TVIEW].data;
    const metadata = tData[bindingIndex];
    if (typeof metadata === "string") {
      if (metadata.indexOf(INTERPOLATION_DELIMITER) > -1) {
        return constructDetailsForInterpolation(lView, bindingIndex, bindingIndex, metadata, newValue);
      }
      return { propName: metadata, oldValue, newValue };
    }
    if (metadata === null) {
      let idx = bindingIndex - 1;
      while (typeof tData[idx] !== "string" && tData[idx + 1] === null) {
        idx--;
      }
      const meta = tData[idx];
      if (typeof meta === "string") {
        const matches = meta.match(new RegExp(INTERPOLATION_DELIMITER, "g"));
        if (matches && matches.length - 1 > bindingIndex - idx) {
          return constructDetailsForInterpolation(lView, idx, bindingIndex, meta, newValue);
        }
      }
    }
    return { propName: void 0, oldValue, newValue };
  }
  var RendererStyleFlags2;
  (function(RendererStyleFlags22) {
    RendererStyleFlags22[RendererStyleFlags22["Important"] = 1] = "Important";
    RendererStyleFlags22[RendererStyleFlags22["DashCase"] = 2] = "DashCase";
  })(RendererStyleFlags2 || (RendererStyleFlags2 = {}));
  var _icuContainerIterate;
  function icuContainerIterate(tIcuContainerNode, lView) {
    return _icuContainerIterate(tIcuContainerNode, lView);
  }
  function ensureIcuContainerVisitorLoaded(loader) {
    if (_icuContainerIterate === void 0) {
      _icuContainerIterate = loader();
    }
  }
  var unusedValueExportToPlacateAjd$3 = 1;
  function getLViewParent(lView) {
    ngDevMode && assertLView(lView);
    const parent = lView[PARENT];
    return isLContainer(parent) ? parent[PARENT] : parent;
  }
  function getRootView(componentOrLView) {
    ngDevMode && assertDefined(componentOrLView, "component");
    let lView = isLView(componentOrLView) ? componentOrLView : readPatchedLView(componentOrLView);
    while (lView && !(lView[FLAGS] & 512)) {
      lView = getLViewParent(lView);
    }
    ngDevMode && assertLView(lView);
    return lView;
  }
  function getRootContext(viewOrComponent) {
    const rootView = getRootView(viewOrComponent);
    ngDevMode && assertDefined(rootView[CONTEXT], "RootView has no context. Perhaps it is disconnected?");
    return rootView[CONTEXT];
  }
  function getFirstLContainer(lView) {
    return getNearestLContainer(lView[CHILD_HEAD]);
  }
  function getNextLContainer(container) {
    return getNearestLContainer(container[NEXT]);
  }
  function getNearestLContainer(viewOrContainer) {
    while (viewOrContainer !== null && !isLContainer(viewOrContainer)) {
      viewOrContainer = viewOrContainer[NEXT];
    }
    return viewOrContainer;
  }
  var unusedValueToPlacateAjd$2 = unusedValueExportToPlacateAjd$7 + unusedValueExportToPlacateAjd$4 + unusedValueExportToPlacateAjd$3 + unusedValueExportToPlacateAjd$6 + unusedValueExportToPlacateAjd$8;
  function applyToElementOrContainer(action, renderer, parent, lNodeToHandle, beforeNode) {
    if (lNodeToHandle != null) {
      let lContainer;
      let isComponent = false;
      if (isLContainer(lNodeToHandle)) {
        lContainer = lNodeToHandle;
      } else if (isLView(lNodeToHandle)) {
        isComponent = true;
        ngDevMode && assertDefined(lNodeToHandle[HOST], "HOST must be defined for a component LView");
        lNodeToHandle = lNodeToHandle[HOST];
      }
      const rNode = unwrapRNode(lNodeToHandle);
      ngDevMode && !isProceduralRenderer(renderer) && assertDomNode(rNode);
      if (action === 0 && parent !== null) {
        if (beforeNode == null) {
          nativeAppendChild(renderer, parent, rNode);
        } else {
          nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);
        }
      } else if (action === 1 && parent !== null) {
        nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);
      } else if (action === 2) {
        nativeRemoveNode(renderer, rNode, isComponent);
      } else if (action === 3) {
        ngDevMode && ngDevMode.rendererDestroyNode++;
        renderer.destroyNode(rNode);
      }
      if (lContainer != null) {
        applyContainer(renderer, action, lContainer, parent, beforeNode);
      }
    }
  }
  function createTextNode(renderer, value) {
    ngDevMode && ngDevMode.rendererCreateTextNode++;
    ngDevMode && ngDevMode.rendererSetText++;
    return isProceduralRenderer(renderer) ? renderer.createText(value) : renderer.createTextNode(value);
  }
  function updateTextNode(renderer, rNode, value) {
    ngDevMode && ngDevMode.rendererSetText++;
    isProceduralRenderer(renderer) ? renderer.setValue(rNode, value) : rNode.textContent = value;
  }
  function createCommentNode(renderer, value) {
    ngDevMode && ngDevMode.rendererCreateComment++;
    return renderer.createComment(escapeCommentText(value));
  }
  function createElementNode(renderer, name, namespace) {
    ngDevMode && ngDevMode.rendererCreateElement++;
    if (isProceduralRenderer(renderer)) {
      return renderer.createElement(name, namespace);
    } else {
      return namespace === null ? renderer.createElement(name) : renderer.createElementNS(namespace, name);
    }
  }
  function removeViewFromContainer(tView, lView) {
    const renderer = lView[RENDERER];
    applyView(tView, lView, renderer, 2, null, null);
    lView[HOST] = null;
    lView[T_HOST] = null;
  }
  function addViewToContainer(tView, parentTNode, renderer, lView, parentNativeNode, beforeNode) {
    lView[HOST] = parentNativeNode;
    lView[T_HOST] = parentTNode;
    applyView(tView, lView, renderer, 1, parentNativeNode, beforeNode);
  }
  function renderDetachView(tView, lView) {
    applyView(tView, lView, lView[RENDERER], 2, null, null);
  }
  function destroyViewTree(rootView) {
    let lViewOrLContainer = rootView[CHILD_HEAD];
    if (!lViewOrLContainer) {
      return cleanUpView(rootView[TVIEW], rootView);
    }
    while (lViewOrLContainer) {
      let next = null;
      if (isLView(lViewOrLContainer)) {
        next = lViewOrLContainer[CHILD_HEAD];
      } else {
        ngDevMode && assertLContainer(lViewOrLContainer);
        const firstView = lViewOrLContainer[CONTAINER_HEADER_OFFSET];
        if (firstView)
          next = firstView;
      }
      if (!next) {
        while (lViewOrLContainer && !lViewOrLContainer[NEXT] && lViewOrLContainer !== rootView) {
          if (isLView(lViewOrLContainer)) {
            cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);
          }
          lViewOrLContainer = lViewOrLContainer[PARENT];
        }
        if (lViewOrLContainer === null)
          lViewOrLContainer = rootView;
        if (isLView(lViewOrLContainer)) {
          cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);
        }
        next = lViewOrLContainer && lViewOrLContainer[NEXT];
      }
      lViewOrLContainer = next;
    }
  }
  function insertView(tView, lView, lContainer, index) {
    ngDevMode && assertLView(lView);
    ngDevMode && assertLContainer(lContainer);
    const indexInContainer = CONTAINER_HEADER_OFFSET + index;
    const containerLength = lContainer.length;
    if (index > 0) {
      lContainer[indexInContainer - 1][NEXT] = lView;
    }
    if (index < containerLength - CONTAINER_HEADER_OFFSET) {
      lView[NEXT] = lContainer[indexInContainer];
      addToArray(lContainer, CONTAINER_HEADER_OFFSET + index, lView);
    } else {
      lContainer.push(lView);
      lView[NEXT] = null;
    }
    lView[PARENT] = lContainer;
    const declarationLContainer = lView[DECLARATION_LCONTAINER];
    if (declarationLContainer !== null && lContainer !== declarationLContainer) {
      trackMovedView(declarationLContainer, lView);
    }
    const lQueries = lView[QUERIES];
    if (lQueries !== null) {
      lQueries.insertView(tView);
    }
    lView[FLAGS] |= 128;
  }
  function trackMovedView(declarationContainer, lView) {
    ngDevMode && assertDefined(lView, "LView required");
    ngDevMode && assertLContainer(declarationContainer);
    const movedViews = declarationContainer[MOVED_VIEWS];
    const insertedLContainer = lView[PARENT];
    ngDevMode && assertLContainer(insertedLContainer);
    const insertedComponentLView = insertedLContainer[PARENT][DECLARATION_COMPONENT_VIEW];
    ngDevMode && assertDefined(insertedComponentLView, "Missing insertedComponentLView");
    const declaredComponentLView = lView[DECLARATION_COMPONENT_VIEW];
    ngDevMode && assertDefined(declaredComponentLView, "Missing declaredComponentLView");
    if (declaredComponentLView !== insertedComponentLView) {
      declarationContainer[HAS_TRANSPLANTED_VIEWS] = true;
    }
    if (movedViews === null) {
      declarationContainer[MOVED_VIEWS] = [lView];
    } else {
      movedViews.push(lView);
    }
  }
  function detachMovedView(declarationContainer, lView) {
    ngDevMode && assertLContainer(declarationContainer);
    ngDevMode && assertDefined(declarationContainer[MOVED_VIEWS], "A projected view should belong to a non-empty projected views collection");
    const movedViews = declarationContainer[MOVED_VIEWS];
    const declarationViewIndex = movedViews.indexOf(lView);
    const insertionLContainer = lView[PARENT];
    ngDevMode && assertLContainer(insertionLContainer);
    if (lView[FLAGS] & 1024) {
      lView[FLAGS] &= ~1024;
      updateTransplantedViewCount(insertionLContainer, -1);
    }
    movedViews.splice(declarationViewIndex, 1);
  }
  function detachView(lContainer, removeIndex) {
    if (lContainer.length <= CONTAINER_HEADER_OFFSET)
      return;
    const indexInContainer = CONTAINER_HEADER_OFFSET + removeIndex;
    const viewToDetach = lContainer[indexInContainer];
    if (viewToDetach) {
      const declarationLContainer = viewToDetach[DECLARATION_LCONTAINER];
      if (declarationLContainer !== null && declarationLContainer !== lContainer) {
        detachMovedView(declarationLContainer, viewToDetach);
      }
      if (removeIndex > 0) {
        lContainer[indexInContainer - 1][NEXT] = viewToDetach[NEXT];
      }
      const removedLView = removeFromArray(lContainer, CONTAINER_HEADER_OFFSET + removeIndex);
      removeViewFromContainer(viewToDetach[TVIEW], viewToDetach);
      const lQueries = removedLView[QUERIES];
      if (lQueries !== null) {
        lQueries.detachView(removedLView[TVIEW]);
      }
      viewToDetach[PARENT] = null;
      viewToDetach[NEXT] = null;
      viewToDetach[FLAGS] &= ~128;
    }
    return viewToDetach;
  }
  function destroyLView(tView, lView) {
    if (!(lView[FLAGS] & 256)) {
      const renderer = lView[RENDERER];
      if (isProceduralRenderer(renderer) && renderer.destroyNode) {
        applyView(tView, lView, renderer, 3, null, null);
      }
      destroyViewTree(lView);
    }
  }
  function cleanUpView(tView, lView) {
    if (!(lView[FLAGS] & 256)) {
      lView[FLAGS] &= ~128;
      lView[FLAGS] |= 256;
      executeOnDestroys(tView, lView);
      processCleanups(tView, lView);
      if (lView[TVIEW].type === 1 && isProceduralRenderer(lView[RENDERER])) {
        ngDevMode && ngDevMode.rendererDestroy++;
        lView[RENDERER].destroy();
      }
      const declarationContainer = lView[DECLARATION_LCONTAINER];
      if (declarationContainer !== null && isLContainer(lView[PARENT])) {
        if (declarationContainer !== lView[PARENT]) {
          detachMovedView(declarationContainer, lView);
        }
        const lQueries = lView[QUERIES];
        if (lQueries !== null) {
          lQueries.detachView(tView);
        }
      }
    }
  }
  function processCleanups(tView, lView) {
    const tCleanup = tView.cleanup;
    const lCleanup = lView[CLEANUP];
    let lastLCleanupIndex = -1;
    if (tCleanup !== null) {
      for (let i = 0; i < tCleanup.length - 1; i += 2) {
        if (typeof tCleanup[i] === "string") {
          const idxOrTargetGetter = tCleanup[i + 1];
          const target = typeof idxOrTargetGetter === "function" ? idxOrTargetGetter(lView) : unwrapRNode(lView[idxOrTargetGetter]);
          const listener = lCleanup[lastLCleanupIndex = tCleanup[i + 2]];
          const useCaptureOrSubIdx = tCleanup[i + 3];
          if (typeof useCaptureOrSubIdx === "boolean") {
            target.removeEventListener(tCleanup[i], listener, useCaptureOrSubIdx);
          } else {
            if (useCaptureOrSubIdx >= 0) {
              lCleanup[lastLCleanupIndex = useCaptureOrSubIdx]();
            } else {
              lCleanup[lastLCleanupIndex = -useCaptureOrSubIdx].unsubscribe();
            }
          }
          i += 2;
        } else {
          const context2 = lCleanup[lastLCleanupIndex = tCleanup[i + 1]];
          tCleanup[i].call(context2);
        }
      }
    }
    if (lCleanup !== null) {
      for (let i = lastLCleanupIndex + 1; i < lCleanup.length; i++) {
        const instanceCleanupFn = lCleanup[i];
        ngDevMode && assertFunction(instanceCleanupFn, "Expecting instance cleanup function.");
        instanceCleanupFn();
      }
      lView[CLEANUP] = null;
    }
  }
  function executeOnDestroys(tView, lView) {
    let destroyHooks;
    if (tView != null && (destroyHooks = tView.destroyHooks) != null) {
      for (let i = 0; i < destroyHooks.length; i += 2) {
        const context2 = lView[destroyHooks[i]];
        if (!(context2 instanceof NodeInjectorFactory)) {
          const toCall = destroyHooks[i + 1];
          if (Array.isArray(toCall)) {
            for (let j = 0; j < toCall.length; j += 2) {
              const callContext = context2[toCall[j]];
              const hook = toCall[j + 1];
              profiler(4, callContext, hook);
              try {
                hook.call(callContext);
              } finally {
                profiler(5, callContext, hook);
              }
            }
          } else {
            profiler(4, context2, toCall);
            try {
              toCall.call(context2);
            } finally {
              profiler(5, context2, toCall);
            }
          }
        }
      }
    }
  }
  function getParentRElement(tView, tNode, lView) {
    return getClosestRElement(tView, tNode.parent, lView);
  }
  function getClosestRElement(tView, tNode, lView) {
    let parentTNode = tNode;
    while (parentTNode !== null && parentTNode.type & (8 | 32)) {
      tNode = parentTNode;
      parentTNode = tNode.parent;
    }
    if (parentTNode === null) {
      return lView[HOST];
    } else {
      ngDevMode && assertTNodeType(parentTNode, 3 | 4);
      if (parentTNode.flags & 2) {
        ngDevMode && assertTNodeForLView(parentTNode, lView);
        const encapsulation = tView.data[parentTNode.directiveStart].encapsulation;
        if (encapsulation === ViewEncapsulation$1.None || encapsulation === ViewEncapsulation$1.Emulated) {
          return null;
        }
      }
      return getNativeByTNode(parentTNode, lView);
    }
  }
  function nativeInsertBefore(renderer, parent, child, beforeNode, isMove) {
    ngDevMode && ngDevMode.rendererInsertBefore++;
    if (isProceduralRenderer(renderer)) {
      renderer.insertBefore(parent, child, beforeNode, isMove);
    } else {
      parent.insertBefore(child, beforeNode, isMove);
    }
  }
  function nativeAppendChild(renderer, parent, child) {
    ngDevMode && ngDevMode.rendererAppendChild++;
    ngDevMode && assertDefined(parent, "parent node must be defined");
    if (isProceduralRenderer(renderer)) {
      renderer.appendChild(parent, child);
    } else {
      parent.appendChild(child);
    }
  }
  function nativeAppendOrInsertBefore(renderer, parent, child, beforeNode, isMove) {
    if (beforeNode !== null) {
      nativeInsertBefore(renderer, parent, child, beforeNode, isMove);
    } else {
      nativeAppendChild(renderer, parent, child);
    }
  }
  function nativeRemoveChild(renderer, parent, child, isHostElement) {
    if (isProceduralRenderer(renderer)) {
      renderer.removeChild(parent, child, isHostElement);
    } else {
      parent.removeChild(child);
    }
  }
  function nativeParentNode(renderer, node) {
    return isProceduralRenderer(renderer) ? renderer.parentNode(node) : node.parentNode;
  }
  function nativeNextSibling(renderer, node) {
    return isProceduralRenderer(renderer) ? renderer.nextSibling(node) : node.nextSibling;
  }
  function getInsertInFrontOfRNode(parentTNode, currentTNode, lView) {
    return _getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView);
  }
  function getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView) {
    if (parentTNode.type & (8 | 32)) {
      return getNativeByTNode(parentTNode, lView);
    }
    return null;
  }
  var _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithNoI18n;
  var _processI18nInsertBefore;
  function setI18nHandling(getInsertInFrontOfRNodeWithI18n2, processI18nInsertBefore2) {
    _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithI18n2;
    _processI18nInsertBefore = processI18nInsertBefore2;
  }
  function appendChild(tView, lView, childRNode, childTNode) {
    const parentRNode = getParentRElement(tView, childTNode, lView);
    const renderer = lView[RENDERER];
    const parentTNode = childTNode.parent || lView[T_HOST];
    const anchorNode = getInsertInFrontOfRNode(parentTNode, childTNode, lView);
    if (parentRNode != null) {
      if (Array.isArray(childRNode)) {
        for (let i = 0; i < childRNode.length; i++) {
          nativeAppendOrInsertBefore(renderer, parentRNode, childRNode[i], anchorNode, false);
        }
      } else {
        nativeAppendOrInsertBefore(renderer, parentRNode, childRNode, anchorNode, false);
      }
    }
    _processI18nInsertBefore !== void 0 && _processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRNode);
  }
  function getFirstNativeNode(lView, tNode) {
    if (tNode !== null) {
      ngDevMode && assertTNodeType(tNode, 3 | 12 | 32 | 16);
      const tNodeType = tNode.type;
      if (tNodeType & 3) {
        return getNativeByTNode(tNode, lView);
      } else if (tNodeType & 4) {
        return getBeforeNodeForView(-1, lView[tNode.index]);
      } else if (tNodeType & 8) {
        const elIcuContainerChild = tNode.child;
        if (elIcuContainerChild !== null) {
          return getFirstNativeNode(lView, elIcuContainerChild);
        } else {
          const rNodeOrLContainer = lView[tNode.index];
          if (isLContainer(rNodeOrLContainer)) {
            return getBeforeNodeForView(-1, rNodeOrLContainer);
          } else {
            return unwrapRNode(rNodeOrLContainer);
          }
        }
      } else if (tNodeType & 32) {
        let nextRNode = icuContainerIterate(tNode, lView);
        let rNode = nextRNode();
        return rNode || unwrapRNode(lView[tNode.index]);
      } else {
        const projectionNodes = getProjectionNodes(lView, tNode);
        if (projectionNodes !== null) {
          if (Array.isArray(projectionNodes)) {
            return projectionNodes[0];
          }
          const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);
          ngDevMode && assertParentView(parentView);
          return getFirstNativeNode(parentView, projectionNodes);
        } else {
          return getFirstNativeNode(lView, tNode.next);
        }
      }
    }
    return null;
  }
  function getProjectionNodes(lView, tNode) {
    if (tNode !== null) {
      const componentView = lView[DECLARATION_COMPONENT_VIEW];
      const componentHost = componentView[T_HOST];
      const slotIdx = tNode.projection;
      ngDevMode && assertProjectionSlots(lView);
      return componentHost.projection[slotIdx];
    }
    return null;
  }
  function getBeforeNodeForView(viewIndexInContainer, lContainer) {
    const nextViewIndex = CONTAINER_HEADER_OFFSET + viewIndexInContainer + 1;
    if (nextViewIndex < lContainer.length) {
      const lView = lContainer[nextViewIndex];
      const firstTNodeOfView = lView[TVIEW].firstChild;
      if (firstTNodeOfView !== null) {
        return getFirstNativeNode(lView, firstTNodeOfView);
      }
    }
    return lContainer[NATIVE];
  }
  function nativeRemoveNode(renderer, rNode, isHostElement) {
    ngDevMode && ngDevMode.rendererRemoveNode++;
    const nativeParent = nativeParentNode(renderer, rNode);
    if (nativeParent) {
      nativeRemoveChild(renderer, nativeParent, rNode, isHostElement);
    }
  }
  function applyNodes(renderer, action, tNode, lView, parentRElement, beforeNode, isProjection) {
    while (tNode != null) {
      ngDevMode && assertTNodeForLView(tNode, lView);
      ngDevMode && assertTNodeType(tNode, 3 | 12 | 16 | 32);
      const rawSlotValue = lView[tNode.index];
      const tNodeType = tNode.type;
      if (isProjection) {
        if (action === 0) {
          rawSlotValue && attachPatchData(unwrapRNode(rawSlotValue), lView);
          tNode.flags |= 4;
        }
      }
      if ((tNode.flags & 64) !== 64) {
        if (tNodeType & 8) {
          applyNodes(renderer, action, tNode.child, lView, parentRElement, beforeNode, false);
          applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
        } else if (tNodeType & 32) {
          const nextRNode = icuContainerIterate(tNode, lView);
          let rNode;
          while (rNode = nextRNode()) {
            applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);
          }
          applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
        } else if (tNodeType & 16) {
          applyProjectionRecursive(renderer, action, lView, tNode, parentRElement, beforeNode);
        } else {
          ngDevMode && assertTNodeType(tNode, 3 | 4);
          applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
        }
      }
      tNode = isProjection ? tNode.projectionNext : tNode.next;
    }
  }
  function applyView(tView, lView, renderer, action, parentRElement, beforeNode) {
    applyNodes(renderer, action, tView.firstChild, lView, parentRElement, beforeNode, false);
  }
  function applyProjection(tView, lView, tProjectionNode) {
    const renderer = lView[RENDERER];
    const parentRNode = getParentRElement(tView, tProjectionNode, lView);
    const parentTNode = tProjectionNode.parent || lView[T_HOST];
    let beforeNode = getInsertInFrontOfRNode(parentTNode, tProjectionNode, lView);
    applyProjectionRecursive(renderer, 0, lView, tProjectionNode, parentRNode, beforeNode);
  }
  function applyProjectionRecursive(renderer, action, lView, tProjectionNode, parentRElement, beforeNode) {
    const componentLView = lView[DECLARATION_COMPONENT_VIEW];
    const componentNode = componentLView[T_HOST];
    ngDevMode && assertEqual(typeof tProjectionNode.projection, "number", "expecting projection index");
    const nodeToProjectOrRNodes = componentNode.projection[tProjectionNode.projection];
    if (Array.isArray(nodeToProjectOrRNodes)) {
      for (let i = 0; i < nodeToProjectOrRNodes.length; i++) {
        const rNode = nodeToProjectOrRNodes[i];
        applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);
      }
    } else {
      let nodeToProject = nodeToProjectOrRNodes;
      const projectedComponentLView = componentLView[PARENT];
      applyNodes(renderer, action, nodeToProject, projectedComponentLView, parentRElement, beforeNode, true);
    }
  }
  function applyContainer(renderer, action, lContainer, parentRElement, beforeNode) {
    ngDevMode && assertLContainer(lContainer);
    const anchor = lContainer[NATIVE];
    const native = unwrapRNode(lContainer);
    if (anchor !== native) {
      applyToElementOrContainer(action, renderer, parentRElement, anchor, beforeNode);
    }
    for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
      const lView = lContainer[i];
      applyView(lView[TVIEW], lView, renderer, action, parentRElement, anchor);
    }
  }
  function applyStyling(renderer, isClassBased, rNode, prop, value) {
    const isProcedural = isProceduralRenderer(renderer);
    if (isClassBased) {
      if (!value) {
        ngDevMode && ngDevMode.rendererRemoveClass++;
        if (isProcedural) {
          renderer.removeClass(rNode, prop);
        } else {
          rNode.classList.remove(prop);
        }
      } else {
        ngDevMode && ngDevMode.rendererAddClass++;
        if (isProcedural) {
          renderer.addClass(rNode, prop);
        } else {
          ngDevMode && assertDefined(rNode.classList, "HTMLElement expected");
          rNode.classList.add(prop);
        }
      }
    } else {
      let flags = prop.indexOf("-") === -1 ? void 0 : RendererStyleFlags2.DashCase;
      if (value == null) {
        ngDevMode && ngDevMode.rendererRemoveStyle++;
        if (isProcedural) {
          renderer.removeStyle(rNode, prop, flags);
        } else {
          rNode.style.removeProperty(prop);
        }
      } else {
        const isImportant = typeof value === "string" ? value.endsWith("!important") : false;
        if (isImportant) {
          value = value.slice(0, -10);
          flags |= RendererStyleFlags2.Important;
        }
        ngDevMode && ngDevMode.rendererSetStyle++;
        if (isProcedural) {
          renderer.setStyle(rNode, prop, value, flags);
        } else {
          ngDevMode && assertDefined(rNode.style, "HTMLElement expected");
          rNode.style.setProperty(prop, value, isImportant ? "important" : "");
        }
      }
    }
  }
  function writeDirectStyle(renderer, element, newValue) {
    ngDevMode && assertString(newValue, "'newValue' should be a string");
    if (isProceduralRenderer(renderer)) {
      renderer.setAttribute(element, "style", newValue);
    } else {
      element.style.cssText = newValue;
    }
    ngDevMode && ngDevMode.rendererSetStyle++;
  }
  function writeDirectClass(renderer, element, newValue) {
    ngDevMode && assertString(newValue, "'newValue' should be a string");
    if (isProceduralRenderer(renderer)) {
      if (newValue === "") {
        renderer.removeAttribute(element, "class");
      } else {
        renderer.setAttribute(element, "class", newValue);
      }
    } else {
      element.className = newValue;
    }
    ngDevMode && ngDevMode.rendererSetClassName++;
  }
  function classIndexOf(className, classToSearch, startingIndex) {
    ngDevMode && assertNotEqual(classToSearch, "", 'can not look for "" string.');
    let end = className.length;
    while (true) {
      const foundIndex = className.indexOf(classToSearch, startingIndex);
      if (foundIndex === -1)
        return foundIndex;
      if (foundIndex === 0 || className.charCodeAt(foundIndex - 1) <= 32) {
        const length = classToSearch.length;
        if (foundIndex + length === end || className.charCodeAt(foundIndex + length) <= 32) {
          return foundIndex;
        }
      }
      startingIndex = foundIndex + 1;
    }
  }
  var unusedValueToPlacateAjd$1 = unusedValueExportToPlacateAjd$4 + unusedValueExportToPlacateAjd$3;
  var NG_TEMPLATE_SELECTOR = "ng-template";
  function isCssClassMatching(attrs, cssClassToMatch, isProjectionMode) {
    ngDevMode && assertEqual(cssClassToMatch, cssClassToMatch.toLowerCase(), "Class name expected to be lowercase.");
    let i = 0;
    while (i < attrs.length) {
      let item = attrs[i++];
      if (isProjectionMode && item === "class") {
        item = attrs[i];
        if (classIndexOf(item.toLowerCase(), cssClassToMatch, 0) !== -1) {
          return true;
        }
      } else if (item === 1) {
        while (i < attrs.length && typeof (item = attrs[i++]) == "string") {
          if (item.toLowerCase() === cssClassToMatch)
            return true;
        }
        return false;
      }
    }
    return false;
  }
  function isInlineTemplate(tNode) {
    return tNode.type === 4 && tNode.value !== NG_TEMPLATE_SELECTOR;
  }
  function hasTagAndTypeMatch(tNode, currentSelector, isProjectionMode) {
    const tagNameToCompare = tNode.type === 4 && !isProjectionMode ? NG_TEMPLATE_SELECTOR : tNode.value;
    return currentSelector === tagNameToCompare;
  }
  function isNodeMatchingSelector(tNode, selector, isProjectionMode) {
    ngDevMode && assertDefined(selector[0], "Selector should have a tag name");
    let mode = 4;
    const nodeAttrs = tNode.attrs || [];
    const nameOnlyMarkerIdx = getNameOnlyMarkerIndex(nodeAttrs);
    let skipToNextSelector = false;
    for (let i = 0; i < selector.length; i++) {
      const current = selector[i];
      if (typeof current === "number") {
        if (!skipToNextSelector && !isPositive(mode) && !isPositive(current)) {
          return false;
        }
        if (skipToNextSelector && isPositive(current))
          continue;
        skipToNextSelector = false;
        mode = current | mode & 1;
        continue;
      }
      if (skipToNextSelector)
        continue;
      if (mode & 4) {
        mode = 2 | mode & 1;
        if (current !== "" && !hasTagAndTypeMatch(tNode, current, isProjectionMode) || current === "" && selector.length === 1) {
          if (isPositive(mode))
            return false;
          skipToNextSelector = true;
        }
      } else {
        const selectorAttrValue = mode & 8 ? current : selector[++i];
        if (mode & 8 && tNode.attrs !== null) {
          if (!isCssClassMatching(tNode.attrs, selectorAttrValue, isProjectionMode)) {
            if (isPositive(mode))
              return false;
            skipToNextSelector = true;
          }
          continue;
        }
        const attrName = mode & 8 ? "class" : current;
        const attrIndexInNode = findAttrIndexInNode(attrName, nodeAttrs, isInlineTemplate(tNode), isProjectionMode);
        if (attrIndexInNode === -1) {
          if (isPositive(mode))
            return false;
          skipToNextSelector = true;
          continue;
        }
        if (selectorAttrValue !== "") {
          let nodeAttrValue;
          if (attrIndexInNode > nameOnlyMarkerIdx) {
            nodeAttrValue = "";
          } else {
            ngDevMode && assertNotEqual(nodeAttrs[attrIndexInNode], 0, "We do not match directives on namespaced attributes");
            nodeAttrValue = nodeAttrs[attrIndexInNode + 1].toLowerCase();
          }
          const compareAgainstClassName = mode & 8 ? nodeAttrValue : null;
          if (compareAgainstClassName && classIndexOf(compareAgainstClassName, selectorAttrValue, 0) !== -1 || mode & 2 && selectorAttrValue !== nodeAttrValue) {
            if (isPositive(mode))
              return false;
            skipToNextSelector = true;
          }
        }
      }
    }
    return isPositive(mode) || skipToNextSelector;
  }
  function isPositive(mode) {
    return (mode & 1) === 0;
  }
  function findAttrIndexInNode(name, attrs, isInlineTemplate2, isProjectionMode) {
    if (attrs === null)
      return -1;
    let i = 0;
    if (isProjectionMode || !isInlineTemplate2) {
      let bindingsMode = false;
      while (i < attrs.length) {
        const maybeAttrName = attrs[i];
        if (maybeAttrName === name) {
          return i;
        } else if (maybeAttrName === 3 || maybeAttrName === 6) {
          bindingsMode = true;
        } else if (maybeAttrName === 1 || maybeAttrName === 2) {
          let value = attrs[++i];
          while (typeof value === "string") {
            value = attrs[++i];
          }
          continue;
        } else if (maybeAttrName === 4) {
          break;
        } else if (maybeAttrName === 0) {
          i += 4;
          continue;
        }
        i += bindingsMode ? 1 : 2;
      }
      return -1;
    } else {
      return matchTemplateAttribute(attrs, name);
    }
  }
  function isNodeMatchingSelectorList(tNode, selector, isProjectionMode = false) {
    for (let i = 0; i < selector.length; i++) {
      if (isNodeMatchingSelector(tNode, selector[i], isProjectionMode)) {
        return true;
      }
    }
    return false;
  }
  function getProjectAsAttrValue(tNode) {
    const nodeAttrs = tNode.attrs;
    if (nodeAttrs != null) {
      const ngProjectAsAttrIdx = nodeAttrs.indexOf(5);
      if ((ngProjectAsAttrIdx & 1) === 0) {
        return nodeAttrs[ngProjectAsAttrIdx + 1];
      }
    }
    return null;
  }
  function getNameOnlyMarkerIndex(nodeAttrs) {
    for (let i = 0; i < nodeAttrs.length; i++) {
      const nodeAttr = nodeAttrs[i];
      if (isNameOnlyAttributeMarker(nodeAttr)) {
        return i;
      }
    }
    return nodeAttrs.length;
  }
  function matchTemplateAttribute(attrs, name) {
    let i = attrs.indexOf(4);
    if (i > -1) {
      i++;
      while (i < attrs.length) {
        const attr = attrs[i];
        if (typeof attr === "number")
          return -1;
        if (attr === name)
          return i;
        i++;
      }
    }
    return -1;
  }
  function isSelectorInSelectorList(selector, list) {
    selectorListLoop:
      for (let i = 0; i < list.length; i++) {
        const currentSelectorInList = list[i];
        if (selector.length !== currentSelectorInList.length) {
          continue;
        }
        for (let j = 0; j < selector.length; j++) {
          if (selector[j] !== currentSelectorInList[j]) {
            continue selectorListLoop;
          }
        }
        return true;
      }
    return false;
  }
  function maybeWrapInNotSelector(isNegativeMode, chunk) {
    return isNegativeMode ? ":not(" + chunk.trim() + ")" : chunk;
  }
  function stringifyCSSSelector(selector) {
    let result = selector[0];
    let i = 1;
    let mode = 2;
    let currentChunk = "";
    let isNegativeMode = false;
    while (i < selector.length) {
      let valueOrMarker = selector[i];
      if (typeof valueOrMarker === "string") {
        if (mode & 2) {
          const attrValue = selector[++i];
          currentChunk += "[" + valueOrMarker + (attrValue.length > 0 ? '="' + attrValue + '"' : "") + "]";
        } else if (mode & 8) {
          currentChunk += "." + valueOrMarker;
        } else if (mode & 4) {
          currentChunk += " " + valueOrMarker;
        }
      } else {
        if (currentChunk !== "" && !isPositive(valueOrMarker)) {
          result += maybeWrapInNotSelector(isNegativeMode, currentChunk);
          currentChunk = "";
        }
        mode = valueOrMarker;
        isNegativeMode = isNegativeMode || !isPositive(mode);
      }
      i++;
    }
    if (currentChunk !== "") {
      result += maybeWrapInNotSelector(isNegativeMode, currentChunk);
    }
    return result;
  }
  function stringifyCSSSelectorList(selectorList) {
    return selectorList.map(stringifyCSSSelector).join(",");
  }
  function extractAttrsAndClassesFromSelector(selector) {
    const attrs = [];
    const classes = [];
    let i = 1;
    let mode = 2;
    while (i < selector.length) {
      let valueOrMarker = selector[i];
      if (typeof valueOrMarker === "string") {
        if (mode === 2) {
          if (valueOrMarker !== "") {
            attrs.push(valueOrMarker, selector[++i]);
          }
        } else if (mode === 8) {
          classes.push(valueOrMarker);
        }
      } else {
        if (!isPositive(mode))
          break;
        mode = valueOrMarker;
      }
      i++;
    }
    return { attrs, classes };
  }
  var NO_CHANGE = typeof ngDevMode === "undefined" || ngDevMode ? { __brand__: "NO_CHANGE" } : {};
  function \u0275\u0275advance(delta) {
    ngDevMode && assertGreaterThan(delta, 0, "Can only advance forward");
    selectIndexInternal(getTView(), getLView(), getSelectedIndex() + delta, isInCheckNoChangesMode());
  }
  function selectIndexInternal(tView, lView, index, checkNoChangesMode) {
    ngDevMode && assertIndexInDeclRange(lView, index);
    if (!checkNoChangesMode) {
      const hooksInitPhaseCompleted = (lView[FLAGS] & 3) === 3;
      if (hooksInitPhaseCompleted) {
        const preOrderCheckHooks = tView.preOrderCheckHooks;
        if (preOrderCheckHooks !== null) {
          executeCheckHooks(lView, preOrderCheckHooks, index);
        }
      } else {
        const preOrderHooks = tView.preOrderHooks;
        if (preOrderHooks !== null) {
          executeInitAndCheckHooks(lView, preOrderHooks, 0, index);
        }
      }
    }
    setSelectedIndex(index);
  }
  function createNamedArrayType(name) {
    if (ngDevMode) {
      try {
        return newTrustedFunctionForDev("Array", `return class ${name} extends Array{}`)(Array);
      } catch (e) {
        return Array;
      }
    } else {
      throw new Error("Looks like we are in 'prod mode', but we are creating a named Array type, which is wrong! Check your code");
    }
  }
  function toTStylingRange(prev, next) {
    ngDevMode && assertNumberInRange(prev, 0, 32767);
    ngDevMode && assertNumberInRange(next, 0, 32767);
    return prev << 17 | next << 2;
  }
  function getTStylingRangePrev(tStylingRange) {
    ngDevMode && assertNumber(tStylingRange, "expected number");
    return tStylingRange >> 17 & 32767;
  }
  function getTStylingRangePrevDuplicate(tStylingRange) {
    ngDevMode && assertNumber(tStylingRange, "expected number");
    return (tStylingRange & 2) == 2;
  }
  function setTStylingRangePrev(tStylingRange, previous) {
    ngDevMode && assertNumber(tStylingRange, "expected number");
    ngDevMode && assertNumberInRange(previous, 0, 32767);
    return tStylingRange & ~4294836224 | previous << 17;
  }
  function setTStylingRangePrevDuplicate(tStylingRange) {
    ngDevMode && assertNumber(tStylingRange, "expected number");
    return tStylingRange | 2;
  }
  function getTStylingRangeNext(tStylingRange) {
    ngDevMode && assertNumber(tStylingRange, "expected number");
    return (tStylingRange & 131068) >> 2;
  }
  function setTStylingRangeNext(tStylingRange, next) {
    ngDevMode && assertNumber(tStylingRange, "expected number");
    ngDevMode && assertNumberInRange(next, 0, 32767);
    return tStylingRange & ~131068 | next << 2;
  }
  function getTStylingRangeNextDuplicate(tStylingRange) {
    ngDevMode && assertNumber(tStylingRange, "expected number");
    return (tStylingRange & 1) === 1;
  }
  function setTStylingRangeNextDuplicate(tStylingRange) {
    ngDevMode && assertNumber(tStylingRange, "expected number");
    return tStylingRange | 1;
  }
  function attachDebugObject(obj, debug) {
    if (ngDevMode) {
      Object.defineProperty(obj, "debug", { value: debug, enumerable: false });
    } else {
      throw new Error("This method should be guarded with `ngDevMode` so that it can be tree shaken in production!");
    }
  }
  function attachDebugGetter(obj, debugGetter) {
    if (ngDevMode) {
      Object.defineProperty(obj, "debug", { get: debugGetter, enumerable: false });
    } else {
      throw new Error("This method should be guarded with `ngDevMode` so that it can be tree shaken in production!");
    }
  }
  var LVIEW_COMPONENT_CACHE;
  var LVIEW_EMBEDDED_CACHE;
  var LVIEW_ROOT;
  var LVIEW_COMPONENT;
  var LVIEW_EMBEDDED;
  function cloneToLViewFromTViewBlueprint(tView) {
    const debugTView = tView;
    const lView = getLViewToClone(debugTView.type, tView.template && tView.template.name);
    return lView.concat(tView.blueprint);
  }
  var LRootView = class extends Array {
  };
  var LComponentView = class extends Array {
  };
  var LEmbeddedView = class extends Array {
  };
  function getLViewToClone(type, name) {
    switch (type) {
      case 0:
        if (LVIEW_ROOT === void 0)
          LVIEW_ROOT = new LRootView();
        return LVIEW_ROOT;
      case 1:
        if (!ngDevMode || !ngDevMode.namedConstructors) {
          if (LVIEW_COMPONENT === void 0)
            LVIEW_COMPONENT = new LComponentView();
          return LVIEW_COMPONENT;
        }
        if (LVIEW_COMPONENT_CACHE === void 0)
          LVIEW_COMPONENT_CACHE = /* @__PURE__ */ new Map();
        let componentArray = LVIEW_COMPONENT_CACHE.get(name);
        if (componentArray === void 0) {
          componentArray = new (createNamedArrayType("LComponentView" + nameSuffix(name)))();
          LVIEW_COMPONENT_CACHE.set(name, componentArray);
        }
        return componentArray;
      case 2:
        if (!ngDevMode || !ngDevMode.namedConstructors) {
          if (LVIEW_EMBEDDED === void 0)
            LVIEW_EMBEDDED = new LEmbeddedView();
          return LVIEW_EMBEDDED;
        }
        if (LVIEW_EMBEDDED_CACHE === void 0)
          LVIEW_EMBEDDED_CACHE = /* @__PURE__ */ new Map();
        let embeddedArray = LVIEW_EMBEDDED_CACHE.get(name);
        if (embeddedArray === void 0) {
          embeddedArray = new (createNamedArrayType("LEmbeddedView" + nameSuffix(name)))();
          LVIEW_EMBEDDED_CACHE.set(name, embeddedArray);
        }
        return embeddedArray;
    }
  }
  function nameSuffix(text) {
    if (text == null)
      return "";
    const index = text.lastIndexOf("_Template");
    return "_" + (index === -1 ? text : text.substr(0, index));
  }
  var TViewConstructor = class TView {
    constructor(type, blueprint, template, queries, viewQuery, declTNode, data, bindingStartIndex, expandoStartIndex, hostBindingOpCodes, firstCreatePass, firstUpdatePass, staticViewQueries, staticContentQueries, preOrderHooks, preOrderCheckHooks, contentHooks, contentCheckHooks, viewHooks, viewCheckHooks, destroyHooks, cleanup, contentQueries, components, directiveRegistry, pipeRegistry, firstChild, schemas, consts, incompleteFirstPass, _decls, _vars) {
      this.type = type;
      this.blueprint = blueprint;
      this.template = template;
      this.queries = queries;
      this.viewQuery = viewQuery;
      this.declTNode = declTNode;
      this.data = data;
      this.bindingStartIndex = bindingStartIndex;
      this.expandoStartIndex = expandoStartIndex;
      this.hostBindingOpCodes = hostBindingOpCodes;
      this.firstCreatePass = firstCreatePass;
      this.firstUpdatePass = firstUpdatePass;
      this.staticViewQueries = staticViewQueries;
      this.staticContentQueries = staticContentQueries;
      this.preOrderHooks = preOrderHooks;
      this.preOrderCheckHooks = preOrderCheckHooks;
      this.contentHooks = contentHooks;
      this.contentCheckHooks = contentCheckHooks;
      this.viewHooks = viewHooks;
      this.viewCheckHooks = viewCheckHooks;
      this.destroyHooks = destroyHooks;
      this.cleanup = cleanup;
      this.contentQueries = contentQueries;
      this.components = components;
      this.directiveRegistry = directiveRegistry;
      this.pipeRegistry = pipeRegistry;
      this.firstChild = firstChild;
      this.schemas = schemas;
      this.consts = consts;
      this.incompleteFirstPass = incompleteFirstPass;
      this._decls = _decls;
      this._vars = _vars;
    }
    get template_() {
      const buf = [];
      processTNodeChildren(this.firstChild, buf);
      return buf.join("");
    }
    get type_() {
      return TViewTypeAsString[this.type] || `TViewType.?${this.type}?`;
    }
  };
  var TNode = class {
    constructor(tView_, type, index, insertBeforeIndex, injectorIndex, directiveStart, directiveEnd, directiveStylingLast, propertyBindings, flags, providerIndexes, value, attrs, mergedAttrs, localNames, initialInputs, inputs, outputs, tViews, next, projectionNext, child, parent, projection, styles, stylesWithoutHost, residualStyles, classes, classesWithoutHost, residualClasses, classBindings, styleBindings) {
      this.tView_ = tView_;
      this.type = type;
      this.index = index;
      this.insertBeforeIndex = insertBeforeIndex;
      this.injectorIndex = injectorIndex;
      this.directiveStart = directiveStart;
      this.directiveEnd = directiveEnd;
      this.directiveStylingLast = directiveStylingLast;
      this.propertyBindings = propertyBindings;
      this.flags = flags;
      this.providerIndexes = providerIndexes;
      this.value = value;
      this.attrs = attrs;
      this.mergedAttrs = mergedAttrs;
      this.localNames = localNames;
      this.initialInputs = initialInputs;
      this.inputs = inputs;
      this.outputs = outputs;
      this.tViews = tViews;
      this.next = next;
      this.projectionNext = projectionNext;
      this.child = child;
      this.parent = parent;
      this.projection = projection;
      this.styles = styles;
      this.stylesWithoutHost = stylesWithoutHost;
      this.residualStyles = residualStyles;
      this.classes = classes;
      this.classesWithoutHost = classesWithoutHost;
      this.residualClasses = residualClasses;
      this.classBindings = classBindings;
      this.styleBindings = styleBindings;
    }
    debugNodeInjectorPath(lView) {
      const path = [];
      let injectorIndex = getInjectorIndex(this, lView);
      if (injectorIndex === -1) {
        const parentLocation = getParentInjectorLocation(this, lView);
        if (parentLocation !== NO_PARENT_INJECTOR) {
          injectorIndex = getParentInjectorIndex(parentLocation);
          lView = getParentInjectorView(parentLocation, lView);
        } else {
        }
      }
      while (injectorIndex !== -1) {
        ngDevMode && assertNodeInjector(lView, injectorIndex);
        const tNode = lView[TVIEW].data[injectorIndex + 8];
        path.push(buildDebugNode(tNode, lView));
        const parentLocation = lView[injectorIndex + 8];
        if (parentLocation === NO_PARENT_INJECTOR) {
          injectorIndex = -1;
        } else {
          injectorIndex = getParentInjectorIndex(parentLocation);
          lView = getParentInjectorView(parentLocation, lView);
        }
      }
      return path;
    }
    get type_() {
      return toTNodeTypeAsString(this.type) || `TNodeType.?${this.type}?`;
    }
    get flags_() {
      const flags = [];
      if (this.flags & 16)
        flags.push("TNodeFlags.hasClassInput");
      if (this.flags & 8)
        flags.push("TNodeFlags.hasContentQuery");
      if (this.flags & 32)
        flags.push("TNodeFlags.hasStyleInput");
      if (this.flags & 128)
        flags.push("TNodeFlags.hasHostBindings");
      if (this.flags & 2)
        flags.push("TNodeFlags.isComponentHost");
      if (this.flags & 1)
        flags.push("TNodeFlags.isDirectiveHost");
      if (this.flags & 64)
        flags.push("TNodeFlags.isDetached");
      if (this.flags & 4)
        flags.push("TNodeFlags.isProjected");
      return flags.join("|");
    }
    get template_() {
      if (this.type & 1)
        return this.value;
      const buf = [];
      const tagName = typeof this.value === "string" && this.value || this.type_;
      buf.push("<", tagName);
      if (this.flags) {
        buf.push(" ", this.flags_);
      }
      if (this.attrs) {
        for (let i = 0; i < this.attrs.length; ) {
          const attrName = this.attrs[i++];
          if (typeof attrName == "number") {
            break;
          }
          const attrValue = this.attrs[i++];
          buf.push(" ", attrName, '="', attrValue, '"');
        }
      }
      buf.push(">");
      processTNodeChildren(this.child, buf);
      buf.push("</", tagName, ">");
      return buf.join("");
    }
    get styleBindings_() {
      return toDebugStyleBinding(this, false);
    }
    get classBindings_() {
      return toDebugStyleBinding(this, true);
    }
    get providerIndexStart_() {
      return this.providerIndexes & 1048575;
    }
    get providerIndexEnd_() {
      return this.providerIndexStart_ + (this.providerIndexes >>> 20);
    }
  };
  var TNodeDebug = TNode;
  function toDebugStyleBinding(tNode, isClassBased) {
    const tData = tNode.tView_.data;
    const bindings = [];
    const range = isClassBased ? tNode.classBindings : tNode.styleBindings;
    const prev = getTStylingRangePrev(range);
    const next = getTStylingRangeNext(range);
    let isTemplate = next !== 0;
    let cursor = isTemplate ? next : prev;
    while (cursor !== 0) {
      const itemKey = tData[cursor];
      const itemRange = tData[cursor + 1];
      bindings.unshift({
        key: itemKey,
        index: cursor,
        isTemplate,
        prevDuplicate: getTStylingRangePrevDuplicate(itemRange),
        nextDuplicate: getTStylingRangeNextDuplicate(itemRange),
        nextIndex: getTStylingRangeNext(itemRange),
        prevIndex: getTStylingRangePrev(itemRange)
      });
      if (cursor === prev)
        isTemplate = false;
      cursor = getTStylingRangePrev(itemRange);
    }
    bindings.push((isClassBased ? tNode.residualClasses : tNode.residualStyles) || null);
    return bindings;
  }
  function processTNodeChildren(tNode, buf) {
    while (tNode) {
      buf.push(tNode.template_);
      tNode = tNode.next;
    }
  }
  var TViewData = class extends Array {
  };
  var TVIEWDATA_EMPTY;
  function cloneToTViewData(list) {
    if (TVIEWDATA_EMPTY === void 0)
      TVIEWDATA_EMPTY = new TViewData();
    return TVIEWDATA_EMPTY.concat(list);
  }
  var LViewBlueprint = class extends Array {
  };
  var MatchesArray = class extends Array {
  };
  var TViewComponents = class extends Array {
  };
  var TNodeLocalNames = class extends Array {
  };
  var TNodeInitialInputs = class extends Array {
  };
  var LCleanup = class extends Array {
  };
  var TCleanup = class extends Array {
  };
  function attachLViewDebug(lView) {
    attachDebugObject(lView, new LViewDebug(lView));
  }
  function attachLContainerDebug(lContainer) {
    attachDebugObject(lContainer, new LContainerDebug(lContainer));
  }
  function toDebug(obj) {
    if (obj) {
      const debug = obj.debug;
      assertDefined(debug, "Object does not have a debug representation.");
      return debug;
    } else {
      return obj;
    }
  }
  function toHtml(value, includeChildren = false) {
    const node = unwrapRNode(value);
    if (node) {
      switch (node.nodeType) {
        case Node.TEXT_NODE:
          return node.textContent;
        case Node.COMMENT_NODE:
          return `<!--${node.textContent}-->`;
        case Node.ELEMENT_NODE:
          const outerHTML = node.outerHTML;
          if (includeChildren) {
            return outerHTML;
          } else {
            const innerHTML = ">" + node.innerHTML + "<";
            return outerHTML.split(innerHTML)[0] + ">";
          }
      }
    }
    return null;
  }
  var LViewDebug = class {
    constructor(_raw_lView) {
      this._raw_lView = _raw_lView;
    }
    get flags() {
      const flags = this._raw_lView[FLAGS];
      return {
        __raw__flags__: flags,
        initPhaseState: flags & 3,
        creationMode: !!(flags & 4),
        firstViewPass: !!(flags & 8),
        checkAlways: !!(flags & 16),
        dirty: !!(flags & 64),
        attached: !!(flags & 128),
        destroyed: !!(flags & 256),
        isRoot: !!(flags & 512),
        indexWithinInitPhase: flags >> 11
      };
    }
    get parent() {
      return toDebug(this._raw_lView[PARENT]);
    }
    get hostHTML() {
      return toHtml(this._raw_lView[HOST], true);
    }
    get html() {
      return (this.nodes || []).map(mapToHTML).join("");
    }
    get context() {
      return this._raw_lView[CONTEXT];
    }
    get nodes() {
      const lView = this._raw_lView;
      const tNode = lView[TVIEW].firstChild;
      return toDebugNodes(tNode, lView);
    }
    get template() {
      return this.tView.template_;
    }
    get tView() {
      return this._raw_lView[TVIEW];
    }
    get cleanup() {
      return this._raw_lView[CLEANUP];
    }
    get injector() {
      return this._raw_lView[INJECTOR$1];
    }
    get rendererFactory() {
      return this._raw_lView[RENDERER_FACTORY];
    }
    get renderer() {
      return this._raw_lView[RENDERER];
    }
    get sanitizer() {
      return this._raw_lView[SANITIZER];
    }
    get childHead() {
      return toDebug(this._raw_lView[CHILD_HEAD]);
    }
    get next() {
      return toDebug(this._raw_lView[NEXT]);
    }
    get childTail() {
      return toDebug(this._raw_lView[CHILD_TAIL]);
    }
    get declarationView() {
      return toDebug(this._raw_lView[DECLARATION_VIEW]);
    }
    get queries() {
      return this._raw_lView[QUERIES];
    }
    get tHost() {
      return this._raw_lView[T_HOST];
    }
    get decls() {
      return toLViewRange(this.tView, this._raw_lView, HEADER_OFFSET, this.tView.bindingStartIndex);
    }
    get vars() {
      return toLViewRange(this.tView, this._raw_lView, this.tView.bindingStartIndex, this.tView.expandoStartIndex);
    }
    get expando() {
      return toLViewRange(this.tView, this._raw_lView, this.tView.expandoStartIndex, this._raw_lView.length);
    }
    get childViews() {
      const childViews = [];
      let child = this.childHead;
      while (child) {
        childViews.push(child);
        child = child.next;
      }
      return childViews;
    }
  };
  function mapToHTML(node) {
    if (node.type === "ElementContainer") {
      return (node.children || []).map(mapToHTML).join("");
    } else if (node.type === "IcuContainer") {
      throw new Error("Not implemented");
    } else {
      return toHtml(node.native, true) || "";
    }
  }
  function toLViewRange(tView, lView, start, end) {
    let content = [];
    for (let index = start; index < end; index++) {
      content.push({ index, t: tView.data[index], l: lView[index] });
    }
    return { start, end, length: end - start, content };
  }
  function toDebugNodes(tNode, lView) {
    if (tNode) {
      const debugNodes = [];
      let tNodeCursor = tNode;
      while (tNodeCursor) {
        debugNodes.push(buildDebugNode(tNodeCursor, lView));
        tNodeCursor = tNodeCursor.next;
      }
      return debugNodes;
    } else {
      return [];
    }
  }
  function buildDebugNode(tNode, lView) {
    const rawValue = lView[tNode.index];
    const native = unwrapRNode(rawValue);
    const factories = [];
    const instances = [];
    const tView = lView[TVIEW];
    for (let i = tNode.directiveStart; i < tNode.directiveEnd; i++) {
      const def = tView.data[i];
      factories.push(def.type);
      instances.push(lView[i]);
    }
    return {
      html: toHtml(native),
      type: toTNodeTypeAsString(tNode.type),
      tNode,
      native,
      children: toDebugNodes(tNode.child, lView),
      factories,
      instances,
      injector: buildNodeInjectorDebug(tNode, tView, lView),
      get injectorResolutionPath() {
        return tNode.debugNodeInjectorPath(lView);
      }
    };
  }
  function buildNodeInjectorDebug(tNode, tView, lView) {
    const viewProviders = [];
    for (let i = tNode.providerIndexStart_; i < tNode.providerIndexEnd_; i++) {
      viewProviders.push(tView.data[i]);
    }
    const providers = [];
    for (let i = tNode.providerIndexEnd_; i < tNode.directiveEnd; i++) {
      providers.push(tView.data[i]);
    }
    const nodeInjectorDebug = {
      bloom: toBloom(lView, tNode.injectorIndex),
      cumulativeBloom: toBloom(tView.data, tNode.injectorIndex),
      providers,
      viewProviders,
      parentInjectorIndex: lView[tNode.providerIndexStart_ - 1]
    };
    return nodeInjectorDebug;
  }
  function binary(array, idx) {
    const value = array[idx];
    if (typeof value !== "number")
      return "????????";
    const text = "00000000" + value.toString(2);
    return text.substring(text.length - 8);
  }
  function toBloom(array, idx) {
    if (idx < 0) {
      return "NO_NODE_INJECTOR";
    }
    return `${binary(array, idx + 7)}_${binary(array, idx + 6)}_${binary(array, idx + 5)}_${binary(array, idx + 4)}_${binary(array, idx + 3)}_${binary(array, idx + 2)}_${binary(array, idx + 1)}_${binary(array, idx + 0)}`;
  }
  var LContainerDebug = class {
    constructor(_raw_lContainer) {
      this._raw_lContainer = _raw_lContainer;
    }
    get hasTransplantedViews() {
      return this._raw_lContainer[HAS_TRANSPLANTED_VIEWS];
    }
    get views() {
      return this._raw_lContainer.slice(CONTAINER_HEADER_OFFSET).map(toDebug);
    }
    get parent() {
      return toDebug(this._raw_lContainer[PARENT]);
    }
    get movedViews() {
      return this._raw_lContainer[MOVED_VIEWS];
    }
    get host() {
      return this._raw_lContainer[HOST];
    }
    get native() {
      return this._raw_lContainer[NATIVE];
    }
    get next() {
      return toDebug(this._raw_lContainer[NEXT]);
    }
  };
  var _CLEAN_PROMISE = (() => Promise.resolve(null))();
  function processHostBindingOpCodes(tView, lView) {
    const hostBindingOpCodes = tView.hostBindingOpCodes;
    if (hostBindingOpCodes === null)
      return;
    try {
      for (let i = 0; i < hostBindingOpCodes.length; i++) {
        const opCode = hostBindingOpCodes[i];
        if (opCode < 0) {
          setSelectedIndex(~opCode);
        } else {
          const directiveIdx = opCode;
          const bindingRootIndx = hostBindingOpCodes[++i];
          const hostBindingFn = hostBindingOpCodes[++i];
          setBindingRootForHostBindings(bindingRootIndx, directiveIdx);
          const context2 = lView[directiveIdx];
          hostBindingFn(2, context2);
        }
      }
    } finally {
      setSelectedIndex(-1);
    }
  }
  function refreshContentQueries(tView, lView) {
    const contentQueries = tView.contentQueries;
    if (contentQueries !== null) {
      for (let i = 0; i < contentQueries.length; i += 2) {
        const queryStartIdx = contentQueries[i];
        const directiveDefIdx = contentQueries[i + 1];
        if (directiveDefIdx !== -1) {
          const directiveDef = tView.data[directiveDefIdx];
          ngDevMode && assertDefined(directiveDef, "DirectiveDef not found.");
          ngDevMode && assertDefined(directiveDef.contentQueries, "contentQueries function should be defined");
          setCurrentQueryIndex(queryStartIdx);
          directiveDef.contentQueries(2, lView[directiveDefIdx], directiveDefIdx);
        }
      }
    }
  }
  function refreshChildComponents(hostLView, components) {
    for (let i = 0; i < components.length; i++) {
      refreshComponent(hostLView, components[i]);
    }
  }
  function renderChildComponents(hostLView, components) {
    for (let i = 0; i < components.length; i++) {
      renderComponent$1(hostLView, components[i]);
    }
  }
  function createLView(parentLView, tView, context2, flags, host, tHostNode, rendererFactory, renderer, sanitizer, injector) {
    const lView = ngDevMode ? cloneToLViewFromTViewBlueprint(tView) : tView.blueprint.slice();
    lView[HOST] = host;
    lView[FLAGS] = flags | 4 | 128 | 8;
    resetPreOrderHookFlags(lView);
    ngDevMode && tView.declTNode && parentLView && assertTNodeForLView(tView.declTNode, parentLView);
    lView[PARENT] = lView[DECLARATION_VIEW] = parentLView;
    lView[CONTEXT] = context2;
    lView[RENDERER_FACTORY] = rendererFactory || parentLView && parentLView[RENDERER_FACTORY];
    ngDevMode && assertDefined(lView[RENDERER_FACTORY], "RendererFactory is required");
    lView[RENDERER] = renderer || parentLView && parentLView[RENDERER];
    ngDevMode && assertDefined(lView[RENDERER], "Renderer is required");
    lView[SANITIZER] = sanitizer || parentLView && parentLView[SANITIZER] || null;
    lView[INJECTOR$1] = injector || parentLView && parentLView[INJECTOR$1] || null;
    lView[T_HOST] = tHostNode;
    ngDevMode && assertEqual(tView.type == 2 ? parentLView !== null : true, true, "Embedded views must have parentLView");
    lView[DECLARATION_COMPONENT_VIEW] = tView.type == 2 ? parentLView[DECLARATION_COMPONENT_VIEW] : lView;
    ngDevMode && attachLViewDebug(lView);
    return lView;
  }
  function getOrCreateTNode(tView, index, type, name, attrs) {
    ngDevMode && index !== 0 && assertGreaterThanOrEqual(index, HEADER_OFFSET, "TNodes can't be in the LView header.");
    ngDevMode && assertPureTNodeType(type);
    let tNode = tView.data[index];
    if (tNode === null) {
      tNode = createTNodeAtIndex(tView, index, type, name, attrs);
      if (isInI18nBlock()) {
        tNode.flags |= 64;
      }
    } else if (tNode.type & 64) {
      tNode.type = type;
      tNode.value = name;
      tNode.attrs = attrs;
      const parent = getCurrentParentTNode();
      tNode.injectorIndex = parent === null ? -1 : parent.injectorIndex;
      ngDevMode && assertTNodeForTView(tNode, tView);
      ngDevMode && assertEqual(index, tNode.index, "Expecting same index");
    }
    setCurrentTNode(tNode, true);
    return tNode;
  }
  function createTNodeAtIndex(tView, index, type, name, attrs) {
    const currentTNode = getCurrentTNodePlaceholderOk();
    const isParent = isCurrentTNodeParent();
    const parent = isParent ? currentTNode : currentTNode && currentTNode.parent;
    const tNode = tView.data[index] = createTNode(tView, parent, type, index, name, attrs);
    if (tView.firstChild === null) {
      tView.firstChild = tNode;
    }
    if (currentTNode !== null) {
      if (isParent) {
        if (currentTNode.child == null && tNode.parent !== null) {
          currentTNode.child = tNode;
        }
      } else {
        if (currentTNode.next === null) {
          currentTNode.next = tNode;
        }
      }
    }
    return tNode;
  }
  function allocExpando(tView, lView, numSlotsToAlloc, initialValue) {
    if (numSlotsToAlloc === 0)
      return -1;
    if (ngDevMode) {
      assertFirstCreatePass(tView);
      assertSame(tView, lView[TVIEW], "`LView` must be associated with `TView`!");
      assertEqual(tView.data.length, lView.length, "Expecting LView to be same size as TView");
      assertEqual(tView.data.length, tView.blueprint.length, "Expecting Blueprint to be same size as TView");
      assertFirstUpdatePass(tView);
    }
    const allocIdx = lView.length;
    for (let i = 0; i < numSlotsToAlloc; i++) {
      lView.push(initialValue);
      tView.blueprint.push(initialValue);
      tView.data.push(null);
    }
    return allocIdx;
  }
  function renderView(tView, lView, context2) {
    ngDevMode && assertEqual(isCreationMode(lView), true, "Should be run in creation mode");
    enterView(lView);
    try {
      const viewQuery = tView.viewQuery;
      if (viewQuery !== null) {
        executeViewQueryFn(1, viewQuery, context2);
      }
      const templateFn = tView.template;
      if (templateFn !== null) {
        executeTemplate(tView, lView, templateFn, 1, context2);
      }
      if (tView.firstCreatePass) {
        tView.firstCreatePass = false;
      }
      if (tView.staticContentQueries) {
        refreshContentQueries(tView, lView);
      }
      if (tView.staticViewQueries) {
        executeViewQueryFn(2, tView.viewQuery, context2);
      }
      const components = tView.components;
      if (components !== null) {
        renderChildComponents(lView, components);
      }
    } catch (error3) {
      if (tView.firstCreatePass) {
        tView.incompleteFirstPass = true;
        tView.firstCreatePass = false;
      }
      throw error3;
    } finally {
      lView[FLAGS] &= ~4;
      leaveView();
    }
  }
  function refreshView(tView, lView, templateFn, context2) {
    ngDevMode && assertEqual(isCreationMode(lView), false, "Should be run in update mode");
    const flags = lView[FLAGS];
    if ((flags & 256) === 256)
      return;
    enterView(lView);
    const isInCheckNoChangesPass = isInCheckNoChangesMode();
    try {
      resetPreOrderHookFlags(lView);
      setBindingIndex(tView.bindingStartIndex);
      if (templateFn !== null) {
        executeTemplate(tView, lView, templateFn, 2, context2);
      }
      const hooksInitPhaseCompleted = (flags & 3) === 3;
      if (!isInCheckNoChangesPass) {
        if (hooksInitPhaseCompleted) {
          const preOrderCheckHooks = tView.preOrderCheckHooks;
          if (preOrderCheckHooks !== null) {
            executeCheckHooks(lView, preOrderCheckHooks, null);
          }
        } else {
          const preOrderHooks = tView.preOrderHooks;
          if (preOrderHooks !== null) {
            executeInitAndCheckHooks(lView, preOrderHooks, 0, null);
          }
          incrementInitPhaseFlags(lView, 0);
        }
      }
      markTransplantedViewsForRefresh(lView);
      refreshEmbeddedViews(lView);
      if (tView.contentQueries !== null) {
        refreshContentQueries(tView, lView);
      }
      if (!isInCheckNoChangesPass) {
        if (hooksInitPhaseCompleted) {
          const contentCheckHooks = tView.contentCheckHooks;
          if (contentCheckHooks !== null) {
            executeCheckHooks(lView, contentCheckHooks);
          }
        } else {
          const contentHooks = tView.contentHooks;
          if (contentHooks !== null) {
            executeInitAndCheckHooks(lView, contentHooks, 1);
          }
          incrementInitPhaseFlags(lView, 1);
        }
      }
      processHostBindingOpCodes(tView, lView);
      const components = tView.components;
      if (components !== null) {
        refreshChildComponents(lView, components);
      }
      const viewQuery = tView.viewQuery;
      if (viewQuery !== null) {
        executeViewQueryFn(2, viewQuery, context2);
      }
      if (!isInCheckNoChangesPass) {
        if (hooksInitPhaseCompleted) {
          const viewCheckHooks = tView.viewCheckHooks;
          if (viewCheckHooks !== null) {
            executeCheckHooks(lView, viewCheckHooks);
          }
        } else {
          const viewHooks = tView.viewHooks;
          if (viewHooks !== null) {
            executeInitAndCheckHooks(lView, viewHooks, 2);
          }
          incrementInitPhaseFlags(lView, 2);
        }
      }
      if (tView.firstUpdatePass === true) {
        tView.firstUpdatePass = false;
      }
      if (!isInCheckNoChangesPass) {
        lView[FLAGS] &= ~(64 | 8);
      }
      if (lView[FLAGS] & 1024) {
        lView[FLAGS] &= ~1024;
        updateTransplantedViewCount(lView[PARENT], -1);
      }
    } finally {
      leaveView();
    }
  }
  function renderComponentOrTemplate(tView, lView, templateFn, context2) {
    const rendererFactory = lView[RENDERER_FACTORY];
    const normalExecutionPath = !isInCheckNoChangesMode();
    const creationModeIsActive = isCreationMode(lView);
    try {
      if (normalExecutionPath && !creationModeIsActive && rendererFactory.begin) {
        rendererFactory.begin();
      }
      if (creationModeIsActive) {
        renderView(tView, lView, context2);
      }
      refreshView(tView, lView, templateFn, context2);
    } finally {
      if (normalExecutionPath && !creationModeIsActive && rendererFactory.end) {
        rendererFactory.end();
      }
    }
  }
  function executeTemplate(tView, lView, templateFn, rf, context2) {
    const prevSelectedIndex = getSelectedIndex();
    const isUpdatePhase = rf & 2;
    try {
      setSelectedIndex(-1);
      if (isUpdatePhase && lView.length > HEADER_OFFSET) {
        selectIndexInternal(tView, lView, HEADER_OFFSET, isInCheckNoChangesMode());
      }
      const preHookType = isUpdatePhase ? 2 : 0;
      profiler(preHookType, context2);
      templateFn(rf, context2);
    } finally {
      setSelectedIndex(prevSelectedIndex);
      const postHookType = isUpdatePhase ? 3 : 1;
      profiler(postHookType, context2);
    }
  }
  function executeContentQueries(tView, tNode, lView) {
    if (isContentQueryHost(tNode)) {
      const start = tNode.directiveStart;
      const end = tNode.directiveEnd;
      for (let directiveIndex = start; directiveIndex < end; directiveIndex++) {
        const def = tView.data[directiveIndex];
        if (def.contentQueries) {
          def.contentQueries(1, lView[directiveIndex], directiveIndex);
        }
      }
    }
  }
  function createDirectivesInstances(tView, lView, tNode) {
    if (!getBindingsEnabled())
      return;
    instantiateAllDirectives(tView, lView, tNode, getNativeByTNode(tNode, lView));
    if ((tNode.flags & 128) === 128) {
      invokeDirectivesHostBindings(tView, lView, tNode);
    }
  }
  function saveResolvedLocalsInData(viewData, tNode, localRefExtractor = getNativeByTNode) {
    const localNames = tNode.localNames;
    if (localNames !== null) {
      let localIndex = tNode.index + 1;
      for (let i = 0; i < localNames.length; i += 2) {
        const index = localNames[i + 1];
        const value = index === -1 ? localRefExtractor(tNode, viewData) : viewData[index];
        viewData[localIndex++] = value;
      }
    }
  }
  function getOrCreateTComponentView(def) {
    const tView = def.tView;
    if (tView === null || tView.incompleteFirstPass) {
      const declTNode = null;
      return def.tView = createTView(1, declTNode, def.template, def.decls, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery, def.schemas, def.consts);
    }
    return tView;
  }
  function createTView(type, declTNode, templateFn, decls, vars, directives, pipes, viewQuery, schemas, constsOrFactory) {
    ngDevMode && ngDevMode.tView++;
    const bindingStartIndex = HEADER_OFFSET + decls;
    const initialViewLength = bindingStartIndex + vars;
    const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);
    const consts = typeof constsOrFactory === "function" ? constsOrFactory() : constsOrFactory;
    const tView = blueprint[TVIEW] = ngDevMode ? new TViewConstructor(type, blueprint, templateFn, null, viewQuery, declTNode, cloneToTViewData(blueprint).fill(null, bindingStartIndex), bindingStartIndex, initialViewLength, null, true, true, false, false, null, null, null, null, null, null, null, null, null, null, typeof directives === "function" ? directives() : directives, typeof pipes === "function" ? pipes() : pipes, null, schemas, consts, false, decls, vars) : {
      type,
      blueprint,
      template: templateFn,
      queries: null,
      viewQuery,
      declTNode,
      data: blueprint.slice().fill(null, bindingStartIndex),
      bindingStartIndex,
      expandoStartIndex: initialViewLength,
      hostBindingOpCodes: null,
      firstCreatePass: true,
      firstUpdatePass: true,
      staticViewQueries: false,
      staticContentQueries: false,
      preOrderHooks: null,
      preOrderCheckHooks: null,
      contentHooks: null,
      contentCheckHooks: null,
      viewHooks: null,
      viewCheckHooks: null,
      destroyHooks: null,
      cleanup: null,
      contentQueries: null,
      components: null,
      directiveRegistry: typeof directives === "function" ? directives() : directives,
      pipeRegistry: typeof pipes === "function" ? pipes() : pipes,
      firstChild: null,
      schemas,
      consts,
      incompleteFirstPass: false
    };
    if (ngDevMode) {
      Object.seal(tView);
    }
    return tView;
  }
  function createViewBlueprint(bindingStartIndex, initialViewLength) {
    const blueprint = ngDevMode ? new LViewBlueprint() : [];
    for (let i = 0; i < initialViewLength; i++) {
      blueprint.push(i < bindingStartIndex ? null : NO_CHANGE);
    }
    return blueprint;
  }
  function createError(text, token) {
    return new Error(`Renderer: ${text} [${stringifyForError(token)}]`);
  }
  function assertHostNodeExists(rElement, elementOrSelector) {
    if (!rElement) {
      if (typeof elementOrSelector === "string") {
        throw createError("Host node with selector not found:", elementOrSelector);
      } else {
        throw createError("Host node is required:", elementOrSelector);
      }
    }
  }
  function locateHostElement(renderer, elementOrSelector, encapsulation) {
    if (isProceduralRenderer(renderer)) {
      const preserveContent = encapsulation === ViewEncapsulation$1.ShadowDom;
      return renderer.selectRootElement(elementOrSelector, preserveContent);
    }
    let rElement = typeof elementOrSelector === "string" ? renderer.querySelector(elementOrSelector) : elementOrSelector;
    ngDevMode && assertHostNodeExists(rElement, elementOrSelector);
    rElement.textContent = "";
    return rElement;
  }
  function storeCleanupWithContext(tView, lView, context2, cleanupFn) {
    const lCleanup = getOrCreateLViewCleanup(lView);
    if (context2 === null) {
      if (ngDevMode) {
        Object.freeze(getOrCreateTViewCleanup(tView));
      }
      lCleanup.push(cleanupFn);
    } else {
      lCleanup.push(context2);
      if (tView.firstCreatePass) {
        getOrCreateTViewCleanup(tView).push(cleanupFn, lCleanup.length - 1);
      }
    }
  }
  function createTNode(tView, tParent, type, index, value, attrs) {
    ngDevMode && index !== 0 && assertGreaterThanOrEqual(index, HEADER_OFFSET, "TNodes can't be in the LView header.");
    ngDevMode && assertNotSame(attrs, void 0, "'undefined' is not valid value for 'attrs'");
    ngDevMode && ngDevMode.tNode++;
    ngDevMode && tParent && assertTNodeForTView(tParent, tView);
    let injectorIndex = tParent ? tParent.injectorIndex : -1;
    const tNode = ngDevMode ? new TNodeDebug(tView, type, index, null, injectorIndex, -1, -1, -1, null, 0, 0, value, attrs, null, null, void 0, null, null, null, null, null, null, tParent, null, null, null, void 0, null, null, void 0, 0, 0) : {
      type,
      index,
      insertBeforeIndex: null,
      injectorIndex,
      directiveStart: -1,
      directiveEnd: -1,
      directiveStylingLast: -1,
      propertyBindings: null,
      flags: 0,
      providerIndexes: 0,
      value,
      attrs,
      mergedAttrs: null,
      localNames: null,
      initialInputs: void 0,
      inputs: null,
      outputs: null,
      tViews: null,
      next: null,
      projectionNext: null,
      child: null,
      parent: tParent,
      projection: null,
      styles: null,
      stylesWithoutHost: null,
      residualStyles: void 0,
      classes: null,
      classesWithoutHost: null,
      residualClasses: void 0,
      classBindings: 0,
      styleBindings: 0
    };
    if (ngDevMode) {
      Object.seal(tNode);
    }
    return tNode;
  }
  function generatePropertyAliases(inputAliasMap, directiveDefIdx, propStore) {
    for (let publicName in inputAliasMap) {
      if (inputAliasMap.hasOwnProperty(publicName)) {
        propStore = propStore === null ? {} : propStore;
        const internalName = inputAliasMap[publicName];
        if (propStore.hasOwnProperty(publicName)) {
          propStore[publicName].push(directiveDefIdx, internalName);
        } else {
          propStore[publicName] = [directiveDefIdx, internalName];
        }
      }
    }
    return propStore;
  }
  function initializeInputAndOutputAliases(tView, tNode) {
    ngDevMode && assertFirstCreatePass(tView);
    const start = tNode.directiveStart;
    const end = tNode.directiveEnd;
    const tViewData = tView.data;
    const tNodeAttrs = tNode.attrs;
    const inputsFromAttrs = ngDevMode ? new TNodeInitialInputs() : [];
    let inputsStore = null;
    let outputsStore = null;
    for (let i = start; i < end; i++) {
      const directiveDef = tViewData[i];
      const directiveInputs = directiveDef.inputs;
      const initialInputs = tNodeAttrs !== null && !isInlineTemplate(tNode) ? generateInitialInputs(directiveInputs, tNodeAttrs) : null;
      inputsFromAttrs.push(initialInputs);
      inputsStore = generatePropertyAliases(directiveInputs, i, inputsStore);
      outputsStore = generatePropertyAliases(directiveDef.outputs, i, outputsStore);
    }
    if (inputsStore !== null) {
      if (inputsStore.hasOwnProperty("class")) {
        tNode.flags |= 16;
      }
      if (inputsStore.hasOwnProperty("style")) {
        tNode.flags |= 32;
      }
    }
    tNode.initialInputs = inputsFromAttrs;
    tNode.inputs = inputsStore;
    tNode.outputs = outputsStore;
  }
  function mapPropName(name) {
    if (name === "class")
      return "className";
    if (name === "for")
      return "htmlFor";
    if (name === "formaction")
      return "formAction";
    if (name === "innerHtml")
      return "innerHTML";
    if (name === "readonly")
      return "readOnly";
    if (name === "tabindex")
      return "tabIndex";
    return name;
  }
  function elementPropertyInternal(tView, tNode, lView, propName, value, renderer, sanitizer, nativeOnly) {
    ngDevMode && assertNotSame(value, NO_CHANGE, "Incoming value should never be NO_CHANGE.");
    const element = getNativeByTNode(tNode, lView);
    let inputData = tNode.inputs;
    let dataValue;
    if (!nativeOnly && inputData != null && (dataValue = inputData[propName])) {
      setInputsForProperty(tView, lView, dataValue, propName, value);
      if (isComponentHost(tNode))
        markDirtyIfOnPush(lView, tNode.index);
      if (ngDevMode) {
        setNgReflectProperties(lView, element, tNode.type, dataValue, value);
      }
    } else if (tNode.type & 3) {
      propName = mapPropName(propName);
      if (ngDevMode) {
        validateAgainstEventProperties(propName);
        if (!validateProperty(tView, element, propName, tNode)) {
          logUnknownPropertyError(propName, tNode);
          return;
        }
        ngDevMode.rendererSetProperty++;
      }
      value = sanitizer != null ? sanitizer(value, tNode.value || "", propName) : value;
      if (isProceduralRenderer(renderer)) {
        renderer.setProperty(element, propName, value);
      } else if (!isAnimationProp(propName)) {
        element.setProperty ? element.setProperty(propName, value) : element[propName] = value;
      }
    } else if (tNode.type & 12) {
      if (ngDevMode && !matchingSchemas(tView, tNode.value)) {
        logUnknownPropertyError(propName, tNode);
      }
    }
  }
  function markDirtyIfOnPush(lView, viewIndex) {
    ngDevMode && assertLView(lView);
    const childComponentLView = getComponentLViewByIndex(viewIndex, lView);
    if (!(childComponentLView[FLAGS] & 16)) {
      childComponentLView[FLAGS] |= 64;
    }
  }
  function setNgReflectProperty(lView, element, type, attrName, value) {
    const renderer = lView[RENDERER];
    attrName = normalizeDebugBindingName(attrName);
    const debugValue = normalizeDebugBindingValue(value);
    if (type & 3) {
      if (value == null) {
        isProceduralRenderer(renderer) ? renderer.removeAttribute(element, attrName) : element.removeAttribute(attrName);
      } else {
        isProceduralRenderer(renderer) ? renderer.setAttribute(element, attrName, debugValue) : element.setAttribute(attrName, debugValue);
      }
    } else {
      const textContent = escapeCommentText(`bindings=${JSON.stringify({ [attrName]: debugValue }, null, 2)}`);
      if (isProceduralRenderer(renderer)) {
        renderer.setValue(element, textContent);
      } else {
        element.textContent = textContent;
      }
    }
  }
  function setNgReflectProperties(lView, element, type, dataValue, value) {
    if (type & (3 | 4)) {
      for (let i = 0; i < dataValue.length; i += 2) {
        setNgReflectProperty(lView, element, type, dataValue[i + 1], value);
      }
    }
  }
  function validateProperty(tView, element, propName, tNode) {
    if (tView.schemas === null)
      return true;
    if (matchingSchemas(tView, tNode.value) || propName in element || isAnimationProp(propName)) {
      return true;
    }
    return typeof Node === "undefined" || Node === null || !(element instanceof Node);
  }
  function matchingSchemas(tView, tagName) {
    const schemas = tView.schemas;
    if (schemas !== null) {
      for (let i = 0; i < schemas.length; i++) {
        const schema = schemas[i];
        if (schema === NO_ERRORS_SCHEMA || schema === CUSTOM_ELEMENTS_SCHEMA && tagName && tagName.indexOf("-") > -1) {
          return true;
        }
      }
    }
    return false;
  }
  function logUnknownPropertyError(propName, tNode) {
    let message = `Can't bind to '${propName}' since it isn't a known property of '${tNode.value}'.`;
    console.error(formatRuntimeError("303", message));
  }
  function instantiateRootComponent(tView, lView, def) {
    const rootTNode = getCurrentTNode();
    if (tView.firstCreatePass) {
      if (def.providersResolver)
        def.providersResolver(def);
      const directiveIndex = allocExpando(tView, lView, 1, null);
      ngDevMode && assertEqual(directiveIndex, rootTNode.directiveStart, "Because this is a root component the allocated expando should match the TNode component.");
      configureViewWithDirective(tView, rootTNode, lView, directiveIndex, def);
    }
    const directive = getNodeInjectable(lView, tView, rootTNode.directiveStart, rootTNode);
    attachPatchData(directive, lView);
    const native = getNativeByTNode(rootTNode, lView);
    if (native) {
      attachPatchData(native, lView);
    }
    return directive;
  }
  function resolveDirectives(tView, lView, tNode, localRefs) {
    ngDevMode && assertFirstCreatePass(tView);
    let hasDirectives = false;
    if (getBindingsEnabled()) {
      const directiveDefs = findDirectiveDefMatches(tView, lView, tNode);
      const exportsMap = localRefs === null ? null : { "": -1 };
      if (directiveDefs !== null) {
        hasDirectives = true;
        initTNodeFlags(tNode, tView.data.length, directiveDefs.length);
        for (let i = 0; i < directiveDefs.length; i++) {
          const def = directiveDefs[i];
          if (def.providersResolver)
            def.providersResolver(def);
        }
        let preOrderHooksFound = false;
        let preOrderCheckHooksFound = false;
        let directiveIdx = allocExpando(tView, lView, directiveDefs.length, null);
        ngDevMode && assertSame(directiveIdx, tNode.directiveStart, "TNode.directiveStart should point to just allocated space");
        for (let i = 0; i < directiveDefs.length; i++) {
          const def = directiveDefs[i];
          tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);
          configureViewWithDirective(tView, tNode, lView, directiveIdx, def);
          saveNameToExportMap(directiveIdx, def, exportsMap);
          if (def.contentQueries !== null)
            tNode.flags |= 8;
          if (def.hostBindings !== null || def.hostAttrs !== null || def.hostVars !== 0)
            tNode.flags |= 128;
          const lifeCycleHooks = def.type.prototype;
          if (!preOrderHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngOnInit || lifeCycleHooks.ngDoCheck)) {
            (tView.preOrderHooks || (tView.preOrderHooks = [])).push(tNode.index);
            preOrderHooksFound = true;
          }
          if (!preOrderCheckHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngDoCheck)) {
            (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(tNode.index);
            preOrderCheckHooksFound = true;
          }
          directiveIdx++;
        }
        initializeInputAndOutputAliases(tView, tNode);
      }
      if (exportsMap)
        cacheMatchingLocalNames(tNode, localRefs, exportsMap);
    }
    tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);
    return hasDirectives;
  }
  function registerHostBindingOpCodes(tView, tNode, lView, directiveIdx, directiveVarsIdx, def) {
    ngDevMode && assertFirstCreatePass(tView);
    const hostBindings = def.hostBindings;
    if (hostBindings) {
      let hostBindingOpCodes = tView.hostBindingOpCodes;
      if (hostBindingOpCodes === null) {
        hostBindingOpCodes = tView.hostBindingOpCodes = [];
      }
      const elementIndx = ~tNode.index;
      if (lastSelectedElementIdx(hostBindingOpCodes) != elementIndx) {
        hostBindingOpCodes.push(elementIndx);
      }
      hostBindingOpCodes.push(directiveIdx, directiveVarsIdx, hostBindings);
    }
  }
  function lastSelectedElementIdx(hostBindingOpCodes) {
    let i = hostBindingOpCodes.length;
    while (i > 0) {
      const value = hostBindingOpCodes[--i];
      if (typeof value === "number" && value < 0) {
        return value;
      }
    }
    return 0;
  }
  function instantiateAllDirectives(tView, lView, tNode, native) {
    const start = tNode.directiveStart;
    const end = tNode.directiveEnd;
    if (!tView.firstCreatePass) {
      getOrCreateNodeInjectorForNode(tNode, lView);
    }
    attachPatchData(native, lView);
    const initialInputs = tNode.initialInputs;
    for (let i = start; i < end; i++) {
      const def = tView.data[i];
      const isComponent = isComponentDef(def);
      if (isComponent) {
        ngDevMode && assertTNodeType(tNode, 3);
        addComponentLogic(lView, tNode, def);
      }
      const directive = getNodeInjectable(lView, tView, i, tNode);
      attachPatchData(directive, lView);
      if (initialInputs !== null) {
        setInputsFromAttrs(lView, i - start, directive, def, tNode, initialInputs);
      }
      if (isComponent) {
        const componentView = getComponentLViewByIndex(tNode.index, lView);
        componentView[CONTEXT] = directive;
      }
    }
  }
  function invokeDirectivesHostBindings(tView, lView, tNode) {
    const start = tNode.directiveStart;
    const end = tNode.directiveEnd;
    const firstCreatePass = tView.firstCreatePass;
    const elementIndex = tNode.index;
    const currentDirectiveIndex = getCurrentDirectiveIndex();
    try {
      setSelectedIndex(elementIndex);
      for (let dirIndex = start; dirIndex < end; dirIndex++) {
        const def = tView.data[dirIndex];
        const directive = lView[dirIndex];
        setCurrentDirectiveIndex(dirIndex);
        if (def.hostBindings !== null || def.hostVars !== 0 || def.hostAttrs !== null) {
          invokeHostBindingsInCreationMode(def, directive);
        }
      }
    } finally {
      setSelectedIndex(-1);
      setCurrentDirectiveIndex(currentDirectiveIndex);
    }
  }
  function invokeHostBindingsInCreationMode(def, directive) {
    if (def.hostBindings !== null) {
      def.hostBindings(1, directive);
    }
  }
  function findDirectiveDefMatches(tView, viewData, tNode) {
    ngDevMode && assertFirstCreatePass(tView);
    ngDevMode && assertTNodeType(tNode, 3 | 12);
    const registry = tView.directiveRegistry;
    let matches = null;
    if (registry) {
      for (let i = 0; i < registry.length; i++) {
        const def = registry[i];
        if (isNodeMatchingSelectorList(tNode, def.selectors, false)) {
          matches || (matches = ngDevMode ? new MatchesArray() : []);
          diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, viewData), tView, def.type);
          if (isComponentDef(def)) {
            if (ngDevMode) {
              assertTNodeType(tNode, 2, `"${tNode.value}" tags cannot be used as component hosts. Please use a different tag to activate the ${stringify(def.type)} component.`);
              if (tNode.flags & 2)
                throwMultipleComponentError(tNode);
            }
            markAsComponentHost(tView, tNode);
            matches.unshift(def);
          } else {
            matches.push(def);
          }
        }
      }
    }
    return matches;
  }
  function markAsComponentHost(tView, hostTNode) {
    ngDevMode && assertFirstCreatePass(tView);
    hostTNode.flags |= 2;
    (tView.components || (tView.components = ngDevMode ? new TViewComponents() : [])).push(hostTNode.index);
  }
  function cacheMatchingLocalNames(tNode, localRefs, exportsMap) {
    if (localRefs) {
      const localNames = tNode.localNames = ngDevMode ? new TNodeLocalNames() : [];
      for (let i = 0; i < localRefs.length; i += 2) {
        const index = exportsMap[localRefs[i + 1]];
        if (index == null)
          throw new RuntimeError("301", `Export of name '${localRefs[i + 1]}' not found!`);
        localNames.push(localRefs[i], index);
      }
    }
  }
  function saveNameToExportMap(directiveIdx, def, exportsMap) {
    if (exportsMap) {
      if (def.exportAs) {
        for (let i = 0; i < def.exportAs.length; i++) {
          exportsMap[def.exportAs[i]] = directiveIdx;
        }
      }
      if (isComponentDef(def))
        exportsMap[""] = directiveIdx;
    }
  }
  function initTNodeFlags(tNode, index, numberOfDirectives) {
    ngDevMode && assertNotEqual(numberOfDirectives, tNode.directiveEnd - tNode.directiveStart, "Reached the max number of directives");
    tNode.flags |= 1;
    tNode.directiveStart = index;
    tNode.directiveEnd = index + numberOfDirectives;
    tNode.providerIndexes = index;
  }
  function configureViewWithDirective(tView, tNode, lView, directiveIndex, def) {
    ngDevMode && assertGreaterThanOrEqual(directiveIndex, HEADER_OFFSET, "Must be in Expando section");
    tView.data[directiveIndex] = def;
    const directiveFactory = def.factory || (def.factory = getFactoryDef(def.type, true));
    const nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, isComponentDef(def), null);
    tView.blueprint[directiveIndex] = nodeInjectorFactory;
    lView[directiveIndex] = nodeInjectorFactory;
    registerHostBindingOpCodes(tView, tNode, lView, directiveIndex, allocExpando(tView, lView, def.hostVars, NO_CHANGE), def);
  }
  function addComponentLogic(lView, hostTNode, def) {
    const native = getNativeByTNode(hostTNode, lView);
    const tView = getOrCreateTComponentView(def);
    const rendererFactory = lView[RENDERER_FACTORY];
    const componentView = addToViewTree(lView, createLView(lView, tView, null, def.onPush ? 64 : 16, native, hostTNode, rendererFactory, rendererFactory.createRenderer(native, def), null, null));
    lView[hostTNode.index] = componentView;
  }
  function elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace) {
    if (ngDevMode) {
      assertNotSame(value, NO_CHANGE, "Incoming value should never be NO_CHANGE.");
      validateAgainstEventAttributes(name);
      assertTNodeType(tNode, 2, `Attempted to set attribute \`${name}\` on a container node. Host bindings are not valid on ng-container or ng-template.`);
    }
    const element = getNativeByTNode(tNode, lView);
    setElementAttribute(lView[RENDERER], element, namespace, tNode.value, name, value, sanitizer);
  }
  function setElementAttribute(renderer, element, namespace, tagName, name, value, sanitizer) {
    if (value == null) {
      ngDevMode && ngDevMode.rendererRemoveAttribute++;
      isProceduralRenderer(renderer) ? renderer.removeAttribute(element, name, namespace) : element.removeAttribute(name);
    } else {
      ngDevMode && ngDevMode.rendererSetAttribute++;
      const strValue = sanitizer == null ? renderStringify(value) : sanitizer(value, tagName || "", name);
      if (isProceduralRenderer(renderer)) {
        renderer.setAttribute(element, name, strValue, namespace);
      } else {
        namespace ? element.setAttributeNS(namespace, name, strValue) : element.setAttribute(name, strValue);
      }
    }
  }
  function setInputsFromAttrs(lView, directiveIndex, instance, def, tNode, initialInputData) {
    const initialInputs = initialInputData[directiveIndex];
    if (initialInputs !== null) {
      const setInput = def.setInput;
      for (let i = 0; i < initialInputs.length; ) {
        const publicName = initialInputs[i++];
        const privateName = initialInputs[i++];
        const value = initialInputs[i++];
        if (setInput !== null) {
          def.setInput(instance, value, publicName, privateName);
        } else {
          instance[privateName] = value;
        }
        if (ngDevMode) {
          const nativeElement = getNativeByTNode(tNode, lView);
          setNgReflectProperty(lView, nativeElement, tNode.type, privateName, value);
        }
      }
    }
  }
  function generateInitialInputs(inputs, attrs) {
    let inputsToStore = null;
    let i = 0;
    while (i < attrs.length) {
      const attrName = attrs[i];
      if (attrName === 0) {
        i += 4;
        continue;
      } else if (attrName === 5) {
        i += 2;
        continue;
      }
      if (typeof attrName === "number")
        break;
      if (inputs.hasOwnProperty(attrName)) {
        if (inputsToStore === null)
          inputsToStore = [];
        inputsToStore.push(attrName, inputs[attrName], attrs[i + 1]);
      }
      i += 2;
    }
    return inputsToStore;
  }
  var LContainerArray = class LContainer extends Array {
  };
  function createLContainer(hostNative, currentView, native, tNode) {
    ngDevMode && assertLView(currentView);
    ngDevMode && !isProceduralRenderer(currentView[RENDERER]) && assertDomNode(native);
    const lContainer = new (ngDevMode ? LContainerArray : Array)(hostNative, true, false, currentView, null, 0, tNode, native, null, null);
    ngDevMode && assertEqual(lContainer.length, CONTAINER_HEADER_OFFSET, "Should allocate correct number of slots for LContainer header.");
    ngDevMode && attachLContainerDebug(lContainer);
    return lContainer;
  }
  function refreshEmbeddedViews(lView) {
    for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
      for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
        const embeddedLView = lContainer[i];
        const embeddedTView = embeddedLView[TVIEW];
        ngDevMode && assertDefined(embeddedTView, "TView must be allocated");
        if (viewAttachedToChangeDetector(embeddedLView)) {
          refreshView(embeddedTView, embeddedLView, embeddedTView.template, embeddedLView[CONTEXT]);
        }
      }
    }
  }
  function markTransplantedViewsForRefresh(lView) {
    for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
      if (!lContainer[HAS_TRANSPLANTED_VIEWS])
        continue;
      const movedViews = lContainer[MOVED_VIEWS];
      ngDevMode && assertDefined(movedViews, "Transplanted View flags set but missing MOVED_VIEWS");
      for (let i = 0; i < movedViews.length; i++) {
        const movedLView = movedViews[i];
        const insertionLContainer = movedLView[PARENT];
        ngDevMode && assertLContainer(insertionLContainer);
        if ((movedLView[FLAGS] & 1024) === 0) {
          updateTransplantedViewCount(insertionLContainer, 1);
        }
        movedLView[FLAGS] |= 1024;
      }
    }
  }
  function refreshComponent(hostLView, componentHostIdx) {
    ngDevMode && assertEqual(isCreationMode(hostLView), false, "Should be run in update mode");
    const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);
    if (viewAttachedToChangeDetector(componentView)) {
      const tView = componentView[TVIEW];
      if (componentView[FLAGS] & (16 | 64)) {
        refreshView(tView, componentView, tView.template, componentView[CONTEXT]);
      } else if (componentView[TRANSPLANTED_VIEWS_TO_REFRESH] > 0) {
        refreshContainsDirtyView(componentView);
      }
    }
  }
  function refreshContainsDirtyView(lView) {
    for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {
      for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
        const embeddedLView = lContainer[i];
        if (embeddedLView[FLAGS] & 1024) {
          const embeddedTView = embeddedLView[TVIEW];
          ngDevMode && assertDefined(embeddedTView, "TView must be allocated");
          refreshView(embeddedTView, embeddedLView, embeddedTView.template, embeddedLView[CONTEXT]);
        } else if (embeddedLView[TRANSPLANTED_VIEWS_TO_REFRESH] > 0) {
          refreshContainsDirtyView(embeddedLView);
        }
      }
    }
    const tView = lView[TVIEW];
    const components = tView.components;
    if (components !== null) {
      for (let i = 0; i < components.length; i++) {
        const componentView = getComponentLViewByIndex(components[i], lView);
        if (viewAttachedToChangeDetector(componentView) && componentView[TRANSPLANTED_VIEWS_TO_REFRESH] > 0) {
          refreshContainsDirtyView(componentView);
        }
      }
    }
  }
  function renderComponent$1(hostLView, componentHostIdx) {
    ngDevMode && assertEqual(isCreationMode(hostLView), true, "Should be run in creation mode");
    const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);
    const componentTView = componentView[TVIEW];
    syncViewWithBlueprint(componentTView, componentView);
    renderView(componentTView, componentView, componentView[CONTEXT]);
  }
  function syncViewWithBlueprint(tView, lView) {
    for (let i = lView.length; i < tView.blueprint.length; i++) {
      lView.push(tView.blueprint[i]);
    }
  }
  function addToViewTree(lView, lViewOrLContainer) {
    if (lView[CHILD_HEAD]) {
      lView[CHILD_TAIL][NEXT] = lViewOrLContainer;
    } else {
      lView[CHILD_HEAD] = lViewOrLContainer;
    }
    lView[CHILD_TAIL] = lViewOrLContainer;
    return lViewOrLContainer;
  }
  function markViewDirty(lView) {
    while (lView) {
      lView[FLAGS] |= 64;
      const parent = getLViewParent(lView);
      if (isRootView(lView) && !parent) {
        return lView;
      }
      lView = parent;
    }
    return null;
  }
  function scheduleTick(rootContext, flags) {
    const nothingScheduled = rootContext.flags === 0;
    if (nothingScheduled && rootContext.clean == _CLEAN_PROMISE) {
      rootContext.flags |= flags;
      let res;
      rootContext.clean = new Promise((r) => res = r);
      rootContext.scheduler(() => {
        if (rootContext.flags & 1) {
          rootContext.flags &= ~1;
          tickRootContext(rootContext);
        }
        if (rootContext.flags & 2) {
          rootContext.flags &= ~2;
          const playerHandler = rootContext.playerHandler;
          if (playerHandler) {
            playerHandler.flushPlayers();
          }
        }
        rootContext.clean = _CLEAN_PROMISE;
        res(null);
      });
    }
  }
  function tickRootContext(rootContext) {
    for (let i = 0; i < rootContext.components.length; i++) {
      const rootComponent = rootContext.components[i];
      const lView = readPatchedLView(rootComponent);
      const tView = lView[TVIEW];
      renderComponentOrTemplate(tView, lView, tView.template, rootComponent);
    }
  }
  function detectChangesInternal(tView, lView, context2) {
    const rendererFactory = lView[RENDERER_FACTORY];
    if (rendererFactory.begin)
      rendererFactory.begin();
    try {
      refreshView(tView, lView, tView.template, context2);
    } catch (error3) {
      handleError(lView, error3);
      throw error3;
    } finally {
      if (rendererFactory.end)
        rendererFactory.end();
    }
  }
  function detectChangesInRootView(lView) {
    tickRootContext(lView[CONTEXT]);
  }
  function checkNoChangesInternal(tView, view, context2) {
    setIsInCheckNoChangesMode(true);
    try {
      detectChangesInternal(tView, view, context2);
    } finally {
      setIsInCheckNoChangesMode(false);
    }
  }
  function checkNoChangesInRootView(lView) {
    setIsInCheckNoChangesMode(true);
    try {
      detectChangesInRootView(lView);
    } finally {
      setIsInCheckNoChangesMode(false);
    }
  }
  function executeViewQueryFn(flags, viewQueryFn, component) {
    ngDevMode && assertDefined(viewQueryFn, "View queries function to execute must be defined.");
    setCurrentQueryIndex(0);
    viewQueryFn(flags, component);
  }
  function storePropertyBindingMetadata(tData, tNode, propertyName, bindingIndex, ...interpolationParts) {
    if (tData[bindingIndex] === null) {
      if (tNode.inputs == null || !tNode.inputs[propertyName]) {
        const propBindingIdxs = tNode.propertyBindings || (tNode.propertyBindings = []);
        propBindingIdxs.push(bindingIndex);
        let bindingMetadata = propertyName;
        if (interpolationParts.length > 0) {
          bindingMetadata += INTERPOLATION_DELIMITER + interpolationParts.join(INTERPOLATION_DELIMITER);
        }
        tData[bindingIndex] = bindingMetadata;
      }
    }
  }
  var CLEAN_PROMISE = _CLEAN_PROMISE;
  function getOrCreateLViewCleanup(view) {
    return view[CLEANUP] || (view[CLEANUP] = ngDevMode ? new LCleanup() : []);
  }
  function getOrCreateTViewCleanup(tView) {
    return tView.cleanup || (tView.cleanup = ngDevMode ? new TCleanup() : []);
  }
  function loadComponentRenderer(currentDef, tNode, lView) {
    if (currentDef === null || isComponentDef(currentDef)) {
      lView = unwrapLView(lView[tNode.index]);
    }
    return lView[RENDERER];
  }
  function handleError(lView, error3) {
    const injector = lView[INJECTOR$1];
    const errorHandler2 = injector ? injector.get(ErrorHandler, null) : null;
    errorHandler2 && errorHandler2.handleError(error3);
  }
  function setInputsForProperty(tView, lView, inputs, publicName, value) {
    for (let i = 0; i < inputs.length; ) {
      const index = inputs[i++];
      const privateName = inputs[i++];
      const instance = lView[index];
      ngDevMode && assertIndexInRange(lView, index);
      const def = tView.data[index];
      if (def.setInput !== null) {
        def.setInput(instance, value, publicName, privateName);
      } else {
        instance[privateName] = value;
      }
    }
  }
  function textBindingInternal(lView, index, value) {
    ngDevMode && assertString(value, "Value should be a string");
    ngDevMode && assertNotSame(value, NO_CHANGE, "value should not be NO_CHANGE");
    ngDevMode && assertIndexInRange(lView, index);
    const element = getNativeByIndex(index, lView);
    ngDevMode && assertDefined(element, "native element should exist");
    updateTextNode(lView[RENDERER], element, value);
  }
  function computeStaticStyling(tNode, attrs, writeToHost) {
    ngDevMode && assertFirstCreatePass(getTView(), "Expecting to be called in first template pass only");
    let styles = writeToHost ? tNode.styles : null;
    let classes = writeToHost ? tNode.classes : null;
    let mode = 0;
    if (attrs !== null) {
      for (let i = 0; i < attrs.length; i++) {
        const value = attrs[i];
        if (typeof value === "number") {
          mode = value;
        } else if (mode == 1) {
          classes = concatStringsWithSpace(classes, value);
        } else if (mode == 2) {
          const style = value;
          const styleValue = attrs[++i];
          styles = concatStringsWithSpace(styles, style + ": " + styleValue + ";");
        }
      }
    }
    writeToHost ? tNode.styles = styles : tNode.stylesWithoutHost = styles;
    writeToHost ? tNode.classes = classes : tNode.classesWithoutHost = classes;
  }
  function detectChanges(component) {
    const view = getComponentViewByInstance(component);
    detectChangesInternal(view[TVIEW], view, component);
  }
  function markDirty(component) {
    ngDevMode && assertDefined(component, "component");
    const rootView = markViewDirty(getComponentViewByInstance(component));
    ngDevMode && assertDefined(rootView[CONTEXT], "rootContext should be defined");
    scheduleTick(rootView[CONTEXT], 1);
  }
  var INJECTOR = new InjectionToken("INJECTOR", -1);
  var NullInjector = class {
    get(token, notFoundValue = THROW_IF_NOT_FOUND) {
      if (notFoundValue === THROW_IF_NOT_FOUND) {
        const error3 = new Error(`NullInjectorError: No provider for ${stringify(token)}!`);
        error3.name = "NullInjectorError";
        throw error3;
      }
      return notFoundValue;
    }
  };
  var INJECTOR_SCOPE = new InjectionToken("Set Injector scope.");
  var NOT_YET = {};
  var CIRCULAR = {};
  var NULL_INJECTOR$1 = void 0;
  function getNullInjector() {
    if (NULL_INJECTOR$1 === void 0) {
      NULL_INJECTOR$1 = new NullInjector();
    }
    return NULL_INJECTOR$1;
  }
  function createInjector(defType, parent = null, additionalProviders = null, name) {
    const injector = createInjectorWithoutInjectorInstances(defType, parent, additionalProviders, name);
    injector._resolveInjectorDefTypes();
    return injector;
  }
  function createInjectorWithoutInjectorInstances(defType, parent = null, additionalProviders = null, name) {
    return new R3Injector(defType, additionalProviders, parent || getNullInjector(), name);
  }
  var R3Injector = class {
    constructor(def, additionalProviders, parent, source = null) {
      this.parent = parent;
      this.records = /* @__PURE__ */ new Map();
      this.injectorDefTypes = /* @__PURE__ */ new Set();
      this.onDestroy = /* @__PURE__ */ new Set();
      this._destroyed = false;
      const dedupStack = [];
      additionalProviders && deepForEach(additionalProviders, (provider) => this.processProvider(provider, def, additionalProviders));
      deepForEach([def], (injectorDef) => this.processInjectorType(injectorDef, [], dedupStack));
      this.records.set(INJECTOR, makeRecord(void 0, this));
      const record = this.records.get(INJECTOR_SCOPE);
      this.scope = record != null ? record.value : null;
      this.source = source || (typeof def === "object" ? null : stringify(def));
    }
    get destroyed() {
      return this._destroyed;
    }
    destroy() {
      this.assertNotDestroyed();
      this._destroyed = true;
      try {
        this.onDestroy.forEach((service) => service.ngOnDestroy());
      } finally {
        this.records.clear();
        this.onDestroy.clear();
        this.injectorDefTypes.clear();
      }
    }
    get(token, notFoundValue = THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {
      this.assertNotDestroyed();
      const previousInjector = setCurrentInjector(this);
      const previousInjectImplementation = setInjectImplementation(void 0);
      try {
        if (!(flags & InjectFlags.SkipSelf)) {
          let record = this.records.get(token);
          if (record === void 0) {
            const def = couldBeInjectableType(token) && getInjectableDef(token);
            if (def && this.injectableDefInScope(def)) {
              record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET);
            } else {
              record = null;
            }
            this.records.set(token, record);
          }
          if (record != null) {
            return this.hydrate(token, record);
          }
        }
        const nextInjector = !(flags & InjectFlags.Self) ? this.parent : getNullInjector();
        notFoundValue = flags & InjectFlags.Optional && notFoundValue === THROW_IF_NOT_FOUND ? null : notFoundValue;
        return nextInjector.get(token, notFoundValue);
      } catch (e) {
        if (e.name === "NullInjectorError") {
          const path = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];
          path.unshift(stringify(token));
          if (previousInjector) {
            throw e;
          } else {
            return catchInjectorError(e, token, "R3InjectorError", this.source);
          }
        } else {
          throw e;
        }
      } finally {
        setInjectImplementation(previousInjectImplementation);
        setCurrentInjector(previousInjector);
      }
    }
    _resolveInjectorDefTypes() {
      this.injectorDefTypes.forEach((defType) => this.get(defType));
    }
    toString() {
      const tokens = [], records = this.records;
      records.forEach((v, token) => tokens.push(stringify(token)));
      return `R3Injector[${tokens.join(", ")}]`;
    }
    assertNotDestroyed() {
      if (this._destroyed) {
        throw new Error("Injector has already been destroyed.");
      }
    }
    processInjectorType(defOrWrappedDef, parents, dedupStack) {
      defOrWrappedDef = resolveForwardRef(defOrWrappedDef);
      if (!defOrWrappedDef)
        return false;
      let def = getInjectorDef(defOrWrappedDef);
      const ngModule = def == null && defOrWrappedDef.ngModule || void 0;
      const defType = ngModule === void 0 ? defOrWrappedDef : ngModule;
      if (ngDevMode && parents.indexOf(defType) !== -1) {
        const defName = stringify(defType);
        const path = parents.map(stringify);
        throwCyclicDependencyError(defName, path);
      }
      const isDuplicate = dedupStack.indexOf(defType) !== -1;
      if (ngModule !== void 0) {
        def = getInjectorDef(ngModule);
      }
      if (def == null) {
        return false;
      }
      if (def.imports != null && !isDuplicate) {
        ngDevMode && parents.push(defType);
        dedupStack.push(defType);
        let importTypesWithProviders;
        try {
          deepForEach(def.imports, (imported) => {
            if (this.processInjectorType(imported, parents, dedupStack)) {
              if (importTypesWithProviders === void 0)
                importTypesWithProviders = [];
              importTypesWithProviders.push(imported);
            }
          });
        } finally {
          ngDevMode && parents.pop();
        }
        if (importTypesWithProviders !== void 0) {
          for (let i = 0; i < importTypesWithProviders.length; i++) {
            const { ngModule: ngModule2, providers } = importTypesWithProviders[i];
            deepForEach(providers, (provider) => this.processProvider(provider, ngModule2, providers || EMPTY_ARRAY));
          }
        }
      }
      this.injectorDefTypes.add(defType);
      const factory = getFactoryDef(defType) || (() => new defType());
      this.records.set(defType, makeRecord(factory, NOT_YET));
      const defProviders = def.providers;
      if (defProviders != null && !isDuplicate) {
        const injectorType = defOrWrappedDef;
        deepForEach(defProviders, (provider) => this.processProvider(provider, injectorType, defProviders));
      }
      return ngModule !== void 0 && defOrWrappedDef.providers !== void 0;
    }
    processProvider(provider, ngModuleType, providers) {
      provider = resolveForwardRef(provider);
      let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider && provider.provide);
      const record = providerToRecord(provider, ngModuleType, providers);
      if (!isTypeProvider(provider) && provider.multi === true) {
        let multiRecord = this.records.get(token);
        if (multiRecord) {
          if (ngDevMode && multiRecord.multi === void 0) {
            throwMixedMultiProviderError();
          }
        } else {
          multiRecord = makeRecord(void 0, NOT_YET, true);
          multiRecord.factory = () => injectArgs(multiRecord.multi);
          this.records.set(token, multiRecord);
        }
        token = provider;
        multiRecord.multi.push(provider);
      } else {
        const existing = this.records.get(token);
        if (ngDevMode && existing && existing.multi !== void 0) {
          throwMixedMultiProviderError();
        }
      }
      this.records.set(token, record);
    }
    hydrate(token, record) {
      if (ngDevMode && record.value === CIRCULAR) {
        throwCyclicDependencyError(stringify(token));
      } else if (record.value === NOT_YET) {
        record.value = CIRCULAR;
        record.value = record.factory();
      }
      if (typeof record.value === "object" && record.value && hasOnDestroy(record.value)) {
        this.onDestroy.add(record.value);
      }
      return record.value;
    }
    injectableDefInScope(def) {
      if (!def.providedIn) {
        return false;
      }
      const providedIn = resolveForwardRef(def.providedIn);
      if (typeof providedIn === "string") {
        return providedIn === "any" || providedIn === this.scope;
      } else {
        return this.injectorDefTypes.has(providedIn);
      }
    }
  };
  function injectableDefOrInjectorDefFactory(token) {
    const injectableDef = getInjectableDef(token);
    const factory = injectableDef !== null ? injectableDef.factory : getFactoryDef(token);
    if (factory !== null) {
      return factory;
    }
    if (token instanceof InjectionToken) {
      throw new Error(`Token ${stringify(token)} is missing a \u0275prov definition.`);
    }
    if (token instanceof Function) {
      return getUndecoratedInjectableFactory(token);
    }
    throw new Error("unreachable");
  }
  function getUndecoratedInjectableFactory(token) {
    const paramLength = token.length;
    if (paramLength > 0) {
      const args = newArray(paramLength, "?");
      throw new Error(`Can't resolve all parameters for ${stringify(token)}: (${args.join(", ")}).`);
    }
    const inheritedInjectableDef = getInheritedInjectableDef(token);
    if (inheritedInjectableDef !== null) {
      return () => inheritedInjectableDef.factory(token);
    } else {
      return () => new token();
    }
  }
  function providerToRecord(provider, ngModuleType, providers) {
    if (isValueProvider(provider)) {
      return makeRecord(void 0, provider.useValue);
    } else {
      const factory = providerToFactory(provider, ngModuleType, providers);
      return makeRecord(factory, NOT_YET);
    }
  }
  function providerToFactory(provider, ngModuleType, providers) {
    let factory = void 0;
    if (isTypeProvider(provider)) {
      const unwrappedProvider = resolveForwardRef(provider);
      return getFactoryDef(unwrappedProvider) || injectableDefOrInjectorDefFactory(unwrappedProvider);
    } else {
      if (isValueProvider(provider)) {
        factory = () => resolveForwardRef(provider.useValue);
      } else if (isFactoryProvider(provider)) {
        factory = () => provider.useFactory(...injectArgs(provider.deps || []));
      } else if (isExistingProvider(provider)) {
        factory = () => \u0275\u0275inject(resolveForwardRef(provider.useExisting));
      } else {
        const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));
        if (ngDevMode && !classRef) {
          throwInvalidProviderError(ngModuleType, providers, provider);
        }
        if (hasDeps(provider)) {
          factory = () => new classRef(...injectArgs(provider.deps));
        } else {
          return getFactoryDef(classRef) || injectableDefOrInjectorDefFactory(classRef);
        }
      }
    }
    return factory;
  }
  function makeRecord(factory, value, multi = false) {
    return {
      factory,
      value,
      multi: multi ? [] : void 0
    };
  }
  function isValueProvider(value) {
    return value !== null && typeof value == "object" && USE_VALUE$1 in value;
  }
  function isExistingProvider(value) {
    return !!(value && value.useExisting);
  }
  function isFactoryProvider(value) {
    return !!(value && value.useFactory);
  }
  function isTypeProvider(value) {
    return typeof value === "function";
  }
  function isClassProvider(value) {
    return !!value.useClass;
  }
  function hasDeps(value) {
    return !!value.deps;
  }
  function hasOnDestroy(value) {
    return value !== null && typeof value === "object" && typeof value.ngOnDestroy === "function";
  }
  function couldBeInjectableType(value) {
    return typeof value === "function" || typeof value === "object" && value instanceof InjectionToken;
  }
  var Injector = class {
    static create(options, parent) {
      if (Array.isArray(options)) {
        return createInjector({ name: "" }, parent, options, "");
      } else {
        const name = options.name ?? "";
        return createInjector({ name }, options.parent, options.providers, name);
      }
    }
  };
  Injector.THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;
  Injector.NULL = /* @__PURE__ */ new NullInjector();
  Injector.\u0275prov = \u0275\u0275defineInjectable({
    token: Injector,
    providedIn: "any",
    factory: () => \u0275\u0275inject(INJECTOR)
  });
  Injector.__NG_ELEMENT_ID__ = -1;
  function getComponent$1(element) {
    assertDomElement(element);
    const context2 = getLContext(element);
    if (context2 === null)
      return null;
    if (context2.component === void 0) {
      context2.component = getComponentAtNodeIndex(context2.nodeIndex, context2.lView);
    }
    return context2.component;
  }
  function getContext(element) {
    assertDomElement(element);
    const context2 = getLContext(element);
    return context2 === null ? null : context2.lView[CONTEXT];
  }
  function getOwningComponent(elementOrDir) {
    const context2 = getLContext(elementOrDir);
    if (context2 === null)
      return null;
    let lView = context2.lView;
    let parent;
    ngDevMode && assertLView(lView);
    while (lView[TVIEW].type === 2 && (parent = getLViewParent(lView))) {
      lView = parent;
    }
    return lView[FLAGS] & 512 ? null : lView[CONTEXT];
  }
  function getRootComponents(elementOrDir) {
    return [...getRootContext(elementOrDir).components];
  }
  function getInjector(elementOrDir) {
    const context2 = getLContext(elementOrDir);
    if (context2 === null)
      return Injector.NULL;
    const tNode = context2.lView[TVIEW].data[context2.nodeIndex];
    return new NodeInjector(tNode, context2.lView);
  }
  function getInjectionTokens(element) {
    const context2 = getLContext(element);
    if (context2 === null)
      return [];
    const lView = context2.lView;
    const tView = lView[TVIEW];
    const tNode = tView.data[context2.nodeIndex];
    const providerTokens = [];
    const startIndex = tNode.providerIndexes & 1048575;
    const endIndex = tNode.directiveEnd;
    for (let i = startIndex; i < endIndex; i++) {
      let value = tView.data[i];
      if (isDirectiveDefHack(value)) {
        value = value.type;
      }
      providerTokens.push(value);
    }
    return providerTokens;
  }
  function getDirectives(node) {
    if (node instanceof Text) {
      return [];
    }
    const context2 = getLContext(node);
    if (context2 === null) {
      return [];
    }
    const lView = context2.lView;
    const tView = lView[TVIEW];
    const nodeIndex = context2.nodeIndex;
    if (!tView?.data[nodeIndex]) {
      return [];
    }
    if (context2.directives === void 0) {
      context2.directives = getDirectivesAtNodeIndex(nodeIndex, lView, false);
    }
    return context2.directives === null ? [] : [...context2.directives];
  }
  function getDirectiveMetadata$1(directiveOrComponentInstance) {
    const { constructor } = directiveOrComponentInstance;
    if (!constructor) {
      throw new Error("Unable to find the instance constructor");
    }
    const componentDef = getComponentDef(constructor);
    if (componentDef) {
      return {
        inputs: componentDef.inputs,
        outputs: componentDef.outputs,
        encapsulation: componentDef.encapsulation,
        changeDetection: componentDef.onPush ? ChangeDetectionStrategy.OnPush : ChangeDetectionStrategy.Default
      };
    }
    const directiveDef = getDirectiveDef(constructor);
    if (directiveDef) {
      return { inputs: directiveDef.inputs, outputs: directiveDef.outputs };
    }
    return null;
  }
  function getLocalRefs(target) {
    const context2 = getLContext(target);
    if (context2 === null)
      return {};
    if (context2.localRefs === void 0) {
      context2.localRefs = discoverLocalRefs(context2.lView, context2.nodeIndex);
    }
    return context2.localRefs || {};
  }
  function getHostElement(componentOrDirective) {
    return getLContext(componentOrDirective).native;
  }
  function getListeners(element) {
    assertDomElement(element);
    const lContext = getLContext(element);
    if (lContext === null)
      return [];
    const lView = lContext.lView;
    const tView = lView[TVIEW];
    const lCleanup = lView[CLEANUP];
    const tCleanup = tView.cleanup;
    const listeners = [];
    if (tCleanup && lCleanup) {
      for (let i = 0; i < tCleanup.length; ) {
        const firstParam = tCleanup[i++];
        const secondParam = tCleanup[i++];
        if (typeof firstParam === "string") {
          const name = firstParam;
          const listenerElement = unwrapRNode(lView[secondParam]);
          const callback = lCleanup[tCleanup[i++]];
          const useCaptureOrIndx = tCleanup[i++];
          const type = typeof useCaptureOrIndx === "boolean" || useCaptureOrIndx >= 0 ? "dom" : "output";
          const useCapture = typeof useCaptureOrIndx === "boolean" ? useCaptureOrIndx : false;
          if (element == listenerElement) {
            listeners.push({ element, name, callback, useCapture, type });
          }
        }
      }
    }
    listeners.sort(sortListeners);
    return listeners;
  }
  function sortListeners(a, b) {
    if (a.name == b.name)
      return 0;
    return a.name < b.name ? -1 : 1;
  }
  function isDirectiveDefHack(obj) {
    return obj.type !== void 0 && obj.template !== void 0 && obj.declaredInputs !== void 0;
  }
  function assertDomElement(value) {
    if (typeof Element !== "undefined" && !(value instanceof Element)) {
      throw new Error("Expecting instance of DOM Element");
    }
  }
  function applyChanges(component) {
    markDirty(component);
    getRootComponents(component).forEach((rootComponent) => detectChanges(rootComponent));
  }
  var GLOBAL_PUBLISH_EXPANDO_KEY = "ng";
  var _published = false;
  function publishDefaultGlobalUtils$1() {
    if (!_published) {
      _published = true;
      publishGlobalUtil("\u0275setProfiler", setProfiler);
      publishGlobalUtil("getDirectiveMetadata", getDirectiveMetadata$1);
      publishGlobalUtil("getComponent", getComponent$1);
      publishGlobalUtil("getContext", getContext);
      publishGlobalUtil("getListeners", getListeners);
      publishGlobalUtil("getOwningComponent", getOwningComponent);
      publishGlobalUtil("getHostElement", getHostElement);
      publishGlobalUtil("getInjector", getInjector);
      publishGlobalUtil("getRootComponents", getRootComponents);
      publishGlobalUtil("getDirectives", getDirectives);
      publishGlobalUtil("applyChanges", applyChanges);
    }
  }
  function publishGlobalUtil(name, fn2) {
    if (typeof COMPILED === "undefined" || !COMPILED) {
      const w = _global2;
      ngDevMode && assertDefined(fn2, "function not defined");
      if (w) {
        let container = w[GLOBAL_PUBLISH_EXPANDO_KEY];
        if (!container) {
          container = w[GLOBAL_PUBLISH_EXPANDO_KEY] = {};
        }
        container[name] = fn2;
      }
    }
  }
  function renderComponent(componentType, opts = {}) {
    ngDevMode && publishDefaultGlobalUtils$1();
    ngDevMode && assertComponentType(componentType);
    const rendererFactory = opts.rendererFactory || domRendererFactory3;
    const sanitizer = opts.sanitizer || null;
    const componentDef = getComponentDef(componentType);
    if (componentDef.type != componentType)
      componentDef.type = componentType;
    const componentTag = componentDef.selectors[0][0];
    const hostRenderer = rendererFactory.createRenderer(null, null);
    const hostRNode = locateHostElement(hostRenderer, opts.host || componentTag, componentDef.encapsulation);
    const rootFlags = componentDef.onPush ? 64 | 512 : 16 | 512;
    const rootContext = createRootContext(opts.scheduler, opts.playerHandler);
    const renderer = rendererFactory.createRenderer(hostRNode, componentDef);
    const rootTView = createTView(0, null, null, 1, 0, null, null, null, null, null);
    const rootView = createLView(null, rootTView, rootContext, rootFlags, null, null, rendererFactory, renderer, null, opts.injector || null);
    enterView(rootView);
    let component;
    try {
      if (rendererFactory.begin)
        rendererFactory.begin();
      const componentView = createRootComponentView(hostRNode, componentDef, rootView, rendererFactory, renderer, sanitizer);
      component = createRootComponent(componentView, componentDef, rootView, rootContext, opts.hostFeatures || null);
      renderView(rootTView, rootView, null);
      refreshView(rootTView, rootView, null, null);
    } finally {
      leaveView();
      if (rendererFactory.end)
        rendererFactory.end();
    }
    return component;
  }
  function createRootComponentView(rNode, def, rootView, rendererFactory, hostRenderer, sanitizer) {
    const tView = rootView[TVIEW];
    const index = HEADER_OFFSET;
    ngDevMode && assertIndexInRange(rootView, index);
    rootView[index] = rNode;
    const tNode = getOrCreateTNode(tView, index, 2, "#host", null);
    const mergedAttrs = tNode.mergedAttrs = def.hostAttrs;
    if (mergedAttrs !== null) {
      computeStaticStyling(tNode, mergedAttrs, true);
      if (rNode !== null) {
        setUpAttributes(hostRenderer, rNode, mergedAttrs);
        if (tNode.classes !== null) {
          writeDirectClass(hostRenderer, rNode, tNode.classes);
        }
        if (tNode.styles !== null) {
          writeDirectStyle(hostRenderer, rNode, tNode.styles);
        }
      }
    }
    const viewRenderer = rendererFactory.createRenderer(rNode, def);
    const componentView = createLView(rootView, getOrCreateTComponentView(def), null, def.onPush ? 64 : 16, rootView[index], tNode, rendererFactory, viewRenderer, sanitizer || null, null);
    if (tView.firstCreatePass) {
      diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, rootView), tView, def.type);
      markAsComponentHost(tView, tNode);
      initTNodeFlags(tNode, rootView.length, 1);
    }
    addToViewTree(rootView, componentView);
    return rootView[index] = componentView;
  }
  function createRootComponent(componentView, componentDef, rootLView, rootContext, hostFeatures) {
    const tView = rootLView[TVIEW];
    const component = instantiateRootComponent(tView, rootLView, componentDef);
    rootContext.components.push(component);
    componentView[CONTEXT] = component;
    hostFeatures && hostFeatures.forEach((feature) => feature(component, componentDef));
    if (componentDef.contentQueries) {
      const tNode = getCurrentTNode();
      ngDevMode && assertDefined(tNode, "TNode expected");
      componentDef.contentQueries(1, component, tNode.directiveStart);
    }
    const rootTNode = getCurrentTNode();
    ngDevMode && assertDefined(rootTNode, "tNode should have been already created");
    if (tView.firstCreatePass && (componentDef.hostBindings !== null || componentDef.hostAttrs !== null)) {
      setSelectedIndex(rootTNode.index);
      const rootTView = rootLView[TVIEW];
      registerHostBindingOpCodes(rootTView, rootTNode, rootLView, rootTNode.directiveStart, rootTNode.directiveEnd, componentDef);
      invokeHostBindingsInCreationMode(componentDef, component);
    }
    return component;
  }
  function createRootContext(scheduler, playerHandler) {
    return {
      components: [],
      scheduler: scheduler || defaultScheduler,
      clean: CLEAN_PROMISE,
      playerHandler: playerHandler || null,
      flags: 0
    };
  }
  function LifecycleHooksFeature(component, def) {
    const lView = readPatchedLView(component);
    ngDevMode && assertDefined(lView, "LView is required");
    const tView = lView[TVIEW];
    const tNode = getCurrentTNode();
    ngDevMode && assertDefined(tNode, "TNode is required");
    registerPostOrderHooks(tView, tNode);
  }
  function whenRendered(component) {
    return getRootContext(component).clean;
  }
  function getSuperType(type) {
    return Object.getPrototypeOf(type.prototype).constructor;
  }
  function \u0275\u0275InheritDefinitionFeature(definition) {
    let superType = getSuperType(definition.type);
    let shouldInheritFields = true;
    const inheritanceChain = [definition];
    while (superType) {
      let superDef = void 0;
      if (isComponentDef(definition)) {
        superDef = superType.\u0275cmp || superType.\u0275dir;
      } else {
        if (superType.\u0275cmp) {
          throw new Error("Directives cannot inherit Components");
        }
        superDef = superType.\u0275dir;
      }
      if (superDef) {
        if (shouldInheritFields) {
          inheritanceChain.push(superDef);
          const writeableDef = definition;
          writeableDef.inputs = maybeUnwrapEmpty(definition.inputs);
          writeableDef.declaredInputs = maybeUnwrapEmpty(definition.declaredInputs);
          writeableDef.outputs = maybeUnwrapEmpty(definition.outputs);
          const superHostBindings = superDef.hostBindings;
          superHostBindings && inheritHostBindings(definition, superHostBindings);
          const superViewQuery = superDef.viewQuery;
          const superContentQueries = superDef.contentQueries;
          superViewQuery && inheritViewQuery(definition, superViewQuery);
          superContentQueries && inheritContentQueries(definition, superContentQueries);
          fillProperties(definition.inputs, superDef.inputs);
          fillProperties(definition.declaredInputs, superDef.declaredInputs);
          fillProperties(definition.outputs, superDef.outputs);
          if (isComponentDef(superDef) && superDef.data.animation) {
            const defData = definition.data;
            defData.animation = (defData.animation || []).concat(superDef.data.animation);
          }
        }
        const features = superDef.features;
        if (features) {
          for (let i = 0; i < features.length; i++) {
            const feature = features[i];
            if (feature && feature.ngInherit) {
              feature(definition);
            }
            if (feature === \u0275\u0275InheritDefinitionFeature) {
              shouldInheritFields = false;
            }
          }
        }
      }
      superType = Object.getPrototypeOf(superType);
    }
    mergeHostAttrsAcrossInheritance(inheritanceChain);
  }
  function mergeHostAttrsAcrossInheritance(inheritanceChain) {
    let hostVars = 0;
    let hostAttrs = null;
    for (let i = inheritanceChain.length - 1; i >= 0; i--) {
      const def = inheritanceChain[i];
      def.hostVars = hostVars += def.hostVars;
      def.hostAttrs = mergeHostAttrs(def.hostAttrs, hostAttrs = mergeHostAttrs(hostAttrs, def.hostAttrs));
    }
  }
  function maybeUnwrapEmpty(value) {
    if (value === EMPTY_OBJ) {
      return {};
    } else if (value === EMPTY_ARRAY) {
      return [];
    } else {
      return value;
    }
  }
  function inheritViewQuery(definition, superViewQuery) {
    const prevViewQuery = definition.viewQuery;
    if (prevViewQuery) {
      definition.viewQuery = (rf, ctx) => {
        superViewQuery(rf, ctx);
        prevViewQuery(rf, ctx);
      };
    } else {
      definition.viewQuery = superViewQuery;
    }
  }
  function inheritContentQueries(definition, superContentQueries) {
    const prevContentQueries = definition.contentQueries;
    if (prevContentQueries) {
      definition.contentQueries = (rf, ctx, directiveIndex) => {
        superContentQueries(rf, ctx, directiveIndex);
        prevContentQueries(rf, ctx, directiveIndex);
      };
    } else {
      definition.contentQueries = superContentQueries;
    }
  }
  function inheritHostBindings(definition, superHostBindings) {
    const prevHostBindings = definition.hostBindings;
    if (prevHostBindings) {
      definition.hostBindings = (rf, ctx) => {
        superHostBindings(rf, ctx);
        prevHostBindings(rf, ctx);
      };
    } else {
      definition.hostBindings = superHostBindings;
    }
  }
  var COPY_DIRECTIVE_FIELDS = [
    "providersResolver"
  ];
  var COPY_COMPONENT_FIELDS = [
    "template",
    "decls",
    "consts",
    "vars",
    "onPush",
    "ngContentSelectors",
    "styles",
    "encapsulation",
    "schemas"
  ];
  function \u0275\u0275CopyDefinitionFeature(definition) {
    let superType = getSuperType(definition.type);
    let superDef = void 0;
    if (isComponentDef(definition)) {
      superDef = superType.\u0275cmp;
    } else {
      superDef = superType.\u0275dir;
    }
    const defAny = definition;
    for (const field of COPY_DIRECTIVE_FIELDS) {
      defAny[field] = superDef[field];
    }
    if (isComponentDef(superDef)) {
      for (const field of COPY_COMPONENT_FIELDS) {
        defAny[field] = superDef[field];
      }
    }
  }
  var _symbolIterator = null;
  function getSymbolIterator2() {
    if (!_symbolIterator) {
      const Symbol2 = _global2["Symbol"];
      if (Symbol2 && Symbol2.iterator) {
        _symbolIterator = Symbol2.iterator;
      } else {
        const keys = Object.getOwnPropertyNames(Map.prototype);
        for (let i = 0; i < keys.length; ++i) {
          const key = keys[i];
          if (key !== "entries" && key !== "size" && Map.prototype[key] === Map.prototype["entries"]) {
            _symbolIterator = key;
          }
        }
      }
    }
    return _symbolIterator;
  }
  function devModeEqual(a, b) {
    const isListLikeIterableA = isListLikeIterable(a);
    const isListLikeIterableB = isListLikeIterable(b);
    if (isListLikeIterableA && isListLikeIterableB) {
      return areIterablesEqual(a, b, devModeEqual);
    } else {
      const isAObject = a && (typeof a === "object" || typeof a === "function");
      const isBObject = b && (typeof b === "object" || typeof b === "function");
      if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {
        return true;
      } else {
        return Object.is(a, b);
      }
    }
  }
  function isListLikeIterable(obj) {
    if (!isJsObject(obj))
      return false;
    return Array.isArray(obj) || !(obj instanceof Map) && getSymbolIterator2() in obj;
  }
  function areIterablesEqual(a, b, comparator) {
    const iterator1 = a[getSymbolIterator2()]();
    const iterator2 = b[getSymbolIterator2()]();
    while (true) {
      const item1 = iterator1.next();
      const item2 = iterator2.next();
      if (item1.done && item2.done)
        return true;
      if (item1.done || item2.done)
        return false;
      if (!comparator(item1.value, item2.value))
        return false;
    }
  }
  function iterateListLike(obj, fn2) {
    if (Array.isArray(obj)) {
      for (let i = 0; i < obj.length; i++) {
        fn2(obj[i]);
      }
    } else {
      const iterator2 = obj[getSymbolIterator2()]();
      let item;
      while (!(item = iterator2.next()).done) {
        fn2(item.value);
      }
    }
  }
  function isJsObject(o) {
    return o !== null && (typeof o === "function" || typeof o === "object");
  }
  function updateBinding(lView, bindingIndex, value) {
    return lView[bindingIndex] = value;
  }
  function getBinding(lView, bindingIndex) {
    ngDevMode && assertIndexInRange(lView, bindingIndex);
    ngDevMode && assertNotSame(lView[bindingIndex], NO_CHANGE, "Stored value should never be NO_CHANGE.");
    return lView[bindingIndex];
  }
  function bindingUpdated(lView, bindingIndex, value) {
    ngDevMode && assertNotSame(value, NO_CHANGE, "Incoming value should never be NO_CHANGE.");
    ngDevMode && assertLessThan(bindingIndex, lView.length, `Slot should have been initialized to NO_CHANGE`);
    const oldValue = lView[bindingIndex];
    if (Object.is(oldValue, value)) {
      return false;
    } else {
      if (ngDevMode && isInCheckNoChangesMode()) {
        const oldValueToCompare = oldValue !== NO_CHANGE ? oldValue : void 0;
        if (!devModeEqual(oldValueToCompare, value)) {
          const details = getExpressionChangedErrorDetails(lView, bindingIndex, oldValueToCompare, value);
          throwErrorIfNoChangesMode(oldValue === NO_CHANGE, details.oldValue, details.newValue, details.propName);
        }
        return false;
      }
      lView[bindingIndex] = value;
      return true;
    }
  }
  function bindingUpdated2(lView, bindingIndex, exp1, exp2) {
    const different = bindingUpdated(lView, bindingIndex, exp1);
    return bindingUpdated(lView, bindingIndex + 1, exp2) || different;
  }
  function bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) {
    const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
    return bindingUpdated(lView, bindingIndex + 2, exp3) || different;
  }
  function bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) {
    const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
    return bindingUpdated2(lView, bindingIndex + 2, exp3, exp4) || different;
  }
  function \u0275\u0275attribute(name, value, sanitizer, namespace) {
    const lView = getLView();
    const bindingIndex = nextBindingIndex();
    if (bindingUpdated(lView, bindingIndex, value)) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace);
      ngDevMode && storePropertyBindingMetadata(tView.data, tNode, "attr." + name, bindingIndex);
    }
    return \u0275\u0275attribute;
  }
  function interpolationV(lView, values) {
    ngDevMode && assertLessThan(2, values.length, "should have at least 3 values");
    ngDevMode && assertEqual(values.length % 2, 1, "should have an odd number of values");
    let isBindingUpdated = false;
    let bindingIndex = getBindingIndex();
    for (let i = 1; i < values.length; i += 2) {
      isBindingUpdated = bindingUpdated(lView, bindingIndex++, values[i]) || isBindingUpdated;
    }
    setBindingIndex(bindingIndex);
    if (!isBindingUpdated) {
      return NO_CHANGE;
    }
    let content = values[0];
    for (let i = 1; i < values.length; i += 2) {
      content += renderStringify(values[i]) + values[i + 1];
    }
    return content;
  }
  function interpolation1(lView, prefix, v0, suffix) {
    const different = bindingUpdated(lView, nextBindingIndex(), v0);
    return different ? prefix + renderStringify(v0) + suffix : NO_CHANGE;
  }
  function interpolation2(lView, prefix, v0, i0, v1, suffix) {
    const bindingIndex = getBindingIndex();
    const different = bindingUpdated2(lView, bindingIndex, v0, v1);
    incrementBindingIndex(2);
    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + suffix : NO_CHANGE;
  }
  function interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix) {
    const bindingIndex = getBindingIndex();
    const different = bindingUpdated3(lView, bindingIndex, v0, v1, v2);
    incrementBindingIndex(3);
    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + suffix : NO_CHANGE;
  }
  function interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
    const bindingIndex = getBindingIndex();
    const different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
    incrementBindingIndex(4);
    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + suffix : NO_CHANGE;
  }
  function interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
    const bindingIndex = getBindingIndex();
    let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
    different = bindingUpdated(lView, bindingIndex + 4, v4) || different;
    incrementBindingIndex(5);
    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + suffix : NO_CHANGE;
  }
  function interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
    const bindingIndex = getBindingIndex();
    let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
    different = bindingUpdated2(lView, bindingIndex + 4, v4, v5) || different;
    incrementBindingIndex(6);
    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + suffix : NO_CHANGE;
  }
  function interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
    const bindingIndex = getBindingIndex();
    let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
    different = bindingUpdated3(lView, bindingIndex + 4, v4, v5, v6) || different;
    incrementBindingIndex(7);
    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 + renderStringify(v6) + suffix : NO_CHANGE;
  }
  function interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
    const bindingIndex = getBindingIndex();
    let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
    different = bindingUpdated4(lView, bindingIndex + 4, v4, v5, v6, v7) || different;
    incrementBindingIndex(8);
    return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 + renderStringify(v6) + i6 + renderStringify(v7) + suffix : NO_CHANGE;
  }
  function \u0275\u0275attributeInterpolate1(attrName, prefix, v0, suffix, sanitizer, namespace) {
    const lView = getLView();
    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tNode = getSelectedTNode();
      elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
      ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 1, prefix, suffix);
    }
    return \u0275\u0275attributeInterpolate1;
  }
  function \u0275\u0275attributeInterpolate2(attrName, prefix, v0, i0, v1, suffix, sanitizer, namespace) {
    const lView = getLView();
    const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tNode = getSelectedTNode();
      elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
      ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 2, prefix, i0, suffix);
    }
    return \u0275\u0275attributeInterpolate2;
  }
  function \u0275\u0275attributeInterpolate3(attrName, prefix, v0, i0, v1, i1, v2, suffix, sanitizer, namespace) {
    const lView = getLView();
    const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tNode = getSelectedTNode();
      elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
      ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 3, prefix, i0, i1, suffix);
    }
    return \u0275\u0275attributeInterpolate3;
  }
  function \u0275\u0275attributeInterpolate4(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, sanitizer, namespace) {
    const lView = getLView();
    const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tNode = getSelectedTNode();
      elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
      ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 4, prefix, i0, i1, i2, suffix);
    }
    return \u0275\u0275attributeInterpolate4;
  }
  function \u0275\u0275attributeInterpolate5(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, sanitizer, namespace) {
    const lView = getLView();
    const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tNode = getSelectedTNode();
      elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
      ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 5, prefix, i0, i1, i2, i3, suffix);
    }
    return \u0275\u0275attributeInterpolate5;
  }
  function \u0275\u0275attributeInterpolate6(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, sanitizer, namespace) {
    const lView = getLView();
    const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tNode = getSelectedTNode();
      elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
      ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 6, prefix, i0, i1, i2, i3, i4, suffix);
    }
    return \u0275\u0275attributeInterpolate6;
  }
  function \u0275\u0275attributeInterpolate7(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer, namespace) {
    const lView = getLView();
    const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tNode = getSelectedTNode();
      elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
      ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 7, prefix, i0, i1, i2, i3, i4, i5, suffix);
    }
    return \u0275\u0275attributeInterpolate7;
  }
  function \u0275\u0275attributeInterpolate8(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer, namespace) {
    const lView = getLView();
    const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tNode = getSelectedTNode();
      elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);
      ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - 8, prefix, i0, i1, i2, i3, i4, i5, i6, suffix);
    }
    return \u0275\u0275attributeInterpolate8;
  }
  function \u0275\u0275attributeInterpolateV(attrName, values, sanitizer, namespace) {
    const lView = getLView();
    const interpolated = interpolationV(lView, values);
    if (interpolated !== NO_CHANGE) {
      const tNode = getSelectedTNode();
      elementAttributeInternal(tNode, lView, attrName, interpolated, sanitizer, namespace);
      if (ngDevMode) {
        const interpolationInBetween = [values[0]];
        for (let i = 2; i < values.length; i += 2) {
          interpolationInBetween.push(values[i]);
        }
        storePropertyBindingMetadata(getTView().data, tNode, "attr." + attrName, getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);
      }
    }
    return \u0275\u0275attributeInterpolateV;
  }
  function templateFirstCreatePass(index, tView, lView, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex) {
    ngDevMode && assertFirstCreatePass(tView);
    ngDevMode && ngDevMode.firstCreatePass++;
    const tViewConsts = tView.consts;
    const tNode = getOrCreateTNode(tView, index, 4, tagName || null, getConstant(tViewConsts, attrsIndex));
    resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex));
    registerPostOrderHooks(tView, tNode);
    const embeddedTView = tNode.tViews = createTView(2, tNode, templateFn, decls, vars, tView.directiveRegistry, tView.pipeRegistry, null, tView.schemas, tViewConsts);
    if (tView.queries !== null) {
      tView.queries.template(tView, tNode);
      embeddedTView.queries = tView.queries.embeddedTView(tNode);
    }
    return tNode;
  }
  function \u0275\u0275template(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {
    const lView = getLView();
    const tView = getTView();
    const adjustedIndex = index + HEADER_OFFSET;
    const tNode = tView.firstCreatePass ? templateFirstCreatePass(adjustedIndex, tView, lView, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
    setCurrentTNode(tNode, false);
    const comment = lView[RENDERER].createComment(ngDevMode ? "container" : "");
    appendChild(tView, lView, comment, tNode);
    attachPatchData(comment, lView);
    addToViewTree(lView, lView[adjustedIndex] = createLContainer(comment, lView, comment, tNode));
    if (isDirectiveHost(tNode)) {
      createDirectivesInstances(tView, lView, tNode);
    }
    if (localRefsIndex != null) {
      saveResolvedLocalsInData(lView, tNode, localRefExtractor);
    }
  }
  function store(tView, lView, index, value) {
    if (index >= tView.data.length) {
      tView.data[index] = null;
      tView.blueprint[index] = null;
    }
    lView[index] = value;
  }
  function \u0275\u0275reference(index) {
    const contextLView = getContextLView();
    return load(contextLView, HEADER_OFFSET + index);
  }
  var angularCoreDiEnv = {
    "\u0275\u0275defineInjectable": \u0275\u0275defineInjectable,
    "\u0275\u0275defineInjector": \u0275\u0275defineInjector,
    "\u0275\u0275inject": \u0275\u0275inject,
    "\u0275\u0275invalidFactoryDep": \u0275\u0275invalidFactoryDep,
    "resolveForwardRef": resolveForwardRef
  };
  function compileInjectable(type, meta) {
    let ngInjectableDef = null;
    let ngFactoryDef = null;
    if (!type.hasOwnProperty(NG_PROV_DEF)) {
      Object.defineProperty(type, NG_PROV_DEF, {
        get: () => {
          if (ngInjectableDef === null) {
            const compiler = getCompilerFacade({ usage: 0, kind: "injectable", type });
            ngInjectableDef = compiler.compileInjectable(angularCoreDiEnv, `ng:///${type.name}/\u0275prov.js`, getInjectableMetadata(type, meta));
          }
          return ngInjectableDef;
        }
      });
    }
    if (!type.hasOwnProperty(NG_FACTORY_DEF)) {
      Object.defineProperty(type, NG_FACTORY_DEF, {
        get: () => {
          if (ngFactoryDef === null) {
            const compiler = getCompilerFacade({ usage: 0, kind: "injectable", type });
            ngFactoryDef = compiler.compileFactory(angularCoreDiEnv, `ng:///${type.name}/\u0275fac.js`, {
              name: type.name,
              type,
              typeArgumentCount: 0,
              deps: reflectDependencies(type),
              target: compiler.FactoryTarget.Injectable
            });
          }
          return ngFactoryDef;
        },
        configurable: true
      });
    }
  }
  var USE_VALUE = getClosureSafeProperty({ provide: String, useValue: getClosureSafeProperty });
  function isUseClassProvider(meta) {
    return meta.useClass !== void 0;
  }
  function isUseValueProvider(meta) {
    return USE_VALUE in meta;
  }
  function isUseFactoryProvider(meta) {
    return meta.useFactory !== void 0;
  }
  function isUseExistingProvider(meta) {
    return meta.useExisting !== void 0;
  }
  function getInjectableMetadata(type, srcMeta) {
    const meta = srcMeta || { providedIn: null };
    const compilerMeta = {
      name: type.name,
      type,
      typeArgumentCount: 0,
      providedIn: meta.providedIn
    };
    if ((isUseClassProvider(meta) || isUseFactoryProvider(meta)) && meta.deps !== void 0) {
      compilerMeta.deps = convertDependencies(meta.deps);
    }
    if (isUseClassProvider(meta)) {
      compilerMeta.useClass = meta.useClass;
    } else if (isUseValueProvider(meta)) {
      compilerMeta.useValue = meta.useValue;
    } else if (isUseFactoryProvider(meta)) {
      compilerMeta.useFactory = meta.useFactory;
    } else if (isUseExistingProvider(meta)) {
      compilerMeta.useExisting = meta.useExisting;
    }
    return compilerMeta;
  }
  var Injectable = makeDecorator("Injectable", void 0, void 0, void 0, (type, meta) => compileInjectable(type, meta));
  function findFirstClosedCycle(keys) {
    const res = [];
    for (let i = 0; i < keys.length; ++i) {
      if (res.indexOf(keys[i]) > -1) {
        res.push(keys[i]);
        return res;
      }
      res.push(keys[i]);
    }
    return res;
  }
  function constructResolvingPath(keys) {
    if (keys.length > 1) {
      const reversed = findFirstClosedCycle(keys.slice().reverse());
      const tokenStrs = reversed.map((k) => stringify(k.token));
      return " (" + tokenStrs.join(" -> ") + ")";
    }
    return "";
  }
  function injectionError(injector, key, constructResolvingMessage, originalError) {
    const keys = [key];
    const errMsg = constructResolvingMessage(keys);
    const error3 = originalError ? wrappedError(errMsg, originalError) : Error(errMsg);
    error3.addKey = addKey;
    error3.keys = keys;
    error3.injectors = [injector];
    error3.constructResolvingMessage = constructResolvingMessage;
    error3[ERROR_ORIGINAL_ERROR] = originalError;
    return error3;
  }
  function addKey(injector, key) {
    this.injectors.push(injector);
    this.keys.push(key);
    this.message = this.constructResolvingMessage(this.keys);
  }
  function noProviderError(injector, key) {
    return injectionError(injector, key, function(keys) {
      const first2 = stringify(keys[0].token);
      return `No provider for ${first2}!${constructResolvingPath(keys)}`;
    });
  }
  function cyclicDependencyError(injector, key) {
    return injectionError(injector, key, function(keys) {
      return `Cannot instantiate cyclic dependency!${constructResolvingPath(keys)}`;
    });
  }
  function instantiationError(injector, originalException, originalStack, key) {
    return injectionError(injector, key, function(keys) {
      const first2 = stringify(keys[0].token);
      return `${originalException.message}: Error during instantiation of ${first2}!${constructResolvingPath(keys)}.`;
    }, originalException);
  }
  function invalidProviderError(provider) {
    return Error(`Invalid provider - only instances of Provider and Type are allowed, got: ${provider}`);
  }
  function noAnnotationError(typeOrFunc, params) {
    const signature = [];
    for (let i = 0, ii = params.length; i < ii; i++) {
      const parameter = params[i];
      if (!parameter || parameter.length == 0) {
        signature.push("?");
      } else {
        signature.push(parameter.map(stringify).join(" "));
      }
    }
    return Error("Cannot resolve all parameters for '" + stringify(typeOrFunc) + "'(" + signature.join(", ") + "). Make sure that all the parameters are decorated with Inject or have valid type annotations and that '" + stringify(typeOrFunc) + "' is decorated with Injectable.");
  }
  function outOfBoundsError(index) {
    return Error(`Index ${index} is out-of-bounds.`);
  }
  function mixingMultiProvidersWithRegularProvidersError(provider1, provider2) {
    return Error(`Cannot mix multi providers and regular providers, got: ${provider1} ${provider2}`);
  }
  var ReflectiveKey = class {
    constructor(token, id) {
      this.token = token;
      this.id = id;
      if (!token) {
        throw new Error("Token must be defined!");
      }
      this.displayName = stringify(this.token);
    }
    static get(token) {
      return _globalKeyRegistry.get(resolveForwardRef(token));
    }
    static get numberOfKeys() {
      return _globalKeyRegistry.numberOfKeys;
    }
  };
  var KeyRegistry = class {
    constructor() {
      this._allKeys = /* @__PURE__ */ new Map();
    }
    get(token) {
      if (token instanceof ReflectiveKey)
        return token;
      if (this._allKeys.has(token)) {
        return this._allKeys.get(token);
      }
      const newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);
      this._allKeys.set(token, newKey);
      return newKey;
    }
    get numberOfKeys() {
      return this._allKeys.size;
    }
  };
  var _globalKeyRegistry = new KeyRegistry();
  var Reflector = class {
    constructor(reflectionCapabilities) {
      this.reflectionCapabilities = reflectionCapabilities;
    }
    updateCapabilities(caps) {
      this.reflectionCapabilities = caps;
    }
    factory(type) {
      return this.reflectionCapabilities.factory(type);
    }
    parameters(typeOrFunc) {
      return this.reflectionCapabilities.parameters(typeOrFunc);
    }
    annotations(typeOrFunc) {
      return this.reflectionCapabilities.annotations(typeOrFunc);
    }
    propMetadata(typeOrFunc) {
      return this.reflectionCapabilities.propMetadata(typeOrFunc);
    }
    hasLifecycleHook(type, lcProperty) {
      return this.reflectionCapabilities.hasLifecycleHook(type, lcProperty);
    }
    getter(name) {
      return this.reflectionCapabilities.getter(name);
    }
    setter(name) {
      return this.reflectionCapabilities.setter(name);
    }
    method(name) {
      return this.reflectionCapabilities.method(name);
    }
    importUri(type) {
      return this.reflectionCapabilities.importUri(type);
    }
    resourceUri(type) {
      return this.reflectionCapabilities.resourceUri(type);
    }
    resolveIdentifier(name, moduleUrl, members, runtime) {
      return this.reflectionCapabilities.resolveIdentifier(name, moduleUrl, members, runtime);
    }
    resolveEnum(identifier, name) {
      return this.reflectionCapabilities.resolveEnum(identifier, name);
    }
  };
  var reflector = new Reflector(new ReflectionCapabilities());
  var ReflectiveDependency = class {
    constructor(key, optional, visibility) {
      this.key = key;
      this.optional = optional;
      this.visibility = visibility;
    }
    static fromKey(key) {
      return new ReflectiveDependency(key, false, null);
    }
  };
  var _EMPTY_LIST = [];
  var ResolvedReflectiveProvider_ = class {
    constructor(key, resolvedFactories, multiProvider) {
      this.key = key;
      this.resolvedFactories = resolvedFactories;
      this.multiProvider = multiProvider;
      this.resolvedFactory = this.resolvedFactories[0];
    }
  };
  var ResolvedReflectiveFactory = class {
    constructor(factory, dependencies) {
      this.factory = factory;
      this.dependencies = dependencies;
    }
  };
  function resolveReflectiveFactory(provider) {
    let factoryFn;
    let resolvedDeps;
    if (provider.useClass) {
      const useClass = resolveForwardRef(provider.useClass);
      factoryFn = reflector.factory(useClass);
      resolvedDeps = _dependenciesFor(useClass);
    } else if (provider.useExisting) {
      factoryFn = (aliasInstance) => aliasInstance;
      resolvedDeps = [ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))];
    } else if (provider.useFactory) {
      factoryFn = provider.useFactory;
      resolvedDeps = constructDependencies(provider.useFactory, provider.deps);
    } else {
      factoryFn = () => provider.useValue;
      resolvedDeps = _EMPTY_LIST;
    }
    return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);
  }
  function resolveReflectiveProvider(provider) {
    return new ResolvedReflectiveProvider_(ReflectiveKey.get(provider.provide), [resolveReflectiveFactory(provider)], provider.multi || false);
  }
  function resolveReflectiveProviders(providers) {
    const normalized = _normalizeProviders(providers, []);
    const resolved = normalized.map(resolveReflectiveProvider);
    const resolvedProviderMap = mergeResolvedReflectiveProviders(resolved, /* @__PURE__ */ new Map());
    return Array.from(resolvedProviderMap.values());
  }
  function mergeResolvedReflectiveProviders(providers, normalizedProvidersMap) {
    for (let i = 0; i < providers.length; i++) {
      const provider = providers[i];
      const existing = normalizedProvidersMap.get(provider.key.id);
      if (existing) {
        if (provider.multiProvider !== existing.multiProvider) {
          throw mixingMultiProvidersWithRegularProvidersError(existing, provider);
        }
        if (provider.multiProvider) {
          for (let j = 0; j < provider.resolvedFactories.length; j++) {
            existing.resolvedFactories.push(provider.resolvedFactories[j]);
          }
        } else {
          normalizedProvidersMap.set(provider.key.id, provider);
        }
      } else {
        let resolvedProvider;
        if (provider.multiProvider) {
          resolvedProvider = new ResolvedReflectiveProvider_(provider.key, provider.resolvedFactories.slice(), provider.multiProvider);
        } else {
          resolvedProvider = provider;
        }
        normalizedProvidersMap.set(provider.key.id, resolvedProvider);
      }
    }
    return normalizedProvidersMap;
  }
  function _normalizeProviders(providers, res) {
    providers.forEach((b) => {
      if (b instanceof Type) {
        res.push({ provide: b, useClass: b });
      } else if (b && typeof b == "object" && b.provide !== void 0) {
        res.push(b);
      } else if (Array.isArray(b)) {
        _normalizeProviders(b, res);
      } else {
        throw invalidProviderError(b);
      }
    });
    return res;
  }
  function constructDependencies(typeOrFunc, dependencies) {
    if (!dependencies) {
      return _dependenciesFor(typeOrFunc);
    } else {
      const params = dependencies.map((t) => [t]);
      return dependencies.map((t) => _extractToken(typeOrFunc, t, params));
    }
  }
  function _dependenciesFor(typeOrFunc) {
    const params = reflector.parameters(typeOrFunc);
    if (!params)
      return [];
    if (params.some((p) => p == null)) {
      throw noAnnotationError(typeOrFunc, params);
    }
    return params.map((p) => _extractToken(typeOrFunc, p, params));
  }
  function _extractToken(typeOrFunc, metadata, params) {
    let token = null;
    let optional = false;
    if (!Array.isArray(metadata)) {
      if (metadata instanceof Inject) {
        return _createDependency(metadata.token, optional, null);
      } else {
        return _createDependency(metadata, optional, null);
      }
    }
    let visibility = null;
    for (let i = 0; i < metadata.length; ++i) {
      const paramMetadata = metadata[i];
      if (paramMetadata instanceof Type) {
        token = paramMetadata;
      } else if (paramMetadata instanceof Inject) {
        token = paramMetadata.token;
      } else if (paramMetadata instanceof Optional) {
        optional = true;
      } else if (paramMetadata instanceof Self || paramMetadata instanceof SkipSelf) {
        visibility = paramMetadata;
      } else if (paramMetadata instanceof InjectionToken) {
        token = paramMetadata;
      }
    }
    token = resolveForwardRef(token);
    if (token != null) {
      return _createDependency(token, optional, visibility);
    } else {
      throw noAnnotationError(typeOrFunc, params);
    }
  }
  function _createDependency(token, optional, visibility) {
    return new ReflectiveDependency(ReflectiveKey.get(token), optional, visibility);
  }
  var UNDEFINED = {};
  var ReflectiveInjector = class {
    static resolve(providers) {
      return resolveReflectiveProviders(providers);
    }
    static resolveAndCreate(providers, parent) {
      const ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
      return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);
    }
    static fromResolvedProviders(providers, parent) {
      return new ReflectiveInjector_(providers, parent);
    }
  };
  var ReflectiveInjector_ = class {
    constructor(_providers, _parent) {
      this._constructionCounter = 0;
      this._providers = _providers;
      this.parent = _parent || null;
      const len = _providers.length;
      this.keyIds = [];
      this.objs = [];
      for (let i = 0; i < len; i++) {
        this.keyIds[i] = _providers[i].key.id;
        this.objs[i] = UNDEFINED;
      }
    }
    get(token, notFoundValue = THROW_IF_NOT_FOUND) {
      return this._getByKey(ReflectiveKey.get(token), null, notFoundValue);
    }
    resolveAndCreateChild(providers) {
      const ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
      return this.createChildFromResolved(ResolvedReflectiveProviders);
    }
    createChildFromResolved(providers) {
      const inj = new ReflectiveInjector_(providers);
      inj.parent = this;
      return inj;
    }
    resolveAndInstantiate(provider) {
      return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);
    }
    instantiateResolved(provider) {
      return this._instantiateProvider(provider);
    }
    getProviderAtIndex(index) {
      if (index < 0 || index >= this._providers.length) {
        throw outOfBoundsError(index);
      }
      return this._providers[index];
    }
    _new(provider) {
      if (this._constructionCounter++ > this._getMaxNumberOfObjects()) {
        throw cyclicDependencyError(this, provider.key);
      }
      return this._instantiateProvider(provider);
    }
    _getMaxNumberOfObjects() {
      return this.objs.length;
    }
    _instantiateProvider(provider) {
      if (provider.multiProvider) {
        const res = [];
        for (let i = 0; i < provider.resolvedFactories.length; ++i) {
          res[i] = this._instantiate(provider, provider.resolvedFactories[i]);
        }
        return res;
      } else {
        return this._instantiate(provider, provider.resolvedFactories[0]);
      }
    }
    _instantiate(provider, ResolvedReflectiveFactory2) {
      const factory = ResolvedReflectiveFactory2.factory;
      let deps;
      try {
        deps = ResolvedReflectiveFactory2.dependencies.map((dep) => this._getByReflectiveDependency(dep));
      } catch (e) {
        if (e.addKey) {
          e.addKey(this, provider.key);
        }
        throw e;
      }
      let obj;
      try {
        obj = factory(...deps);
      } catch (e) {
        throw instantiationError(this, e, e.stack, provider.key);
      }
      return obj;
    }
    _getByReflectiveDependency(dep) {
      return this._getByKey(dep.key, dep.visibility, dep.optional ? null : THROW_IF_NOT_FOUND);
    }
    _getByKey(key, visibility, notFoundValue) {
      if (key === ReflectiveInjector_.INJECTOR_KEY) {
        return this;
      }
      if (visibility instanceof Self) {
        return this._getByKeySelf(key, notFoundValue);
      } else {
        return this._getByKeyDefault(key, notFoundValue, visibility);
      }
    }
    _getObjByKeyId(keyId) {
      for (let i = 0; i < this.keyIds.length; i++) {
        if (this.keyIds[i] === keyId) {
          if (this.objs[i] === UNDEFINED) {
            this.objs[i] = this._new(this._providers[i]);
          }
          return this.objs[i];
        }
      }
      return UNDEFINED;
    }
    _throwOrNull(key, notFoundValue) {
      if (notFoundValue !== THROW_IF_NOT_FOUND) {
        return notFoundValue;
      } else {
        throw noProviderError(this, key);
      }
    }
    _getByKeySelf(key, notFoundValue) {
      const obj = this._getObjByKeyId(key.id);
      return obj !== UNDEFINED ? obj : this._throwOrNull(key, notFoundValue);
    }
    _getByKeyDefault(key, notFoundValue, visibility) {
      let inj;
      if (visibility instanceof SkipSelf) {
        inj = this.parent;
      } else {
        inj = this;
      }
      while (inj instanceof ReflectiveInjector_) {
        const inj_ = inj;
        const obj = inj_._getObjByKeyId(key.id);
        if (obj !== UNDEFINED)
          return obj;
        inj = inj_.parent;
      }
      if (inj !== null) {
        return inj.get(key.token, notFoundValue);
      } else {
        return this._throwOrNull(key, notFoundValue);
      }
    }
    get displayName() {
      const providers = _mapProviders(this, (b) => ' "' + b.key.displayName + '" ').join(", ");
      return `ReflectiveInjector(providers: [${providers}])`;
    }
    toString() {
      return this.displayName;
    }
  };
  ReflectiveInjector_.INJECTOR_KEY = /* @__PURE__ */ ReflectiveKey.get(Injector);
  function _mapProviders(injector, fn2) {
    const res = [];
    for (let i = 0; i < injector._providers.length; ++i) {
      res[i] = fn2(injector.getProviderAtIndex(i));
    }
    return res;
  }
  function \u0275\u0275directiveInject(token, flags = InjectFlags.Default) {
    const lView = getLView();
    if (lView === null) {
      ngDevMode && assertInjectImplementationNotEqual(\u0275\u0275directiveInject);
      return \u0275\u0275inject(token, flags);
    }
    const tNode = getCurrentTNode();
    return getOrCreateInjectable(tNode, lView, resolveForwardRef(token), flags);
  }
  function \u0275\u0275invalidFactory() {
    const msg = ngDevMode ? `This constructor was not compatible with Dependency Injection.` : "invalid";
    throw new Error(msg);
  }
  function \u0275\u0275property(propName, value, sanitizer) {
    const lView = getLView();
    const bindingIndex = nextBindingIndex();
    if (bindingUpdated(lView, bindingIndex, value)) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, false);
      ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
    }
    return \u0275\u0275property;
  }
  function setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased) {
    const inputs = tNode.inputs;
    const property = isClassBased ? "class" : "style";
    setInputsForProperty(tView, lView, inputs[property], property, value);
  }
  function elementStartFirstCreatePass(index, tView, lView, native, name, attrsIndex, localRefsIndex) {
    ngDevMode && assertFirstCreatePass(tView);
    ngDevMode && ngDevMode.firstCreatePass++;
    const tViewConsts = tView.consts;
    const attrs = getConstant(tViewConsts, attrsIndex);
    const tNode = getOrCreateTNode(tView, index, 2, name, attrs);
    const hasDirectives = resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex));
    ngDevMode && logUnknownElementError(tView, native, tNode, hasDirectives);
    if (tNode.attrs !== null) {
      computeStaticStyling(tNode, tNode.attrs, false);
    }
    if (tNode.mergedAttrs !== null) {
      computeStaticStyling(tNode, tNode.mergedAttrs, true);
    }
    if (tView.queries !== null) {
      tView.queries.elementStart(tView, tNode);
    }
    return tNode;
  }
  function \u0275\u0275elementStart(index, name, attrsIndex, localRefsIndex) {
    const lView = getLView();
    const tView = getTView();
    const adjustedIndex = HEADER_OFFSET + index;
    ngDevMode && assertEqual(getBindingIndex(), tView.bindingStartIndex, "elements should be created before any bindings");
    ngDevMode && assertIndexInRange(lView, adjustedIndex);
    const renderer = lView[RENDERER];
    const native = lView[adjustedIndex] = createElementNode(renderer, name, getNamespace$1());
    const tNode = tView.firstCreatePass ? elementStartFirstCreatePass(adjustedIndex, tView, lView, native, name, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
    setCurrentTNode(tNode, true);
    const mergedAttrs = tNode.mergedAttrs;
    if (mergedAttrs !== null) {
      setUpAttributes(renderer, native, mergedAttrs);
    }
    const classes = tNode.classes;
    if (classes !== null) {
      writeDirectClass(renderer, native, classes);
    }
    const styles = tNode.styles;
    if (styles !== null) {
      writeDirectStyle(renderer, native, styles);
    }
    if ((tNode.flags & 64) !== 64) {
      appendChild(tView, lView, native, tNode);
    }
    if (getElementDepthCount() === 0) {
      attachPatchData(native, lView);
    }
    increaseElementDepthCount();
    if (isDirectiveHost(tNode)) {
      createDirectivesInstances(tView, lView, tNode);
      executeContentQueries(tView, tNode, lView);
    }
    if (localRefsIndex !== null) {
      saveResolvedLocalsInData(lView, tNode);
    }
  }
  function \u0275\u0275elementEnd() {
    let currentTNode = getCurrentTNode();
    ngDevMode && assertDefined(currentTNode, "No parent node to close.");
    if (isCurrentTNodeParent()) {
      setCurrentTNodeAsNotParent();
    } else {
      ngDevMode && assertHasParent(getCurrentTNode());
      currentTNode = currentTNode.parent;
      setCurrentTNode(currentTNode, false);
    }
    const tNode = currentTNode;
    ngDevMode && assertTNodeType(tNode, 3);
    decreaseElementDepthCount();
    const tView = getTView();
    if (tView.firstCreatePass) {
      registerPostOrderHooks(tView, currentTNode);
      if (isContentQueryHost(currentTNode)) {
        tView.queries.elementEnd(currentTNode);
      }
    }
    if (tNode.classesWithoutHost != null && hasClassInput(tNode)) {
      setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.classesWithoutHost, true);
    }
    if (tNode.stylesWithoutHost != null && hasStyleInput(tNode)) {
      setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.stylesWithoutHost, false);
    }
  }
  function \u0275\u0275element(index, name, attrsIndex, localRefsIndex) {
    \u0275\u0275elementStart(index, name, attrsIndex, localRefsIndex);
    \u0275\u0275elementEnd();
  }
  function logUnknownElementError(tView, element, tNode, hasDirectives) {
    const schemas = tView.schemas;
    if (schemas === null)
      return;
    const tagName = tNode.value;
    if (!hasDirectives && tagName !== null) {
      const isUnknown = typeof HTMLUnknownElement !== "undefined" && HTMLUnknownElement && element instanceof HTMLUnknownElement || typeof customElements !== "undefined" && tagName.indexOf("-") > -1 && !customElements.get(tagName);
      if (isUnknown && !matchingSchemas(tView, tagName)) {
        let message = `'${tagName}' is not a known element:
`;
        message += `1. If '${tagName}' is an Angular component, then verify that it is part of this module.
`;
        if (tagName && tagName.indexOf("-") > -1) {
          message += `2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.`;
        } else {
          message += `2. To allow any element add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;
        }
        console.error(formatRuntimeError("304", message));
      }
    }
  }
  function elementContainerStartFirstCreatePass(index, tView, lView, attrsIndex, localRefsIndex) {
    ngDevMode && ngDevMode.firstCreatePass++;
    const tViewConsts = tView.consts;
    const attrs = getConstant(tViewConsts, attrsIndex);
    const tNode = getOrCreateTNode(tView, index, 8, "ng-container", attrs);
    if (attrs !== null) {
      computeStaticStyling(tNode, attrs, true);
    }
    const localRefs = getConstant(tViewConsts, localRefsIndex);
    resolveDirectives(tView, lView, tNode, localRefs);
    if (tView.queries !== null) {
      tView.queries.elementStart(tView, tNode);
    }
    return tNode;
  }
  function \u0275\u0275elementContainerStart(index, attrsIndex, localRefsIndex) {
    const lView = getLView();
    const tView = getTView();
    const adjustedIndex = index + HEADER_OFFSET;
    ngDevMode && assertIndexInRange(lView, adjustedIndex);
    ngDevMode && assertEqual(getBindingIndex(), tView.bindingStartIndex, "element containers should be created before any bindings");
    const tNode = tView.firstCreatePass ? elementContainerStartFirstCreatePass(adjustedIndex, tView, lView, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];
    setCurrentTNode(tNode, true);
    ngDevMode && ngDevMode.rendererCreateComment++;
    const native = lView[adjustedIndex] = lView[RENDERER].createComment(ngDevMode ? "ng-container" : "");
    appendChild(tView, lView, native, tNode);
    attachPatchData(native, lView);
    if (isDirectiveHost(tNode)) {
      createDirectivesInstances(tView, lView, tNode);
      executeContentQueries(tView, tNode, lView);
    }
    if (localRefsIndex != null) {
      saveResolvedLocalsInData(lView, tNode);
    }
  }
  function \u0275\u0275elementContainerEnd() {
    let currentTNode = getCurrentTNode();
    const tView = getTView();
    if (isCurrentTNodeParent()) {
      setCurrentTNodeAsNotParent();
    } else {
      ngDevMode && assertHasParent(currentTNode);
      currentTNode = currentTNode.parent;
      setCurrentTNode(currentTNode, false);
    }
    ngDevMode && assertTNodeType(currentTNode, 8);
    if (tView.firstCreatePass) {
      registerPostOrderHooks(tView, currentTNode);
      if (isContentQueryHost(currentTNode)) {
        tView.queries.elementEnd(currentTNode);
      }
    }
  }
  function \u0275\u0275elementContainer(index, attrsIndex, localRefsIndex) {
    \u0275\u0275elementContainerStart(index, attrsIndex, localRefsIndex);
    \u0275\u0275elementContainerEnd();
  }
  function \u0275\u0275getCurrentView() {
    return getLView();
  }
  function isPromise2(obj) {
    return !!obj && typeof obj.then === "function";
  }
  function isSubscribable(obj) {
    return !!obj && typeof obj.subscribe === "function";
  }
  var isObservable = isSubscribable;
  function \u0275\u0275listener(eventName, listenerFn, useCapture, eventTargetResolver) {
    const lView = getLView();
    const tView = getTView();
    const tNode = getCurrentTNode();
    listenerInternal(tView, lView, lView[RENDERER], tNode, eventName, listenerFn, !!useCapture, eventTargetResolver);
    return \u0275\u0275listener;
  }
  function \u0275\u0275syntheticHostListener(eventName, listenerFn) {
    const tNode = getCurrentTNode();
    const lView = getLView();
    const tView = getTView();
    const currentDef = getCurrentDirectiveDef(tView.data);
    const renderer = loadComponentRenderer(currentDef, tNode, lView);
    listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn, false);
    return \u0275\u0275syntheticHostListener;
  }
  function findExistingListener(tView, lView, eventName, tNodeIdx) {
    const tCleanup = tView.cleanup;
    if (tCleanup != null) {
      for (let i = 0; i < tCleanup.length - 1; i += 2) {
        const cleanupEventName = tCleanup[i];
        if (cleanupEventName === eventName && tCleanup[i + 1] === tNodeIdx) {
          const lCleanup = lView[CLEANUP];
          const listenerIdxInLCleanup = tCleanup[i + 2];
          return lCleanup.length > listenerIdxInLCleanup ? lCleanup[listenerIdxInLCleanup] : null;
        }
        if (typeof cleanupEventName === "string") {
          i += 2;
        }
      }
    }
    return null;
  }
  function listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn, useCapture, eventTargetResolver) {
    const isTNodeDirectiveHost = isDirectiveHost(tNode);
    const firstCreatePass = tView.firstCreatePass;
    const tCleanup = firstCreatePass && getOrCreateTViewCleanup(tView);
    const context2 = lView[CONTEXT];
    const lCleanup = getOrCreateLViewCleanup(lView);
    ngDevMode && assertTNodeType(tNode, 3 | 12);
    let processOutputs = true;
    if (tNode.type & 3 || eventTargetResolver) {
      const native = getNativeByTNode(tNode, lView);
      const target = eventTargetResolver ? eventTargetResolver(native) : native;
      const lCleanupIndex = lCleanup.length;
      const idxOrTargetGetter = eventTargetResolver ? (_lView) => eventTargetResolver(unwrapRNode(_lView[tNode.index])) : tNode.index;
      if (isProceduralRenderer(renderer)) {
        let existingListener = null;
        if (!eventTargetResolver && isTNodeDirectiveHost) {
          existingListener = findExistingListener(tView, lView, eventName, tNode.index);
        }
        if (existingListener !== null) {
          const lastListenerFn = existingListener.__ngLastListenerFn__ || existingListener;
          lastListenerFn.__ngNextListenerFn__ = listenerFn;
          existingListener.__ngLastListenerFn__ = listenerFn;
          processOutputs = false;
        } else {
          listenerFn = wrapListener(tNode, lView, context2, listenerFn, false);
          const cleanupFn = renderer.listen(target, eventName, listenerFn);
          ngDevMode && ngDevMode.rendererAddEventListener++;
          lCleanup.push(listenerFn, cleanupFn);
          tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, lCleanupIndex + 1);
        }
      } else {
        listenerFn = wrapListener(tNode, lView, context2, listenerFn, true);
        target.addEventListener(eventName, listenerFn, useCapture);
        ngDevMode && ngDevMode.rendererAddEventListener++;
        lCleanup.push(listenerFn);
        tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, useCapture);
      }
    } else {
      listenerFn = wrapListener(tNode, lView, context2, listenerFn, false);
    }
    const outputs = tNode.outputs;
    let props;
    if (processOutputs && outputs !== null && (props = outputs[eventName])) {
      const propsLength = props.length;
      if (propsLength) {
        for (let i = 0; i < propsLength; i += 2) {
          const index = props[i];
          ngDevMode && assertIndexInRange(lView, index);
          const minifiedName = props[i + 1];
          const directiveInstance = lView[index];
          const output = directiveInstance[minifiedName];
          if (ngDevMode && !isObservable(output)) {
            throw new Error(`@Output ${minifiedName} not initialized in '${directiveInstance.constructor.name}'.`);
          }
          const subscription = output.subscribe(listenerFn);
          const idx = lCleanup.length;
          lCleanup.push(listenerFn, subscription);
          tCleanup && tCleanup.push(eventName, tNode.index, idx, -(idx + 1));
        }
      }
    }
  }
  function executeListenerWithErrorHandling(lView, context2, listenerFn, e) {
    try {
      profiler(6, context2, listenerFn);
      return listenerFn(e) !== false;
    } catch (error3) {
      handleError(lView, error3);
      return false;
    } finally {
      profiler(7, context2, listenerFn);
    }
  }
  function wrapListener(tNode, lView, context2, listenerFn, wrapWithPreventDefault) {
    return function wrapListenerIn_markDirtyAndPreventDefault(e) {
      if (e === Function) {
        return listenerFn;
      }
      const startView = tNode.flags & 2 ? getComponentLViewByIndex(tNode.index, lView) : lView;
      if ((lView[FLAGS] & 32) === 0) {
        markViewDirty(startView);
      }
      let result = executeListenerWithErrorHandling(lView, context2, listenerFn, e);
      let nextListenerFn = wrapListenerIn_markDirtyAndPreventDefault.__ngNextListenerFn__;
      while (nextListenerFn) {
        result = executeListenerWithErrorHandling(lView, context2, nextListenerFn, e) && result;
        nextListenerFn = nextListenerFn.__ngNextListenerFn__;
      }
      if (wrapWithPreventDefault && result === false) {
        e.preventDefault();
        e.returnValue = false;
      }
      return result;
    };
  }
  function \u0275\u0275nextContext(level = 1) {
    return nextContextImpl(level);
  }
  function matchingProjectionSlotIndex(tNode, projectionSlots) {
    let wildcardNgContentIndex = null;
    const ngProjectAsAttrVal = getProjectAsAttrValue(tNode);
    for (let i = 0; i < projectionSlots.length; i++) {
      const slotValue = projectionSlots[i];
      if (slotValue === "*") {
        wildcardNgContentIndex = i;
        continue;
      }
      if (ngProjectAsAttrVal === null ? isNodeMatchingSelectorList(tNode, slotValue, true) : isSelectorInSelectorList(ngProjectAsAttrVal, slotValue)) {
        return i;
      }
    }
    return wildcardNgContentIndex;
  }
  function \u0275\u0275projectionDef(projectionSlots) {
    const componentNode = getLView()[DECLARATION_COMPONENT_VIEW][T_HOST];
    if (!componentNode.projection) {
      const numProjectionSlots = projectionSlots ? projectionSlots.length : 1;
      const projectionHeads = componentNode.projection = newArray(numProjectionSlots, null);
      const tails = projectionHeads.slice();
      let componentChild = componentNode.child;
      while (componentChild !== null) {
        const slotIndex = projectionSlots ? matchingProjectionSlotIndex(componentChild, projectionSlots) : 0;
        if (slotIndex !== null) {
          if (tails[slotIndex]) {
            tails[slotIndex].projectionNext = componentChild;
          } else {
            projectionHeads[slotIndex] = componentChild;
          }
          tails[slotIndex] = componentChild;
        }
        componentChild = componentChild.next;
      }
    }
  }
  function \u0275\u0275projection(nodeIndex, selectorIndex = 0, attrs) {
    const lView = getLView();
    const tView = getTView();
    const tProjectionNode = getOrCreateTNode(tView, HEADER_OFFSET + nodeIndex, 16, null, attrs || null);
    if (tProjectionNode.projection === null)
      tProjectionNode.projection = selectorIndex;
    setCurrentTNodeAsNotParent();
    if ((tProjectionNode.flags & 64) !== 64) {
      applyProjection(tView, lView, tProjectionNode);
    }
  }
  function \u0275\u0275propertyInterpolate(propName, v0, sanitizer) {
    \u0275\u0275propertyInterpolate1(propName, "", v0, "", sanitizer);
    return \u0275\u0275propertyInterpolate;
  }
  function \u0275\u0275propertyInterpolate1(propName, prefix, v0, suffix, sanitizer) {
    const lView = getLView();
    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
      ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 1, prefix, suffix);
    }
    return \u0275\u0275propertyInterpolate1;
  }
  function \u0275\u0275propertyInterpolate2(propName, prefix, v0, i0, v1, suffix, sanitizer) {
    const lView = getLView();
    const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
      ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 2, prefix, i0, suffix);
    }
    return \u0275\u0275propertyInterpolate2;
  }
  function \u0275\u0275propertyInterpolate3(propName, prefix, v0, i0, v1, i1, v2, suffix, sanitizer) {
    const lView = getLView();
    const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
      ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 3, prefix, i0, i1, suffix);
    }
    return \u0275\u0275propertyInterpolate3;
  }
  function \u0275\u0275propertyInterpolate4(propName, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, sanitizer) {
    const lView = getLView();
    const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
      ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 4, prefix, i0, i1, i2, suffix);
    }
    return \u0275\u0275propertyInterpolate4;
  }
  function \u0275\u0275propertyInterpolate5(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, sanitizer) {
    const lView = getLView();
    const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
      ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 5, prefix, i0, i1, i2, i3, suffix);
    }
    return \u0275\u0275propertyInterpolate5;
  }
  function \u0275\u0275propertyInterpolate6(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, sanitizer) {
    const lView = getLView();
    const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
      ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 6, prefix, i0, i1, i2, i3, i4, suffix);
    }
    return \u0275\u0275propertyInterpolate6;
  }
  function \u0275\u0275propertyInterpolate7(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer) {
    const lView = getLView();
    const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
      ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 7, prefix, i0, i1, i2, i3, i4, i5, suffix);
    }
    return \u0275\u0275propertyInterpolate7;
  }
  function \u0275\u0275propertyInterpolate8(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer) {
    const lView = getLView();
    const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
    if (interpolatedValue !== NO_CHANGE) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
      ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 8, prefix, i0, i1, i2, i3, i4, i5, i6, suffix);
    }
    return \u0275\u0275propertyInterpolate8;
  }
  function \u0275\u0275propertyInterpolateV(propName, values, sanitizer) {
    const lView = getLView();
    const interpolatedValue = interpolationV(lView, values);
    if (interpolatedValue !== NO_CHANGE) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);
      if (ngDevMode) {
        const interpolationInBetween = [values[0]];
        for (let i = 2; i < values.length; i += 2) {
          interpolationInBetween.push(values[i]);
        }
        storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);
      }
    }
    return \u0275\u0275propertyInterpolateV;
  }
  function insertTStylingBinding(tData, tNode, tStylingKeyWithStatic, index, isHostBinding2, isClassBinding) {
    ngDevMode && assertFirstUpdatePass(getTView());
    let tBindings = isClassBinding ? tNode.classBindings : tNode.styleBindings;
    let tmplHead = getTStylingRangePrev(tBindings);
    let tmplTail = getTStylingRangeNext(tBindings);
    tData[index] = tStylingKeyWithStatic;
    let isKeyDuplicateOfStatic = false;
    let tStylingKey;
    if (Array.isArray(tStylingKeyWithStatic)) {
      const staticKeyValueArray = tStylingKeyWithStatic;
      tStylingKey = staticKeyValueArray[1];
      if (tStylingKey === null || keyValueArrayIndexOf(staticKeyValueArray, tStylingKey) > 0) {
        isKeyDuplicateOfStatic = true;
      }
    } else {
      tStylingKey = tStylingKeyWithStatic;
    }
    if (isHostBinding2) {
      const hasTemplateBindings = tmplTail !== 0;
      if (hasTemplateBindings) {
        const previousNode = getTStylingRangePrev(tData[tmplHead + 1]);
        tData[index + 1] = toTStylingRange(previousNode, tmplHead);
        if (previousNode !== 0) {
          tData[previousNode + 1] = setTStylingRangeNext(tData[previousNode + 1], index);
        }
        tData[tmplHead + 1] = setTStylingRangePrev(tData[tmplHead + 1], index);
      } else {
        tData[index + 1] = toTStylingRange(tmplHead, 0);
        if (tmplHead !== 0) {
          tData[tmplHead + 1] = setTStylingRangeNext(tData[tmplHead + 1], index);
        }
        tmplHead = index;
      }
    } else {
      tData[index + 1] = toTStylingRange(tmplTail, 0);
      ngDevMode && assertEqual(tmplHead !== 0 && tmplTail === 0, false, "Adding template bindings after hostBindings is not allowed.");
      if (tmplHead === 0) {
        tmplHead = index;
      } else {
        tData[tmplTail + 1] = setTStylingRangeNext(tData[tmplTail + 1], index);
      }
      tmplTail = index;
    }
    if (isKeyDuplicateOfStatic) {
      tData[index + 1] = setTStylingRangePrevDuplicate(tData[index + 1]);
    }
    markDuplicates(tData, tStylingKey, index, true, isClassBinding);
    markDuplicates(tData, tStylingKey, index, false, isClassBinding);
    markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding);
    tBindings = toTStylingRange(tmplHead, tmplTail);
    if (isClassBinding) {
      tNode.classBindings = tBindings;
    } else {
      tNode.styleBindings = tBindings;
    }
  }
  function markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding) {
    const residual = isClassBinding ? tNode.residualClasses : tNode.residualStyles;
    if (residual != null && typeof tStylingKey == "string" && keyValueArrayIndexOf(residual, tStylingKey) >= 0) {
      tData[index + 1] = setTStylingRangeNextDuplicate(tData[index + 1]);
    }
  }
  function markDuplicates(tData, tStylingKey, index, isPrevDir, isClassBinding) {
    const tStylingAtIndex = tData[index + 1];
    const isMap = tStylingKey === null;
    let cursor = isPrevDir ? getTStylingRangePrev(tStylingAtIndex) : getTStylingRangeNext(tStylingAtIndex);
    let foundDuplicate = false;
    while (cursor !== 0 && (foundDuplicate === false || isMap)) {
      ngDevMode && assertIndexInRange(tData, cursor);
      const tStylingValueAtCursor = tData[cursor];
      const tStyleRangeAtCursor = tData[cursor + 1];
      if (isStylingMatch(tStylingValueAtCursor, tStylingKey)) {
        foundDuplicate = true;
        tData[cursor + 1] = isPrevDir ? setTStylingRangeNextDuplicate(tStyleRangeAtCursor) : setTStylingRangePrevDuplicate(tStyleRangeAtCursor);
      }
      cursor = isPrevDir ? getTStylingRangePrev(tStyleRangeAtCursor) : getTStylingRangeNext(tStyleRangeAtCursor);
    }
    if (foundDuplicate) {
      tData[index + 1] = isPrevDir ? setTStylingRangePrevDuplicate(tStylingAtIndex) : setTStylingRangeNextDuplicate(tStylingAtIndex);
    }
  }
  function isStylingMatch(tStylingKeyCursor, tStylingKey) {
    ngDevMode && assertNotEqual(Array.isArray(tStylingKey), true, "Expected that 'tStylingKey' has been unwrapped");
    if (tStylingKeyCursor === null || tStylingKey == null || (Array.isArray(tStylingKeyCursor) ? tStylingKeyCursor[1] : tStylingKeyCursor) === tStylingKey) {
      return true;
    } else if (Array.isArray(tStylingKeyCursor) && typeof tStylingKey === "string") {
      return keyValueArrayIndexOf(tStylingKeyCursor, tStylingKey) >= 0;
    }
    return false;
  }
  var parserState = {
    textEnd: 0,
    key: 0,
    keyEnd: 0,
    value: 0,
    valueEnd: 0
  };
  function getLastParsedKey(text) {
    return text.substring(parserState.key, parserState.keyEnd);
  }
  function getLastParsedValue(text) {
    return text.substring(parserState.value, parserState.valueEnd);
  }
  function parseClassName(text) {
    resetParserState(text);
    return parseClassNameNext(text, consumeWhitespace(text, 0, parserState.textEnd));
  }
  function parseClassNameNext(text, index) {
    const end = parserState.textEnd;
    if (end === index) {
      return -1;
    }
    index = parserState.keyEnd = consumeClassToken(text, parserState.key = index, end);
    return consumeWhitespace(text, index, end);
  }
  function parseStyle(text) {
    resetParserState(text);
    return parseStyleNext(text, consumeWhitespace(text, 0, parserState.textEnd));
  }
  function parseStyleNext(text, startIndex) {
    const end = parserState.textEnd;
    let index = parserState.key = consumeWhitespace(text, startIndex, end);
    if (end === index) {
      return -1;
    }
    index = parserState.keyEnd = consumeStyleKey(text, index, end);
    index = consumeSeparator(text, index, end, 58);
    index = parserState.value = consumeWhitespace(text, index, end);
    index = parserState.valueEnd = consumeStyleValue(text, index, end);
    return consumeSeparator(text, index, end, 59);
  }
  function resetParserState(text) {
    parserState.key = 0;
    parserState.keyEnd = 0;
    parserState.value = 0;
    parserState.valueEnd = 0;
    parserState.textEnd = text.length;
  }
  function consumeWhitespace(text, startIndex, endIndex) {
    while (startIndex < endIndex && text.charCodeAt(startIndex) <= 32) {
      startIndex++;
    }
    return startIndex;
  }
  function consumeClassToken(text, startIndex, endIndex) {
    while (startIndex < endIndex && text.charCodeAt(startIndex) > 32) {
      startIndex++;
    }
    return startIndex;
  }
  function consumeStyleKey(text, startIndex, endIndex) {
    let ch;
    while (startIndex < endIndex && ((ch = text.charCodeAt(startIndex)) === 45 || ch === 95 || (ch & -33) >= 65 && (ch & -33) <= 90 || ch >= 48 && ch <= 57)) {
      startIndex++;
    }
    return startIndex;
  }
  function consumeSeparator(text, startIndex, endIndex, separator) {
    startIndex = consumeWhitespace(text, startIndex, endIndex);
    if (startIndex < endIndex) {
      if (ngDevMode && text.charCodeAt(startIndex) !== separator) {
        malformedStyleError(text, String.fromCharCode(separator), startIndex);
      }
      startIndex++;
    }
    return startIndex;
  }
  function consumeStyleValue(text, startIndex, endIndex) {
    let ch1 = -1;
    let ch2 = -1;
    let ch3 = -1;
    let i = startIndex;
    let lastChIndex = i;
    while (i < endIndex) {
      const ch = text.charCodeAt(i++);
      if (ch === 59) {
        return lastChIndex;
      } else if (ch === 34 || ch === 39) {
        lastChIndex = i = consumeQuotedText(text, ch, i, endIndex);
      } else if (startIndex === i - 4 && ch3 === 85 && ch2 === 82 && ch1 === 76 && ch === 40) {
        lastChIndex = i = consumeQuotedText(text, 41, i, endIndex);
      } else if (ch > 32) {
        lastChIndex = i;
      }
      ch3 = ch2;
      ch2 = ch1;
      ch1 = ch & -33;
    }
    return lastChIndex;
  }
  function consumeQuotedText(text, quoteCharCode, startIndex, endIndex) {
    let ch1 = -1;
    let index = startIndex;
    while (index < endIndex) {
      const ch = text.charCodeAt(index++);
      if (ch == quoteCharCode && ch1 !== 92) {
        return index;
      }
      if (ch == 92 && ch1 === 92) {
        ch1 = 0;
      } else {
        ch1 = ch;
      }
    }
    throw ngDevMode ? malformedStyleError(text, String.fromCharCode(quoteCharCode), endIndex) : new Error();
  }
  function malformedStyleError(text, expecting, index) {
    ngDevMode && assertEqual(typeof text === "string", true, "String expected here");
    throw throwError(`Malformed style at location ${index} in string '` + text.substring(0, index) + "[>>" + text.substring(index, index + 1) + "<<]" + text.substr(index + 1) + `'. Expecting '${expecting}'.`);
  }
  function \u0275\u0275styleProp(prop, value, suffix) {
    checkStylingProperty(prop, value, suffix, false);
    return \u0275\u0275styleProp;
  }
  function \u0275\u0275classProp(className, value) {
    checkStylingProperty(className, value, null, true);
    return \u0275\u0275classProp;
  }
  function \u0275\u0275styleMap(styles) {
    checkStylingMap(styleKeyValueArraySet, styleStringParser, styles, false);
  }
  function styleStringParser(keyValueArray, text) {
    for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i)) {
      styleKeyValueArraySet(keyValueArray, getLastParsedKey(text), getLastParsedValue(text));
    }
  }
  function \u0275\u0275classMap(classes) {
    checkStylingMap(keyValueArraySet, classStringParser, classes, true);
  }
  function classStringParser(keyValueArray, text) {
    for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {
      keyValueArraySet(keyValueArray, getLastParsedKey(text), true);
    }
  }
  function checkStylingProperty(prop, value, suffix, isClassBased) {
    const lView = getLView();
    const tView = getTView();
    const bindingIndex = incrementBindingIndex(2);
    if (tView.firstUpdatePass) {
      stylingFirstUpdatePass(tView, prop, bindingIndex, isClassBased);
    }
    if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {
      const tNode = tView.data[getSelectedIndex()];
      updateStyling(tView, tNode, lView, lView[RENDERER], prop, lView[bindingIndex + 1] = normalizeSuffix(value, suffix), isClassBased, bindingIndex);
    }
  }
  function checkStylingMap(keyValueArraySet2, stringParser, value, isClassBased) {
    const tView = getTView();
    const bindingIndex = incrementBindingIndex(2);
    if (tView.firstUpdatePass) {
      stylingFirstUpdatePass(tView, null, bindingIndex, isClassBased);
    }
    const lView = getLView();
    if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {
      const tNode = tView.data[getSelectedIndex()];
      if (hasStylingInputShadow(tNode, isClassBased) && !isInHostBindings(tView, bindingIndex)) {
        if (ngDevMode) {
          const tStylingKey = tView.data[bindingIndex];
          assertEqual(Array.isArray(tStylingKey) ? tStylingKey[1] : tStylingKey, false, "Styling linked list shadow input should be marked as 'false'");
        }
        let staticPrefix = isClassBased ? tNode.classesWithoutHost : tNode.stylesWithoutHost;
        ngDevMode && isClassBased === false && staticPrefix !== null && assertEqual(staticPrefix.endsWith(";"), true, "Expecting static portion to end with ';'");
        if (staticPrefix !== null) {
          value = concatStringsWithSpace(staticPrefix, value ? value : "");
        }
        setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased);
      } else {
        updateStylingMap(tView, tNode, lView, lView[RENDERER], lView[bindingIndex + 1], lView[bindingIndex + 1] = toStylingKeyValueArray(keyValueArraySet2, stringParser, value), isClassBased, bindingIndex);
      }
    }
  }
  function isInHostBindings(tView, bindingIndex) {
    return bindingIndex >= tView.expandoStartIndex;
  }
  function stylingFirstUpdatePass(tView, tStylingKey, bindingIndex, isClassBased) {
    ngDevMode && assertFirstUpdatePass(tView);
    const tData = tView.data;
    if (tData[bindingIndex + 1] === null) {
      const tNode = tData[getSelectedIndex()];
      ngDevMode && assertDefined(tNode, "TNode expected");
      const isHostBindings = isInHostBindings(tView, bindingIndex);
      if (hasStylingInputShadow(tNode, isClassBased) && tStylingKey === null && !isHostBindings) {
        tStylingKey = false;
      }
      tStylingKey = wrapInStaticStylingKey(tData, tNode, tStylingKey, isClassBased);
      insertTStylingBinding(tData, tNode, tStylingKey, bindingIndex, isHostBindings, isClassBased);
    }
  }
  function wrapInStaticStylingKey(tData, tNode, stylingKey, isClassBased) {
    const hostDirectiveDef = getCurrentDirectiveDef(tData);
    let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;
    if (hostDirectiveDef === null) {
      const isFirstStylingInstructionInTemplate = (isClassBased ? tNode.classBindings : tNode.styleBindings) === 0;
      if (isFirstStylingInstructionInTemplate) {
        stylingKey = collectStylingFromDirectives(null, tData, tNode, stylingKey, isClassBased);
        stylingKey = collectStylingFromTAttrs(stylingKey, tNode.attrs, isClassBased);
        residual = null;
      }
    } else {
      const directiveStylingLast = tNode.directiveStylingLast;
      const isFirstStylingInstructionInHostBinding = directiveStylingLast === -1 || tData[directiveStylingLast] !== hostDirectiveDef;
      if (isFirstStylingInstructionInHostBinding) {
        stylingKey = collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased);
        if (residual === null) {
          let templateStylingKey = getTemplateHeadTStylingKey(tData, tNode, isClassBased);
          if (templateStylingKey !== void 0 && Array.isArray(templateStylingKey)) {
            templateStylingKey = collectStylingFromDirectives(null, tData, tNode, templateStylingKey[1], isClassBased);
            templateStylingKey = collectStylingFromTAttrs(templateStylingKey, tNode.attrs, isClassBased);
            setTemplateHeadTStylingKey(tData, tNode, isClassBased, templateStylingKey);
          }
        } else {
          residual = collectResidual(tData, tNode, isClassBased);
        }
      }
    }
    if (residual !== void 0) {
      isClassBased ? tNode.residualClasses = residual : tNode.residualStyles = residual;
    }
    return stylingKey;
  }
  function getTemplateHeadTStylingKey(tData, tNode, isClassBased) {
    const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;
    if (getTStylingRangeNext(bindings) === 0) {
      return void 0;
    }
    return tData[getTStylingRangePrev(bindings)];
  }
  function setTemplateHeadTStylingKey(tData, tNode, isClassBased, tStylingKey) {
    const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;
    ngDevMode && assertNotEqual(getTStylingRangeNext(bindings), 0, "Expecting to have at least one template styling binding.");
    tData[getTStylingRangePrev(bindings)] = tStylingKey;
  }
  function collectResidual(tData, tNode, isClassBased) {
    let residual = void 0;
    const directiveEnd = tNode.directiveEnd;
    ngDevMode && assertNotEqual(tNode.directiveStylingLast, -1, "By the time this function gets called at least one hostBindings-node styling instruction must have executed.");
    for (let i = 1 + tNode.directiveStylingLast; i < directiveEnd; i++) {
      const attrs = tData[i].hostAttrs;
      residual = collectStylingFromTAttrs(residual, attrs, isClassBased);
    }
    return collectStylingFromTAttrs(residual, tNode.attrs, isClassBased);
  }
  function collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased) {
    let currentDirective = null;
    const directiveEnd = tNode.directiveEnd;
    let directiveStylingLast = tNode.directiveStylingLast;
    if (directiveStylingLast === -1) {
      directiveStylingLast = tNode.directiveStart;
    } else {
      directiveStylingLast++;
    }
    while (directiveStylingLast < directiveEnd) {
      currentDirective = tData[directiveStylingLast];
      ngDevMode && assertDefined(currentDirective, "expected to be defined");
      stylingKey = collectStylingFromTAttrs(stylingKey, currentDirective.hostAttrs, isClassBased);
      if (currentDirective === hostDirectiveDef)
        break;
      directiveStylingLast++;
    }
    if (hostDirectiveDef !== null) {
      tNode.directiveStylingLast = directiveStylingLast;
    }
    return stylingKey;
  }
  function collectStylingFromTAttrs(stylingKey, attrs, isClassBased) {
    const desiredMarker = isClassBased ? 1 : 2;
    let currentMarker = -1;
    if (attrs !== null) {
      for (let i = 0; i < attrs.length; i++) {
        const item = attrs[i];
        if (typeof item === "number") {
          currentMarker = item;
        } else {
          if (currentMarker === desiredMarker) {
            if (!Array.isArray(stylingKey)) {
              stylingKey = stylingKey === void 0 ? [] : ["", stylingKey];
            }
            keyValueArraySet(stylingKey, item, isClassBased ? true : attrs[++i]);
          }
        }
      }
    }
    return stylingKey === void 0 ? null : stylingKey;
  }
  function toStylingKeyValueArray(keyValueArraySet2, stringParser, value) {
    if (value == null || value === "")
      return EMPTY_ARRAY;
    const styleKeyValueArray = [];
    const unwrappedValue = unwrapSafeValue(value);
    if (Array.isArray(unwrappedValue)) {
      for (let i = 0; i < unwrappedValue.length; i++) {
        keyValueArraySet2(styleKeyValueArray, unwrappedValue[i], true);
      }
    } else if (typeof unwrappedValue === "object") {
      for (const key in unwrappedValue) {
        if (unwrappedValue.hasOwnProperty(key)) {
          keyValueArraySet2(styleKeyValueArray, key, unwrappedValue[key]);
        }
      }
    } else if (typeof unwrappedValue === "string") {
      stringParser(styleKeyValueArray, unwrappedValue);
    } else {
      ngDevMode && throwError("Unsupported styling type " + typeof unwrappedValue + ": " + unwrappedValue);
    }
    return styleKeyValueArray;
  }
  function styleKeyValueArraySet(keyValueArray, key, value) {
    keyValueArraySet(keyValueArray, key, unwrapSafeValue(value));
  }
  function updateStylingMap(tView, tNode, lView, renderer, oldKeyValueArray, newKeyValueArray, isClassBased, bindingIndex) {
    if (oldKeyValueArray === NO_CHANGE) {
      oldKeyValueArray = EMPTY_ARRAY;
    }
    let oldIndex = 0;
    let newIndex = 0;
    let oldKey = 0 < oldKeyValueArray.length ? oldKeyValueArray[0] : null;
    let newKey = 0 < newKeyValueArray.length ? newKeyValueArray[0] : null;
    while (oldKey !== null || newKey !== null) {
      ngDevMode && assertLessThan(oldIndex, 999, "Are we stuck in infinite loop?");
      ngDevMode && assertLessThan(newIndex, 999, "Are we stuck in infinite loop?");
      const oldValue = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex + 1] : void 0;
      const newValue = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex + 1] : void 0;
      let setKey = null;
      let setValue = void 0;
      if (oldKey === newKey) {
        oldIndex += 2;
        newIndex += 2;
        if (oldValue !== newValue) {
          setKey = newKey;
          setValue = newValue;
        }
      } else if (newKey === null || oldKey !== null && oldKey < newKey) {
        oldIndex += 2;
        setKey = oldKey;
      } else {
        ngDevMode && assertDefined(newKey, "Expecting to have a valid key");
        newIndex += 2;
        setKey = newKey;
        setValue = newValue;
      }
      if (setKey !== null) {
        updateStyling(tView, tNode, lView, renderer, setKey, setValue, isClassBased, bindingIndex);
      }
      oldKey = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex] : null;
      newKey = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex] : null;
    }
  }
  function updateStyling(tView, tNode, lView, renderer, prop, value, isClassBased, bindingIndex) {
    if (!(tNode.type & 3)) {
      return;
    }
    const tData = tView.data;
    const tRange = tData[bindingIndex + 1];
    const higherPriorityValue = getTStylingRangeNextDuplicate(tRange) ? findStylingValue(tData, tNode, lView, prop, getTStylingRangeNext(tRange), isClassBased) : void 0;
    if (!isStylingValuePresent(higherPriorityValue)) {
      if (!isStylingValuePresent(value)) {
        if (getTStylingRangePrevDuplicate(tRange)) {
          value = findStylingValue(tData, null, lView, prop, bindingIndex, isClassBased);
        }
      }
      const rNode = getNativeByIndex(getSelectedIndex(), lView);
      applyStyling(renderer, isClassBased, rNode, prop, value);
    }
  }
  function findStylingValue(tData, tNode, lView, prop, index, isClassBased) {
    const isPrevDirection = tNode === null;
    let value = void 0;
    while (index > 0) {
      const rawKey = tData[index];
      const containsStatics = Array.isArray(rawKey);
      const key = containsStatics ? rawKey[1] : rawKey;
      const isStylingMap = key === null;
      let valueAtLViewIndex = lView[index + 1];
      if (valueAtLViewIndex === NO_CHANGE) {
        valueAtLViewIndex = isStylingMap ? EMPTY_ARRAY : void 0;
      }
      let currentValue = isStylingMap ? keyValueArrayGet(valueAtLViewIndex, prop) : key === prop ? valueAtLViewIndex : void 0;
      if (containsStatics && !isStylingValuePresent(currentValue)) {
        currentValue = keyValueArrayGet(rawKey, prop);
      }
      if (isStylingValuePresent(currentValue)) {
        value = currentValue;
        if (isPrevDirection) {
          return value;
        }
      }
      const tRange = tData[index + 1];
      index = isPrevDirection ? getTStylingRangePrev(tRange) : getTStylingRangeNext(tRange);
    }
    if (tNode !== null) {
      let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;
      if (residual != null) {
        value = keyValueArrayGet(residual, prop);
      }
    }
    return value;
  }
  function isStylingValuePresent(value) {
    return value !== void 0;
  }
  function normalizeSuffix(value, suffix) {
    if (value == null) {
    } else if (typeof suffix === "string") {
      value = value + suffix;
    } else if (typeof value === "object") {
      value = stringify(unwrapSafeValue(value));
    }
    return value;
  }
  function hasStylingInputShadow(tNode, isClassBased) {
    return (tNode.flags & (isClassBased ? 16 : 32)) !== 0;
  }
  function \u0275\u0275text(index, value = "") {
    const lView = getLView();
    const tView = getTView();
    const adjustedIndex = index + HEADER_OFFSET;
    ngDevMode && assertEqual(getBindingIndex(), tView.bindingStartIndex, "text nodes should be created before any bindings");
    ngDevMode && assertIndexInRange(lView, adjustedIndex);
    const tNode = tView.firstCreatePass ? getOrCreateTNode(tView, adjustedIndex, 1, value, null) : tView.data[adjustedIndex];
    const textNative = lView[adjustedIndex] = createTextNode(lView[RENDERER], value);
    appendChild(tView, lView, textNative, tNode);
    setCurrentTNode(tNode, false);
  }
  function \u0275\u0275textInterpolate(v0) {
    \u0275\u0275textInterpolate1("", v0, "");
    return \u0275\u0275textInterpolate;
  }
  function \u0275\u0275textInterpolate1(prefix, v0, suffix) {
    const lView = getLView();
    const interpolated = interpolation1(lView, prefix, v0, suffix);
    if (interpolated !== NO_CHANGE) {
      textBindingInternal(lView, getSelectedIndex(), interpolated);
    }
    return \u0275\u0275textInterpolate1;
  }
  function \u0275\u0275textInterpolate2(prefix, v0, i0, v1, suffix) {
    const lView = getLView();
    const interpolated = interpolation2(lView, prefix, v0, i0, v1, suffix);
    if (interpolated !== NO_CHANGE) {
      textBindingInternal(lView, getSelectedIndex(), interpolated);
    }
    return \u0275\u0275textInterpolate2;
  }
  function \u0275\u0275textInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {
    const lView = getLView();
    const interpolated = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
    if (interpolated !== NO_CHANGE) {
      textBindingInternal(lView, getSelectedIndex(), interpolated);
    }
    return \u0275\u0275textInterpolate3;
  }
  function \u0275\u0275textInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
    const lView = getLView();
    const interpolated = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
    if (interpolated !== NO_CHANGE) {
      textBindingInternal(lView, getSelectedIndex(), interpolated);
    }
    return \u0275\u0275textInterpolate4;
  }
  function \u0275\u0275textInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
    const lView = getLView();
    const interpolated = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
    if (interpolated !== NO_CHANGE) {
      textBindingInternal(lView, getSelectedIndex(), interpolated);
    }
    return \u0275\u0275textInterpolate5;
  }
  function \u0275\u0275textInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
    const lView = getLView();
    const interpolated = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
    if (interpolated !== NO_CHANGE) {
      textBindingInternal(lView, getSelectedIndex(), interpolated);
    }
    return \u0275\u0275textInterpolate6;
  }
  function \u0275\u0275textInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
    const lView = getLView();
    const interpolated = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
    if (interpolated !== NO_CHANGE) {
      textBindingInternal(lView, getSelectedIndex(), interpolated);
    }
    return \u0275\u0275textInterpolate7;
  }
  function \u0275\u0275textInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
    const lView = getLView();
    const interpolated = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
    if (interpolated !== NO_CHANGE) {
      textBindingInternal(lView, getSelectedIndex(), interpolated);
    }
    return \u0275\u0275textInterpolate8;
  }
  function \u0275\u0275textInterpolateV(values) {
    const lView = getLView();
    const interpolated = interpolationV(lView, values);
    if (interpolated !== NO_CHANGE) {
      textBindingInternal(lView, getSelectedIndex(), interpolated);
    }
    return \u0275\u0275textInterpolateV;
  }
  function \u0275\u0275classMapInterpolate1(prefix, v0, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
  }
  function \u0275\u0275classMapInterpolate2(prefix, v0, i0, v1, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
  }
  function \u0275\u0275classMapInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
  }
  function \u0275\u0275classMapInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
  }
  function \u0275\u0275classMapInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
  }
  function \u0275\u0275classMapInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
  }
  function \u0275\u0275classMapInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
  }
  function \u0275\u0275classMapInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
  }
  function \u0275\u0275classMapInterpolateV(values) {
    const lView = getLView();
    const interpolatedValue = interpolationV(lView, values);
    checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);
  }
  function \u0275\u0275styleMapInterpolate1(prefix, v0, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
    \u0275\u0275styleMap(interpolatedValue);
  }
  function \u0275\u0275styleMapInterpolate2(prefix, v0, i0, v1, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
    \u0275\u0275styleMap(interpolatedValue);
  }
  function \u0275\u0275styleMapInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
    \u0275\u0275styleMap(interpolatedValue);
  }
  function \u0275\u0275styleMapInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
    \u0275\u0275styleMap(interpolatedValue);
  }
  function \u0275\u0275styleMapInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
    \u0275\u0275styleMap(interpolatedValue);
  }
  function \u0275\u0275styleMapInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
    \u0275\u0275styleMap(interpolatedValue);
  }
  function \u0275\u0275styleMapInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
    \u0275\u0275styleMap(interpolatedValue);
  }
  function \u0275\u0275styleMapInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
    const lView = getLView();
    const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
    \u0275\u0275styleMap(interpolatedValue);
  }
  function \u0275\u0275styleMapInterpolateV(values) {
    const lView = getLView();
    const interpolatedValue = interpolationV(lView, values);
    \u0275\u0275styleMap(interpolatedValue);
  }
  function \u0275\u0275stylePropInterpolate1(prop, prefix, v0, suffix, valueSuffix) {
    const lView = getLView();
    const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return \u0275\u0275stylePropInterpolate1;
  }
  function \u0275\u0275stylePropInterpolate2(prop, prefix, v0, i0, v1, suffix, valueSuffix) {
    const lView = getLView();
    const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return \u0275\u0275stylePropInterpolate2;
  }
  function \u0275\u0275stylePropInterpolate3(prop, prefix, v0, i0, v1, i1, v2, suffix, valueSuffix) {
    const lView = getLView();
    const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return \u0275\u0275stylePropInterpolate3;
  }
  function \u0275\u0275stylePropInterpolate4(prop, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, valueSuffix) {
    const lView = getLView();
    const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return \u0275\u0275stylePropInterpolate4;
  }
  function \u0275\u0275stylePropInterpolate5(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, valueSuffix) {
    const lView = getLView();
    const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return \u0275\u0275stylePropInterpolate5;
  }
  function \u0275\u0275stylePropInterpolate6(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, valueSuffix) {
    const lView = getLView();
    const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return \u0275\u0275stylePropInterpolate6;
  }
  function \u0275\u0275stylePropInterpolate7(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, valueSuffix) {
    const lView = getLView();
    const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return \u0275\u0275stylePropInterpolate7;
  }
  function \u0275\u0275stylePropInterpolate8(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, valueSuffix) {
    const lView = getLView();
    const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return \u0275\u0275stylePropInterpolate8;
  }
  function \u0275\u0275stylePropInterpolateV(prop, values, valueSuffix) {
    const lView = getLView();
    const interpolatedValue = interpolationV(lView, values);
    checkStylingProperty(prop, interpolatedValue, valueSuffix, false);
    return \u0275\u0275stylePropInterpolateV;
  }
  function \u0275\u0275hostProperty(propName, value, sanitizer) {
    const lView = getLView();
    const bindingIndex = nextBindingIndex();
    if (bindingUpdated(lView, bindingIndex, value)) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, true);
      ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
    }
    return \u0275\u0275hostProperty;
  }
  function \u0275\u0275syntheticHostProperty(propName, value, sanitizer) {
    const lView = getLView();
    const bindingIndex = nextBindingIndex();
    if (bindingUpdated(lView, bindingIndex, value)) {
      const tView = getTView();
      const tNode = getSelectedTNode();
      const currentDef = getCurrentDirectiveDef(tView.data);
      const renderer = loadComponentRenderer(currentDef, tNode, lView);
      elementPropertyInternal(tView, tNode, lView, propName, value, renderer, sanitizer, true);
      ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);
    }
    return \u0275\u0275syntheticHostProperty;
  }
  if (typeof ngI18nClosureMode === "undefined") {
    (function() {
      _global2["ngI18nClosureMode"] = typeof goog !== "undefined" && typeof goog.getMsg === "function";
    })();
  }
  var u = void 0;
  function plural(val) {
    const n = val, i = Math.floor(Math.abs(val)), v = val.toString().replace(/^[^.]*\.?/, "").length;
    if (i === 1 && v === 0)
      return 1;
    return 5;
  }
  var localeEn = ["en", [["a", "p"], ["AM", "PM"], u], [["AM", "PM"], u, u], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], u, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], u, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", u, "{1} 'at' {0}", u], [".", ",", ";", "%", "+", "-", "E", "\xD7", "\u2030", "\u221E", "NaN", ":"], ["#,##0.###", "#,##0%", "\xA4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr", plural];
  var LOCALE_DATA = {};
  function registerLocaleData(data, localeId, extraData) {
    if (typeof localeId !== "string") {
      extraData = localeId;
      localeId = data[LocaleDataIndex.LocaleId];
    }
    localeId = localeId.toLowerCase().replace(/_/g, "-");
    LOCALE_DATA[localeId] = data;
    if (extraData) {
      LOCALE_DATA[localeId][LocaleDataIndex.ExtraData] = extraData;
    }
  }
  function findLocaleData(locale) {
    const normalizedLocale = normalizeLocale(locale);
    let match2 = getLocaleData(normalizedLocale);
    if (match2) {
      return match2;
    }
    const parentLocale = normalizedLocale.split("-")[0];
    match2 = getLocaleData(parentLocale);
    if (match2) {
      return match2;
    }
    if (parentLocale === "en") {
      return localeEn;
    }
    throw new Error(`Missing locale data for the locale "${locale}".`);
  }
  function getLocaleCurrencyCode(locale) {
    const data = findLocaleData(locale);
    return data[LocaleDataIndex.CurrencyCode] || null;
  }
  function getLocalePluralCase(locale) {
    const data = findLocaleData(locale);
    return data[LocaleDataIndex.PluralCase];
  }
  function getLocaleData(normalizedLocale) {
    if (!(normalizedLocale in LOCALE_DATA)) {
      LOCALE_DATA[normalizedLocale] = _global2.ng && _global2.ng.common && _global2.ng.common.locales && _global2.ng.common.locales[normalizedLocale];
    }
    return LOCALE_DATA[normalizedLocale];
  }
  function unregisterAllLocaleData() {
    LOCALE_DATA = {};
  }
  var LocaleDataIndex;
  (function(LocaleDataIndex2) {
    LocaleDataIndex2[LocaleDataIndex2["LocaleId"] = 0] = "LocaleId";
    LocaleDataIndex2[LocaleDataIndex2["DayPeriodsFormat"] = 1] = "DayPeriodsFormat";
    LocaleDataIndex2[LocaleDataIndex2["DayPeriodsStandalone"] = 2] = "DayPeriodsStandalone";
    LocaleDataIndex2[LocaleDataIndex2["DaysFormat"] = 3] = "DaysFormat";
    LocaleDataIndex2[LocaleDataIndex2["DaysStandalone"] = 4] = "DaysStandalone";
    LocaleDataIndex2[LocaleDataIndex2["MonthsFormat"] = 5] = "MonthsFormat";
    LocaleDataIndex2[LocaleDataIndex2["MonthsStandalone"] = 6] = "MonthsStandalone";
    LocaleDataIndex2[LocaleDataIndex2["Eras"] = 7] = "Eras";
    LocaleDataIndex2[LocaleDataIndex2["FirstDayOfWeek"] = 8] = "FirstDayOfWeek";
    LocaleDataIndex2[LocaleDataIndex2["WeekendRange"] = 9] = "WeekendRange";
    LocaleDataIndex2[LocaleDataIndex2["DateFormat"] = 10] = "DateFormat";
    LocaleDataIndex2[LocaleDataIndex2["TimeFormat"] = 11] = "TimeFormat";
    LocaleDataIndex2[LocaleDataIndex2["DateTimeFormat"] = 12] = "DateTimeFormat";
    LocaleDataIndex2[LocaleDataIndex2["NumberSymbols"] = 13] = "NumberSymbols";
    LocaleDataIndex2[LocaleDataIndex2["NumberFormats"] = 14] = "NumberFormats";
    LocaleDataIndex2[LocaleDataIndex2["CurrencyCode"] = 15] = "CurrencyCode";
    LocaleDataIndex2[LocaleDataIndex2["CurrencySymbol"] = 16] = "CurrencySymbol";
    LocaleDataIndex2[LocaleDataIndex2["CurrencyName"] = 17] = "CurrencyName";
    LocaleDataIndex2[LocaleDataIndex2["Currencies"] = 18] = "Currencies";
    LocaleDataIndex2[LocaleDataIndex2["Directionality"] = 19] = "Directionality";
    LocaleDataIndex2[LocaleDataIndex2["PluralCase"] = 20] = "PluralCase";
    LocaleDataIndex2[LocaleDataIndex2["ExtraData"] = 21] = "ExtraData";
  })(LocaleDataIndex || (LocaleDataIndex = {}));
  function normalizeLocale(locale) {
    return locale.toLowerCase().replace(/_/g, "-");
  }
  var pluralMapping = ["zero", "one", "two", "few", "many"];
  function getPluralCase(value, locale) {
    const plural2 = getLocalePluralCase(locale)(parseInt(value, 10));
    const result = pluralMapping[plural2];
    return result !== void 0 ? result : "other";
  }
  var DEFAULT_LOCALE_ID = "en-US";
  var USD_CURRENCY_CODE = "USD";
  var ELEMENT_MARKER = {
    marker: "element"
  };
  var ICU_MARKER = {
    marker: "ICU"
  };
  var I18nCreateOpCode;
  (function(I18nCreateOpCode2) {
    I18nCreateOpCode2[I18nCreateOpCode2["SHIFT"] = 2] = "SHIFT";
    I18nCreateOpCode2[I18nCreateOpCode2["APPEND_EAGERLY"] = 1] = "APPEND_EAGERLY";
    I18nCreateOpCode2[I18nCreateOpCode2["COMMENT"] = 2] = "COMMENT";
  })(I18nCreateOpCode || (I18nCreateOpCode = {}));
  var LOCALE_ID$1 = DEFAULT_LOCALE_ID;
  function setLocaleId(localeId) {
    assertDefined(localeId, `Expected localeId to be defined`);
    if (typeof localeId === "string") {
      LOCALE_ID$1 = localeId.toLowerCase().replace(/_/g, "-");
    }
  }
  function getLocaleId() {
    return LOCALE_ID$1;
  }
  function getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView) {
    const tNodeInsertBeforeIndex = currentTNode.insertBeforeIndex;
    const insertBeforeIndex = Array.isArray(tNodeInsertBeforeIndex) ? tNodeInsertBeforeIndex[0] : tNodeInsertBeforeIndex;
    if (insertBeforeIndex === null) {
      return getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView);
    } else {
      ngDevMode && assertIndexInRange(lView, insertBeforeIndex);
      return unwrapRNode(lView[insertBeforeIndex]);
    }
  }
  function processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRElement) {
    const tNodeInsertBeforeIndex = childTNode.insertBeforeIndex;
    if (Array.isArray(tNodeInsertBeforeIndex)) {
      ngDevMode && assertDomNode(childRNode);
      let i18nParent = childRNode;
      let anchorRNode = null;
      if (!(childTNode.type & 3)) {
        anchorRNode = i18nParent;
        i18nParent = parentRElement;
      }
      if (i18nParent !== null && (childTNode.flags & 2) === 0) {
        for (let i = 1; i < tNodeInsertBeforeIndex.length; i++) {
          const i18nChild = lView[tNodeInsertBeforeIndex[i]];
          nativeInsertBefore(renderer, i18nParent, i18nChild, anchorRNode, false);
        }
      }
    }
  }
  function addTNodeAndUpdateInsertBeforeIndex(previousTNodes, newTNode) {
    ngDevMode && assertEqual(newTNode.insertBeforeIndex, null, "We expect that insertBeforeIndex is not set");
    previousTNodes.push(newTNode);
    if (previousTNodes.length > 1) {
      for (let i = previousTNodes.length - 2; i >= 0; i--) {
        const existingTNode = previousTNodes[i];
        if (!isI18nText(existingTNode)) {
          if (isNewTNodeCreatedBefore(existingTNode, newTNode) && getInsertBeforeIndex(existingTNode) === null) {
            setInsertBeforeIndex(existingTNode, newTNode.index);
          }
        }
      }
    }
  }
  function isI18nText(tNode) {
    return !(tNode.type & 64);
  }
  function isNewTNodeCreatedBefore(existingTNode, newTNode) {
    return isI18nText(newTNode) || existingTNode.index > newTNode.index;
  }
  function getInsertBeforeIndex(tNode) {
    const index = tNode.insertBeforeIndex;
    return Array.isArray(index) ? index[0] : index;
  }
  function setInsertBeforeIndex(tNode, value) {
    const index = tNode.insertBeforeIndex;
    if (Array.isArray(index)) {
      index[0] = value;
    } else {
      setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);
      tNode.insertBeforeIndex = value;
    }
  }
  function getTIcu(tView, index) {
    const value = tView.data[index];
    if (value === null || typeof value === "string")
      return null;
    if (ngDevMode && !(value.hasOwnProperty("tViews") || value.hasOwnProperty("currentCaseLViewIndex"))) {
      throwError("We expect to get 'null'|'TIcu'|'TIcuContainer', but got: " + value);
    }
    const tIcu = value.hasOwnProperty("currentCaseLViewIndex") ? value : value.value;
    ngDevMode && assertTIcu(tIcu);
    return tIcu;
  }
  function setTIcu(tView, index, tIcu) {
    const tNode = tView.data[index];
    ngDevMode && assertEqual(tNode === null || tNode.hasOwnProperty("tViews"), true, "We expect to get 'null'|'TIcuContainer'");
    if (tNode === null) {
      tView.data[index] = tIcu;
    } else {
      ngDevMode && assertTNodeType(tNode, 32);
      tNode.value = tIcu;
    }
  }
  function setTNodeInsertBeforeIndex(tNode, index) {
    ngDevMode && assertTNode(tNode);
    let insertBeforeIndex = tNode.insertBeforeIndex;
    if (insertBeforeIndex === null) {
      setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);
      insertBeforeIndex = tNode.insertBeforeIndex = [null, index];
    } else {
      assertEqual(Array.isArray(insertBeforeIndex), true, "Expecting array here");
      insertBeforeIndex.push(index);
    }
  }
  function createTNodePlaceholder(tView, previousTNodes, index) {
    const tNode = createTNodeAtIndex(tView, index, 64, null, null);
    addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tNode);
    return tNode;
  }
  function getCurrentICUCaseIndex(tIcu, lView) {
    const currentCase = lView[tIcu.currentCaseLViewIndex];
    return currentCase === null ? currentCase : currentCase < 0 ? ~currentCase : currentCase;
  }
  function getParentFromIcuCreateOpCode(mergedCode) {
    return mergedCode >>> 17;
  }
  function getRefFromIcuCreateOpCode(mergedCode) {
    return (mergedCode & 131070) >>> 1;
  }
  function getInstructionFromIcuCreateOpCode(mergedCode) {
    return mergedCode & 1;
  }
  function icuCreateOpCode(opCode, parentIdx, refIdx) {
    ngDevMode && assertGreaterThanOrEqual(parentIdx, 0, "Missing parent index");
    ngDevMode && assertGreaterThan(refIdx, 0, "Missing ref index");
    return opCode | parentIdx << 17 | refIdx << 1;
  }
  var changeMask = 0;
  var changeMaskCounter = 0;
  function setMaskBit(hasChange) {
    if (hasChange) {
      changeMask = changeMask | 1 << Math.min(changeMaskCounter, 31);
    }
    changeMaskCounter++;
  }
  function applyI18n(tView, lView, index) {
    if (changeMaskCounter > 0) {
      ngDevMode && assertDefined(tView, `tView should be defined`);
      const tI18n = tView.data[index];
      const updateOpCodes = Array.isArray(tI18n) ? tI18n : tI18n.update;
      const bindingsStartIndex = getBindingIndex() - changeMaskCounter - 1;
      applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask);
    }
    changeMask = 0;
    changeMaskCounter = 0;
  }
  function applyCreateOpCodes(lView, createOpCodes, parentRNode, insertInFrontOf) {
    const renderer = lView[RENDERER];
    for (let i = 0; i < createOpCodes.length; i++) {
      const opCode = createOpCodes[i++];
      const text = createOpCodes[i];
      const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;
      const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;
      const index = opCode >>> I18nCreateOpCode.SHIFT;
      let rNode = lView[index];
      if (rNode === null) {
        rNode = lView[index] = isComment ? renderer.createComment(text) : createTextNode(renderer, text);
      }
      if (appendNow && parentRNode !== null) {
        nativeInsertBefore(renderer, parentRNode, rNode, insertInFrontOf, false);
      }
    }
  }
  function applyMutableOpCodes(tView, mutableOpCodes, lView, anchorRNode) {
    ngDevMode && assertDomNode(anchorRNode);
    const renderer = lView[RENDERER];
    let rootIdx = null;
    let rootRNode;
    for (let i = 0; i < mutableOpCodes.length; i++) {
      const opCode = mutableOpCodes[i];
      if (typeof opCode == "string") {
        const textNodeIndex = mutableOpCodes[++i];
        if (lView[textNodeIndex] === null) {
          ngDevMode && ngDevMode.rendererCreateTextNode++;
          ngDevMode && assertIndexInRange(lView, textNodeIndex);
          lView[textNodeIndex] = createTextNode(renderer, opCode);
        }
      } else if (typeof opCode == "number") {
        switch (opCode & 1) {
          case 0:
            const parentIdx = getParentFromIcuCreateOpCode(opCode);
            if (rootIdx === null) {
              rootIdx = parentIdx;
              rootRNode = nativeParentNode(renderer, anchorRNode);
            }
            let insertInFrontOf;
            let parentRNode;
            if (parentIdx === rootIdx) {
              insertInFrontOf = anchorRNode;
              parentRNode = rootRNode;
            } else {
              insertInFrontOf = null;
              parentRNode = unwrapRNode(lView[parentIdx]);
            }
            if (parentRNode !== null) {
              ngDevMode && assertDomNode(parentRNode);
              const refIdx = getRefFromIcuCreateOpCode(opCode);
              ngDevMode && assertGreaterThan(refIdx, HEADER_OFFSET, "Missing ref");
              const child = lView[refIdx];
              ngDevMode && assertDomNode(child);
              nativeInsertBefore(renderer, parentRNode, child, insertInFrontOf, false);
              const tIcu = getTIcu(tView, refIdx);
              if (tIcu !== null && typeof tIcu === "object") {
                ngDevMode && assertTIcu(tIcu);
                const caseIndex = getCurrentICUCaseIndex(tIcu, lView);
                if (caseIndex !== null) {
                  applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, lView[tIcu.anchorIdx]);
                }
              }
            }
            break;
          case 1:
            const elementNodeIndex = opCode >>> 1;
            const attrName = mutableOpCodes[++i];
            const attrValue = mutableOpCodes[++i];
            setElementAttribute(renderer, getNativeByIndex(elementNodeIndex, lView), null, null, attrName, attrValue, null);
            break;
          default:
            throw new Error(`Unable to determine the type of mutate operation for "${opCode}"`);
        }
      } else {
        switch (opCode) {
          case ICU_MARKER:
            const commentValue = mutableOpCodes[++i];
            const commentNodeIndex = mutableOpCodes[++i];
            if (lView[commentNodeIndex] === null) {
              ngDevMode && assertEqual(typeof commentValue, "string", `Expected "${commentValue}" to be a comment node value`);
              ngDevMode && ngDevMode.rendererCreateComment++;
              ngDevMode && assertIndexInExpandoRange(lView, commentNodeIndex);
              const commentRNode = lView[commentNodeIndex] = createCommentNode(renderer, commentValue);
              attachPatchData(commentRNode, lView);
            }
            break;
          case ELEMENT_MARKER:
            const tagName = mutableOpCodes[++i];
            const elementNodeIndex = mutableOpCodes[++i];
            if (lView[elementNodeIndex] === null) {
              ngDevMode && assertEqual(typeof tagName, "string", `Expected "${tagName}" to be an element node tag name`);
              ngDevMode && ngDevMode.rendererCreateElement++;
              ngDevMode && assertIndexInExpandoRange(lView, elementNodeIndex);
              const elementRNode = lView[elementNodeIndex] = createElementNode(renderer, tagName, null);
              attachPatchData(elementRNode, lView);
            }
            break;
          default:
            ngDevMode && throwError(`Unable to determine the type of mutate operation for "${opCode}"`);
        }
      }
    }
  }
  function applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask2) {
    for (let i = 0; i < updateOpCodes.length; i++) {
      const checkBit = updateOpCodes[i];
      const skipCodes = updateOpCodes[++i];
      if (checkBit & changeMask2) {
        let value = "";
        for (let j = i + 1; j <= i + skipCodes; j++) {
          const opCode = updateOpCodes[j];
          if (typeof opCode == "string") {
            value += opCode;
          } else if (typeof opCode == "number") {
            if (opCode < 0) {
              value += renderStringify(lView[bindingsStartIndex - opCode]);
            } else {
              const nodeIndex = opCode >>> 2;
              switch (opCode & 3) {
                case 1:
                  const propName = updateOpCodes[++j];
                  const sanitizeFn = updateOpCodes[++j];
                  const tNodeOrTagName = tView.data[nodeIndex];
                  ngDevMode && assertDefined(tNodeOrTagName, "Experting TNode or string");
                  if (typeof tNodeOrTagName === "string") {
                    setElementAttribute(lView[RENDERER], lView[nodeIndex], null, tNodeOrTagName, propName, value, sanitizeFn);
                  } else {
                    elementPropertyInternal(tView, tNodeOrTagName, lView, propName, value, lView[RENDERER], sanitizeFn, false);
                  }
                  break;
                case 0:
                  const rText = lView[nodeIndex];
                  rText !== null && updateTextNode(lView[RENDERER], rText, value);
                  break;
                case 2:
                  applyIcuSwitchCase(tView, getTIcu(tView, nodeIndex), lView, value);
                  break;
                case 3:
                  applyIcuUpdateCase(tView, getTIcu(tView, nodeIndex), bindingsStartIndex, lView);
                  break;
              }
            }
          }
        }
      } else {
        const opCode = updateOpCodes[i + 1];
        if (opCode > 0 && (opCode & 3) === 3) {
          const nodeIndex = opCode >>> 2;
          const tIcu = getTIcu(tView, nodeIndex);
          const currentIndex = lView[tIcu.currentCaseLViewIndex];
          if (currentIndex < 0) {
            applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView);
          }
        }
      }
      i += skipCodes;
    }
  }
  function applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView) {
    ngDevMode && assertIndexInRange(lView, tIcu.currentCaseLViewIndex);
    let activeCaseIndex = lView[tIcu.currentCaseLViewIndex];
    if (activeCaseIndex !== null) {
      let mask = changeMask;
      if (activeCaseIndex < 0) {
        activeCaseIndex = lView[tIcu.currentCaseLViewIndex] = ~activeCaseIndex;
        mask = -1;
      }
      applyUpdateOpCodes(tView, lView, tIcu.update[activeCaseIndex], bindingsStartIndex, mask);
    }
  }
  function applyIcuSwitchCase(tView, tIcu, lView, value) {
    const caseIndex = getCaseIndex(tIcu, value);
    let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);
    if (activeCaseIndex !== caseIndex) {
      applyIcuSwitchCaseRemove(tView, tIcu, lView);
      lView[tIcu.currentCaseLViewIndex] = caseIndex === null ? null : ~caseIndex;
      if (caseIndex !== null) {
        const anchorRNode = lView[tIcu.anchorIdx];
        if (anchorRNode) {
          ngDevMode && assertDomNode(anchorRNode);
          applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, anchorRNode);
        }
      }
    }
  }
  function applyIcuSwitchCaseRemove(tView, tIcu, lView) {
    let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);
    if (activeCaseIndex !== null) {
      const removeCodes = tIcu.remove[activeCaseIndex];
      for (let i = 0; i < removeCodes.length; i++) {
        const nodeOrIcuIndex = removeCodes[i];
        if (nodeOrIcuIndex > 0) {
          const rNode = getNativeByIndex(nodeOrIcuIndex, lView);
          rNode !== null && nativeRemoveNode(lView[RENDERER], rNode);
        } else {
          applyIcuSwitchCaseRemove(tView, getTIcu(tView, ~nodeOrIcuIndex), lView);
        }
      }
    }
  }
  function getCaseIndex(icuExpression, bindingValue) {
    let index = icuExpression.cases.indexOf(bindingValue);
    if (index === -1) {
      switch (icuExpression.type) {
        case 1: {
          const resolvedCase = getPluralCase(bindingValue, getLocaleId());
          index = icuExpression.cases.indexOf(resolvedCase);
          if (index === -1 && resolvedCase !== "other") {
            index = icuExpression.cases.indexOf("other");
          }
          break;
        }
        case 0: {
          index = icuExpression.cases.indexOf("other");
          break;
        }
      }
    }
    return index === -1 ? null : index;
  }
  function loadIcuContainerVisitor() {
    const _stack = [];
    let _index = -1;
    let _lView;
    let _removes;
    function icuContainerIteratorStart(tIcuContainerNode, lView) {
      _lView = lView;
      while (_stack.length)
        _stack.pop();
      ngDevMode && assertTNodeForLView(tIcuContainerNode, lView);
      enterIcu(tIcuContainerNode.value, lView);
      return icuContainerIteratorNext;
    }
    function enterIcu(tIcu, lView) {
      _index = 0;
      const currentCase = getCurrentICUCaseIndex(tIcu, lView);
      if (currentCase !== null) {
        ngDevMode && assertNumberInRange(currentCase, 0, tIcu.cases.length - 1);
        _removes = tIcu.remove[currentCase];
      } else {
        _removes = EMPTY_ARRAY;
      }
    }
    function icuContainerIteratorNext() {
      if (_index < _removes.length) {
        const removeOpCode = _removes[_index++];
        ngDevMode && assertNumber(removeOpCode, "Expecting OpCode number");
        if (removeOpCode > 0) {
          const rNode = _lView[removeOpCode];
          ngDevMode && assertDomNode(rNode);
          return rNode;
        } else {
          _stack.push(_index, _removes);
          const tIcuIndex = ~removeOpCode;
          const tIcu = _lView[TVIEW].data[tIcuIndex];
          ngDevMode && assertTIcu(tIcu);
          enterIcu(tIcu, _lView);
          return icuContainerIteratorNext();
        }
      } else {
        if (_stack.length === 0) {
          return null;
        } else {
          _removes = _stack.pop();
          _index = _stack.pop();
          return icuContainerIteratorNext();
        }
      }
    }
    return icuContainerIteratorStart;
  }
  function i18nCreateOpCodesToString(opcodes) {
    const createOpCodes = opcodes || (Array.isArray(this) ? this : []);
    let lines = [];
    for (let i = 0; i < createOpCodes.length; i++) {
      const opCode = createOpCodes[i++];
      const text = createOpCodes[i];
      const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;
      const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;
      const index = opCode >>> I18nCreateOpCode.SHIFT;
      lines.push(`lView[${index}] = document.${isComment ? "createComment" : "createText"}(${JSON.stringify(text)});`);
      if (appendNow) {
        lines.push(`parent.appendChild(lView[${index}]);`);
      }
    }
    return lines;
  }
  function i18nUpdateOpCodesToString(opcodes) {
    const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));
    let lines = [];
    function consumeOpCode(value) {
      const ref = value >>> 2;
      const opCode = value & 3;
      switch (opCode) {
        case 0:
          return `(lView[${ref}] as Text).textContent = $$$`;
        case 1:
          const attrName = parser.consumeString();
          const sanitizationFn = parser.consumeFunction();
          const value2 = sanitizationFn ? `(${sanitizationFn})($$$)` : "$$$";
          return `(lView[${ref}] as Element).setAttribute('${attrName}', ${value2})`;
        case 2:
          return `icuSwitchCase(${ref}, $$$)`;
        case 3:
          return `icuUpdateCase(${ref})`;
      }
      throw new Error("unexpected OpCode");
    }
    while (parser.hasMore()) {
      let mask = parser.consumeNumber();
      let size = parser.consumeNumber();
      const end = parser.i + size;
      const statements = [];
      let statement = "";
      while (parser.i < end) {
        let value = parser.consumeNumberOrString();
        if (typeof value === "string") {
          statement += value;
        } else if (value < 0) {
          statement += "${lView[i" + value + "]}";
        } else {
          const opCodeText = consumeOpCode(value);
          statements.push(opCodeText.replace("$$$", "`" + statement + "`") + ";");
          statement = "";
        }
      }
      lines.push(`if (mask & 0b${mask.toString(2)}) { ${statements.join(" ")} }`);
    }
    return lines;
  }
  function icuCreateOpCodesToString(opcodes) {
    const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));
    let lines = [];
    function consumeOpCode(opCode) {
      const parent = getParentFromIcuCreateOpCode(opCode);
      const ref = getRefFromIcuCreateOpCode(opCode);
      switch (getInstructionFromIcuCreateOpCode(opCode)) {
        case 0:
          return `(lView[${parent}] as Element).appendChild(lView[${lastRef}])`;
        case 1:
          return `(lView[${ref}] as Element).setAttribute("${parser.consumeString()}", "${parser.consumeString()}")`;
      }
      throw new Error("Unexpected OpCode: " + getInstructionFromIcuCreateOpCode(opCode));
    }
    let lastRef = -1;
    while (parser.hasMore()) {
      let value = parser.consumeNumberStringOrMarker();
      if (value === ICU_MARKER) {
        const text = parser.consumeString();
        lastRef = parser.consumeNumber();
        lines.push(`lView[${lastRef}] = document.createComment("${text}")`);
      } else if (value === ELEMENT_MARKER) {
        const text = parser.consumeString();
        lastRef = parser.consumeNumber();
        lines.push(`lView[${lastRef}] = document.createElement("${text}")`);
      } else if (typeof value === "string") {
        lastRef = parser.consumeNumber();
        lines.push(`lView[${lastRef}] = document.createTextNode("${value}")`);
      } else if (typeof value === "number") {
        const line = consumeOpCode(value);
        line && lines.push(line);
      } else {
        throw new Error("Unexpected value");
      }
    }
    return lines;
  }
  function i18nRemoveOpCodesToString(opcodes) {
    const removeCodes = opcodes || (Array.isArray(this) ? this : []);
    let lines = [];
    for (let i = 0; i < removeCodes.length; i++) {
      const nodeOrIcuIndex = removeCodes[i];
      if (nodeOrIcuIndex > 0) {
        lines.push(`remove(lView[${nodeOrIcuIndex}])`);
      } else {
        lines.push(`removeNestedICU(${~nodeOrIcuIndex})`);
      }
    }
    return lines;
  }
  var OpCodeParser = class {
    constructor(codes) {
      this.i = 0;
      this.codes = codes;
    }
    hasMore() {
      return this.i < this.codes.length;
    }
    consumeNumber() {
      let value = this.codes[this.i++];
      assertNumber(value, "expecting number in OpCode");
      return value;
    }
    consumeString() {
      let value = this.codes[this.i++];
      assertString(value, "expecting string in OpCode");
      return value;
    }
    consumeFunction() {
      let value = this.codes[this.i++];
      if (value === null || typeof value === "function") {
        return value;
      }
      throw new Error("expecting function in OpCode");
    }
    consumeNumberOrString() {
      let value = this.codes[this.i++];
      if (typeof value === "string") {
        return value;
      }
      assertNumber(value, "expecting number or string in OpCode");
      return value;
    }
    consumeNumberStringOrMarker() {
      let value = this.codes[this.i++];
      if (typeof value === "string" || typeof value === "number" || value == ICU_MARKER || value == ELEMENT_MARKER) {
        return value;
      }
      assertNumber(value, "expecting number, string, ICU_MARKER or ELEMENT_MARKER in OpCode");
      return value;
    }
  };
  var BINDING_REGEXP = /(\d+):?\d*/gi;
  var ICU_REGEXP = /({\s*\d+:?\d*\s*,\s*\S{6}\s*,[\s\S]*})/gi;
  var NESTED_ICU = /(\d+)/;
  var ICU_BLOCK_REGEXP = /^\s*(\d+:?\d*)\s*,\s*(select|plural)\s*,/;
  var MARKER = `\uFFFD`;
  var SUBTEMPLATE_REGEXP = /\/?\*(\d+:\d+)/gi;
  var PH_REGEXP = /(\/?[#*]\d+):?\d*/gi;
  var NGSP_UNICODE_REGEXP = /\uE500/g;
  function replaceNgsp(value) {
    return value.replace(NGSP_UNICODE_REGEXP, " ");
  }
  function i18nStartFirstCreatePass(tView, parentTNodeIndex, lView, index, message, subTemplateIndex) {
    const rootTNode = getCurrentParentTNode();
    const createOpCodes = [];
    const updateOpCodes = [];
    const existingTNodeStack = [[]];
    if (ngDevMode) {
      attachDebugGetter(createOpCodes, i18nCreateOpCodesToString);
      attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
    }
    message = getTranslationForTemplate(message, subTemplateIndex);
    const msgParts = replaceNgsp(message).split(PH_REGEXP);
    for (let i = 0; i < msgParts.length; i++) {
      let value = msgParts[i];
      if ((i & 1) === 0) {
        const parts = i18nParseTextIntoPartsAndICU(value);
        for (let j = 0; j < parts.length; j++) {
          let part = parts[j];
          if ((j & 1) === 0) {
            const text = part;
            ngDevMode && assertString(text, "Parsed ICU part should be string");
            if (text !== "") {
              i18nStartFirstCreatePassProcessTextNode(tView, rootTNode, existingTNodeStack[0], createOpCodes, updateOpCodes, lView, text);
            }
          } else {
            const icuExpression = part;
            if (typeof icuExpression !== "object") {
              throw new Error(`Unable to parse ICU expression in "${message}" message.`);
            }
            const icuContainerTNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodeStack[0], lView, createOpCodes, ngDevMode ? `ICU ${index}:${icuExpression.mainBinding}` : "", true);
            const icuNodeIndex = icuContainerTNode.index;
            ngDevMode && assertGreaterThanOrEqual(icuNodeIndex, HEADER_OFFSET, "Index must be in absolute LView offset");
            icuStart(tView, lView, updateOpCodes, parentTNodeIndex, icuExpression, icuNodeIndex);
          }
        }
      } else {
        const isClosing = value.charCodeAt(0) === 47;
        const type = value.charCodeAt(isClosing ? 1 : 0);
        ngDevMode && assertOneOf(type, 42, 35);
        const index2 = HEADER_OFFSET + Number.parseInt(value.substring(isClosing ? 2 : 1));
        if (isClosing) {
          existingTNodeStack.shift();
          setCurrentTNode(getCurrentParentTNode(), false);
        } else {
          const tNode = createTNodePlaceholder(tView, existingTNodeStack[0], index2);
          existingTNodeStack.unshift([]);
          setCurrentTNode(tNode, true);
        }
      }
    }
    tView.data[index] = {
      create: createOpCodes,
      update: updateOpCodes
    };
  }
  function createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, text, isICU) {
    const i18nNodeIdx = allocExpando(tView, lView, 1, null);
    let opCode = i18nNodeIdx << I18nCreateOpCode.SHIFT;
    let parentTNode = getCurrentParentTNode();
    if (rootTNode === parentTNode) {
      parentTNode = null;
    }
    if (parentTNode === null) {
      opCode |= I18nCreateOpCode.APPEND_EAGERLY;
    }
    if (isICU) {
      opCode |= I18nCreateOpCode.COMMENT;
      ensureIcuContainerVisitorLoaded(loadIcuContainerVisitor);
    }
    createOpCodes.push(opCode, text === null ? "" : text);
    const tNode = createTNodeAtIndex(tView, i18nNodeIdx, isICU ? 32 : 1, text === null ? ngDevMode ? "{{?}}" : "" : text, null);
    addTNodeAndUpdateInsertBeforeIndex(existingTNodes, tNode);
    const tNodeIdx = tNode.index;
    setCurrentTNode(tNode, false);
    if (parentTNode !== null && rootTNode !== parentTNode) {
      setTNodeInsertBeforeIndex(parentTNode, tNodeIdx);
    }
    return tNode;
  }
  function i18nStartFirstCreatePassProcessTextNode(tView, rootTNode, existingTNodes, createOpCodes, updateOpCodes, lView, text) {
    const hasBinding = text.match(BINDING_REGEXP);
    const tNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, hasBinding ? null : text, false);
    if (hasBinding) {
      generateBindingUpdateOpCodes(updateOpCodes, text, tNode.index, null, 0, null);
    }
  }
  function i18nAttributesFirstPass(tView, index, values) {
    const previousElement = getCurrentTNode();
    const previousElementIndex = previousElement.index;
    const updateOpCodes = [];
    if (ngDevMode) {
      attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
    }
    if (tView.firstCreatePass && tView.data[index] === null) {
      for (let i = 0; i < values.length; i += 2) {
        const attrName = values[i];
        const message = values[i + 1];
        if (message !== "") {
          if (ICU_REGEXP.test(message)) {
            throw new Error(`ICU expressions are not supported in attributes. Message: "${message}".`);
          }
          generateBindingUpdateOpCodes(updateOpCodes, message, previousElementIndex, attrName, countBindings(updateOpCodes), null);
        }
      }
      tView.data[index] = updateOpCodes;
    }
  }
  function generateBindingUpdateOpCodes(updateOpCodes, str, destinationNode, attrName, bindingStart, sanitizeFn) {
    ngDevMode && assertGreaterThanOrEqual(destinationNode, HEADER_OFFSET, "Index must be in absolute LView offset");
    const maskIndex = updateOpCodes.length;
    const sizeIndex = maskIndex + 1;
    updateOpCodes.push(null, null);
    const startIndex = maskIndex + 2;
    if (ngDevMode) {
      attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);
    }
    const textParts = str.split(BINDING_REGEXP);
    let mask = 0;
    for (let j = 0; j < textParts.length; j++) {
      const textValue = textParts[j];
      if (j & 1) {
        const bindingIndex = bindingStart + parseInt(textValue, 10);
        updateOpCodes.push(-1 - bindingIndex);
        mask = mask | toMaskBit(bindingIndex);
      } else if (textValue !== "") {
        updateOpCodes.push(textValue);
      }
    }
    updateOpCodes.push(destinationNode << 2 | (attrName ? 1 : 0));
    if (attrName) {
      updateOpCodes.push(attrName, sanitizeFn);
    }
    updateOpCodes[maskIndex] = mask;
    updateOpCodes[sizeIndex] = updateOpCodes.length - startIndex;
    return mask;
  }
  function countBindings(opCodes) {
    let count = 0;
    for (let i = 0; i < opCodes.length; i++) {
      const opCode = opCodes[i];
      if (typeof opCode === "number" && opCode < 0) {
        count++;
      }
    }
    return count;
  }
  function toMaskBit(bindingIndex) {
    return 1 << Math.min(bindingIndex, 31);
  }
  function isRootTemplateMessage(subTemplateIndex) {
    return subTemplateIndex === -1;
  }
  function removeInnerTemplateTranslation(message) {
    let match2;
    let res = "";
    let index = 0;
    let inTemplate = false;
    let tagMatched;
    while ((match2 = SUBTEMPLATE_REGEXP.exec(message)) !== null) {
      if (!inTemplate) {
        res += message.substring(index, match2.index + match2[0].length);
        tagMatched = match2[1];
        inTemplate = true;
      } else {
        if (match2[0] === `${MARKER}/*${tagMatched}${MARKER}`) {
          index = match2.index;
          inTemplate = false;
        }
      }
    }
    ngDevMode && assertEqual(inTemplate, false, `Tag mismatch: unable to find the end of the sub-template in the translation "${message}"`);
    res += message.substr(index);
    return res;
  }
  function getTranslationForTemplate(message, subTemplateIndex) {
    if (isRootTemplateMessage(subTemplateIndex)) {
      return removeInnerTemplateTranslation(message);
    } else {
      const start = message.indexOf(`:${subTemplateIndex}${MARKER}`) + 2 + subTemplateIndex.toString().length;
      const end = message.search(new RegExp(`${MARKER}\\/\\*\\d+:${subTemplateIndex}${MARKER}`));
      return removeInnerTemplateTranslation(message.substring(start, end));
    }
  }
  function icuStart(tView, lView, updateOpCodes, parentIdx, icuExpression, anchorIdx) {
    ngDevMode && assertDefined(icuExpression, "ICU expression must be defined");
    let bindingMask = 0;
    const tIcu = {
      type: icuExpression.type,
      currentCaseLViewIndex: allocExpando(tView, lView, 1, null),
      anchorIdx,
      cases: [],
      create: [],
      remove: [],
      update: []
    };
    addUpdateIcuSwitch(updateOpCodes, icuExpression, anchorIdx);
    setTIcu(tView, anchorIdx, tIcu);
    const values = icuExpression.values;
    for (let i = 0; i < values.length; i++) {
      const valueArr = values[i];
      const nestedIcus = [];
      for (let j = 0; j < valueArr.length; j++) {
        const value = valueArr[j];
        if (typeof value !== "string") {
          const icuIndex = nestedIcus.push(value) - 1;
          valueArr[j] = `<!--\uFFFD${icuIndex}\uFFFD-->`;
        }
      }
      bindingMask = parseIcuCase(tView, tIcu, lView, updateOpCodes, parentIdx, icuExpression.cases[i], valueArr.join(""), nestedIcus) | bindingMask;
    }
    if (bindingMask) {
      addUpdateIcuUpdate(updateOpCodes, bindingMask, anchorIdx);
    }
  }
  function parseICUBlock(pattern) {
    const cases = [];
    const values = [];
    let icuType = 1;
    let mainBinding = 0;
    pattern = pattern.replace(ICU_BLOCK_REGEXP, function(str, binding, type) {
      if (type === "select") {
        icuType = 0;
      } else {
        icuType = 1;
      }
      mainBinding = parseInt(binding.substr(1), 10);
      return "";
    });
    const parts = i18nParseTextIntoPartsAndICU(pattern);
    for (let pos = 0; pos < parts.length; ) {
      let key = parts[pos++].trim();
      if (icuType === 1) {
        key = key.replace(/\s*(?:=)?(\w+)\s*/, "$1");
      }
      if (key.length) {
        cases.push(key);
      }
      const blocks = i18nParseTextIntoPartsAndICU(parts[pos++]);
      if (cases.length > values.length) {
        values.push(blocks);
      }
    }
    return { type: icuType, mainBinding, cases, values };
  }
  function i18nParseTextIntoPartsAndICU(pattern) {
    if (!pattern) {
      return [];
    }
    let prevPos = 0;
    const braceStack = [];
    const results = [];
    const braces = /[{}]/g;
    braces.lastIndex = 0;
    let match2;
    while (match2 = braces.exec(pattern)) {
      const pos = match2.index;
      if (match2[0] == "}") {
        braceStack.pop();
        if (braceStack.length == 0) {
          const block = pattern.substring(prevPos, pos);
          if (ICU_BLOCK_REGEXP.test(block)) {
            results.push(parseICUBlock(block));
          } else {
            results.push(block);
          }
          prevPos = pos + 1;
        }
      } else {
        if (braceStack.length == 0) {
          const substring2 = pattern.substring(prevPos, pos);
          results.push(substring2);
          prevPos = pos + 1;
        }
        braceStack.push("{");
      }
    }
    const substring = pattern.substring(prevPos);
    results.push(substring);
    return results;
  }
  function parseIcuCase(tView, tIcu, lView, updateOpCodes, parentIdx, caseName, unsafeCaseHtml, nestedIcus) {
    const create = [];
    const remove2 = [];
    const update = [];
    if (ngDevMode) {
      attachDebugGetter(create, icuCreateOpCodesToString);
      attachDebugGetter(remove2, i18nRemoveOpCodesToString);
      attachDebugGetter(update, i18nUpdateOpCodesToString);
    }
    tIcu.cases.push(caseName);
    tIcu.create.push(create);
    tIcu.remove.push(remove2);
    tIcu.update.push(update);
    const inertBodyHelper2 = getInertBodyHelper(getDocument());
    const inertBodyElement = inertBodyHelper2.getInertBodyElement(unsafeCaseHtml);
    ngDevMode && assertDefined(inertBodyElement, "Unable to generate inert body element");
    const inertRootNode = getTemplateContent(inertBodyElement) || inertBodyElement;
    if (inertRootNode) {
      return walkIcuTree(tView, tIcu, lView, updateOpCodes, create, remove2, update, inertRootNode, parentIdx, nestedIcus, 0);
    } else {
      return 0;
    }
  }
  function walkIcuTree(tView, tIcu, lView, sharedUpdateOpCodes, create, remove2, update, parentNode, parentIdx, nestedIcus, depth) {
    let bindingMask = 0;
    let currentNode = parentNode.firstChild;
    while (currentNode) {
      const newIndex = allocExpando(tView, lView, 1, null);
      switch (currentNode.nodeType) {
        case Node.ELEMENT_NODE:
          const element = currentNode;
          const tagName = element.tagName.toLowerCase();
          if (VALID_ELEMENTS.hasOwnProperty(tagName)) {
            addCreateNodeAndAppend(create, ELEMENT_MARKER, tagName, parentIdx, newIndex);
            tView.data[newIndex] = tagName;
            const elAttrs = element.attributes;
            for (let i = 0; i < elAttrs.length; i++) {
              const attr = elAttrs.item(i);
              const lowerAttrName = attr.name.toLowerCase();
              const hasBinding2 = !!attr.value.match(BINDING_REGEXP);
              if (hasBinding2) {
                if (VALID_ATTRS.hasOwnProperty(lowerAttrName)) {
                  if (URI_ATTRS[lowerAttrName]) {
                    generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, _sanitizeUrl);
                  } else if (SRCSET_ATTRS[lowerAttrName]) {
                    generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, sanitizeSrcset);
                  } else {
                    generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, null);
                  }
                } else {
                  ngDevMode && console.warn(`WARNING: ignoring unsafe attribute value ${lowerAttrName} on element ${tagName} (see https://g.co/ng/security#xss)`);
                }
              } else {
                addCreateAttribute(create, newIndex, attr);
              }
            }
            bindingMask = walkIcuTree(tView, tIcu, lView, sharedUpdateOpCodes, create, remove2, update, currentNode, newIndex, nestedIcus, depth + 1) | bindingMask;
            addRemoveNode(remove2, newIndex, depth);
          }
          break;
        case Node.TEXT_NODE:
          const value = currentNode.textContent || "";
          const hasBinding = value.match(BINDING_REGEXP);
          addCreateNodeAndAppend(create, null, hasBinding ? "" : value, parentIdx, newIndex);
          addRemoveNode(remove2, newIndex, depth);
          if (hasBinding) {
            bindingMask = generateBindingUpdateOpCodes(update, value, newIndex, null, 0, null) | bindingMask;
          }
          break;
        case Node.COMMENT_NODE:
          const isNestedIcu = NESTED_ICU.exec(currentNode.textContent || "");
          if (isNestedIcu) {
            const nestedIcuIndex = parseInt(isNestedIcu[1], 10);
            const icuExpression = nestedIcus[nestedIcuIndex];
            addCreateNodeAndAppend(create, ICU_MARKER, ngDevMode ? `nested ICU ${nestedIcuIndex}` : "", parentIdx, newIndex);
            icuStart(tView, lView, sharedUpdateOpCodes, parentIdx, icuExpression, newIndex);
            addRemoveNestedIcu(remove2, newIndex, depth);
          }
          break;
      }
      currentNode = currentNode.nextSibling;
    }
    return bindingMask;
  }
  function addRemoveNode(remove2, index, depth) {
    if (depth === 0) {
      remove2.push(index);
    }
  }
  function addRemoveNestedIcu(remove2, index, depth) {
    if (depth === 0) {
      remove2.push(~index);
      remove2.push(index);
    }
  }
  function addUpdateIcuSwitch(update, icuExpression, index) {
    update.push(toMaskBit(icuExpression.mainBinding), 2, -1 - icuExpression.mainBinding, index << 2 | 2);
  }
  function addUpdateIcuUpdate(update, bindingMask, index) {
    update.push(bindingMask, 1, index << 2 | 3);
  }
  function addCreateNodeAndAppend(create, marker, text, appendToParentIdx, createAtIdx) {
    if (marker !== null) {
      create.push(marker);
    }
    create.push(text, createAtIdx, icuCreateOpCode(0, appendToParentIdx, createAtIdx));
  }
  function addCreateAttribute(create, newIndex, attr) {
    create.push(newIndex << 1 | 1, attr.name, attr.value);
  }
  var ROOT_TEMPLATE_ID = 0;
  var PP_MULTI_VALUE_PLACEHOLDERS_REGEXP = /\[(.+??)\]/;
  var PP_PLACEHOLDERS_REGEXP = /\[(.+??)\]|(\/?\*\d+:\d+)/g;
  var PP_ICU_VARS_REGEXP = /({\s*)(VAR_(PLURAL|SELECT)(_\d+)?)(\s*,)/g;
  var PP_ICU_PLACEHOLDERS_REGEXP = /{([A-Z0-9_]+)}/g;
  var PP_ICUS_REGEXP = /I18N_EXP_(ICU(_\d+)?)/g;
  var PP_CLOSE_TEMPLATE_REGEXP = /\/\*/;
  var PP_TEMPLATE_ID_REGEXP = /\d+\:(\d+)/;
  function i18nPostprocess(message, replacements = {}) {
    let result = message;
    if (PP_MULTI_VALUE_PLACEHOLDERS_REGEXP.test(message)) {
      const matches = {};
      const templateIdsStack = [ROOT_TEMPLATE_ID];
      result = result.replace(PP_PLACEHOLDERS_REGEXP, (m, phs, tmpl) => {
        const content = phs || tmpl;
        const placeholders = matches[content] || [];
        if (!placeholders.length) {
          content.split("|").forEach((placeholder2) => {
            const match2 = placeholder2.match(PP_TEMPLATE_ID_REGEXP);
            const templateId2 = match2 ? parseInt(match2[1], 10) : ROOT_TEMPLATE_ID;
            const isCloseTemplateTag2 = PP_CLOSE_TEMPLATE_REGEXP.test(placeholder2);
            placeholders.push([templateId2, isCloseTemplateTag2, placeholder2]);
          });
          matches[content] = placeholders;
        }
        if (!placeholders.length) {
          throw new Error(`i18n postprocess: unmatched placeholder - ${content}`);
        }
        const currentTemplateId = templateIdsStack[templateIdsStack.length - 1];
        let idx = 0;
        for (let i = 0; i < placeholders.length; i++) {
          if (placeholders[i][0] === currentTemplateId) {
            idx = i;
            break;
          }
        }
        const [templateId, isCloseTemplateTag, placeholder] = placeholders[idx];
        if (isCloseTemplateTag) {
          templateIdsStack.pop();
        } else if (currentTemplateId !== templateId) {
          templateIdsStack.push(templateId);
        }
        placeholders.splice(idx, 1);
        return placeholder;
      });
    }
    if (!Object.keys(replacements).length) {
      return result;
    }
    result = result.replace(PP_ICU_VARS_REGEXP, (match2, start, key, _type, _idx, end) => {
      return replacements.hasOwnProperty(key) ? `${start}${replacements[key]}${end}` : match2;
    });
    result = result.replace(PP_ICU_PLACEHOLDERS_REGEXP, (match2, key) => {
      return replacements.hasOwnProperty(key) ? replacements[key] : match2;
    });
    result = result.replace(PP_ICUS_REGEXP, (match2, key) => {
      if (replacements.hasOwnProperty(key)) {
        const list = replacements[key];
        if (!list.length) {
          throw new Error(`i18n postprocess: unmatched ICU - ${match2} with key: ${key}`);
        }
        return list.shift();
      }
      return match2;
    });
    return result;
  }
  function \u0275\u0275i18nStart(index, messageIndex, subTemplateIndex = -1) {
    const tView = getTView();
    const lView = getLView();
    const adjustedIndex = HEADER_OFFSET + index;
    ngDevMode && assertDefined(tView, `tView should be defined`);
    const message = getConstant(tView.consts, messageIndex);
    const parentTNode = getCurrentParentTNode();
    if (tView.firstCreatePass) {
      i18nStartFirstCreatePass(tView, parentTNode === null ? 0 : parentTNode.index, lView, adjustedIndex, message, subTemplateIndex);
    }
    const tI18n = tView.data[adjustedIndex];
    const sameViewParentTNode = parentTNode === lView[T_HOST] ? null : parentTNode;
    const parentRNode = getClosestRElement(tView, sameViewParentTNode, lView);
    const insertInFrontOf = parentTNode && parentTNode.type & 8 ? lView[parentTNode.index] : null;
    applyCreateOpCodes(lView, tI18n.create, parentRNode, insertInFrontOf);
    setInI18nBlock(true);
  }
  function \u0275\u0275i18nEnd() {
    setInI18nBlock(false);
  }
  function \u0275\u0275i18n(index, messageIndex, subTemplateIndex) {
    \u0275\u0275i18nStart(index, messageIndex, subTemplateIndex);
    \u0275\u0275i18nEnd();
  }
  function \u0275\u0275i18nAttributes(index, attrsIndex) {
    const tView = getTView();
    ngDevMode && assertDefined(tView, `tView should be defined`);
    const attrs = getConstant(tView.consts, attrsIndex);
    i18nAttributesFirstPass(tView, index + HEADER_OFFSET, attrs);
  }
  function \u0275\u0275i18nExp(value) {
    const lView = getLView();
    setMaskBit(bindingUpdated(lView, nextBindingIndex(), value));
    return \u0275\u0275i18nExp;
  }
  function \u0275\u0275i18nApply(index) {
    applyI18n(getTView(), getLView(), index + HEADER_OFFSET);
  }
  function \u0275\u0275i18nPostprocess(message, replacements = {}) {
    return i18nPostprocess(message, replacements);
  }
  function providersResolver(def, providers, viewProviders) {
    const tView = getTView();
    if (tView.firstCreatePass) {
      const isComponent = isComponentDef(def);
      resolveProvider(viewProviders, tView.data, tView.blueprint, isComponent, true);
      resolveProvider(providers, tView.data, tView.blueprint, isComponent, false);
    }
  }
  function resolveProvider(provider, tInjectables, lInjectablesBlueprint, isComponent, isViewProvider) {
    provider = resolveForwardRef(provider);
    if (Array.isArray(provider)) {
      for (let i = 0; i < provider.length; i++) {
        resolveProvider(provider[i], tInjectables, lInjectablesBlueprint, isComponent, isViewProvider);
      }
    } else {
      const tView = getTView();
      const lView = getLView();
      let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider.provide);
      let providerFactory = providerToFactory(provider);
      const tNode = getCurrentTNode();
      const beginIndex = tNode.providerIndexes & 1048575;
      const endIndex = tNode.directiveStart;
      const cptViewProvidersCount = tNode.providerIndexes >> 20;
      if (isTypeProvider(provider) || !provider.multi) {
        const factory = new NodeInjectorFactory(providerFactory, isViewProvider, \u0275\u0275directiveInject);
        const existingFactoryIndex = indexOf(token, tInjectables, isViewProvider ? beginIndex : beginIndex + cptViewProvidersCount, endIndex);
        if (existingFactoryIndex === -1) {
          diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);
          registerDestroyHooksIfSupported(tView, provider, tInjectables.length);
          tInjectables.push(token);
          tNode.directiveStart++;
          tNode.directiveEnd++;
          if (isViewProvider) {
            tNode.providerIndexes += 1048576;
          }
          lInjectablesBlueprint.push(factory);
          lView.push(factory);
        } else {
          lInjectablesBlueprint[existingFactoryIndex] = factory;
          lView[existingFactoryIndex] = factory;
        }
      } else {
        const existingProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex + cptViewProvidersCount, endIndex);
        const existingViewProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex, beginIndex + cptViewProvidersCount);
        const doesProvidersFactoryExist = existingProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingProvidersFactoryIndex];
        const doesViewProvidersFactoryExist = existingViewProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingViewProvidersFactoryIndex];
        if (isViewProvider && !doesViewProvidersFactoryExist || !isViewProvider && !doesProvidersFactoryExist) {
          diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);
          const factory = multiFactory(isViewProvider ? multiViewProvidersFactoryResolver : multiProvidersFactoryResolver, lInjectablesBlueprint.length, isViewProvider, isComponent, providerFactory);
          if (!isViewProvider && doesViewProvidersFactoryExist) {
            lInjectablesBlueprint[existingViewProvidersFactoryIndex].providerFactory = factory;
          }
          registerDestroyHooksIfSupported(tView, provider, tInjectables.length, 0);
          tInjectables.push(token);
          tNode.directiveStart++;
          tNode.directiveEnd++;
          if (isViewProvider) {
            tNode.providerIndexes += 1048576;
          }
          lInjectablesBlueprint.push(factory);
          lView.push(factory);
        } else {
          const indexInFactory = multiFactoryAdd(lInjectablesBlueprint[isViewProvider ? existingViewProvidersFactoryIndex : existingProvidersFactoryIndex], providerFactory, !isViewProvider && isComponent);
          registerDestroyHooksIfSupported(tView, provider, existingProvidersFactoryIndex > -1 ? existingProvidersFactoryIndex : existingViewProvidersFactoryIndex, indexInFactory);
        }
        if (!isViewProvider && isComponent && doesViewProvidersFactoryExist) {
          lInjectablesBlueprint[existingViewProvidersFactoryIndex].componentProviders++;
        }
      }
    }
  }
  function registerDestroyHooksIfSupported(tView, provider, contextIndex, indexInFactory) {
    const providerIsTypeProvider = isTypeProvider(provider);
    const providerIsClassProvider = isClassProvider(provider);
    if (providerIsTypeProvider || providerIsClassProvider) {
      const classToken = providerIsClassProvider ? resolveForwardRef(provider.useClass) : provider;
      const prototype = classToken.prototype;
      const ngOnDestroy = prototype.ngOnDestroy;
      if (ngOnDestroy) {
        const hooks = tView.destroyHooks || (tView.destroyHooks = []);
        if (!providerIsTypeProvider && provider.multi) {
          ngDevMode && assertDefined(indexInFactory, "indexInFactory when registering multi factory destroy hook");
          const existingCallbacksIndex = hooks.indexOf(contextIndex);
          if (existingCallbacksIndex === -1) {
            hooks.push(contextIndex, [indexInFactory, ngOnDestroy]);
          } else {
            hooks[existingCallbacksIndex + 1].push(indexInFactory, ngOnDestroy);
          }
        } else {
          hooks.push(contextIndex, ngOnDestroy);
        }
      }
    }
  }
  function multiFactoryAdd(multiFactory2, factory, isComponentProvider) {
    if (isComponentProvider) {
      multiFactory2.componentProviders++;
    }
    return multiFactory2.multi.push(factory) - 1;
  }
  function indexOf(item, arr, begin, end) {
    for (let i = begin; i < end; i++) {
      if (arr[i] === item)
        return i;
    }
    return -1;
  }
  function multiProvidersFactoryResolver(_, tData, lData, tNode) {
    return multiResolve(this.multi, []);
  }
  function multiViewProvidersFactoryResolver(_, tData, lView, tNode) {
    const factories = this.multi;
    let result;
    if (this.providerFactory) {
      const componentCount = this.providerFactory.componentProviders;
      const multiProviders = getNodeInjectable(lView, lView[TVIEW], this.providerFactory.index, tNode);
      result = multiProviders.slice(0, componentCount);
      multiResolve(factories, result);
      for (let i = componentCount; i < multiProviders.length; i++) {
        result.push(multiProviders[i]);
      }
    } else {
      result = [];
      multiResolve(factories, result);
    }
    return result;
  }
  function multiResolve(factories, result) {
    for (let i = 0; i < factories.length; i++) {
      const factory = factories[i];
      result.push(factory());
    }
    return result;
  }
  function multiFactory(factoryFn, index, isViewProvider, isComponent, f) {
    const factory = new NodeInjectorFactory(factoryFn, isViewProvider, \u0275\u0275directiveInject);
    factory.multi = [];
    factory.index = index;
    factory.componentProviders = 0;
    multiFactoryAdd(factory, f, isComponent && !isViewProvider);
    return factory;
  }
  function \u0275\u0275ProvidersFeature(providers, viewProviders = []) {
    return (definition) => {
      definition.providersResolver = (def, processProvidersFn) => {
        return providersResolver(def, processProvidersFn ? processProvidersFn(providers) : providers, viewProviders);
      };
    };
  }
  var ComponentRef$1 = class {
  };
  var ComponentFactory$1 = class {
  };
  function noComponentFactoryError(component) {
    const error3 = Error(`No component factory found for ${stringify(component)}. Did you add it to @NgModule.entryComponents?`);
    error3[ERROR_COMPONENT] = component;
    return error3;
  }
  var ERROR_COMPONENT = "ngComponent";
  var _NullComponentFactoryResolver = class {
    resolveComponentFactory(component) {
      throw noComponentFactoryError(component);
    }
  };
  var ComponentFactoryResolver$1 = class {
  };
  ComponentFactoryResolver$1.NULL = /* @__PURE__ */ new _NullComponentFactoryResolver();
  function injectElementRef() {
    return createElementRef(getCurrentTNode(), getLView());
  }
  function createElementRef(tNode, lView) {
    return new ElementRef(getNativeByTNode(tNode, lView));
  }
  var ElementRef = class {
    constructor(nativeElement) {
      this.nativeElement = nativeElement;
    }
  };
  ElementRef.__NG_ELEMENT_ID__ = injectElementRef;
  function unwrapElementRef(value) {
    return value instanceof ElementRef ? value.nativeElement : value;
  }
  var Renderer2Interceptor = new InjectionToken("Renderer2Interceptor");
  var RendererFactory2 = class {
  };
  var Renderer2 = class {
  };
  Renderer2.__NG_ELEMENT_ID__ = () => injectRenderer2();
  function getOrCreateRenderer2(lView) {
    const renderer = lView[RENDERER];
    if (ngDevMode && !isProceduralRenderer(renderer)) {
      throw new Error("Cannot inject Renderer2 when the application uses Renderer3!");
    }
    return renderer;
  }
  function injectRenderer2() {
    const lView = getLView();
    const tNode = getCurrentTNode();
    const nodeAtIndex = getComponentLViewByIndex(tNode.index, lView);
    return getOrCreateRenderer2(isLView(nodeAtIndex) ? nodeAtIndex : lView);
  }
  var Sanitizer = class {
  };
  Sanitizer.\u0275prov = \u0275\u0275defineInjectable({
    token: Sanitizer,
    providedIn: "root",
    factory: () => null
  });
  var Version = class {
    constructor(full) {
      this.full = full;
      this.major = full.split(".")[0];
      this.minor = full.split(".")[1];
      this.patch = full.split(".").slice(2).join(".");
    }
  };
  var VERSION = new Version("13.0.3");
  var NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};
  function collectNativeNodes(tView, lView, tNode, result, isProjection = false) {
    while (tNode !== null) {
      ngDevMode && assertTNodeType(tNode, 3 | 12 | 16 | 32);
      const lNode = lView[tNode.index];
      if (lNode !== null) {
        result.push(unwrapRNode(lNode));
      }
      if (isLContainer(lNode)) {
        for (let i = CONTAINER_HEADER_OFFSET; i < lNode.length; i++) {
          const lViewInAContainer = lNode[i];
          const lViewFirstChildTNode = lViewInAContainer[TVIEW].firstChild;
          if (lViewFirstChildTNode !== null) {
            collectNativeNodes(lViewInAContainer[TVIEW], lViewInAContainer, lViewFirstChildTNode, result);
          }
        }
      }
      const tNodeType = tNode.type;
      if (tNodeType & 8) {
        collectNativeNodes(tView, lView, tNode.child, result);
      } else if (tNodeType & 32) {
        const nextRNode = icuContainerIterate(tNode, lView);
        let rNode;
        while (rNode = nextRNode()) {
          result.push(rNode);
        }
      } else if (tNodeType & 16) {
        const nodesInSlot = getProjectionNodes(lView, tNode);
        if (Array.isArray(nodesInSlot)) {
          result.push(...nodesInSlot);
        } else {
          const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);
          ngDevMode && assertParentView(parentView);
          collectNativeNodes(parentView[TVIEW], parentView, nodesInSlot, result, true);
        }
      }
      tNode = isProjection ? tNode.projectionNext : tNode.next;
    }
    return result;
  }
  var ViewRef$1 = class {
    constructor(_lView, _cdRefInjectingView) {
      this._lView = _lView;
      this._cdRefInjectingView = _cdRefInjectingView;
      this._appRef = null;
      this._attachedToViewContainer = false;
    }
    get rootNodes() {
      const lView = this._lView;
      const tView = lView[TVIEW];
      return collectNativeNodes(tView, lView, tView.firstChild, []);
    }
    get context() {
      return this._lView[CONTEXT];
    }
    set context(value) {
      this._lView[CONTEXT] = value;
    }
    get destroyed() {
      return (this._lView[FLAGS] & 256) === 256;
    }
    destroy() {
      if (this._appRef) {
        this._appRef.detachView(this);
      } else if (this._attachedToViewContainer) {
        const parent = this._lView[PARENT];
        if (isLContainer(parent)) {
          const viewRefs = parent[VIEW_REFS];
          const index = viewRefs ? viewRefs.indexOf(this) : -1;
          if (index > -1) {
            ngDevMode && assertEqual(index, parent.indexOf(this._lView) - CONTAINER_HEADER_OFFSET, "An attached view should be in the same position within its container as its ViewRef in the VIEW_REFS array.");
            detachView(parent, index);
            removeFromArray(viewRefs, index);
          }
        }
        this._attachedToViewContainer = false;
      }
      destroyLView(this._lView[TVIEW], this._lView);
    }
    onDestroy(callback) {
      storeCleanupWithContext(this._lView[TVIEW], this._lView, null, callback);
    }
    markForCheck() {
      markViewDirty(this._cdRefInjectingView || this._lView);
    }
    detach() {
      this._lView[FLAGS] &= ~128;
    }
    reattach() {
      this._lView[FLAGS] |= 128;
    }
    detectChanges() {
      detectChangesInternal(this._lView[TVIEW], this._lView, this.context);
    }
    checkNoChanges() {
      checkNoChangesInternal(this._lView[TVIEW], this._lView, this.context);
    }
    attachToViewContainerRef() {
      if (this._appRef) {
        throw new Error("This view is already attached directly to the ApplicationRef!");
      }
      this._attachedToViewContainer = true;
    }
    detachFromAppRef() {
      this._appRef = null;
      renderDetachView(this._lView[TVIEW], this._lView);
    }
    attachToAppRef(appRef) {
      if (this._attachedToViewContainer) {
        throw new Error("This view is already attached to a ViewContainer!");
      }
      this._appRef = appRef;
    }
  };
  var RootViewRef = class extends ViewRef$1 {
    constructor(_view) {
      super(_view);
      this._view = _view;
    }
    detectChanges() {
      detectChangesInRootView(this._view);
    }
    checkNoChanges() {
      checkNoChangesInRootView(this._view);
    }
    get context() {
      return null;
    }
  };
  var ComponentFactoryResolver = class extends ComponentFactoryResolver$1 {
    constructor(ngModule) {
      super();
      this.ngModule = ngModule;
    }
    resolveComponentFactory(component) {
      ngDevMode && assertComponentType(component);
      const componentDef = getComponentDef(component);
      return new ComponentFactory(componentDef, this.ngModule);
    }
  };
  function toRefArray(map2) {
    const array = [];
    for (let nonMinified in map2) {
      if (map2.hasOwnProperty(nonMinified)) {
        const minified = map2[nonMinified];
        array.push({ propName: minified, templateName: nonMinified });
      }
    }
    return array;
  }
  function getNamespace(elementName) {
    const name = elementName.toLowerCase();
    return name === "svg" ? SVG_NAMESPACE : name === "math" ? MATH_ML_NAMESPACE : null;
  }
  var SCHEDULER = new InjectionToken("SCHEDULER_TOKEN", {
    providedIn: "root",
    factory: () => defaultScheduler
  });
  function createChainedInjector(rootViewInjector, moduleInjector) {
    return {
      get: (token, notFoundValue, flags) => {
        const value = rootViewInjector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, flags);
        if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR || notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {
          return value;
        }
        return moduleInjector.get(token, notFoundValue, flags);
      }
    };
  }
  var ComponentFactory = class extends ComponentFactory$1 {
    constructor(componentDef, ngModule) {
      super();
      this.componentDef = componentDef;
      this.ngModule = ngModule;
      this.componentType = componentDef.type;
      this.selector = stringifyCSSSelectorList(componentDef.selectors);
      this.ngContentSelectors = componentDef.ngContentSelectors ? componentDef.ngContentSelectors : [];
      this.isBoundToModule = !!ngModule;
    }
    get inputs() {
      return toRefArray(this.componentDef.inputs);
    }
    get outputs() {
      return toRefArray(this.componentDef.outputs);
    }
    create(injector, projectableNodes, rootSelectorOrNode, ngModule) {
      ngModule = ngModule || this.ngModule;
      const rootViewInjector = ngModule ? createChainedInjector(injector, ngModule.injector) : injector;
      const rendererFactory = rootViewInjector.get(RendererFactory2, domRendererFactory3);
      const sanitizer = rootViewInjector.get(Sanitizer, null);
      const hostRenderer = rendererFactory.createRenderer(null, this.componentDef);
      const elementName = this.componentDef.selectors[0][0] || "div";
      const hostRNode = rootSelectorOrNode ? locateHostElement(hostRenderer, rootSelectorOrNode, this.componentDef.encapsulation) : createElementNode(rendererFactory.createRenderer(null, this.componentDef), elementName, getNamespace(elementName));
      const rootFlags = this.componentDef.onPush ? 64 | 512 : 16 | 512;
      const rootContext = createRootContext();
      const rootTView = createTView(0, null, null, 1, 0, null, null, null, null, null);
      const rootLView = createLView(null, rootTView, rootContext, rootFlags, null, null, rendererFactory, hostRenderer, sanitizer, rootViewInjector);
      enterView(rootLView);
      let component;
      let tElementNode;
      try {
        const componentView = createRootComponentView(hostRNode, this.componentDef, rootLView, rendererFactory, hostRenderer);
        if (hostRNode) {
          if (rootSelectorOrNode) {
            setUpAttributes(hostRenderer, hostRNode, ["ng-version", VERSION.full]);
          } else {
            const { attrs, classes } = extractAttrsAndClassesFromSelector(this.componentDef.selectors[0]);
            if (attrs) {
              setUpAttributes(hostRenderer, hostRNode, attrs);
            }
            if (classes && classes.length > 0) {
              writeDirectClass(hostRenderer, hostRNode, classes.join(" "));
            }
          }
        }
        tElementNode = getTNode(rootTView, HEADER_OFFSET);
        if (projectableNodes !== void 0) {
          const projection = tElementNode.projection = [];
          for (let i = 0; i < this.ngContentSelectors.length; i++) {
            const nodesforSlot = projectableNodes[i];
            projection.push(nodesforSlot != null ? Array.from(nodesforSlot) : null);
          }
        }
        component = createRootComponent(componentView, this.componentDef, rootLView, rootContext, [LifecycleHooksFeature]);
        renderView(rootTView, rootLView, null);
      } finally {
        leaveView();
      }
      return new ComponentRef(this.componentType, component, createElementRef(tElementNode, rootLView), rootLView, tElementNode);
    }
  };
  var componentFactoryResolver = new ComponentFactoryResolver();
  var ComponentRef = class extends ComponentRef$1 {
    constructor(componentType, instance, location2, _rootLView, _tNode) {
      super();
      this.location = location2;
      this._rootLView = _rootLView;
      this._tNode = _tNode;
      this.instance = instance;
      this.hostView = this.changeDetectorRef = new RootViewRef(_rootLView);
      this.componentType = componentType;
    }
    get injector() {
      return new NodeInjector(this._tNode, this._rootLView);
    }
    destroy() {
      this.hostView.destroy();
    }
    onDestroy(callback) {
      this.hostView.onDestroy(callback);
    }
  };
  function setClassMetadata(type, decorators, ctorParameters, propDecorators) {
    return noSideEffects(() => {
      const clazz = type;
      if (decorators !== null) {
        if (clazz.hasOwnProperty("decorators") && clazz.decorators !== void 0) {
          clazz.decorators.push(...decorators);
        } else {
          clazz.decorators = decorators;
        }
      }
      if (ctorParameters !== null) {
        clazz.ctorParameters = ctorParameters;
      }
      if (propDecorators !== null) {
        if (clazz.hasOwnProperty("propDecorators") && clazz.propDecorators !== void 0) {
          clazz.propDecorators = { ...clazz.propDecorators, ...propDecorators };
        } else {
          clazz.propDecorators = propDecorators;
        }
      }
    });
  }
  var NgModuleRef$1 = class {
  };
  var NgModuleFactory$1 = class {
  };
  var modules = /* @__PURE__ */ new Map();
  function assertSameOrNotExisting(id, type, incoming) {
    if (type && type !== incoming) {
      throw new Error(`Duplicate module registered for ${id} - ${stringify(type)} vs ${stringify(type.name)}`);
    }
  }
  function registerNgModuleType(ngModuleType) {
    const visited = /* @__PURE__ */ new Set();
    recurse(ngModuleType);
    function recurse(ngModuleType2) {
      const def = getNgModuleDef(ngModuleType2, true);
      const id = def.id;
      if (id !== null) {
        const existing = modules.get(id);
        assertSameOrNotExisting(id, existing, ngModuleType2);
        modules.set(id, ngModuleType2);
      }
      const imports = maybeUnwrapFn(def.imports);
      for (const i of imports) {
        if (!visited.has(i)) {
          visited.add(i);
          recurse(i);
        }
      }
    }
  }
  function getRegisteredNgModuleType(id) {
    return modules.get(id) || autoRegisterModuleById[id];
  }
  function createNgModuleRef(ngModule, parentInjector) {
    return new NgModuleRef(ngModule, parentInjector ?? null);
  }
  var NgModuleRef = class extends NgModuleRef$1 {
    constructor(ngModuleType, _parent) {
      super();
      this._parent = _parent;
      this._bootstrapComponents = [];
      this.injector = this;
      this.destroyCbs = [];
      this.componentFactoryResolver = new ComponentFactoryResolver(this);
      const ngModuleDef = getNgModuleDef(ngModuleType);
      ngDevMode && assertDefined(ngModuleDef, `NgModule '${stringify(ngModuleType)}' is not a subtype of 'NgModuleType'.`);
      this._bootstrapComponents = maybeUnwrapFn(ngModuleDef.bootstrap);
      this._r3Injector = createInjectorWithoutInjectorInstances(ngModuleType, _parent, [
        { provide: NgModuleRef$1, useValue: this },
        {
          provide: ComponentFactoryResolver$1,
          useValue: this.componentFactoryResolver
        }
      ], stringify(ngModuleType));
      this._r3Injector._resolveInjectorDefTypes();
      this.instance = this.get(ngModuleType);
    }
    get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, injectFlags = InjectFlags.Default) {
      if (token === Injector || token === NgModuleRef$1 || token === INJECTOR) {
        return this;
      }
      return this._r3Injector.get(token, notFoundValue, injectFlags);
    }
    destroy() {
      ngDevMode && assertDefined(this.destroyCbs, "NgModule already destroyed");
      const injector = this._r3Injector;
      !injector.destroyed && injector.destroy();
      this.destroyCbs.forEach((fn2) => fn2());
      this.destroyCbs = null;
    }
    onDestroy(callback) {
      ngDevMode && assertDefined(this.destroyCbs, "NgModule already destroyed");
      this.destroyCbs.push(callback);
    }
  };
  var NgModuleFactory = class extends NgModuleFactory$1 {
    constructor(moduleType) {
      super();
      this.moduleType = moduleType;
      const ngModuleDef = getNgModuleDef(moduleType);
      if (ngModuleDef !== null) {
        registerNgModuleType(moduleType);
      }
    }
    create(parentInjector) {
      return new NgModuleRef(this.moduleType, parentInjector);
    }
  };
  function \u0275\u0275pureFunction0(slotOffset, pureFn, thisArg) {
    const bindingIndex = getBindingRoot() + slotOffset;
    const lView = getLView();
    return lView[bindingIndex] === NO_CHANGE ? updateBinding(lView, bindingIndex, thisArg ? pureFn.call(thisArg) : pureFn()) : getBinding(lView, bindingIndex);
  }
  function \u0275\u0275pureFunction1(slotOffset, pureFn, exp, thisArg) {
    return pureFunction1Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp, thisArg);
  }
  function \u0275\u0275pureFunction2(slotOffset, pureFn, exp1, exp2, thisArg) {
    return pureFunction2Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, thisArg);
  }
  function \u0275\u0275pureFunction3(slotOffset, pureFn, exp1, exp2, exp3, thisArg) {
    return pureFunction3Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, thisArg);
  }
  function \u0275\u0275pureFunction4(slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {
    return pureFunction4Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg);
  }
  function \u0275\u0275pureFunction5(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, thisArg) {
    const bindingIndex = getBindingRoot() + slotOffset;
    const lView = getLView();
    const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
    return bindingUpdated(lView, bindingIndex + 4, exp5) || different ? updateBinding(lView, bindingIndex + 5, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5) : pureFn(exp1, exp2, exp3, exp4, exp5)) : getBinding(lView, bindingIndex + 5);
  }
  function \u0275\u0275pureFunction6(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, thisArg) {
    const bindingIndex = getBindingRoot() + slotOffset;
    const lView = getLView();
    const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
    return bindingUpdated2(lView, bindingIndex + 4, exp5, exp6) || different ? updateBinding(lView, bindingIndex + 6, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6)) : getBinding(lView, bindingIndex + 6);
  }
  function \u0275\u0275pureFunction7(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, thisArg) {
    const bindingIndex = getBindingRoot() + slotOffset;
    const lView = getLView();
    let different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
    return bindingUpdated3(lView, bindingIndex + 4, exp5, exp6, exp7) || different ? updateBinding(lView, bindingIndex + 7, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7)) : getBinding(lView, bindingIndex + 7);
  }
  function \u0275\u0275pureFunction8(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8, thisArg) {
    const bindingIndex = getBindingRoot() + slotOffset;
    const lView = getLView();
    const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
    return bindingUpdated4(lView, bindingIndex + 4, exp5, exp6, exp7, exp8) || different ? updateBinding(lView, bindingIndex + 8, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8)) : getBinding(lView, bindingIndex + 8);
  }
  function \u0275\u0275pureFunctionV(slotOffset, pureFn, exps, thisArg) {
    return pureFunctionVInternal(getLView(), getBindingRoot(), slotOffset, pureFn, exps, thisArg);
  }
  function getPureFunctionReturnValue(lView, returnValueIndex) {
    ngDevMode && assertIndexInRange(lView, returnValueIndex);
    const lastReturnValue = lView[returnValueIndex];
    return lastReturnValue === NO_CHANGE ? void 0 : lastReturnValue;
  }
  function pureFunction1Internal(lView, bindingRoot, slotOffset, pureFn, exp, thisArg) {
    const bindingIndex = bindingRoot + slotOffset;
    return bindingUpdated(lView, bindingIndex, exp) ? updateBinding(lView, bindingIndex + 1, thisArg ? pureFn.call(thisArg, exp) : pureFn(exp)) : getPureFunctionReturnValue(lView, bindingIndex + 1);
  }
  function pureFunction2Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, thisArg) {
    const bindingIndex = bindingRoot + slotOffset;
    return bindingUpdated2(lView, bindingIndex, exp1, exp2) ? updateBinding(lView, bindingIndex + 2, thisArg ? pureFn.call(thisArg, exp1, exp2) : pureFn(exp1, exp2)) : getPureFunctionReturnValue(lView, bindingIndex + 2);
  }
  function pureFunction3Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, thisArg) {
    const bindingIndex = bindingRoot + slotOffset;
    return bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) ? updateBinding(lView, bindingIndex + 3, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3) : pureFn(exp1, exp2, exp3)) : getPureFunctionReturnValue(lView, bindingIndex + 3);
  }
  function pureFunction4Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {
    const bindingIndex = bindingRoot + slotOffset;
    return bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) ? updateBinding(lView, bindingIndex + 4, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4) : pureFn(exp1, exp2, exp3, exp4)) : getPureFunctionReturnValue(lView, bindingIndex + 4);
  }
  function pureFunctionVInternal(lView, bindingRoot, slotOffset, pureFn, exps, thisArg) {
    let bindingIndex = bindingRoot + slotOffset;
    let different = false;
    for (let i = 0; i < exps.length; i++) {
      bindingUpdated(lView, bindingIndex++, exps[i]) && (different = true);
    }
    return different ? updateBinding(lView, bindingIndex, pureFn.apply(thisArg, exps)) : getPureFunctionReturnValue(lView, bindingIndex);
  }
  function \u0275\u0275pipe(index, pipeName) {
    const tView = getTView();
    let pipeDef;
    const adjustedIndex = index + HEADER_OFFSET;
    if (tView.firstCreatePass) {
      pipeDef = getPipeDef(pipeName, tView.pipeRegistry);
      tView.data[adjustedIndex] = pipeDef;
      if (pipeDef.onDestroy) {
        (tView.destroyHooks || (tView.destroyHooks = [])).push(adjustedIndex, pipeDef.onDestroy);
      }
    } else {
      pipeDef = tView.data[adjustedIndex];
    }
    const pipeFactory = pipeDef.factory || (pipeDef.factory = getFactoryDef(pipeDef.type, true));
    const previousInjectImplementation = setInjectImplementation(\u0275\u0275directiveInject);
    try {
      const previousIncludeViewProviders = setIncludeViewProviders(false);
      const pipeInstance = pipeFactory();
      setIncludeViewProviders(previousIncludeViewProviders);
      store(tView, getLView(), adjustedIndex, pipeInstance);
      return pipeInstance;
    } finally {
      setInjectImplementation(previousInjectImplementation);
    }
  }
  function getPipeDef(name, registry) {
    if (registry) {
      for (let i = registry.length - 1; i >= 0; i--) {
        const pipeDef = registry[i];
        if (name === pipeDef.name) {
          return pipeDef;
        }
      }
    }
    if (ngDevMode) {
      const lView = getLView();
      const declarationLView = lView[DECLARATION_COMPONENT_VIEW];
      const context2 = declarationLView[CONTEXT];
      const component = context2 ? ` in the '${context2.constructor.name}' component` : "";
      throw new RuntimeError("302", `The pipe '${name}' could not be found${component}!`);
    }
  }
  function \u0275\u0275pipeBind1(index, slotOffset, v1) {
    const adjustedIndex = index + HEADER_OFFSET;
    const lView = getLView();
    const pipeInstance = load(lView, adjustedIndex);
    return isPure(lView, adjustedIndex) ? pureFunction1Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, pipeInstance) : pipeInstance.transform(v1);
  }
  function \u0275\u0275pipeBind2(index, slotOffset, v1, v2) {
    const adjustedIndex = index + HEADER_OFFSET;
    const lView = getLView();
    const pipeInstance = load(lView, adjustedIndex);
    return isPure(lView, adjustedIndex) ? pureFunction2Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, pipeInstance) : pipeInstance.transform(v1, v2);
  }
  function \u0275\u0275pipeBind3(index, slotOffset, v1, v2, v3) {
    const adjustedIndex = index + HEADER_OFFSET;
    const lView = getLView();
    const pipeInstance = load(lView, adjustedIndex);
    return isPure(lView, adjustedIndex) ? pureFunction3Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, pipeInstance) : pipeInstance.transform(v1, v2, v3);
  }
  function \u0275\u0275pipeBind4(index, slotOffset, v1, v2, v3, v4) {
    const adjustedIndex = index + HEADER_OFFSET;
    const lView = getLView();
    const pipeInstance = load(lView, adjustedIndex);
    return isPure(lView, adjustedIndex) ? pureFunction4Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, v4, pipeInstance) : pipeInstance.transform(v1, v2, v3, v4);
  }
  function \u0275\u0275pipeBindV(index, slotOffset, values) {
    const adjustedIndex = index + HEADER_OFFSET;
    const lView = getLView();
    const pipeInstance = load(lView, adjustedIndex);
    return isPure(lView, adjustedIndex) ? pureFunctionVInternal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, values, pipeInstance) : pipeInstance.transform.apply(pipeInstance, values);
  }
  function isPure(lView, index) {
    return lView[TVIEW].data[index].pure;
  }
  var EventEmitter_ = class extends Subject {
    constructor(isAsync = false) {
      super();
      this.__isAsync = isAsync;
    }
    emit(value) {
      super.next(value);
    }
    subscribe(observerOrNext, error3, complete) {
      let nextFn = observerOrNext;
      let errorFn = error3 || (() => null);
      let completeFn = complete;
      if (observerOrNext && typeof observerOrNext === "object") {
        const observer = observerOrNext;
        nextFn = observer.next?.bind(observer);
        errorFn = observer.error?.bind(observer);
        completeFn = observer.complete?.bind(observer);
      }
      if (this.__isAsync) {
        errorFn = _wrapInTimeout(errorFn);
        if (nextFn) {
          nextFn = _wrapInTimeout(nextFn);
        }
        if (completeFn) {
          completeFn = _wrapInTimeout(completeFn);
        }
      }
      const sink = super.subscribe({ next: nextFn, error: errorFn, complete: completeFn });
      if (observerOrNext instanceof Subscription) {
        observerOrNext.add(sink);
      }
      return sink;
    }
  };
  function _wrapInTimeout(fn2) {
    return (value) => {
      setTimeout(fn2, void 0, value);
    };
  }
  var EventEmitter = EventEmitter_;
  function symbolIterator() {
    return this._results[getSymbolIterator2()]();
  }
  var QueryList = class {
    constructor(_emitDistinctChangesOnly = false) {
      this._emitDistinctChangesOnly = _emitDistinctChangesOnly;
      this.dirty = true;
      this._results = [];
      this._changesDetected = false;
      this._changes = null;
      this.length = 0;
      this.first = void 0;
      this.last = void 0;
      const symbol = getSymbolIterator2();
      const proto = QueryList.prototype;
      if (!proto[symbol])
        proto[symbol] = symbolIterator;
    }
    get changes() {
      return this._changes || (this._changes = new EventEmitter());
    }
    get(index) {
      return this._results[index];
    }
    map(fn2) {
      return this._results.map(fn2);
    }
    filter(fn2) {
      return this._results.filter(fn2);
    }
    find(fn2) {
      return this._results.find(fn2);
    }
    reduce(fn2, init) {
      return this._results.reduce(fn2, init);
    }
    forEach(fn2) {
      this._results.forEach(fn2);
    }
    some(fn2) {
      return this._results.some(fn2);
    }
    toArray() {
      return this._results.slice();
    }
    toString() {
      return this._results.toString();
    }
    reset(resultsTree, identityAccessor) {
      const self2 = this;
      self2.dirty = false;
      const newResultFlat = flatten(resultsTree);
      if (this._changesDetected = !arrayEquals(self2._results, newResultFlat, identityAccessor)) {
        self2._results = newResultFlat;
        self2.length = newResultFlat.length;
        self2.last = newResultFlat[this.length - 1];
        self2.first = newResultFlat[0];
      }
    }
    notifyOnChanges() {
      if (this._changes && (this._changesDetected || !this._emitDistinctChangesOnly))
        this._changes.emit(this);
    }
    setDirty() {
      this.dirty = true;
    }
    destroy() {
      this.changes.complete();
      this.changes.unsubscribe();
    }
  };
  Symbol.iterator;
  var TemplateRef = class {
  };
  TemplateRef.__NG_ELEMENT_ID__ = injectTemplateRef;
  var ViewEngineTemplateRef = TemplateRef;
  var R3TemplateRef = class TemplateRef2 extends ViewEngineTemplateRef {
    constructor(_declarationLView, _declarationTContainer, elementRef) {
      super();
      this._declarationLView = _declarationLView;
      this._declarationTContainer = _declarationTContainer;
      this.elementRef = elementRef;
    }
    createEmbeddedView(context2) {
      const embeddedTView = this._declarationTContainer.tViews;
      const embeddedLView = createLView(this._declarationLView, embeddedTView, context2, 16, null, embeddedTView.declTNode, null, null, null, null);
      const declarationLContainer = this._declarationLView[this._declarationTContainer.index];
      ngDevMode && assertLContainer(declarationLContainer);
      embeddedLView[DECLARATION_LCONTAINER] = declarationLContainer;
      const declarationViewLQueries = this._declarationLView[QUERIES];
      if (declarationViewLQueries !== null) {
        embeddedLView[QUERIES] = declarationViewLQueries.createEmbeddedView(embeddedTView);
      }
      renderView(embeddedTView, embeddedLView, context2);
      return new ViewRef$1(embeddedLView);
    }
  };
  function injectTemplateRef() {
    return createTemplateRef(getCurrentTNode(), getLView());
  }
  function createTemplateRef(hostTNode, hostLView) {
    if (hostTNode.type & 4) {
      ngDevMode && assertDefined(hostTNode.tViews, "TView must be allocated");
      return new R3TemplateRef(hostLView, hostTNode, createElementRef(hostTNode, hostLView));
    }
    return null;
  }
  var ViewContainerRef = class {
  };
  ViewContainerRef.__NG_ELEMENT_ID__ = injectViewContainerRef;
  function injectViewContainerRef() {
    const previousTNode = getCurrentTNode();
    return createContainerRef(previousTNode, getLView());
  }
  var VE_ViewContainerRef = ViewContainerRef;
  var R3ViewContainerRef = class ViewContainerRef2 extends VE_ViewContainerRef {
    constructor(_lContainer, _hostTNode, _hostLView) {
      super();
      this._lContainer = _lContainer;
      this._hostTNode = _hostTNode;
      this._hostLView = _hostLView;
    }
    get element() {
      return createElementRef(this._hostTNode, this._hostLView);
    }
    get injector() {
      return new NodeInjector(this._hostTNode, this._hostLView);
    }
    get parentInjector() {
      const parentLocation = getParentInjectorLocation(this._hostTNode, this._hostLView);
      if (hasParentInjector(parentLocation)) {
        const parentView = getParentInjectorView(parentLocation, this._hostLView);
        const injectorIndex = getParentInjectorIndex(parentLocation);
        ngDevMode && assertNodeInjector(parentView, injectorIndex);
        const parentTNode = parentView[TVIEW].data[injectorIndex + 8];
        return new NodeInjector(parentTNode, parentView);
      } else {
        return new NodeInjector(null, this._hostLView);
      }
    }
    clear() {
      while (this.length > 0) {
        this.remove(this.length - 1);
      }
    }
    get(index) {
      const viewRefs = getViewRefs(this._lContainer);
      return viewRefs !== null && viewRefs[index] || null;
    }
    get length() {
      return this._lContainer.length - CONTAINER_HEADER_OFFSET;
    }
    createEmbeddedView(templateRef, context2, index) {
      const viewRef = templateRef.createEmbeddedView(context2 || {});
      this.insert(viewRef, index);
      return viewRef;
    }
    createComponent(componentFactoryOrType, indexOrOptions, injector, projectableNodes, ngModuleRef) {
      const isComponentFactory = componentFactoryOrType && !isType(componentFactoryOrType);
      let index;
      if (isComponentFactory) {
        if (ngDevMode) {
          assertEqual(typeof indexOrOptions !== "object", true, "It looks like Component factory was provided as the first argument and an options object as the second argument. This combination of arguments is incompatible. You can either change the first argument to provide Component type or change the second argument to be a number (representing an index at which to insert the new component's host view into this container)");
        }
        index = indexOrOptions;
      } else {
        if (ngDevMode) {
          assertDefined(getComponentDef(componentFactoryOrType), `Provided Component class doesn't contain Component definition. Please check whether provided class has @Component decorator.`);
          assertEqual(typeof indexOrOptions !== "number", true, "It looks like Component type was provided as the first argument and a number (representing an index at which to insert the new component's host view into this container as the second argument. This combination of arguments is incompatible. Please use an object as the second argument instead.");
        }
        const options = indexOrOptions || {};
        index = options.index;
        injector = options.injector;
        projectableNodes = options.projectableNodes;
        ngModuleRef = options.ngModuleRef;
      }
      const componentFactory = isComponentFactory ? componentFactoryOrType : new ComponentFactory(getComponentDef(componentFactoryOrType));
      const contextInjector = injector || this.parentInjector;
      if (!ngModuleRef && componentFactory.ngModule == null && contextInjector) {
        const result = contextInjector.get(NgModuleRef$1, null);
        if (result) {
          ngModuleRef = result;
        }
      }
      const componentRef = componentFactory.create(contextInjector, projectableNodes, void 0, ngModuleRef);
      this.insert(componentRef.hostView, index);
      return componentRef;
    }
    insert(viewRef, index) {
      const lView = viewRef._lView;
      const tView = lView[TVIEW];
      if (ngDevMode && viewRef.destroyed) {
        throw new Error("Cannot insert a destroyed View in a ViewContainer!");
      }
      if (viewAttachedToContainer(lView)) {
        const prevIdx = this.indexOf(viewRef);
        if (prevIdx !== -1) {
          this.detach(prevIdx);
        } else {
          const prevLContainer = lView[PARENT];
          ngDevMode && assertEqual(isLContainer(prevLContainer), true, "An attached view should have its PARENT point to a container.");
          const prevVCRef = new R3ViewContainerRef(prevLContainer, prevLContainer[T_HOST], prevLContainer[PARENT]);
          prevVCRef.detach(prevVCRef.indexOf(viewRef));
        }
      }
      const adjustedIdx = this._adjustIndex(index);
      const lContainer = this._lContainer;
      insertView(tView, lView, lContainer, adjustedIdx);
      const beforeNode = getBeforeNodeForView(adjustedIdx, lContainer);
      const renderer = lView[RENDERER];
      const parentRNode = nativeParentNode(renderer, lContainer[NATIVE]);
      if (parentRNode !== null) {
        addViewToContainer(tView, lContainer[T_HOST], renderer, lView, parentRNode, beforeNode);
      }
      viewRef.attachToViewContainerRef();
      addToArray(getOrCreateViewRefs(lContainer), adjustedIdx, viewRef);
      return viewRef;
    }
    move(viewRef, newIndex) {
      if (ngDevMode && viewRef.destroyed) {
        throw new Error("Cannot move a destroyed View in a ViewContainer!");
      }
      return this.insert(viewRef, newIndex);
    }
    indexOf(viewRef) {
      const viewRefsArr = getViewRefs(this._lContainer);
      return viewRefsArr !== null ? viewRefsArr.indexOf(viewRef) : -1;
    }
    remove(index) {
      const adjustedIdx = this._adjustIndex(index, -1);
      const detachedView = detachView(this._lContainer, adjustedIdx);
      if (detachedView) {
        removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx);
        destroyLView(detachedView[TVIEW], detachedView);
      }
    }
    detach(index) {
      const adjustedIdx = this._adjustIndex(index, -1);
      const view = detachView(this._lContainer, adjustedIdx);
      const wasDetached = view && removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx) != null;
      return wasDetached ? new ViewRef$1(view) : null;
    }
    _adjustIndex(index, shift = 0) {
      if (index == null) {
        return this.length + shift;
      }
      if (ngDevMode) {
        assertGreaterThan(index, -1, `ViewRef index must be positive, got ${index}`);
        assertLessThan(index, this.length + 1 + shift, "index");
      }
      return index;
    }
  };
  function getViewRefs(lContainer) {
    return lContainer[VIEW_REFS];
  }
  function getOrCreateViewRefs(lContainer) {
    return lContainer[VIEW_REFS] || (lContainer[VIEW_REFS] = []);
  }
  function createContainerRef(hostTNode, hostLView) {
    ngDevMode && assertTNodeType(hostTNode, 12 | 3);
    let lContainer;
    const slotValue = hostLView[hostTNode.index];
    if (isLContainer(slotValue)) {
      lContainer = slotValue;
    } else {
      let commentNode;
      if (hostTNode.type & 8) {
        commentNode = unwrapRNode(slotValue);
      } else {
        const renderer = hostLView[RENDERER];
        ngDevMode && ngDevMode.rendererCreateComment++;
        commentNode = renderer.createComment(ngDevMode ? "container" : "");
        const hostNative = getNativeByTNode(hostTNode, hostLView);
        const parentOfHostNative = nativeParentNode(renderer, hostNative);
        nativeInsertBefore(renderer, parentOfHostNative, commentNode, nativeNextSibling(renderer, hostNative), false);
      }
      hostLView[hostTNode.index] = lContainer = createLContainer(slotValue, hostLView, commentNode, hostTNode);
      addToViewTree(hostLView, lContainer);
    }
    return new R3ViewContainerRef(lContainer, hostTNode, hostLView);
  }
  var unusedValueExportToPlacateAjd$1 = 1;
  var unusedValueExportToPlacateAjd = 1;
  var unusedValueToPlacateAjd = unusedValueExportToPlacateAjd$1 + unusedValueExportToPlacateAjd$5 + unusedValueExportToPlacateAjd$4 + unusedValueExportToPlacateAjd;
  var LQuery_ = class {
    constructor(queryList) {
      this.queryList = queryList;
      this.matches = null;
    }
    clone() {
      return new LQuery_(this.queryList);
    }
    setDirty() {
      this.queryList.setDirty();
    }
  };
  var LQueries_ = class {
    constructor(queries = []) {
      this.queries = queries;
    }
    createEmbeddedView(tView) {
      const tQueries = tView.queries;
      if (tQueries !== null) {
        const noOfInheritedQueries = tView.contentQueries !== null ? tView.contentQueries[0] : tQueries.length;
        const viewLQueries = [];
        for (let i = 0; i < noOfInheritedQueries; i++) {
          const tQuery = tQueries.getByIndex(i);
          const parentLQuery = this.queries[tQuery.indexInDeclarationView];
          viewLQueries.push(parentLQuery.clone());
        }
        return new LQueries_(viewLQueries);
      }
      return null;
    }
    insertView(tView) {
      this.dirtyQueriesWithMatches(tView);
    }
    detachView(tView) {
      this.dirtyQueriesWithMatches(tView);
    }
    dirtyQueriesWithMatches(tView) {
      for (let i = 0; i < this.queries.length; i++) {
        if (getTQuery(tView, i).matches !== null) {
          this.queries[i].setDirty();
        }
      }
    }
  };
  var TQueryMetadata_ = class {
    constructor(predicate, flags, read = null) {
      this.predicate = predicate;
      this.flags = flags;
      this.read = read;
    }
  };
  var TQueries_ = class {
    constructor(queries = []) {
      this.queries = queries;
    }
    elementStart(tView, tNode) {
      ngDevMode && assertFirstCreatePass(tView, "Queries should collect results on the first template pass only");
      for (let i = 0; i < this.queries.length; i++) {
        this.queries[i].elementStart(tView, tNode);
      }
    }
    elementEnd(tNode) {
      for (let i = 0; i < this.queries.length; i++) {
        this.queries[i].elementEnd(tNode);
      }
    }
    embeddedTView(tNode) {
      let queriesForTemplateRef = null;
      for (let i = 0; i < this.length; i++) {
        const childQueryIndex = queriesForTemplateRef !== null ? queriesForTemplateRef.length : 0;
        const tqueryClone = this.getByIndex(i).embeddedTView(tNode, childQueryIndex);
        if (tqueryClone) {
          tqueryClone.indexInDeclarationView = i;
          if (queriesForTemplateRef !== null) {
            queriesForTemplateRef.push(tqueryClone);
          } else {
            queriesForTemplateRef = [tqueryClone];
          }
        }
      }
      return queriesForTemplateRef !== null ? new TQueries_(queriesForTemplateRef) : null;
    }
    template(tView, tNode) {
      ngDevMode && assertFirstCreatePass(tView, "Queries should collect results on the first template pass only");
      for (let i = 0; i < this.queries.length; i++) {
        this.queries[i].template(tView, tNode);
      }
    }
    getByIndex(index) {
      ngDevMode && assertIndexInRange(this.queries, index);
      return this.queries[index];
    }
    get length() {
      return this.queries.length;
    }
    track(tquery) {
      this.queries.push(tquery);
    }
  };
  var TQuery_ = class {
    constructor(metadata, nodeIndex = -1) {
      this.metadata = metadata;
      this.matches = null;
      this.indexInDeclarationView = -1;
      this.crossesNgTemplate = false;
      this._appliesToNextNode = true;
      this._declarationNodeIndex = nodeIndex;
    }
    elementStart(tView, tNode) {
      if (this.isApplyingToNode(tNode)) {
        this.matchTNode(tView, tNode);
      }
    }
    elementEnd(tNode) {
      if (this._declarationNodeIndex === tNode.index) {
        this._appliesToNextNode = false;
      }
    }
    template(tView, tNode) {
      this.elementStart(tView, tNode);
    }
    embeddedTView(tNode, childQueryIndex) {
      if (this.isApplyingToNode(tNode)) {
        this.crossesNgTemplate = true;
        this.addMatch(-tNode.index, childQueryIndex);
        return new TQuery_(this.metadata);
      }
      return null;
    }
    isApplyingToNode(tNode) {
      if (this._appliesToNextNode && (this.metadata.flags & 1) !== 1) {
        const declarationNodeIdx = this._declarationNodeIndex;
        let parent = tNode.parent;
        while (parent !== null && parent.type & 8 && parent.index !== declarationNodeIdx) {
          parent = parent.parent;
        }
        return declarationNodeIdx === (parent !== null ? parent.index : -1);
      }
      return this._appliesToNextNode;
    }
    matchTNode(tView, tNode) {
      const predicate = this.metadata.predicate;
      if (Array.isArray(predicate)) {
        for (let i = 0; i < predicate.length; i++) {
          const name = predicate[i];
          this.matchTNodeWithReadOption(tView, tNode, getIdxOfMatchingSelector(tNode, name));
          this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, name, false, false));
        }
      } else {
        if (predicate === TemplateRef) {
          if (tNode.type & 4) {
            this.matchTNodeWithReadOption(tView, tNode, -1);
          }
        } else {
          this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, predicate, false, false));
        }
      }
    }
    matchTNodeWithReadOption(tView, tNode, nodeMatchIdx) {
      if (nodeMatchIdx !== null) {
        const read = this.metadata.read;
        if (read !== null) {
          if (read === ElementRef || read === ViewContainerRef || read === TemplateRef && tNode.type & 4) {
            this.addMatch(tNode.index, -2);
          } else {
            const directiveOrProviderIdx = locateDirectiveOrProvider(tNode, tView, read, false, false);
            if (directiveOrProviderIdx !== null) {
              this.addMatch(tNode.index, directiveOrProviderIdx);
            }
          }
        } else {
          this.addMatch(tNode.index, nodeMatchIdx);
        }
      }
    }
    addMatch(tNodeIdx, matchIdx) {
      if (this.matches === null) {
        this.matches = [tNodeIdx, matchIdx];
      } else {
        this.matches.push(tNodeIdx, matchIdx);
      }
    }
  };
  function getIdxOfMatchingSelector(tNode, selector) {
    const localNames = tNode.localNames;
    if (localNames !== null) {
      for (let i = 0; i < localNames.length; i += 2) {
        if (localNames[i] === selector) {
          return localNames[i + 1];
        }
      }
    }
    return null;
  }
  function createResultByTNodeType(tNode, currentView) {
    if (tNode.type & (3 | 8)) {
      return createElementRef(tNode, currentView);
    } else if (tNode.type & 4) {
      return createTemplateRef(tNode, currentView);
    }
    return null;
  }
  function createResultForNode(lView, tNode, matchingIdx, read) {
    if (matchingIdx === -1) {
      return createResultByTNodeType(tNode, lView);
    } else if (matchingIdx === -2) {
      return createSpecialToken(lView, tNode, read);
    } else {
      return getNodeInjectable(lView, lView[TVIEW], matchingIdx, tNode);
    }
  }
  function createSpecialToken(lView, tNode, read) {
    if (read === ElementRef) {
      return createElementRef(tNode, lView);
    } else if (read === TemplateRef) {
      return createTemplateRef(tNode, lView);
    } else if (read === ViewContainerRef) {
      ngDevMode && assertTNodeType(tNode, 3 | 12);
      return createContainerRef(tNode, lView);
    } else {
      ngDevMode && throwError(`Special token to read should be one of ElementRef, TemplateRef or ViewContainerRef but got ${stringify(read)}.`);
    }
  }
  function materializeViewResults(tView, lView, tQuery, queryIndex) {
    const lQuery = lView[QUERIES].queries[queryIndex];
    if (lQuery.matches === null) {
      const tViewData = tView.data;
      const tQueryMatches = tQuery.matches;
      const result = [];
      for (let i = 0; i < tQueryMatches.length; i += 2) {
        const matchedNodeIdx = tQueryMatches[i];
        if (matchedNodeIdx < 0) {
          result.push(null);
        } else {
          ngDevMode && assertIndexInRange(tViewData, matchedNodeIdx);
          const tNode = tViewData[matchedNodeIdx];
          result.push(createResultForNode(lView, tNode, tQueryMatches[i + 1], tQuery.metadata.read));
        }
      }
      lQuery.matches = result;
    }
    return lQuery.matches;
  }
  function collectQueryResults(tView, lView, queryIndex, result) {
    const tQuery = tView.queries.getByIndex(queryIndex);
    const tQueryMatches = tQuery.matches;
    if (tQueryMatches !== null) {
      const lViewResults = materializeViewResults(tView, lView, tQuery, queryIndex);
      for (let i = 0; i < tQueryMatches.length; i += 2) {
        const tNodeIdx = tQueryMatches[i];
        if (tNodeIdx > 0) {
          result.push(lViewResults[i / 2]);
        } else {
          const childQueryIndex = tQueryMatches[i + 1];
          const declarationLContainer = lView[-tNodeIdx];
          ngDevMode && assertLContainer(declarationLContainer);
          for (let i2 = CONTAINER_HEADER_OFFSET; i2 < declarationLContainer.length; i2++) {
            const embeddedLView = declarationLContainer[i2];
            if (embeddedLView[DECLARATION_LCONTAINER] === embeddedLView[PARENT]) {
              collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);
            }
          }
          if (declarationLContainer[MOVED_VIEWS] !== null) {
            const embeddedLViews = declarationLContainer[MOVED_VIEWS];
            for (let i2 = 0; i2 < embeddedLViews.length; i2++) {
              const embeddedLView = embeddedLViews[i2];
              collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);
            }
          }
        }
      }
    }
    return result;
  }
  function \u0275\u0275queryRefresh(queryList) {
    const lView = getLView();
    const tView = getTView();
    const queryIndex = getCurrentQueryIndex();
    setCurrentQueryIndex(queryIndex + 1);
    const tQuery = getTQuery(tView, queryIndex);
    if (queryList.dirty && isCreationMode(lView) === ((tQuery.metadata.flags & 2) === 2)) {
      if (tQuery.matches === null) {
        queryList.reset([]);
      } else {
        const result = tQuery.crossesNgTemplate ? collectQueryResults(tView, lView, queryIndex, []) : materializeViewResults(tView, lView, tQuery, queryIndex);
        queryList.reset(result, unwrapElementRef);
        queryList.notifyOnChanges();
      }
      return true;
    }
    return false;
  }
  function \u0275\u0275viewQuery(predicate, flags, read) {
    ngDevMode && assertNumber(flags, "Expecting flags");
    const tView = getTView();
    if (tView.firstCreatePass) {
      createTQuery(tView, new TQueryMetadata_(predicate, flags, read), -1);
      if ((flags & 2) === 2) {
        tView.staticViewQueries = true;
      }
    }
    createLQuery(tView, getLView(), flags);
  }
  function \u0275\u0275contentQuery(directiveIndex, predicate, flags, read) {
    ngDevMode && assertNumber(flags, "Expecting flags");
    const tView = getTView();
    if (tView.firstCreatePass) {
      const tNode = getCurrentTNode();
      createTQuery(tView, new TQueryMetadata_(predicate, flags, read), tNode.index);
      saveContentQueryAndDirectiveIndex(tView, directiveIndex);
      if ((flags & 2) === 2) {
        tView.staticContentQueries = true;
      }
    }
    createLQuery(tView, getLView(), flags);
  }
  function \u0275\u0275loadQuery() {
    return loadQueryInternal(getLView(), getCurrentQueryIndex());
  }
  function loadQueryInternal(lView, queryIndex) {
    ngDevMode && assertDefined(lView[QUERIES], "LQueries should be defined when trying to load a query");
    ngDevMode && assertIndexInRange(lView[QUERIES].queries, queryIndex);
    return lView[QUERIES].queries[queryIndex].queryList;
  }
  function createLQuery(tView, lView, flags) {
    const queryList = new QueryList((flags & 4) === 4);
    storeCleanupWithContext(tView, lView, queryList, queryList.destroy);
    if (lView[QUERIES] === null)
      lView[QUERIES] = new LQueries_();
    lView[QUERIES].queries.push(new LQuery_(queryList));
  }
  function createTQuery(tView, metadata, nodeIndex) {
    if (tView.queries === null)
      tView.queries = new TQueries_();
    tView.queries.track(new TQuery_(metadata, nodeIndex));
  }
  function saveContentQueryAndDirectiveIndex(tView, directiveIndex) {
    const tViewContentQueries = tView.contentQueries || (tView.contentQueries = []);
    const lastSavedDirectiveIndex = tViewContentQueries.length ? tViewContentQueries[tViewContentQueries.length - 1] : -1;
    if (directiveIndex !== lastSavedDirectiveIndex) {
      tViewContentQueries.push(tView.queries.length - 1, directiveIndex);
    }
  }
  function getTQuery(tView, index) {
    ngDevMode && assertDefined(tView.queries, "TQueries must be defined to retrieve a TQuery");
    return tView.queries.getByIndex(index);
  }
  function \u0275\u0275templateRefExtractor(tNode, lView) {
    return createTemplateRef(tNode, lView);
  }
  var angularCoreEnv = (() => ({
    "\u0275\u0275attribute": \u0275\u0275attribute,
    "\u0275\u0275attributeInterpolate1": \u0275\u0275attributeInterpolate1,
    "\u0275\u0275attributeInterpolate2": \u0275\u0275attributeInterpolate2,
    "\u0275\u0275attributeInterpolate3": \u0275\u0275attributeInterpolate3,
    "\u0275\u0275attributeInterpolate4": \u0275\u0275attributeInterpolate4,
    "\u0275\u0275attributeInterpolate5": \u0275\u0275attributeInterpolate5,
    "\u0275\u0275attributeInterpolate6": \u0275\u0275attributeInterpolate6,
    "\u0275\u0275attributeInterpolate7": \u0275\u0275attributeInterpolate7,
    "\u0275\u0275attributeInterpolate8": \u0275\u0275attributeInterpolate8,
    "\u0275\u0275attributeInterpolateV": \u0275\u0275attributeInterpolateV,
    "\u0275\u0275defineComponent": \u0275\u0275defineComponent,
    "\u0275\u0275defineDirective": \u0275\u0275defineDirective,
    "\u0275\u0275defineInjectable": \u0275\u0275defineInjectable,
    "\u0275\u0275defineInjector": \u0275\u0275defineInjector,
    "\u0275\u0275defineNgModule": \u0275\u0275defineNgModule,
    "\u0275\u0275definePipe": \u0275\u0275definePipe,
    "\u0275\u0275directiveInject": \u0275\u0275directiveInject,
    "\u0275\u0275getInheritedFactory": \u0275\u0275getInheritedFactory,
    "\u0275\u0275inject": \u0275\u0275inject,
    "\u0275\u0275injectAttribute": \u0275\u0275injectAttribute,
    "\u0275\u0275invalidFactory": \u0275\u0275invalidFactory,
    "\u0275\u0275invalidFactoryDep": \u0275\u0275invalidFactoryDep,
    "\u0275\u0275templateRefExtractor": \u0275\u0275templateRefExtractor,
    "\u0275\u0275NgOnChangesFeature": \u0275\u0275NgOnChangesFeature,
    "\u0275\u0275ProvidersFeature": \u0275\u0275ProvidersFeature,
    "\u0275\u0275CopyDefinitionFeature": \u0275\u0275CopyDefinitionFeature,
    "\u0275\u0275InheritDefinitionFeature": \u0275\u0275InheritDefinitionFeature,
    "\u0275\u0275nextContext": \u0275\u0275nextContext,
    "\u0275\u0275namespaceHTML": \u0275\u0275namespaceHTML,
    "\u0275\u0275namespaceMathML": \u0275\u0275namespaceMathML,
    "\u0275\u0275namespaceSVG": \u0275\u0275namespaceSVG,
    "\u0275\u0275enableBindings": \u0275\u0275enableBindings,
    "\u0275\u0275disableBindings": \u0275\u0275disableBindings,
    "\u0275\u0275elementStart": \u0275\u0275elementStart,
    "\u0275\u0275elementEnd": \u0275\u0275elementEnd,
    "\u0275\u0275element": \u0275\u0275element,
    "\u0275\u0275elementContainerStart": \u0275\u0275elementContainerStart,
    "\u0275\u0275elementContainerEnd": \u0275\u0275elementContainerEnd,
    "\u0275\u0275elementContainer": \u0275\u0275elementContainer,
    "\u0275\u0275pureFunction0": \u0275\u0275pureFunction0,
    "\u0275\u0275pureFunction1": \u0275\u0275pureFunction1,
    "\u0275\u0275pureFunction2": \u0275\u0275pureFunction2,
    "\u0275\u0275pureFunction3": \u0275\u0275pureFunction3,
    "\u0275\u0275pureFunction4": \u0275\u0275pureFunction4,
    "\u0275\u0275pureFunction5": \u0275\u0275pureFunction5,
    "\u0275\u0275pureFunction6": \u0275\u0275pureFunction6,
    "\u0275\u0275pureFunction7": \u0275\u0275pureFunction7,
    "\u0275\u0275pureFunction8": \u0275\u0275pureFunction8,
    "\u0275\u0275pureFunctionV": \u0275\u0275pureFunctionV,
    "\u0275\u0275getCurrentView": \u0275\u0275getCurrentView,
    "\u0275\u0275restoreView": \u0275\u0275restoreView,
    "\u0275\u0275listener": \u0275\u0275listener,
    "\u0275\u0275projection": \u0275\u0275projection,
    "\u0275\u0275syntheticHostProperty": \u0275\u0275syntheticHostProperty,
    "\u0275\u0275syntheticHostListener": \u0275\u0275syntheticHostListener,
    "\u0275\u0275pipeBind1": \u0275\u0275pipeBind1,
    "\u0275\u0275pipeBind2": \u0275\u0275pipeBind2,
    "\u0275\u0275pipeBind3": \u0275\u0275pipeBind3,
    "\u0275\u0275pipeBind4": \u0275\u0275pipeBind4,
    "\u0275\u0275pipeBindV": \u0275\u0275pipeBindV,
    "\u0275\u0275projectionDef": \u0275\u0275projectionDef,
    "\u0275\u0275hostProperty": \u0275\u0275hostProperty,
    "\u0275\u0275property": \u0275\u0275property,
    "\u0275\u0275propertyInterpolate": \u0275\u0275propertyInterpolate,
    "\u0275\u0275propertyInterpolate1": \u0275\u0275propertyInterpolate1,
    "\u0275\u0275propertyInterpolate2": \u0275\u0275propertyInterpolate2,
    "\u0275\u0275propertyInterpolate3": \u0275\u0275propertyInterpolate3,
    "\u0275\u0275propertyInterpolate4": \u0275\u0275propertyInterpolate4,
    "\u0275\u0275propertyInterpolate5": \u0275\u0275propertyInterpolate5,
    "\u0275\u0275propertyInterpolate6": \u0275\u0275propertyInterpolate6,
    "\u0275\u0275propertyInterpolate7": \u0275\u0275propertyInterpolate7,
    "\u0275\u0275propertyInterpolate8": \u0275\u0275propertyInterpolate8,
    "\u0275\u0275propertyInterpolateV": \u0275\u0275propertyInterpolateV,
    "\u0275\u0275pipe": \u0275\u0275pipe,
    "\u0275\u0275queryRefresh": \u0275\u0275queryRefresh,
    "\u0275\u0275viewQuery": \u0275\u0275viewQuery,
    "\u0275\u0275loadQuery": \u0275\u0275loadQuery,
    "\u0275\u0275contentQuery": \u0275\u0275contentQuery,
    "\u0275\u0275reference": \u0275\u0275reference,
    "\u0275\u0275classMap": \u0275\u0275classMap,
    "\u0275\u0275classMapInterpolate1": \u0275\u0275classMapInterpolate1,
    "\u0275\u0275classMapInterpolate2": \u0275\u0275classMapInterpolate2,
    "\u0275\u0275classMapInterpolate3": \u0275\u0275classMapInterpolate3,
    "\u0275\u0275classMapInterpolate4": \u0275\u0275classMapInterpolate4,
    "\u0275\u0275classMapInterpolate5": \u0275\u0275classMapInterpolate5,
    "\u0275\u0275classMapInterpolate6": \u0275\u0275classMapInterpolate6,
    "\u0275\u0275classMapInterpolate7": \u0275\u0275classMapInterpolate7,
    "\u0275\u0275classMapInterpolate8": \u0275\u0275classMapInterpolate8,
    "\u0275\u0275classMapInterpolateV": \u0275\u0275classMapInterpolateV,
    "\u0275\u0275styleMap": \u0275\u0275styleMap,
    "\u0275\u0275styleMapInterpolate1": \u0275\u0275styleMapInterpolate1,
    "\u0275\u0275styleMapInterpolate2": \u0275\u0275styleMapInterpolate2,
    "\u0275\u0275styleMapInterpolate3": \u0275\u0275styleMapInterpolate3,
    "\u0275\u0275styleMapInterpolate4": \u0275\u0275styleMapInterpolate4,
    "\u0275\u0275styleMapInterpolate5": \u0275\u0275styleMapInterpolate5,
    "\u0275\u0275styleMapInterpolate6": \u0275\u0275styleMapInterpolate6,
    "\u0275\u0275styleMapInterpolate7": \u0275\u0275styleMapInterpolate7,
    "\u0275\u0275styleMapInterpolate8": \u0275\u0275styleMapInterpolate8,
    "\u0275\u0275styleMapInterpolateV": \u0275\u0275styleMapInterpolateV,
    "\u0275\u0275styleProp": \u0275\u0275styleProp,
    "\u0275\u0275stylePropInterpolate1": \u0275\u0275stylePropInterpolate1,
    "\u0275\u0275stylePropInterpolate2": \u0275\u0275stylePropInterpolate2,
    "\u0275\u0275stylePropInterpolate3": \u0275\u0275stylePropInterpolate3,
    "\u0275\u0275stylePropInterpolate4": \u0275\u0275stylePropInterpolate4,
    "\u0275\u0275stylePropInterpolate5": \u0275\u0275stylePropInterpolate5,
    "\u0275\u0275stylePropInterpolate6": \u0275\u0275stylePropInterpolate6,
    "\u0275\u0275stylePropInterpolate7": \u0275\u0275stylePropInterpolate7,
    "\u0275\u0275stylePropInterpolate8": \u0275\u0275stylePropInterpolate8,
    "\u0275\u0275stylePropInterpolateV": \u0275\u0275stylePropInterpolateV,
    "\u0275\u0275classProp": \u0275\u0275classProp,
    "\u0275\u0275advance": \u0275\u0275advance,
    "\u0275\u0275template": \u0275\u0275template,
    "\u0275\u0275text": \u0275\u0275text,
    "\u0275\u0275textInterpolate": \u0275\u0275textInterpolate,
    "\u0275\u0275textInterpolate1": \u0275\u0275textInterpolate1,
    "\u0275\u0275textInterpolate2": \u0275\u0275textInterpolate2,
    "\u0275\u0275textInterpolate3": \u0275\u0275textInterpolate3,
    "\u0275\u0275textInterpolate4": \u0275\u0275textInterpolate4,
    "\u0275\u0275textInterpolate5": \u0275\u0275textInterpolate5,
    "\u0275\u0275textInterpolate6": \u0275\u0275textInterpolate6,
    "\u0275\u0275textInterpolate7": \u0275\u0275textInterpolate7,
    "\u0275\u0275textInterpolate8": \u0275\u0275textInterpolate8,
    "\u0275\u0275textInterpolateV": \u0275\u0275textInterpolateV,
    "\u0275\u0275i18n": \u0275\u0275i18n,
    "\u0275\u0275i18nAttributes": \u0275\u0275i18nAttributes,
    "\u0275\u0275i18nExp": \u0275\u0275i18nExp,
    "\u0275\u0275i18nStart": \u0275\u0275i18nStart,
    "\u0275\u0275i18nEnd": \u0275\u0275i18nEnd,
    "\u0275\u0275i18nApply": \u0275\u0275i18nApply,
    "\u0275\u0275i18nPostprocess": \u0275\u0275i18nPostprocess,
    "\u0275\u0275resolveWindow": \u0275\u0275resolveWindow,
    "\u0275\u0275resolveDocument": \u0275\u0275resolveDocument,
    "\u0275\u0275resolveBody": \u0275\u0275resolveBody,
    "\u0275\u0275setComponentScope": \u0275\u0275setComponentScope,
    "\u0275\u0275setNgModuleScope": \u0275\u0275setNgModuleScope,
    "\u0275\u0275sanitizeHtml": \u0275\u0275sanitizeHtml,
    "\u0275\u0275sanitizeStyle": \u0275\u0275sanitizeStyle,
    "\u0275\u0275sanitizeResourceUrl": \u0275\u0275sanitizeResourceUrl,
    "\u0275\u0275sanitizeScript": \u0275\u0275sanitizeScript,
    "\u0275\u0275sanitizeUrl": \u0275\u0275sanitizeUrl,
    "\u0275\u0275sanitizeUrlOrResourceUrl": \u0275\u0275sanitizeUrlOrResourceUrl,
    "\u0275\u0275trustConstantHtml": \u0275\u0275trustConstantHtml,
    "\u0275\u0275trustConstantResourceUrl": \u0275\u0275trustConstantResourceUrl,
    "forwardRef": forwardRef,
    "resolveForwardRef": resolveForwardRef
  }))();
  var jitOptions = null;
  function setJitOptions(options) {
    if (jitOptions !== null) {
      if (options.defaultEncapsulation !== jitOptions.defaultEncapsulation) {
        ngDevMode && console.error("Provided value for `defaultEncapsulation` can not be changed once it has been set.");
        return;
      }
      if (options.preserveWhitespaces !== jitOptions.preserveWhitespaces) {
        ngDevMode && console.error("Provided value for `preserveWhitespaces` can not be changed once it has been set.");
        return;
      }
    }
    jitOptions = options;
  }
  function getJitOptions() {
    return jitOptions;
  }
  function resetJitOptions() {
    jitOptions = null;
  }
  var moduleQueue = [];
  function enqueueModuleForDelayedScoping(moduleType, ngModule) {
    moduleQueue.push({ moduleType, ngModule });
  }
  var flushingModuleQueue = false;
  function flushModuleScopingQueueAsMuchAsPossible() {
    if (!flushingModuleQueue) {
      flushingModuleQueue = true;
      try {
        for (let i = moduleQueue.length - 1; i >= 0; i--) {
          const { moduleType, ngModule } = moduleQueue[i];
          if (ngModule.declarations && ngModule.declarations.every(isResolvedDeclaration)) {
            moduleQueue.splice(i, 1);
            setScopeOnDeclaredComponents(moduleType, ngModule);
          }
        }
      } finally {
        flushingModuleQueue = false;
      }
    }
  }
  function isResolvedDeclaration(declaration) {
    if (Array.isArray(declaration)) {
      return declaration.every(isResolvedDeclaration);
    }
    return !!resolveForwardRef(declaration);
  }
  function compileNgModule(moduleType, ngModule = {}) {
    compileNgModuleDefs(moduleType, ngModule);
    enqueueModuleForDelayedScoping(moduleType, ngModule);
  }
  function compileNgModuleDefs(moduleType, ngModule, allowDuplicateDeclarationsInRoot = false) {
    ngDevMode && assertDefined(moduleType, "Required value moduleType");
    ngDevMode && assertDefined(ngModule, "Required value ngModule");
    const declarations = flatten(ngModule.declarations || EMPTY_ARRAY);
    let ngModuleDef = null;
    Object.defineProperty(moduleType, NG_MOD_DEF, {
      configurable: true,
      get: () => {
        if (ngModuleDef === null) {
          if (ngDevMode && ngModule.imports && ngModule.imports.indexOf(moduleType) > -1) {
            throw new Error(`'${stringifyForError(moduleType)}' module can't import itself`);
          }
          const compiler = getCompilerFacade({ usage: 0, kind: "NgModule", type: moduleType });
          ngModuleDef = compiler.compileNgModule(angularCoreEnv, `ng:///${moduleType.name}/\u0275mod.js`, {
            type: moduleType,
            bootstrap: flatten(ngModule.bootstrap || EMPTY_ARRAY).map(resolveForwardRef),
            declarations: declarations.map(resolveForwardRef),
            imports: flatten(ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef).map(expandModuleWithProviders),
            exports: flatten(ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef).map(expandModuleWithProviders),
            schemas: ngModule.schemas ? flatten(ngModule.schemas) : null,
            id: ngModule.id || null
          });
          if (!ngModuleDef.schemas) {
            ngModuleDef.schemas = [];
          }
        }
        return ngModuleDef;
      }
    });
    let ngFactoryDef = null;
    Object.defineProperty(moduleType, NG_FACTORY_DEF, {
      get: () => {
        if (ngFactoryDef === null) {
          const compiler = getCompilerFacade({ usage: 0, kind: "NgModule", type: moduleType });
          ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${moduleType.name}/\u0275fac.js`, {
            name: moduleType.name,
            type: moduleType,
            deps: reflectDependencies(moduleType),
            target: compiler.FactoryTarget.NgModule,
            typeArgumentCount: 0
          });
        }
        return ngFactoryDef;
      },
      configurable: !!ngDevMode
    });
    let ngInjectorDef = null;
    Object.defineProperty(moduleType, NG_INJ_DEF, {
      get: () => {
        if (ngInjectorDef === null) {
          ngDevMode && verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot);
          const meta = {
            name: moduleType.name,
            type: moduleType,
            providers: ngModule.providers || EMPTY_ARRAY,
            imports: [
              (ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef),
              (ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef)
            ]
          };
          const compiler = getCompilerFacade({ usage: 0, kind: "NgModule", type: moduleType });
          ngInjectorDef = compiler.compileInjector(angularCoreEnv, `ng:///${moduleType.name}/\u0275inj.js`, meta);
        }
        return ngInjectorDef;
      },
      configurable: !!ngDevMode
    });
  }
  function verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot, importingModule) {
    if (verifiedNgModule.get(moduleType))
      return;
    verifiedNgModule.set(moduleType, true);
    moduleType = resolveForwardRef(moduleType);
    let ngModuleDef;
    if (importingModule) {
      ngModuleDef = getNgModuleDef(moduleType);
      if (!ngModuleDef) {
        throw new Error(`Unexpected value '${moduleType.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);
      }
    } else {
      ngModuleDef = getNgModuleDef(moduleType, true);
    }
    const errors = [];
    const declarations = maybeUnwrapFn(ngModuleDef.declarations);
    const imports = maybeUnwrapFn(ngModuleDef.imports);
    flatten(imports).map(unwrapModuleWithProvidersImports).forEach((mod) => {
      verifySemanticsOfNgModuleImport(mod, moduleType);
      verifySemanticsOfNgModuleDef(mod, false, moduleType);
    });
    const exports = maybeUnwrapFn(ngModuleDef.exports);
    declarations.forEach(verifyDeclarationsHaveDefinitions);
    declarations.forEach(verifyDirectivesHaveSelector);
    const combinedDeclarations = [
      ...declarations.map(resolveForwardRef),
      ...flatten(imports.map(computeCombinedExports)).map(resolveForwardRef)
    ];
    exports.forEach(verifyExportsAreDeclaredOrReExported);
    declarations.forEach((decl) => verifyDeclarationIsUnique(decl, allowDuplicateDeclarationsInRoot));
    declarations.forEach(verifyComponentEntryComponentsIsPartOfNgModule);
    const ngModule = getAnnotation(moduleType, "NgModule");
    if (ngModule) {
      ngModule.imports && flatten(ngModule.imports).map(unwrapModuleWithProvidersImports).forEach((mod) => {
        verifySemanticsOfNgModuleImport(mod, moduleType);
        verifySemanticsOfNgModuleDef(mod, false, moduleType);
      });
      ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyCorrectBootstrapType);
      ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyComponentIsPartOfNgModule);
      ngModule.entryComponents && deepForEach(ngModule.entryComponents, verifyComponentIsPartOfNgModule);
    }
    if (errors.length) {
      throw new Error(errors.join("\n"));
    }
    function verifyDeclarationsHaveDefinitions(type) {
      type = resolveForwardRef(type);
      const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef$1(type);
      if (!def) {
        errors.push(`Unexpected value '${stringifyForError(type)}' declared by the module '${stringifyForError(moduleType)}'. Please add a @Pipe/@Directive/@Component annotation.`);
      }
    }
    function verifyDirectivesHaveSelector(type) {
      type = resolveForwardRef(type);
      const def = getDirectiveDef(type);
      if (!getComponentDef(type) && def && def.selectors.length == 0) {
        errors.push(`Directive ${stringifyForError(type)} has no selector, please add it!`);
      }
    }
    function verifyExportsAreDeclaredOrReExported(type) {
      type = resolveForwardRef(type);
      const kind = getComponentDef(type) && "component" || getDirectiveDef(type) && "directive" || getPipeDef$1(type) && "pipe";
      if (kind) {
        if (combinedDeclarations.lastIndexOf(type) === -1) {
          errors.push(`Can't export ${kind} ${stringifyForError(type)} from ${stringifyForError(moduleType)} as it was neither declared nor imported!`);
        }
      }
    }
    function verifyDeclarationIsUnique(type, suppressErrors) {
      type = resolveForwardRef(type);
      const existingModule = ownerNgModule.get(type);
      if (existingModule && existingModule !== moduleType) {
        if (!suppressErrors) {
          const modules2 = [existingModule, moduleType].map(stringifyForError).sort();
          errors.push(`Type ${stringifyForError(type)} is part of the declarations of 2 modules: ${modules2[0]} and ${modules2[1]}! Please consider moving ${stringifyForError(type)} to a higher module that imports ${modules2[0]} and ${modules2[1]}. You can also create a new NgModule that exports and includes ${stringifyForError(type)} then import that NgModule in ${modules2[0]} and ${modules2[1]}.`);
        }
      } else {
        ownerNgModule.set(type, moduleType);
      }
    }
    function verifyComponentIsPartOfNgModule(type) {
      type = resolveForwardRef(type);
      const existingModule = ownerNgModule.get(type);
      if (!existingModule) {
        errors.push(`Component ${stringifyForError(type)} is not part of any NgModule or the module has not been imported into your module.`);
      }
    }
    function verifyCorrectBootstrapType(type) {
      type = resolveForwardRef(type);
      if (!getComponentDef(type)) {
        errors.push(`${stringifyForError(type)} cannot be used as an entry component.`);
      }
    }
    function verifyComponentEntryComponentsIsPartOfNgModule(type) {
      type = resolveForwardRef(type);
      if (getComponentDef(type)) {
        const component = getAnnotation(type, "Component");
        if (component && component.entryComponents) {
          deepForEach(component.entryComponents, verifyComponentIsPartOfNgModule);
        }
      }
    }
    function verifySemanticsOfNgModuleImport(type, importingModule2) {
      type = resolveForwardRef(type);
      if (getComponentDef(type) || getDirectiveDef(type)) {
        throw new Error(`Unexpected directive '${type.name}' imported by the module '${importingModule2.name}'. Please add an @NgModule annotation.`);
      }
      if (getPipeDef$1(type)) {
        throw new Error(`Unexpected pipe '${type.name}' imported by the module '${importingModule2.name}'. Please add an @NgModule annotation.`);
      }
    }
  }
  function unwrapModuleWithProvidersImports(typeOrWithProviders) {
    typeOrWithProviders = resolveForwardRef(typeOrWithProviders);
    return typeOrWithProviders.ngModule || typeOrWithProviders;
  }
  function getAnnotation(type, name) {
    let annotation = null;
    collect(type.__annotations__);
    collect(type.decorators);
    return annotation;
    function collect(annotations) {
      if (annotations) {
        annotations.forEach(readAnnotation);
      }
    }
    function readAnnotation(decorator) {
      if (!annotation) {
        const proto = Object.getPrototypeOf(decorator);
        if (proto.ngMetadataName == name) {
          annotation = decorator;
        } else if (decorator.type) {
          const proto2 = Object.getPrototypeOf(decorator.type);
          if (proto2.ngMetadataName == name) {
            annotation = decorator.args[0];
          }
        }
      }
    }
  }
  var ownerNgModule = /* @__PURE__ */ new WeakMap();
  var verifiedNgModule = /* @__PURE__ */ new WeakMap();
  function resetCompiledComponents() {
    ownerNgModule = /* @__PURE__ */ new WeakMap();
    verifiedNgModule = /* @__PURE__ */ new WeakMap();
    moduleQueue.length = 0;
  }
  function computeCombinedExports(type) {
    type = resolveForwardRef(type);
    const ngModuleDef = getNgModuleDef(type, true);
    return [...flatten(maybeUnwrapFn(ngModuleDef.exports).map((type2) => {
      const ngModuleDef2 = getNgModuleDef(type2);
      if (ngModuleDef2) {
        verifySemanticsOfNgModuleDef(type2, false);
        return computeCombinedExports(type2);
      } else {
        return type2;
      }
    }))];
  }
  function setScopeOnDeclaredComponents(moduleType, ngModule) {
    const declarations = flatten(ngModule.declarations || EMPTY_ARRAY);
    const transitiveScopes = transitiveScopesFor(moduleType);
    declarations.forEach((declaration) => {
      if (declaration.hasOwnProperty(NG_COMP_DEF)) {
        const component = declaration;
        const componentDef = getComponentDef(component);
        patchComponentDefWithScope(componentDef, transitiveScopes);
      } else if (!declaration.hasOwnProperty(NG_DIR_DEF) && !declaration.hasOwnProperty(NG_PIPE_DEF)) {
        declaration.ngSelectorScope = moduleType;
      }
    });
  }
  function patchComponentDefWithScope(componentDef, transitiveScopes) {
    componentDef.directiveDefs = () => Array.from(transitiveScopes.compilation.directives).map((dir) => dir.hasOwnProperty(NG_COMP_DEF) ? getComponentDef(dir) : getDirectiveDef(dir)).filter((def) => !!def);
    componentDef.pipeDefs = () => Array.from(transitiveScopes.compilation.pipes).map((pipe) => getPipeDef$1(pipe));
    componentDef.schemas = transitiveScopes.schemas;
    componentDef.tView = null;
  }
  function transitiveScopesFor(moduleType) {
    if (!isNgModule(moduleType)) {
      throw new Error(`${moduleType.name} does not have a module def (\u0275mod property)`);
    }
    const def = getNgModuleDef(moduleType);
    if (def.transitiveCompileScopes !== null) {
      return def.transitiveCompileScopes;
    }
    const scopes = {
      schemas: def.schemas || null,
      compilation: {
        directives: /* @__PURE__ */ new Set(),
        pipes: /* @__PURE__ */ new Set()
      },
      exported: {
        directives: /* @__PURE__ */ new Set(),
        pipes: /* @__PURE__ */ new Set()
      }
    };
    maybeUnwrapFn(def.imports).forEach((imported) => {
      const importedType = imported;
      if (!isNgModule(importedType)) {
        throw new Error(`Importing ${importedType.name} which does not have a \u0275mod property`);
      }
      const importedScope = transitiveScopesFor(importedType);
      importedScope.exported.directives.forEach((entry) => scopes.compilation.directives.add(entry));
      importedScope.exported.pipes.forEach((entry) => scopes.compilation.pipes.add(entry));
    });
    maybeUnwrapFn(def.declarations).forEach((declared) => {
      const declaredWithDefs = declared;
      if (getPipeDef$1(declaredWithDefs)) {
        scopes.compilation.pipes.add(declared);
      } else {
        scopes.compilation.directives.add(declared);
      }
    });
    maybeUnwrapFn(def.exports).forEach((exported) => {
      const exportedType = exported;
      if (isNgModule(exportedType)) {
        const exportedScope = transitiveScopesFor(exportedType);
        exportedScope.exported.directives.forEach((entry) => {
          scopes.compilation.directives.add(entry);
          scopes.exported.directives.add(entry);
        });
        exportedScope.exported.pipes.forEach((entry) => {
          scopes.compilation.pipes.add(entry);
          scopes.exported.pipes.add(entry);
        });
      } else if (getPipeDef$1(exportedType)) {
        scopes.exported.pipes.add(exportedType);
      } else {
        scopes.exported.directives.add(exportedType);
      }
    });
    def.transitiveCompileScopes = scopes;
    return scopes;
  }
  function expandModuleWithProviders(value) {
    if (isModuleWithProviders(value)) {
      return value.ngModule;
    }
    return value;
  }
  function isModuleWithProviders(value) {
    return value.ngModule !== void 0;
  }
  function isNgModule(value) {
    return !!getNgModuleDef(value);
  }
  var compilationDepth = 0;
  function compileComponent(type, metadata) {
    (typeof ngDevMode === "undefined" || ngDevMode) && initNgDevMode();
    let ngComponentDef = null;
    maybeQueueResolutionOfComponentResources(type, metadata);
    addDirectiveFactoryDef(type, metadata);
    Object.defineProperty(type, NG_COMP_DEF, {
      get: () => {
        if (ngComponentDef === null) {
          const compiler = getCompilerFacade({ usage: 0, kind: "component", type });
          if (componentNeedsResolution(metadata)) {
            const error3 = [`Component '${type.name}' is not resolved:`];
            if (metadata.templateUrl) {
              error3.push(` - templateUrl: ${metadata.templateUrl}`);
            }
            if (metadata.styleUrls && metadata.styleUrls.length) {
              error3.push(` - styleUrls: ${JSON.stringify(metadata.styleUrls)}`);
            }
            error3.push(`Did you run and wait for 'resolveComponentResources()'?`);
            throw new Error(error3.join("\n"));
          }
          const options = getJitOptions();
          let preserveWhitespaces = metadata.preserveWhitespaces;
          if (preserveWhitespaces === void 0) {
            if (options !== null && options.preserveWhitespaces !== void 0) {
              preserveWhitespaces = options.preserveWhitespaces;
            } else {
              preserveWhitespaces = false;
            }
          }
          let encapsulation = metadata.encapsulation;
          if (encapsulation === void 0) {
            if (options !== null && options.defaultEncapsulation !== void 0) {
              encapsulation = options.defaultEncapsulation;
            } else {
              encapsulation = ViewEncapsulation$1.Emulated;
            }
          }
          const templateUrl = metadata.templateUrl || `ng:///${type.name}/template.html`;
          const meta = {
            ...directiveMetadata(type, metadata),
            typeSourceSpan: compiler.createParseSourceSpan("Component", type.name, templateUrl),
            template: metadata.template || "",
            preserveWhitespaces,
            styles: metadata.styles || EMPTY_ARRAY,
            animations: metadata.animations,
            directives: [],
            changeDetection: metadata.changeDetection,
            pipes: /* @__PURE__ */ new Map(),
            encapsulation,
            interpolation: metadata.interpolation,
            viewProviders: metadata.viewProviders || null
          };
          compilationDepth++;
          try {
            if (meta.usesInheritance) {
              addDirectiveDefToUndecoratedParents(type);
            }
            ngComponentDef = compiler.compileComponent(angularCoreEnv, templateUrl, meta);
          } finally {
            compilationDepth--;
          }
          if (compilationDepth === 0) {
            flushModuleScopingQueueAsMuchAsPossible();
          }
          if (hasSelectorScope(type)) {
            const scopes = transitiveScopesFor(type.ngSelectorScope);
            patchComponentDefWithScope(ngComponentDef, scopes);
          }
        }
        return ngComponentDef;
      },
      configurable: !!ngDevMode
    });
  }
  function hasSelectorScope(component) {
    return component.ngSelectorScope !== void 0;
  }
  function compileDirective(type, directive) {
    let ngDirectiveDef = null;
    addDirectiveFactoryDef(type, directive || {});
    Object.defineProperty(type, NG_DIR_DEF, {
      get: () => {
        if (ngDirectiveDef === null) {
          const meta = getDirectiveMetadata(type, directive || {});
          const compiler = getCompilerFacade({ usage: 0, kind: "directive", type });
          ngDirectiveDef = compiler.compileDirective(angularCoreEnv, meta.sourceMapUrl, meta.metadata);
        }
        return ngDirectiveDef;
      },
      configurable: !!ngDevMode
    });
  }
  function getDirectiveMetadata(type, metadata) {
    const name = type && type.name;
    const sourceMapUrl = `ng:///${name}/\u0275dir.js`;
    const compiler = getCompilerFacade({ usage: 0, kind: "directive", type });
    const facade = directiveMetadata(type, metadata);
    facade.typeSourceSpan = compiler.createParseSourceSpan("Directive", name, sourceMapUrl);
    if (facade.usesInheritance) {
      addDirectiveDefToUndecoratedParents(type);
    }
    return { metadata: facade, sourceMapUrl };
  }
  function addDirectiveFactoryDef(type, metadata) {
    let ngFactoryDef = null;
    Object.defineProperty(type, NG_FACTORY_DEF, {
      get: () => {
        if (ngFactoryDef === null) {
          const meta = getDirectiveMetadata(type, metadata);
          const compiler = getCompilerFacade({ usage: 0, kind: "directive", type });
          ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${type.name}/\u0275fac.js`, {
            name: meta.metadata.name,
            type: meta.metadata.type,
            typeArgumentCount: 0,
            deps: reflectDependencies(type),
            target: compiler.FactoryTarget.Directive
          });
        }
        return ngFactoryDef;
      },
      configurable: !!ngDevMode
    });
  }
  function extendsDirectlyFromObject(type) {
    return Object.getPrototypeOf(type.prototype) === Object.prototype;
  }
  function directiveMetadata(type, metadata) {
    const reflect = getReflect();
    const propMetadata = reflect.ownPropMetadata(type);
    return {
      name: type.name,
      type,
      selector: metadata.selector !== void 0 ? metadata.selector : null,
      host: metadata.host || EMPTY_OBJ,
      propMetadata,
      inputs: metadata.inputs || EMPTY_ARRAY,
      outputs: metadata.outputs || EMPTY_ARRAY,
      queries: extractQueriesMetadata(type, propMetadata, isContentQuery),
      lifecycle: { usesOnChanges: reflect.hasLifecycleHook(type, "ngOnChanges") },
      typeSourceSpan: null,
      usesInheritance: !extendsDirectlyFromObject(type),
      exportAs: extractExportAs(metadata.exportAs),
      providers: metadata.providers || null,
      viewQueries: extractQueriesMetadata(type, propMetadata, isViewQuery)
    };
  }
  function addDirectiveDefToUndecoratedParents(type) {
    const objPrototype = Object.prototype;
    let parent = Object.getPrototypeOf(type.prototype).constructor;
    while (parent && parent !== objPrototype) {
      if (!getDirectiveDef(parent) && !getComponentDef(parent) && shouldAddAbstractDirective(parent)) {
        compileDirective(parent, null);
      }
      parent = Object.getPrototypeOf(parent);
    }
  }
  function convertToR3QueryPredicate(selector) {
    return typeof selector === "string" ? splitByComma(selector) : resolveForwardRef(selector);
  }
  function convertToR3QueryMetadata(propertyName, ann) {
    return {
      propertyName,
      predicate: convertToR3QueryPredicate(ann.selector),
      descendants: ann.descendants,
      first: ann.first,
      read: ann.read ? ann.read : null,
      static: !!ann.static,
      emitDistinctChangesOnly: !!ann.emitDistinctChangesOnly
    };
  }
  function extractQueriesMetadata(type, propMetadata, isQueryAnn) {
    const queriesMeta = [];
    for (const field in propMetadata) {
      if (propMetadata.hasOwnProperty(field)) {
        const annotations = propMetadata[field];
        annotations.forEach((ann) => {
          if (isQueryAnn(ann)) {
            if (!ann.selector) {
              throw new Error(`Can't construct a query for the property "${field}" of "${stringifyForError(type)}" since the query selector wasn't defined.`);
            }
            if (annotations.some(isInputAnnotation)) {
              throw new Error(`Cannot combine @Input decorators with query decorators`);
            }
            queriesMeta.push(convertToR3QueryMetadata(field, ann));
          }
        });
      }
    }
    return queriesMeta;
  }
  function extractExportAs(exportAs) {
    return exportAs === void 0 ? null : splitByComma(exportAs);
  }
  function isContentQuery(value) {
    const name = value.ngMetadataName;
    return name === "ContentChild" || name === "ContentChildren";
  }
  function isViewQuery(value) {
    const name = value.ngMetadataName;
    return name === "ViewChild" || name === "ViewChildren";
  }
  function isInputAnnotation(value) {
    return value.ngMetadataName === "Input";
  }
  function splitByComma(value) {
    return value.split(",").map((piece) => piece.trim());
  }
  var LIFECYCLE_HOOKS = [
    "ngOnChanges",
    "ngOnInit",
    "ngOnDestroy",
    "ngDoCheck",
    "ngAfterViewInit",
    "ngAfterViewChecked",
    "ngAfterContentInit",
    "ngAfterContentChecked"
  ];
  function shouldAddAbstractDirective(type) {
    const reflect = getReflect();
    if (LIFECYCLE_HOOKS.some((hookName) => reflect.hasLifecycleHook(type, hookName))) {
      return true;
    }
    const propMetadata = reflect.propMetadata(type);
    for (const field in propMetadata) {
      const annotations = propMetadata[field];
      for (let i = 0; i < annotations.length; i++) {
        const current = annotations[i];
        const metadataName = current.ngMetadataName;
        if (isInputAnnotation(current) || isContentQuery(current) || isViewQuery(current) || metadataName === "Output" || metadataName === "HostBinding" || metadataName === "HostListener") {
          return true;
        }
      }
    }
    return false;
  }
  function compilePipe(type, meta) {
    let ngPipeDef = null;
    let ngFactoryDef = null;
    Object.defineProperty(type, NG_FACTORY_DEF, {
      get: () => {
        if (ngFactoryDef === null) {
          const metadata = getPipeMetadata(type, meta);
          const compiler = getCompilerFacade({ usage: 0, kind: "pipe", type: metadata.type });
          ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${metadata.name}/\u0275fac.js`, {
            name: metadata.name,
            type: metadata.type,
            typeArgumentCount: 0,
            deps: reflectDependencies(type),
            target: compiler.FactoryTarget.Pipe
          });
        }
        return ngFactoryDef;
      },
      configurable: !!ngDevMode
    });
    Object.defineProperty(type, NG_PIPE_DEF, {
      get: () => {
        if (ngPipeDef === null) {
          const metadata = getPipeMetadata(type, meta);
          const compiler = getCompilerFacade({ usage: 0, kind: "pipe", type: metadata.type });
          ngPipeDef = compiler.compilePipe(angularCoreEnv, `ng:///${metadata.name}/\u0275pipe.js`, metadata);
        }
        return ngPipeDef;
      },
      configurable: !!ngDevMode
    });
  }
  function getPipeMetadata(type, meta) {
    return {
      type,
      name: type.name,
      pipeName: meta.name,
      pure: meta.pure !== void 0 ? meta.pure : true
    };
  }
  var Directive = makeDecorator("Directive", (dir = {}) => dir, void 0, void 0, (type, meta) => compileDirective(type, meta));
  var Component = makeDecorator("Component", (c = {}) => ({ changeDetection: ChangeDetectionStrategy.Default, ...c }), Directive, void 0, (type, meta) => compileComponent(type, meta));
  var Pipe = makeDecorator("Pipe", (p) => ({ pure: true, ...p }), void 0, void 0, (type, meta) => compilePipe(type, meta));
  var Input = makePropDecorator("Input", (bindingPropertyName) => ({ bindingPropertyName }));
  var Output = makePropDecorator("Output", (bindingPropertyName) => ({ bindingPropertyName }));
  var HostBinding = makePropDecorator("HostBinding", (hostPropertyName) => ({ hostPropertyName }));
  var HostListener = makePropDecorator("HostListener", (eventName, args) => ({ eventName, args }));
  var NgModule = makeDecorator("NgModule", (ngModule) => ngModule, void 0, void 0, (type, meta) => compileNgModule(type, meta));
  function noop2(...args) {
  }
  var APP_INITIALIZER = new InjectionToken("Application Initializer");
  var ApplicationInitStatus = class {
    constructor(appInits) {
      this.appInits = appInits;
      this.resolve = noop2;
      this.reject = noop2;
      this.initialized = false;
      this.done = false;
      this.donePromise = new Promise((res, rej) => {
        this.resolve = res;
        this.reject = rej;
      });
    }
    runInitializers() {
      if (this.initialized) {
        return;
      }
      const asyncInitPromises = [];
      const complete = () => {
        this.done = true;
        this.resolve();
      };
      if (this.appInits) {
        for (let i = 0; i < this.appInits.length; i++) {
          const initResult = this.appInits[i]();
          if (isPromise2(initResult)) {
            asyncInitPromises.push(initResult);
          } else if (isObservable(initResult)) {
            const observableAsPromise = new Promise((resolve, reject) => {
              initResult.subscribe({ complete: resolve, error: reject });
            });
            asyncInitPromises.push(observableAsPromise);
          }
        }
      }
      Promise.all(asyncInitPromises).then(() => {
        complete();
      }).catch((e) => {
        this.reject(e);
      });
      if (asyncInitPromises.length === 0) {
        complete();
      }
      this.initialized = true;
    }
  };
  ApplicationInitStatus.\u0275fac = function ApplicationInitStatus_Factory(t) {
    return new (t || ApplicationInitStatus)(\u0275\u0275inject(APP_INITIALIZER, 8));
  };
  ApplicationInitStatus.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: ApplicationInitStatus, factory: ApplicationInitStatus.\u0275fac });
  (function() {
    (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationInitStatus, [{
      type: Injectable
    }], function() {
      return [{ type: void 0, decorators: [{
        type: Inject,
        args: [APP_INITIALIZER]
      }, {
        type: Optional
      }] }];
    }, null);
  })();
  var APP_ID = new InjectionToken("AppId");
  function _appIdRandomProviderFactory() {
    return `${_randomChar()}${_randomChar()}${_randomChar()}`;
  }
  var APP_ID_RANDOM_PROVIDER = {
    provide: APP_ID,
    useFactory: _appIdRandomProviderFactory,
    deps: []
  };
  function _randomChar() {
    return String.fromCharCode(97 + Math.floor(Math.random() * 25));
  }
  var PLATFORM_INITIALIZER = new InjectionToken("Platform Initializer");
  var PLATFORM_ID = new InjectionToken("Platform ID");
  var APP_BOOTSTRAP_LISTENER = new InjectionToken("appBootstrapListener");
  var PACKAGE_ROOT_URL = new InjectionToken("Application Packages Root URL");
  var Console = class {
    log(message) {
      console.log(message);
    }
    warn(message) {
      console.warn(message);
    }
  };
  Console.\u0275fac = function Console_Factory(t) {
    return new (t || Console)();
  };
  Console.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: Console, factory: Console.\u0275fac });
  (function() {
    (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Console, [{
      type: Injectable
    }], null, null);
  })();
  var LOCALE_ID = new InjectionToken("LocaleId");
  var DEFAULT_CURRENCY_CODE = new InjectionToken("DefaultCurrencyCode");
  var TRANSLATIONS = new InjectionToken("Translations");
  var TRANSLATIONS_FORMAT = new InjectionToken("TranslationsFormat");
  var MissingTranslationStrategy;
  (function(MissingTranslationStrategy3) {
    MissingTranslationStrategy3[MissingTranslationStrategy3["Error"] = 0] = "Error";
    MissingTranslationStrategy3[MissingTranslationStrategy3["Warning"] = 1] = "Warning";
    MissingTranslationStrategy3[MissingTranslationStrategy3["Ignore"] = 2] = "Ignore";
  })(MissingTranslationStrategy || (MissingTranslationStrategy = {}));
  var ModuleWithComponentFactories = class {
    constructor(ngModuleFactory, componentFactories) {
      this.ngModuleFactory = ngModuleFactory;
      this.componentFactories = componentFactories;
    }
  };
  var Compiler = class {
    compileModuleSync(moduleType) {
      return new NgModuleFactory(moduleType);
    }
    compileModuleAsync(moduleType) {
      return Promise.resolve(this.compileModuleSync(moduleType));
    }
    compileModuleAndAllComponentsSync(moduleType) {
      const ngModuleFactory = this.compileModuleSync(moduleType);
      const moduleDef = getNgModuleDef(moduleType);
      const componentFactories = maybeUnwrapFn(moduleDef.declarations).reduce((factories, declaration) => {
        const componentDef = getComponentDef(declaration);
        componentDef && factories.push(new ComponentFactory(componentDef));
        return factories;
      }, []);
      return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);
    }
    compileModuleAndAllComponentsAsync(moduleType) {
      return Promise.resolve(this.compileModuleAndAllComponentsSync(moduleType));
    }
    clearCache() {
    }
    clearCacheFor(type) {
    }
    getModuleId(moduleType) {
      return void 0;
    }
  };
  Compiler.\u0275fac = function Compiler_Factory(t) {
    return new (t || Compiler)();
  };
  Compiler.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: Compiler, factory: Compiler.\u0275fac });
  (function() {
    (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Compiler, [{
      type: Injectable
    }], null, null);
  })();
  var COMPILER_OPTIONS = new InjectionToken("compilerOptions");
  var CompilerFactory = class {
  };
  var promise = (() => Promise.resolve(0))();
  function scheduleMicroTask(fn2) {
    if (typeof Zone === "undefined") {
      promise.then(() => {
        fn2 && fn2.apply(null, null);
      });
    } else {
      Zone.current.scheduleMicroTask("scheduleMicrotask", fn2);
    }
  }
  function getNativeRequestAnimationFrame() {
    let nativeRequestAnimationFrame = _global2["requestAnimationFrame"];
    let nativeCancelAnimationFrame = _global2["cancelAnimationFrame"];
    if (typeof Zone !== "undefined" && nativeRequestAnimationFrame && nativeCancelAnimationFrame) {
      const unpatchedRequestAnimationFrame = nativeRequestAnimationFrame[Zone.__symbol__("OriginalDelegate")];
      if (unpatchedRequestAnimationFrame) {
        nativeRequestAnimationFrame = unpatchedRequestAnimationFrame;
      }
      const unpatchedCancelAnimationFrame = nativeCancelAnimationFrame[Zone.__symbol__("OriginalDelegate")];
      if (unpatchedCancelAnimationFrame) {
        nativeCancelAnimationFrame = unpatchedCancelAnimationFrame;
      }
    }
    return { nativeRequestAnimationFrame, nativeCancelAnimationFrame };
  }
  var NgZone = class {
    constructor({ enableLongStackTrace = false, shouldCoalesceEventChangeDetection = false, shouldCoalesceRunChangeDetection = false }) {
      this.hasPendingMacrotasks = false;
      this.hasPendingMicrotasks = false;
      this.isStable = true;
      this.onUnstable = new EventEmitter(false);
      this.onMicrotaskEmpty = new EventEmitter(false);
      this.onStable = new EventEmitter(false);
      this.onError = new EventEmitter(false);
      if (typeof Zone == "undefined") {
        throw new Error(`In this configuration Angular requires Zone.js`);
      }
      Zone.assertZonePatched();
      const self2 = this;
      self2._nesting = 0;
      self2._outer = self2._inner = Zone.current;
      if (Zone["TaskTrackingZoneSpec"]) {
        self2._inner = self2._inner.fork(new Zone["TaskTrackingZoneSpec"]());
      }
      if (enableLongStackTrace && Zone["longStackTraceZoneSpec"]) {
        self2._inner = self2._inner.fork(Zone["longStackTraceZoneSpec"]);
      }
      self2.shouldCoalesceEventChangeDetection = !shouldCoalesceRunChangeDetection && shouldCoalesceEventChangeDetection;
      self2.shouldCoalesceRunChangeDetection = shouldCoalesceRunChangeDetection;
      self2.lastRequestAnimationFrameId = -1;
      self2.nativeRequestAnimationFrame = getNativeRequestAnimationFrame().nativeRequestAnimationFrame;
      forkInnerZoneWithAngularBehavior(self2);
    }
    static isInAngularZone() {
      return Zone.current.get("isAngularZone") === true;
    }
    static assertInAngularZone() {
      if (!NgZone.isInAngularZone()) {
        throw new Error("Expected to be in Angular Zone, but it is not!");
      }
    }
    static assertNotInAngularZone() {
      if (NgZone.isInAngularZone()) {
        throw new Error("Expected to not be in Angular Zone, but it is!");
      }
    }
    run(fn2, applyThis, applyArgs) {
      return this._inner.run(fn2, applyThis, applyArgs);
    }
    runTask(fn2, applyThis, applyArgs, name) {
      const zone = this._inner;
      const task = zone.scheduleEventTask("NgZoneEvent: " + name, fn2, EMPTY_PAYLOAD, noop2, noop2);
      try {
        return zone.runTask(task, applyThis, applyArgs);
      } finally {
        zone.cancelTask(task);
      }
    }
    runGuarded(fn2, applyThis, applyArgs) {
      return this._inner.runGuarded(fn2, applyThis, applyArgs);
    }
    runOutsideAngular(fn2) {
      return this._outer.run(fn2);
    }
  };
  var EMPTY_PAYLOAD = {};
  function checkStable(zone) {
    if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {
      try {
        zone._nesting++;
        zone.onMicrotaskEmpty.emit(null);
      } finally {
        zone._nesting--;
        if (!zone.hasPendingMicrotasks) {
          try {
            zone.runOutsideAngular(() => zone.onStable.emit(null));
          } finally {
            zone.isStable = true;
          }
        }
      }
    }
  }
  function delayChangeDetectionForEvents(zone) {
    if (zone.isCheckStableRunning || zone.lastRequestAnimationFrameId !== -1) {
      return;
    }
    zone.lastRequestAnimationFrameId = zone.nativeRequestAnimationFrame.call(_global2, () => {
      if (!zone.fakeTopEventTask) {
        zone.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => {
          zone.lastRequestAnimationFrameId = -1;
          updateMicroTaskStatus(zone);
          zone.isCheckStableRunning = true;
          checkStable(zone);
          zone.isCheckStableRunning = false;
        }, void 0, () => {
        }, () => {
        });
      }
      zone.fakeTopEventTask.invoke();
    });
    updateMicroTaskStatus(zone);
  }
  function forkInnerZoneWithAngularBehavior(zone) {
    const delayChangeDetectionForEventsDelegate = () => {
      delayChangeDetectionForEvents(zone);
    };
    zone._inner = zone._inner.fork({
      name: "angular",
      properties: { "isAngularZone": true },
      onInvokeTask: (delegate, current, target, task, applyThis, applyArgs) => {
        try {
          onEnter(zone);
          return delegate.invokeTask(target, task, applyThis, applyArgs);
        } finally {
          if (zone.shouldCoalesceEventChangeDetection && task.type === "eventTask" || zone.shouldCoalesceRunChangeDetection) {
            delayChangeDetectionForEventsDelegate();
          }
          onLeave(zone);
        }
      },
      onInvoke: (delegate, current, target, callback, applyThis, applyArgs, source) => {
        try {
          onEnter(zone);
          return delegate.invoke(target, callback, applyThis, applyArgs, source);
        } finally {
          if (zone.shouldCoalesceRunChangeDetection) {
            delayChangeDetectionForEventsDelegate();
          }
          onLeave(zone);
        }
      },
      onHasTask: (delegate, current, target, hasTaskState) => {
        delegate.hasTask(target, hasTaskState);
        if (current === target) {
          if (hasTaskState.change == "microTask") {
            zone._hasPendingMicrotasks = hasTaskState.microTask;
            updateMicroTaskStatus(zone);
            checkStable(zone);
          } else if (hasTaskState.change == "macroTask") {
            zone.hasPendingMacrotasks = hasTaskState.macroTask;
          }
        }
      },
      onHandleError: (delegate, current, target, error3) => {
        delegate.handleError(target, error3);
        zone.runOutsideAngular(() => zone.onError.emit(error3));
        return false;
      }
    });
  }
  function updateMicroTaskStatus(zone) {
    if (zone._hasPendingMicrotasks || (zone.shouldCoalesceEventChangeDetection || zone.shouldCoalesceRunChangeDetection) && zone.lastRequestAnimationFrameId !== -1) {
      zone.hasPendingMicrotasks = true;
    } else {
      zone.hasPendingMicrotasks = false;
    }
  }
  function onEnter(zone) {
    zone._nesting++;
    if (zone.isStable) {
      zone.isStable = false;
      zone.onUnstable.emit(null);
    }
  }
  function onLeave(zone) {
    zone._nesting--;
    checkStable(zone);
  }
  var NoopNgZone = class {
    constructor() {
      this.hasPendingMicrotasks = false;
      this.hasPendingMacrotasks = false;
      this.isStable = true;
      this.onUnstable = new EventEmitter();
      this.onMicrotaskEmpty = new EventEmitter();
      this.onStable = new EventEmitter();
      this.onError = new EventEmitter();
    }
    run(fn2, applyThis, applyArgs) {
      return fn2.apply(applyThis, applyArgs);
    }
    runGuarded(fn2, applyThis, applyArgs) {
      return fn2.apply(applyThis, applyArgs);
    }
    runOutsideAngular(fn2) {
      return fn2();
    }
    runTask(fn2, applyThis, applyArgs, name) {
      return fn2.apply(applyThis, applyArgs);
    }
  };
  var Testability = class {
    constructor(_ngZone) {
      this._ngZone = _ngZone;
      this._pendingCount = 0;
      this._isZoneStable = true;
      this._didWork = false;
      this._callbacks = [];
      this.taskTrackingZone = null;
      this._watchAngularEvents();
      _ngZone.run(() => {
        this.taskTrackingZone = typeof Zone == "undefined" ? null : Zone.current.get("TaskTrackingZone");
      });
    }
    _watchAngularEvents() {
      this._ngZone.onUnstable.subscribe({
        next: () => {
          this._didWork = true;
          this._isZoneStable = false;
        }
      });
      this._ngZone.runOutsideAngular(() => {
        this._ngZone.onStable.subscribe({
          next: () => {
            NgZone.assertNotInAngularZone();
            scheduleMicroTask(() => {
              this._isZoneStable = true;
              this._runCallbacksIfReady();
            });
          }
        });
      });
    }
    increasePendingRequestCount() {
      this._pendingCount += 1;
      this._didWork = true;
      return this._pendingCount;
    }
    decreasePendingRequestCount() {
      this._pendingCount -= 1;
      if (this._pendingCount < 0) {
        throw new Error("pending async requests below zero");
      }
      this._runCallbacksIfReady();
      return this._pendingCount;
    }
    isStable() {
      return this._isZoneStable && this._pendingCount === 0 && !this._ngZone.hasPendingMacrotasks;
    }
    _runCallbacksIfReady() {
      if (this.isStable()) {
        scheduleMicroTask(() => {
          while (this._callbacks.length !== 0) {
            let cb = this._callbacks.pop();
            clearTimeout(cb.timeoutId);
            cb.doneCb(this._didWork);
          }
          this._didWork = false;
        });
      } else {
        let pending = this.getPendingTasks();
        this._callbacks = this._callbacks.filter((cb) => {
          if (cb.updateCb && cb.updateCb(pending)) {
            clearTimeout(cb.timeoutId);
            return false;
          }
          return true;
        });
        this._didWork = true;
      }
    }
    getPendingTasks() {
      if (!this.taskTrackingZone) {
        return [];
      }
      return this.taskTrackingZone.macroTasks.map((t) => {
        return {
          source: t.source,
          creationLocation: t.creationLocation,
          data: t.data
        };
      });
    }
    addCallback(cb, timeout, updateCb) {
      let timeoutId = -1;
      if (timeout && timeout > 0) {
        timeoutId = setTimeout(() => {
          this._callbacks = this._callbacks.filter((cb2) => cb2.timeoutId !== timeoutId);
          cb(this._didWork, this.getPendingTasks());
        }, timeout);
      }
      this._callbacks.push({ doneCb: cb, timeoutId, updateCb });
    }
    whenStable(doneCb, timeout, updateCb) {
      if (updateCb && !this.taskTrackingZone) {
        throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');
      }
      this.addCallback(doneCb, timeout, updateCb);
      this._runCallbacksIfReady();
    }
    getPendingRequestCount() {
      return this._pendingCount;
    }
    findProviders(using, provider, exactMatch) {
      return [];
    }
  };
  Testability.\u0275fac = function Testability_Factory(t) {
    return new (t || Testability)(\u0275\u0275inject(NgZone));
  };
  Testability.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: Testability, factory: Testability.\u0275fac });
  (function() {
    (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Testability, [{
      type: Injectable
    }], function() {
      return [{ type: NgZone }];
    }, null);
  })();
  var TestabilityRegistry = class {
    constructor() {
      this._applications = /* @__PURE__ */ new Map();
      _testabilityGetter.addToWindow(this);
    }
    registerApplication(token, testability) {
      this._applications.set(token, testability);
    }
    unregisterApplication(token) {
      this._applications.delete(token);
    }
    unregisterAllApplications() {
      this._applications.clear();
    }
    getTestability(elem) {
      return this._applications.get(elem) || null;
    }
    getAllTestabilities() {
      return Array.from(this._applications.values());
    }
    getAllRootElements() {
      return Array.from(this._applications.keys());
    }
    findTestabilityInTree(elem, findInAncestors = true) {
      return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);
    }
  };
  TestabilityRegistry.\u0275fac = function TestabilityRegistry_Factory(t) {
    return new (t || TestabilityRegistry)();
  };
  TestabilityRegistry.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: TestabilityRegistry, factory: TestabilityRegistry.\u0275fac });
  (function() {
    (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TestabilityRegistry, [{
      type: Injectable
    }], function() {
      return [];
    }, null);
  })();
  var _NoopGetTestability = class {
    addToWindow(registry) {
    }
    findTestabilityInTree(registry, elem, findInAncestors) {
      return null;
    }
  };
  function setTestabilityGetter(getter) {
    _testabilityGetter = getter;
  }
  var _testabilityGetter = new _NoopGetTestability();
  var _platform;
  function compileNgModuleFactory(injector, options, moduleType) {
    ngDevMode && assertNgModuleType(moduleType);
    const moduleFactory = new NgModuleFactory(moduleType);
    if (typeof ngJitMode !== "undefined" && !ngJitMode) {
      return Promise.resolve(moduleFactory);
    }
    const compilerOptions = injector.get(COMPILER_OPTIONS, []).concat(options);
    setJitOptions({
      defaultEncapsulation: _lastDefined(compilerOptions.map((opts) => opts.defaultEncapsulation)),
      preserveWhitespaces: _lastDefined(compilerOptions.map((opts) => opts.preserveWhitespaces))
    });
    if (isComponentResourceResolutionQueueEmpty()) {
      return Promise.resolve(moduleFactory);
    }
    const compilerProviders = _mergeArrays(compilerOptions.map((o) => o.providers));
    if (compilerProviders.length === 0) {
      return Promise.resolve(moduleFactory);
    }
    const compiler = getCompilerFacade({
      usage: 0,
      kind: "NgModule",
      type: moduleType
    });
    const compilerInjector = Injector.create({ providers: compilerProviders });
    const resourceLoader = compilerInjector.get(compiler.ResourceLoader);
    return resolveComponentResources((url) => Promise.resolve(resourceLoader.get(url))).then(() => moduleFactory);
  }
  function publishDefaultGlobalUtils() {
    ngDevMode && publishDefaultGlobalUtils$1();
  }
  function isBoundToModule(cf) {
    return cf.isBoundToModule;
  }
  var ALLOW_MULTIPLE_PLATFORMS = new InjectionToken("AllowMultipleToken");
  var NgProbeToken = class {
    constructor(name, token) {
      this.name = name;
      this.token = token;
    }
  };
  function createPlatform(injector) {
    if (_platform && !_platform.destroyed && !_platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
      const errorMessage = typeof ngDevMode === "undefined" || ngDevMode ? "There can be only one platform. Destroy the previous one to create a new one." : "";
      throw new RuntimeError("400", errorMessage);
    }
    publishDefaultGlobalUtils();
    _platform = injector.get(PlatformRef);
    const inits = injector.get(PLATFORM_INITIALIZER, null);
    if (inits)
      inits.forEach((init) => init());
    return _platform;
  }
  function createPlatformFactory(parentPlatformFactory, name, providers = []) {
    const desc = `Platform: ${name}`;
    const marker = new InjectionToken(desc);
    return (extraProviders = []) => {
      let platform = getPlatform();
      if (!platform || platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
        if (parentPlatformFactory) {
          parentPlatformFactory(providers.concat(extraProviders).concat({ provide: marker, useValue: true }));
        } else {
          const injectedProviders = providers.concat(extraProviders).concat({ provide: marker, useValue: true }, {
            provide: INJECTOR_SCOPE,
            useValue: "platform"
          });
          createPlatform(Injector.create({ providers: injectedProviders, name: desc }));
        }
      }
      return assertPlatform(marker);
    };
  }
  function assertPlatform(requiredToken) {
    const platform = getPlatform();
    if (!platform) {
      const errorMessage = typeof ngDevMode === "undefined" || ngDevMode ? "No platform exists!" : "";
      throw new RuntimeError("401", errorMessage);
    }
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !platform.injector.get(requiredToken, null)) {
      throw new RuntimeError("400", "A platform with a different configuration has been created. Please destroy it first.");
    }
    return platform;
  }
  function destroyPlatform() {
    if (_platform && !_platform.destroyed) {
      _platform.destroy();
    }
  }
  function getPlatform() {
    return _platform && !_platform.destroyed ? _platform : null;
  }
  var PlatformRef = class {
    constructor(_injector) {
      this._injector = _injector;
      this._modules = [];
      this._destroyListeners = [];
      this._destroyed = false;
    }
    bootstrapModuleFactory(moduleFactory, options) {
      const ngZoneOption = options ? options.ngZone : void 0;
      const ngZoneEventCoalescing = options && options.ngZoneEventCoalescing || false;
      const ngZoneRunCoalescing = options && options.ngZoneRunCoalescing || false;
      const ngZone = getNgZone(ngZoneOption, { ngZoneEventCoalescing, ngZoneRunCoalescing });
      const providers = [{ provide: NgZone, useValue: ngZone }];
      return ngZone.run(() => {
        const ngZoneInjector = Injector.create({ providers, parent: this.injector, name: moduleFactory.moduleType.name });
        const moduleRef = moduleFactory.create(ngZoneInjector);
        const exceptionHandler = moduleRef.injector.get(ErrorHandler, null);
        if (!exceptionHandler) {
          const errorMessage = typeof ngDevMode === "undefined" || ngDevMode ? "No ErrorHandler. Is platform module (BrowserModule) included?" : "";
          throw new RuntimeError("402", errorMessage);
        }
        ngZone.runOutsideAngular(() => {
          const subscription = ngZone.onError.subscribe({
            next: (error3) => {
              exceptionHandler.handleError(error3);
            }
          });
          moduleRef.onDestroy(() => {
            remove(this._modules, moduleRef);
            subscription.unsubscribe();
          });
        });
        return _callAndReportToErrorHandler(exceptionHandler, ngZone, () => {
          const initStatus = moduleRef.injector.get(ApplicationInitStatus);
          initStatus.runInitializers();
          return initStatus.donePromise.then(() => {
            const localeId = moduleRef.injector.get(LOCALE_ID, DEFAULT_LOCALE_ID);
            setLocaleId(localeId || DEFAULT_LOCALE_ID);
            this._moduleDoBootstrap(moduleRef);
            return moduleRef;
          });
        });
      });
    }
    bootstrapModule(moduleType, compilerOptions = []) {
      const options = optionsReducer({}, compilerOptions);
      return compileNgModuleFactory(this.injector, options, moduleType).then((moduleFactory) => this.bootstrapModuleFactory(moduleFactory, options));
    }
    _moduleDoBootstrap(moduleRef) {
      const appRef = moduleRef.injector.get(ApplicationRef);
      if (moduleRef._bootstrapComponents.length > 0) {
        moduleRef._bootstrapComponents.forEach((f) => appRef.bootstrap(f));
      } else if (moduleRef.instance.ngDoBootstrap) {
        moduleRef.instance.ngDoBootstrap(appRef);
      } else {
        const errorMessage = typeof ngDevMode === "undefined" || ngDevMode ? `The module ${stringify(moduleRef.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.` : "";
        throw new RuntimeError("403", errorMessage);
      }
      this._modules.push(moduleRef);
    }
    onDestroy(callback) {
      this._destroyListeners.push(callback);
    }
    get injector() {
      return this._injector;
    }
    destroy() {
      if (this._destroyed) {
        const errorMessage = typeof ngDevMode === "undefined" || ngDevMode ? "The platform has already been destroyed!" : "";
        throw new RuntimeError("404", errorMessage);
      }
      this._modules.slice().forEach((module) => module.destroy());
      this._destroyListeners.forEach((listener) => listener());
      this._destroyed = true;
    }
    get destroyed() {
      return this._destroyed;
    }
  };
  PlatformRef.\u0275fac = function PlatformRef_Factory(t) {
    return new (t || PlatformRef)(\u0275\u0275inject(Injector));
  };
  PlatformRef.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: PlatformRef, factory: PlatformRef.\u0275fac });
  (function() {
    (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlatformRef, [{
      type: Injectable
    }], function() {
      return [{ type: Injector }];
    }, null);
  })();
  function getNgZone(ngZoneOption, extra) {
    let ngZone;
    if (ngZoneOption === "noop") {
      ngZone = new NoopNgZone();
    } else {
      ngZone = (ngZoneOption === "zone.js" ? void 0 : ngZoneOption) || new NgZone({
        enableLongStackTrace: typeof ngDevMode === "undefined" ? false : !!ngDevMode,
        shouldCoalesceEventChangeDetection: !!extra?.ngZoneEventCoalescing,
        shouldCoalesceRunChangeDetection: !!extra?.ngZoneRunCoalescing
      });
    }
    return ngZone;
  }
  function _callAndReportToErrorHandler(errorHandler2, ngZone, callback) {
    try {
      const result = callback();
      if (isPromise2(result)) {
        return result.catch((e) => {
          ngZone.runOutsideAngular(() => errorHandler2.handleError(e));
          throw e;
        });
      }
      return result;
    } catch (e) {
      ngZone.runOutsideAngular(() => errorHandler2.handleError(e));
      throw e;
    }
  }
  function optionsReducer(dst, objs) {
    if (Array.isArray(objs)) {
      dst = objs.reduce(optionsReducer, dst);
    } else {
      dst = { ...dst, ...objs };
    }
    return dst;
  }
  var ApplicationRef = class {
    constructor(_zone, _injector, _exceptionHandler, _componentFactoryResolver, _initStatus) {
      this._zone = _zone;
      this._injector = _injector;
      this._exceptionHandler = _exceptionHandler;
      this._componentFactoryResolver = _componentFactoryResolver;
      this._initStatus = _initStatus;
      this._bootstrapListeners = [];
      this._views = [];
      this._runningTick = false;
      this._stable = true;
      this.componentTypes = [];
      this.components = [];
      this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({
        next: () => {
          this._zone.run(() => {
            this.tick();
          });
        }
      });
      const isCurrentlyStable = new Observable((observer) => {
        this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks;
        this._zone.runOutsideAngular(() => {
          observer.next(this._stable);
          observer.complete();
        });
      });
      const isStable = new Observable((observer) => {
        let stableSub;
        this._zone.runOutsideAngular(() => {
          stableSub = this._zone.onStable.subscribe(() => {
            NgZone.assertNotInAngularZone();
            scheduleMicroTask(() => {
              if (!this._stable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks) {
                this._stable = true;
                observer.next(true);
              }
            });
          });
        });
        const unstableSub = this._zone.onUnstable.subscribe(() => {
          NgZone.assertInAngularZone();
          if (this._stable) {
            this._stable = false;
            this._zone.runOutsideAngular(() => {
              observer.next(false);
            });
          }
        });
        return () => {
          stableSub.unsubscribe();
          unstableSub.unsubscribe();
        };
      });
      this.isStable = merge(isCurrentlyStable, isStable.pipe(share()));
    }
    bootstrap(componentOrFactory, rootSelectorOrNode) {
      if (!this._initStatus.done) {
        const errorMessage = typeof ngDevMode === "undefined" || ngDevMode ? "Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module." : "";
        throw new RuntimeError("405", errorMessage);
      }
      let componentFactory;
      if (componentOrFactory instanceof ComponentFactory$1) {
        componentFactory = componentOrFactory;
      } else {
        componentFactory = this._componentFactoryResolver.resolveComponentFactory(componentOrFactory);
      }
      this.componentTypes.push(componentFactory.componentType);
      const ngModule = isBoundToModule(componentFactory) ? void 0 : this._injector.get(NgModuleRef$1);
      const selectorOrNode = rootSelectorOrNode || componentFactory.selector;
      const compRef = componentFactory.create(Injector.NULL, [], selectorOrNode, ngModule);
      const nativeElement = compRef.location.nativeElement;
      const testability = compRef.injector.get(Testability, null);
      const testabilityRegistry = testability && compRef.injector.get(TestabilityRegistry);
      if (testability && testabilityRegistry) {
        testabilityRegistry.registerApplication(nativeElement, testability);
      }
      compRef.onDestroy(() => {
        this.detachView(compRef.hostView);
        remove(this.components, compRef);
        if (testabilityRegistry) {
          testabilityRegistry.unregisterApplication(nativeElement);
        }
      });
      this._loadComponent(compRef);
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        const _console = this._injector.get(Console);
        _console.log(`Angular is running in development mode. Call enableProdMode() to enable production mode.`);
      }
      return compRef;
    }
    tick() {
      if (this._runningTick) {
        const errorMessage = typeof ngDevMode === "undefined" || ngDevMode ? "ApplicationRef.tick is called recursively" : "";
        throw new RuntimeError("101", errorMessage);
      }
      try {
        this._runningTick = true;
        for (let view of this._views) {
          view.detectChanges();
        }
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          for (let view of this._views) {
            view.checkNoChanges();
          }
        }
      } catch (e) {
        this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(e));
      } finally {
        this._runningTick = false;
      }
    }
    attachView(viewRef) {
      const view = viewRef;
      this._views.push(view);
      view.attachToAppRef(this);
    }
    detachView(viewRef) {
      const view = viewRef;
      remove(this._views, view);
      view.detachFromAppRef();
    }
    _loadComponent(componentRef) {
      this.attachView(componentRef.hostView);
      this.tick();
      this.components.push(componentRef);
      const listeners = this._injector.get(APP_BOOTSTRAP_LISTENER, []).concat(this._bootstrapListeners);
      listeners.forEach((listener) => listener(componentRef));
    }
    ngOnDestroy() {
      this._views.slice().forEach((view) => view.destroy());
      this._onMicrotaskEmptySubscription.unsubscribe();
    }
    get viewCount() {
      return this._views.length;
    }
  };
  ApplicationRef.\u0275fac = function ApplicationRef_Factory(t) {
    return new (t || ApplicationRef)(\u0275\u0275inject(NgZone), \u0275\u0275inject(Injector), \u0275\u0275inject(ErrorHandler), \u0275\u0275inject(ComponentFactoryResolver$1), \u0275\u0275inject(ApplicationInitStatus));
  };
  ApplicationRef.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: ApplicationRef, factory: ApplicationRef.\u0275fac });
  (function() {
    (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationRef, [{
      type: Injectable
    }], function() {
      return [{ type: NgZone }, { type: Injector }, { type: ErrorHandler }, { type: ComponentFactoryResolver$1 }, { type: ApplicationInitStatus }];
    }, null);
  })();
  function remove(list, el) {
    const index = list.indexOf(el);
    if (index > -1) {
      list.splice(index, 1);
    }
  }
  function _lastDefined(args) {
    for (let i = args.length - 1; i >= 0; i--) {
      if (args[i] !== void 0) {
        return args[i];
      }
    }
    return void 0;
  }
  function _mergeArrays(parts) {
    const result = [];
    parts.forEach((part) => part && result.push(...part));
    return result;
  }
  var _devMode = true;
  var _runModeLocked = false;
  function isDevMode() {
    _runModeLocked = true;
    return _devMode;
  }
  function enableProdMode() {
    if (_runModeLocked) {
      throw new Error("Cannot enable prod mode after platform setup.");
    }
    if (typeof ngDevMode === void 0 || !!ngDevMode) {
      _global2["ngDevMode"] = false;
    }
    _devMode = false;
  }
  function getModuleFactory(id) {
    const type = getRegisteredNgModuleType(id);
    if (!type)
      throw noModuleError(id);
    return new NgModuleFactory(type);
  }
  function getNgModuleById(id) {
    const type = getRegisteredNgModuleType(id);
    if (!type)
      throw noModuleError(id);
    return type;
  }
  function noModuleError(id) {
    return new Error(`No module with ID ${id} loaded`);
  }
  var ChangeDetectorRef = class {
  };
  ChangeDetectorRef.__NG_ELEMENT_ID__ = injectChangeDetectorRef;
  function injectChangeDetectorRef(flags) {
    return createViewRef(getCurrentTNode(), getLView(), (flags & 16) === 16);
  }
  function createViewRef(tNode, lView, isPipe) {
    if (isComponentHost(tNode) && !isPipe) {
      const componentView = getComponentLViewByIndex(tNode.index, lView);
      return new ViewRef$1(componentView, componentView);
    } else if (tNode.type & (3 | 12 | 32)) {
      const hostComponentView = lView[DECLARATION_COMPONENT_VIEW];
      return new ViewRef$1(hostComponentView, lView);
    }
    return null;
  }
  var ViewRef = class extends ChangeDetectorRef {
  };
  var EmbeddedViewRef = class extends ViewRef {
  };
  var DebugEventListener = class {
    constructor(name, callback) {
      this.name = name;
      this.callback = callback;
    }
  };
  function asNativeElements(debugEls) {
    return debugEls.map((el) => el.nativeElement);
  }
  var DebugNode__POST_R3__ = class {
    constructor(nativeNode) {
      this.nativeNode = nativeNode;
    }
    get parent() {
      const parent = this.nativeNode.parentNode;
      return parent ? new DebugElement__POST_R3__(parent) : null;
    }
    get injector() {
      return getInjector(this.nativeNode);
    }
    get componentInstance() {
      const nativeElement = this.nativeNode;
      return nativeElement && (getComponent$1(nativeElement) || getOwningComponent(nativeElement));
    }
    get context() {
      return getComponent$1(this.nativeNode) || getContext(this.nativeNode);
    }
    get listeners() {
      return getListeners(this.nativeNode).filter((listener) => listener.type === "dom");
    }
    get references() {
      return getLocalRefs(this.nativeNode);
    }
    get providerTokens() {
      return getInjectionTokens(this.nativeNode);
    }
  };
  var DebugElement__POST_R3__ = class extends DebugNode__POST_R3__ {
    constructor(nativeNode) {
      ngDevMode && assertDomNode(nativeNode);
      super(nativeNode);
    }
    get nativeElement() {
      return this.nativeNode.nodeType == Node.ELEMENT_NODE ? this.nativeNode : null;
    }
    get name() {
      const context2 = getLContext(this.nativeNode);
      if (context2 !== null) {
        const lView = context2.lView;
        const tData = lView[TVIEW].data;
        const tNode = tData[context2.nodeIndex];
        return tNode.value;
      } else {
        return this.nativeNode.nodeName;
      }
    }
    get properties() {
      const context2 = getLContext(this.nativeNode);
      if (context2 === null) {
        return {};
      }
      const lView = context2.lView;
      const tData = lView[TVIEW].data;
      const tNode = tData[context2.nodeIndex];
      const properties = {};
      copyDomProperties(this.nativeElement, properties);
      collectPropertyBindings(properties, tNode, lView, tData);
      return properties;
    }
    get attributes() {
      const attributes = {};
      const element = this.nativeElement;
      if (!element) {
        return attributes;
      }
      const context2 = getLContext(element);
      if (context2 === null) {
        return {};
      }
      const lView = context2.lView;
      const tNodeAttrs = lView[TVIEW].data[context2.nodeIndex].attrs;
      const lowercaseTNodeAttrs = [];
      if (tNodeAttrs) {
        let i = 0;
        while (i < tNodeAttrs.length) {
          const attrName = tNodeAttrs[i];
          if (typeof attrName !== "string")
            break;
          const attrValue = tNodeAttrs[i + 1];
          attributes[attrName] = attrValue;
          lowercaseTNodeAttrs.push(attrName.toLowerCase());
          i += 2;
        }
      }
      const eAttrs = element.attributes;
      for (let i = 0; i < eAttrs.length; i++) {
        const attr = eAttrs[i];
        const lowercaseName = attr.name.toLowerCase();
        if (lowercaseTNodeAttrs.indexOf(lowercaseName) === -1) {
          attributes[lowercaseName] = attr.value;
        }
      }
      return attributes;
    }
    get styles() {
      if (this.nativeElement && this.nativeElement.style) {
        return this.nativeElement.style;
      }
      return {};
    }
    get classes() {
      const result = {};
      const element = this.nativeElement;
      const className = element.className;
      const classes = typeof className !== "string" ? className.baseVal.split(" ") : className.split(" ");
      classes.forEach((value) => result[value] = true);
      return result;
    }
    get childNodes() {
      const childNodes = this.nativeNode.childNodes;
      const children = [];
      for (let i = 0; i < childNodes.length; i++) {
        const element = childNodes[i];
        children.push(getDebugNode__POST_R3__(element));
      }
      return children;
    }
    get children() {
      const nativeElement = this.nativeElement;
      if (!nativeElement)
        return [];
      const childNodes = nativeElement.children;
      const children = [];
      for (let i = 0; i < childNodes.length; i++) {
        const element = childNodes[i];
        children.push(getDebugNode__POST_R3__(element));
      }
      return children;
    }
    query(predicate) {
      const results = this.queryAll(predicate);
      return results[0] || null;
    }
    queryAll(predicate) {
      const matches = [];
      _queryAllR3(this, predicate, matches, true);
      return matches;
    }
    queryAllNodes(predicate) {
      const matches = [];
      _queryAllR3(this, predicate, matches, false);
      return matches;
    }
    triggerEventHandler(eventName, eventObj) {
      const node = this.nativeNode;
      const invokedListeners = [];
      this.listeners.forEach((listener) => {
        if (listener.name === eventName) {
          const callback = listener.callback;
          callback.call(node, eventObj);
          invokedListeners.push(callback);
        }
      });
      if (typeof node.eventListeners === "function") {
        node.eventListeners(eventName).forEach((listener) => {
          if (listener.toString().indexOf("__ngUnwrap__") !== -1) {
            const unwrappedListener = listener("__ngUnwrap__");
            return invokedListeners.indexOf(unwrappedListener) === -1 && unwrappedListener.call(node, eventObj);
          }
        });
      }
    }
  };
  function copyDomProperties(element, properties) {
    if (element) {
      let obj = Object.getPrototypeOf(element);
      const NodePrototype = Node.prototype;
      while (obj !== null && obj !== NodePrototype) {
        const descriptors = Object.getOwnPropertyDescriptors(obj);
        for (let key in descriptors) {
          if (!key.startsWith("__") && !key.startsWith("on")) {
            const value = element[key];
            if (isPrimitiveValue(value)) {
              properties[key] = value;
            }
          }
        }
        obj = Object.getPrototypeOf(obj);
      }
    }
  }
  function isPrimitiveValue(value) {
    return typeof value === "string" || typeof value === "boolean" || typeof value === "number" || value === null;
  }
  function _queryAllR3(parentElement, predicate, matches, elementsOnly) {
    const context2 = getLContext(parentElement.nativeNode);
    if (context2 !== null) {
      const parentTNode = context2.lView[TVIEW].data[context2.nodeIndex];
      _queryNodeChildrenR3(parentTNode, context2.lView, predicate, matches, elementsOnly, parentElement.nativeNode);
    } else {
      _queryNativeNodeDescendants(parentElement.nativeNode, predicate, matches, elementsOnly);
    }
  }
  function _queryNodeChildrenR3(tNode, lView, predicate, matches, elementsOnly, rootNativeNode) {
    ngDevMode && assertTNodeForLView(tNode, lView);
    const nativeNode = getNativeByTNodeOrNull(tNode, lView);
    if (tNode.type & (3 | 8)) {
      _addQueryMatchR3(nativeNode, predicate, matches, elementsOnly, rootNativeNode);
      if (isComponentHost(tNode)) {
        const componentView = getComponentLViewByIndex(tNode.index, lView);
        if (componentView && componentView[TVIEW].firstChild) {
          _queryNodeChildrenR3(componentView[TVIEW].firstChild, componentView, predicate, matches, elementsOnly, rootNativeNode);
        }
      } else {
        if (tNode.child) {
          _queryNodeChildrenR3(tNode.child, lView, predicate, matches, elementsOnly, rootNativeNode);
        }
        nativeNode && _queryNativeNodeDescendants(nativeNode, predicate, matches, elementsOnly);
      }
      const nodeOrContainer = lView[tNode.index];
      if (isLContainer(nodeOrContainer)) {
        _queryNodeChildrenInContainerR3(nodeOrContainer, predicate, matches, elementsOnly, rootNativeNode);
      }
    } else if (tNode.type & 4) {
      const lContainer = lView[tNode.index];
      _addQueryMatchR3(lContainer[NATIVE], predicate, matches, elementsOnly, rootNativeNode);
      _queryNodeChildrenInContainerR3(lContainer, predicate, matches, elementsOnly, rootNativeNode);
    } else if (tNode.type & 16) {
      const componentView = lView[DECLARATION_COMPONENT_VIEW];
      const componentHost = componentView[T_HOST];
      const head = componentHost.projection[tNode.projection];
      if (Array.isArray(head)) {
        for (let nativeNode2 of head) {
          _addQueryMatchR3(nativeNode2, predicate, matches, elementsOnly, rootNativeNode);
        }
      } else if (head) {
        const nextLView = componentView[PARENT];
        const nextTNode = nextLView[TVIEW].data[head.index];
        _queryNodeChildrenR3(nextTNode, nextLView, predicate, matches, elementsOnly, rootNativeNode);
      }
    } else if (tNode.child) {
      _queryNodeChildrenR3(tNode.child, lView, predicate, matches, elementsOnly, rootNativeNode);
    }
    if (rootNativeNode !== nativeNode) {
      const nextTNode = tNode.flags & 4 ? tNode.projectionNext : tNode.next;
      if (nextTNode) {
        _queryNodeChildrenR3(nextTNode, lView, predicate, matches, elementsOnly, rootNativeNode);
      }
    }
  }
  function _queryNodeChildrenInContainerR3(lContainer, predicate, matches, elementsOnly, rootNativeNode) {
    for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
      const childView = lContainer[i];
      const firstChild = childView[TVIEW].firstChild;
      if (firstChild) {
        _queryNodeChildrenR3(firstChild, childView, predicate, matches, elementsOnly, rootNativeNode);
      }
    }
  }
  function _addQueryMatchR3(nativeNode, predicate, matches, elementsOnly, rootNativeNode) {
    if (rootNativeNode !== nativeNode) {
      const debugNode = getDebugNode(nativeNode);
      if (!debugNode) {
        return;
      }
      if (elementsOnly && debugNode instanceof DebugElement__POST_R3__ && predicate(debugNode) && matches.indexOf(debugNode) === -1) {
        matches.push(debugNode);
      } else if (!elementsOnly && predicate(debugNode) && matches.indexOf(debugNode) === -1) {
        matches.push(debugNode);
      }
    }
  }
  function _queryNativeNodeDescendants(parentNode, predicate, matches, elementsOnly) {
    const nodes = parentNode.childNodes;
    const length = nodes.length;
    for (let i = 0; i < length; i++) {
      const node = nodes[i];
      const debugNode = getDebugNode(node);
      if (debugNode) {
        if (elementsOnly && debugNode instanceof DebugElement__POST_R3__ && predicate(debugNode) && matches.indexOf(debugNode) === -1) {
          matches.push(debugNode);
        } else if (!elementsOnly && predicate(debugNode) && matches.indexOf(debugNode) === -1) {
          matches.push(debugNode);
        }
        _queryNativeNodeDescendants(node, predicate, matches, elementsOnly);
      }
    }
  }
  function collectPropertyBindings(properties, tNode, lView, tData) {
    let bindingIndexes = tNode.propertyBindings;
    if (bindingIndexes !== null) {
      for (let i = 0; i < bindingIndexes.length; i++) {
        const bindingIndex = bindingIndexes[i];
        const propMetadata = tData[bindingIndex];
        const metadataParts = propMetadata.split(INTERPOLATION_DELIMITER);
        const propertyName = metadataParts[0];
        if (metadataParts.length > 1) {
          let value = metadataParts[1];
          for (let j = 1; j < metadataParts.length - 1; j++) {
            value += renderStringify(lView[bindingIndex + j - 1]) + metadataParts[j + 1];
          }
          properties[propertyName] = value;
        } else {
          properties[propertyName] = lView[bindingIndex];
        }
      }
    }
  }
  var NG_DEBUG_PROPERTY = "__ng_debug__";
  function getDebugNode__POST_R3__(nativeNode) {
    if (nativeNode instanceof Node) {
      if (!nativeNode.hasOwnProperty(NG_DEBUG_PROPERTY)) {
        nativeNode[NG_DEBUG_PROPERTY] = nativeNode.nodeType == Node.ELEMENT_NODE ? new DebugElement__POST_R3__(nativeNode) : new DebugNode__POST_R3__(nativeNode);
      }
      return nativeNode[NG_DEBUG_PROPERTY];
    }
    return null;
  }
  var getDebugNode = getDebugNode__POST_R3__;
  function getDebugNodeR2__POST_R3__(_nativeNode) {
    return null;
  }
  var getDebugNodeR2 = getDebugNodeR2__POST_R3__;
  var DebugNode = DebugNode__POST_R3__;
  var DebugElement = DebugElement__POST_R3__;
  var DefaultIterableDifferFactory = class {
    constructor() {
    }
    supports(obj) {
      return isListLikeIterable(obj);
    }
    create(trackByFn) {
      return new DefaultIterableDiffer(trackByFn);
    }
  };
  var trackByIdentity = (index, item) => item;
  var DefaultIterableDiffer = class {
    constructor(trackByFn) {
      this.length = 0;
      this._linkedRecords = null;
      this._unlinkedRecords = null;
      this._previousItHead = null;
      this._itHead = null;
      this._itTail = null;
      this._additionsHead = null;
      this._additionsTail = null;
      this._movesHead = null;
      this._movesTail = null;
      this._removalsHead = null;
      this._removalsTail = null;
      this._identityChangesHead = null;
      this._identityChangesTail = null;
      this._trackByFn = trackByFn || trackByIdentity;
    }
    forEachItem(fn2) {
      let record;
      for (record = this._itHead; record !== null; record = record._next) {
        fn2(record);
      }
    }
    forEachOperation(fn2) {
      let nextIt = this._itHead;
      let nextRemove = this._removalsHead;
      let addRemoveOffset = 0;
      let moveOffsets = null;
      while (nextIt || nextRemove) {
        const record = !nextRemove || nextIt && nextIt.currentIndex < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ? nextIt : nextRemove;
        const adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);
        const currentIndex = record.currentIndex;
        if (record === nextRemove) {
          addRemoveOffset--;
          nextRemove = nextRemove._nextRemoved;
        } else {
          nextIt = nextIt._next;
          if (record.previousIndex == null) {
            addRemoveOffset++;
          } else {
            if (!moveOffsets)
              moveOffsets = [];
            const localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;
            const localCurrentIndex = currentIndex - addRemoveOffset;
            if (localMovePreviousIndex != localCurrentIndex) {
              for (let i = 0; i < localMovePreviousIndex; i++) {
                const offset = i < moveOffsets.length ? moveOffsets[i] : moveOffsets[i] = 0;
                const index = offset + i;
                if (localCurrentIndex <= index && index < localMovePreviousIndex) {
                  moveOffsets[i] = offset + 1;
                }
              }
              const previousIndex = record.previousIndex;
              moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;
            }
          }
        }
        if (adjPreviousIndex !== currentIndex) {
          fn2(record, adjPreviousIndex, currentIndex);
        }
      }
    }
    forEachPreviousItem(fn2) {
      let record;
      for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
        fn2(record);
      }
    }
    forEachAddedItem(fn2) {
      let record;
      for (record = this._additionsHead; record !== null; record = record._nextAdded) {
        fn2(record);
      }
    }
    forEachMovedItem(fn2) {
      let record;
      for (record = this._movesHead; record !== null; record = record._nextMoved) {
        fn2(record);
      }
    }
    forEachRemovedItem(fn2) {
      let record;
      for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
        fn2(record);
      }
    }
    forEachIdentityChange(fn2) {
      let record;
      for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {
        fn2(record);
      }
    }
    diff(collection) {
      if (collection == null)
        collection = [];
      if (!isListLikeIterable(collection)) {
        throw new Error(`Error trying to diff '${stringify(collection)}'. Only arrays and iterables are allowed`);
      }
      if (this.check(collection)) {
        return this;
      } else {
        return null;
      }
    }
    onDestroy() {
    }
    check(collection) {
      this._reset();
      let record = this._itHead;
      let mayBeDirty = false;
      let index;
      let item;
      let itemTrackBy;
      if (Array.isArray(collection)) {
        this.length = collection.length;
        for (let index2 = 0; index2 < this.length; index2++) {
          item = collection[index2];
          itemTrackBy = this._trackByFn(index2, item);
          if (record === null || !Object.is(record.trackById, itemTrackBy)) {
            record = this._mismatch(record, item, itemTrackBy, index2);
            mayBeDirty = true;
          } else {
            if (mayBeDirty) {
              record = this._verifyReinsertion(record, item, itemTrackBy, index2);
            }
            if (!Object.is(record.item, item))
              this._addIdentityChange(record, item);
          }
          record = record._next;
        }
      } else {
        index = 0;
        iterateListLike(collection, (item2) => {
          itemTrackBy = this._trackByFn(index, item2);
          if (record === null || !Object.is(record.trackById, itemTrackBy)) {
            record = this._mismatch(record, item2, itemTrackBy, index);
            mayBeDirty = true;
          } else {
            if (mayBeDirty) {
              record = this._verifyReinsertion(record, item2, itemTrackBy, index);
            }
            if (!Object.is(record.item, item2))
              this._addIdentityChange(record, item2);
          }
          record = record._next;
          index++;
        });
        this.length = index;
      }
      this._truncate(record);
      this.collection = collection;
      return this.isDirty;
    }
    get isDirty() {
      return this._additionsHead !== null || this._movesHead !== null || this._removalsHead !== null || this._identityChangesHead !== null;
    }
    _reset() {
      if (this.isDirty) {
        let record;
        for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
          record._nextPrevious = record._next;
        }
        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
          record.previousIndex = record.currentIndex;
        }
        this._additionsHead = this._additionsTail = null;
        for (record = this._movesHead; record !== null; record = record._nextMoved) {
          record.previousIndex = record.currentIndex;
        }
        this._movesHead = this._movesTail = null;
        this._removalsHead = this._removalsTail = null;
        this._identityChangesHead = this._identityChangesTail = null;
      }
    }
    _mismatch(record, item, itemTrackBy, index) {
      let previousRecord;
      if (record === null) {
        previousRecord = this._itTail;
      } else {
        previousRecord = record._prev;
        this._remove(record);
      }
      record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
      if (record !== null) {
        if (!Object.is(record.item, item))
          this._addIdentityChange(record, item);
        this._reinsertAfter(record, previousRecord, index);
      } else {
        record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);
        if (record !== null) {
          if (!Object.is(record.item, item))
            this._addIdentityChange(record, item);
          this._moveAfter(record, previousRecord, index);
        } else {
          record = this._addAfter(new IterableChangeRecord_(item, itemTrackBy), previousRecord, index);
        }
      }
      return record;
    }
    _verifyReinsertion(record, item, itemTrackBy, index) {
      let reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
      if (reinsertRecord !== null) {
        record = this._reinsertAfter(reinsertRecord, record._prev, index);
      } else if (record.currentIndex != index) {
        record.currentIndex = index;
        this._addToMoves(record, index);
      }
      return record;
    }
    _truncate(record) {
      while (record !== null) {
        const nextRecord = record._next;
        this._addToRemovals(this._unlink(record));
        record = nextRecord;
      }
      if (this._unlinkedRecords !== null) {
        this._unlinkedRecords.clear();
      }
      if (this._additionsTail !== null) {
        this._additionsTail._nextAdded = null;
      }
      if (this._movesTail !== null) {
        this._movesTail._nextMoved = null;
      }
      if (this._itTail !== null) {
        this._itTail._next = null;
      }
      if (this._removalsTail !== null) {
        this._removalsTail._nextRemoved = null;
      }
      if (this._identityChangesTail !== null) {
        this._identityChangesTail._nextIdentityChange = null;
      }
    }
    _reinsertAfter(record, prevRecord, index) {
      if (this._unlinkedRecords !== null) {
        this._unlinkedRecords.remove(record);
      }
      const prev = record._prevRemoved;
      const next = record._nextRemoved;
      if (prev === null) {
        this._removalsHead = next;
      } else {
        prev._nextRemoved = next;
      }
      if (next === null) {
        this._removalsTail = prev;
      } else {
        next._prevRemoved = prev;
      }
      this._insertAfter(record, prevRecord, index);
      this._addToMoves(record, index);
      return record;
    }
    _moveAfter(record, prevRecord, index) {
      this._unlink(record);
      this._insertAfter(record, prevRecord, index);
      this._addToMoves(record, index);
      return record;
    }
    _addAfter(record, prevRecord, index) {
      this._insertAfter(record, prevRecord, index);
      if (this._additionsTail === null) {
        this._additionsTail = this._additionsHead = record;
      } else {
        this._additionsTail = this._additionsTail._nextAdded = record;
      }
      return record;
    }
    _insertAfter(record, prevRecord, index) {
      const next = prevRecord === null ? this._itHead : prevRecord._next;
      record._next = next;
      record._prev = prevRecord;
      if (next === null) {
        this._itTail = record;
      } else {
        next._prev = record;
      }
      if (prevRecord === null) {
        this._itHead = record;
      } else {
        prevRecord._next = record;
      }
      if (this._linkedRecords === null) {
        this._linkedRecords = new _DuplicateMap();
      }
      this._linkedRecords.put(record);
      record.currentIndex = index;
      return record;
    }
    _remove(record) {
      return this._addToRemovals(this._unlink(record));
    }
    _unlink(record) {
      if (this._linkedRecords !== null) {
        this._linkedRecords.remove(record);
      }
      const prev = record._prev;
      const next = record._next;
      if (prev === null) {
        this._itHead = next;
      } else {
        prev._next = next;
      }
      if (next === null) {
        this._itTail = prev;
      } else {
        next._prev = prev;
      }
      return record;
    }
    _addToMoves(record, toIndex) {
      if (record.previousIndex === toIndex) {
        return record;
      }
      if (this._movesTail === null) {
        this._movesTail = this._movesHead = record;
      } else {
        this._movesTail = this._movesTail._nextMoved = record;
      }
      return record;
    }
    _addToRemovals(record) {
      if (this._unlinkedRecords === null) {
        this._unlinkedRecords = new _DuplicateMap();
      }
      this._unlinkedRecords.put(record);
      record.currentIndex = null;
      record._nextRemoved = null;
      if (this._removalsTail === null) {
        this._removalsTail = this._removalsHead = record;
        record._prevRemoved = null;
      } else {
        record._prevRemoved = this._removalsTail;
        this._removalsTail = this._removalsTail._nextRemoved = record;
      }
      return record;
    }
    _addIdentityChange(record, item) {
      record.item = item;
      if (this._identityChangesTail === null) {
        this._identityChangesTail = this._identityChangesHead = record;
      } else {
        this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
      }
      return record;
    }
  };
  var IterableChangeRecord_ = class {
    constructor(item, trackById) {
      this.item = item;
      this.trackById = trackById;
      this.currentIndex = null;
      this.previousIndex = null;
      this._nextPrevious = null;
      this._prev = null;
      this._next = null;
      this._prevDup = null;
      this._nextDup = null;
      this._prevRemoved = null;
      this._nextRemoved = null;
      this._nextAdded = null;
      this._nextMoved = null;
      this._nextIdentityChange = null;
    }
  };
  var _DuplicateItemRecordList = class {
    constructor() {
      this._head = null;
      this._tail = null;
    }
    add(record) {
      if (this._head === null) {
        this._head = this._tail = record;
        record._nextDup = null;
        record._prevDup = null;
      } else {
        this._tail._nextDup = record;
        record._prevDup = this._tail;
        record._nextDup = null;
        this._tail = record;
      }
    }
    get(trackById, atOrAfterIndex) {
      let record;
      for (record = this._head; record !== null; record = record._nextDup) {
        if ((atOrAfterIndex === null || atOrAfterIndex <= record.currentIndex) && Object.is(record.trackById, trackById)) {
          return record;
        }
      }
      return null;
    }
    remove(record) {
      const prev = record._prevDup;
      const next = record._nextDup;
      if (prev === null) {
        this._head = next;
      } else {
        prev._nextDup = next;
      }
      if (next === null) {
        this._tail = prev;
      } else {
        next._prevDup = prev;
      }
      return this._head === null;
    }
  };
  var _DuplicateMap = class {
    constructor() {
      this.map = /* @__PURE__ */ new Map();
    }
    put(record) {
      const key = record.trackById;
      let duplicates = this.map.get(key);
      if (!duplicates) {
        duplicates = new _DuplicateItemRecordList();
        this.map.set(key, duplicates);
      }
      duplicates.add(record);
    }
    get(trackById, atOrAfterIndex) {
      const key = trackById;
      const recordList = this.map.get(key);
      return recordList ? recordList.get(trackById, atOrAfterIndex) : null;
    }
    remove(record) {
      const key = record.trackById;
      const recordList = this.map.get(key);
      if (recordList.remove(record)) {
        this.map.delete(key);
      }
      return record;
    }
    get isEmpty() {
      return this.map.size === 0;
    }
    clear() {
      this.map.clear();
    }
  };
  function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
    const previousIndex = item.previousIndex;
    if (previousIndex === null)
      return previousIndex;
    let moveOffset = 0;
    if (moveOffsets && previousIndex < moveOffsets.length) {
      moveOffset = moveOffsets[previousIndex];
    }
    return previousIndex + addRemoveOffset + moveOffset;
  }
  var DefaultKeyValueDifferFactory = class {
    constructor() {
    }
    supports(obj) {
      return obj instanceof Map || isJsObject(obj);
    }
    create() {
      return new DefaultKeyValueDiffer();
    }
  };
  var DefaultKeyValueDiffer = class {
    constructor() {
      this._records = /* @__PURE__ */ new Map();
      this._mapHead = null;
      this._appendAfter = null;
      this._previousMapHead = null;
      this._changesHead = null;
      this._changesTail = null;
      this._additionsHead = null;
      this._additionsTail = null;
      this._removalsHead = null;
      this._removalsTail = null;
    }
    get isDirty() {
      return this._additionsHead !== null || this._changesHead !== null || this._removalsHead !== null;
    }
    forEachItem(fn2) {
      let record;
      for (record = this._mapHead; record !== null; record = record._next) {
        fn2(record);
      }
    }
    forEachPreviousItem(fn2) {
      let record;
      for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
        fn2(record);
      }
    }
    forEachChangedItem(fn2) {
      let record;
      for (record = this._changesHead; record !== null; record = record._nextChanged) {
        fn2(record);
      }
    }
    forEachAddedItem(fn2) {
      let record;
      for (record = this._additionsHead; record !== null; record = record._nextAdded) {
        fn2(record);
      }
    }
    forEachRemovedItem(fn2) {
      let record;
      for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
        fn2(record);
      }
    }
    diff(map2) {
      if (!map2) {
        map2 = /* @__PURE__ */ new Map();
      } else if (!(map2 instanceof Map || isJsObject(map2))) {
        throw new Error(`Error trying to diff '${stringify(map2)}'. Only maps and objects are allowed`);
      }
      return this.check(map2) ? this : null;
    }
    onDestroy() {
    }
    check(map2) {
      this._reset();
      let insertBefore = this._mapHead;
      this._appendAfter = null;
      this._forEach(map2, (value, key) => {
        if (insertBefore && insertBefore.key === key) {
          this._maybeAddToChanges(insertBefore, value);
          this._appendAfter = insertBefore;
          insertBefore = insertBefore._next;
        } else {
          const record = this._getOrCreateRecordForKey(key, value);
          insertBefore = this._insertBeforeOrAppend(insertBefore, record);
        }
      });
      if (insertBefore) {
        if (insertBefore._prev) {
          insertBefore._prev._next = null;
        }
        this._removalsHead = insertBefore;
        for (let record = insertBefore; record !== null; record = record._nextRemoved) {
          if (record === this._mapHead) {
            this._mapHead = null;
          }
          this._records.delete(record.key);
          record._nextRemoved = record._next;
          record.previousValue = record.currentValue;
          record.currentValue = null;
          record._prev = null;
          record._next = null;
        }
      }
      if (this._changesTail)
        this._changesTail._nextChanged = null;
      if (this._additionsTail)
        this._additionsTail._nextAdded = null;
      return this.isDirty;
    }
    _insertBeforeOrAppend(before, record) {
      if (before) {
        const prev = before._prev;
        record._next = before;
        record._prev = prev;
        before._prev = record;
        if (prev) {
          prev._next = record;
        }
        if (before === this._mapHead) {
          this._mapHead = record;
        }
        this._appendAfter = before;
        return before;
      }
      if (this._appendAfter) {
        this._appendAfter._next = record;
        record._prev = this._appendAfter;
      } else {
        this._mapHead = record;
      }
      this._appendAfter = record;
      return null;
    }
    _getOrCreateRecordForKey(key, value) {
      if (this._records.has(key)) {
        const record2 = this._records.get(key);
        this._maybeAddToChanges(record2, value);
        const prev = record2._prev;
        const next = record2._next;
        if (prev) {
          prev._next = next;
        }
        if (next) {
          next._prev = prev;
        }
        record2._next = null;
        record2._prev = null;
        return record2;
      }
      const record = new KeyValueChangeRecord_(key);
      this._records.set(key, record);
      record.currentValue = value;
      this._addToAdditions(record);
      return record;
    }
    _reset() {
      if (this.isDirty) {
        let record;
        this._previousMapHead = this._mapHead;
        for (record = this._previousMapHead; record !== null; record = record._next) {
          record._nextPrevious = record._next;
        }
        for (record = this._changesHead; record !== null; record = record._nextChanged) {
          record.previousValue = record.currentValue;
        }
        for (record = this._additionsHead; record != null; record = record._nextAdded) {
          record.previousValue = record.currentValue;
        }
        this._changesHead = this._changesTail = null;
        this._additionsHead = this._additionsTail = null;
        this._removalsHead = null;
      }
    }
    _maybeAddToChanges(record, newValue) {
      if (!Object.is(newValue, record.currentValue)) {
        record.previousValue = record.currentValue;
        record.currentValue = newValue;
        this._addToChanges(record);
      }
    }
    _addToAdditions(record) {
      if (this._additionsHead === null) {
        this._additionsHead = this._additionsTail = record;
      } else {
        this._additionsTail._nextAdded = record;
        this._additionsTail = record;
      }
    }
    _addToChanges(record) {
      if (this._changesHead === null) {
        this._changesHead = this._changesTail = record;
      } else {
        this._changesTail._nextChanged = record;
        this._changesTail = record;
      }
    }
    _forEach(obj, fn2) {
      if (obj instanceof Map) {
        obj.forEach(fn2);
      } else {
        Object.keys(obj).forEach((k) => fn2(obj[k], k));
      }
    }
  };
  var KeyValueChangeRecord_ = class {
    constructor(key) {
      this.key = key;
      this.previousValue = null;
      this.currentValue = null;
      this._nextPrevious = null;
      this._next = null;
      this._prev = null;
      this._nextAdded = null;
      this._nextRemoved = null;
      this._nextChanged = null;
    }
  };
  function defaultIterableDiffersFactory() {
    return new IterableDiffers([new DefaultIterableDifferFactory()]);
  }
  var IterableDiffers = class {
    constructor(factories) {
      this.factories = factories;
    }
    static create(factories, parent) {
      if (parent != null) {
        const copied = parent.factories.slice();
        factories = factories.concat(copied);
      }
      return new IterableDiffers(factories);
    }
    static extend(factories) {
      return {
        provide: IterableDiffers,
        useFactory: (parent) => {
          return IterableDiffers.create(factories, parent || defaultIterableDiffersFactory());
        },
        deps: [[IterableDiffers, new SkipSelf(), new Optional()]]
      };
    }
    find(iterable) {
      const factory = this.factories.find((f) => f.supports(iterable));
      if (factory != null) {
        return factory;
      } else {
        throw new Error(`Cannot find a differ supporting object '${iterable}' of type '${getTypeNameForDebugging(iterable)}'`);
      }
    }
  };
  IterableDiffers.\u0275prov = \u0275\u0275defineInjectable({ token: IterableDiffers, providedIn: "root", factory: defaultIterableDiffersFactory });
  function getTypeNameForDebugging(type) {
    return type["name"] || typeof type;
  }
  function defaultKeyValueDiffersFactory() {
    return new KeyValueDiffers([new DefaultKeyValueDifferFactory()]);
  }
  var KeyValueDiffers = class {
    constructor(factories) {
      this.factories = factories;
    }
    static create(factories, parent) {
      if (parent) {
        const copied = parent.factories.slice();
        factories = factories.concat(copied);
      }
      return new KeyValueDiffers(factories);
    }
    static extend(factories) {
      return {
        provide: KeyValueDiffers,
        useFactory: (parent) => {
          return KeyValueDiffers.create(factories, parent || defaultKeyValueDiffersFactory());
        },
        deps: [[KeyValueDiffers, new SkipSelf(), new Optional()]]
      };
    }
    find(kv) {
      const factory = this.factories.find((f) => f.supports(kv));
      if (factory) {
        return factory;
      }
      throw new Error(`Cannot find a differ supporting object '${kv}'`);
    }
  };
  KeyValueDiffers.\u0275prov = \u0275\u0275defineInjectable({ token: KeyValueDiffers, providedIn: "root", factory: defaultKeyValueDiffersFactory });
  var keyValDiff = [new DefaultKeyValueDifferFactory()];
  var iterableDiff = [new DefaultIterableDifferFactory()];
  var defaultIterableDiffers = new IterableDiffers(iterableDiff);
  var defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);
  var _CORE_PLATFORM_PROVIDERS = [
    { provide: PLATFORM_ID, useValue: "unknown" },
    { provide: PlatformRef, deps: [Injector] },
    { provide: TestabilityRegistry, deps: [] },
    { provide: Console, deps: [] }
  ];
  var platformCore = createPlatformFactory(null, "core", _CORE_PLATFORM_PROVIDERS);
  function _iterableDiffersFactory() {
    return defaultIterableDiffers;
  }
  function _keyValueDiffersFactory() {
    return defaultKeyValueDiffers;
  }
  function _localeFactory(locale) {
    return locale || getGlobalLocale();
  }
  function getGlobalLocale() {
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode && typeof goog !== "undefined" && goog.getLocale() !== "en") {
      return goog.getLocale();
    } else {
      return typeof $localize !== "undefined" && $localize.locale || DEFAULT_LOCALE_ID;
    }
  }
  var APPLICATION_MODULE_PROVIDERS = [
    {
      provide: ApplicationRef,
      useClass: ApplicationRef,
      deps: [NgZone, Injector, ErrorHandler, ComponentFactoryResolver$1, ApplicationInitStatus]
    },
    { provide: SCHEDULER, deps: [NgZone], useFactory: zoneSchedulerFactory },
    {
      provide: ApplicationInitStatus,
      useClass: ApplicationInitStatus,
      deps: [[new Optional(), APP_INITIALIZER]]
    },
    { provide: Compiler, useClass: Compiler, deps: [] },
    APP_ID_RANDOM_PROVIDER,
    { provide: IterableDiffers, useFactory: _iterableDiffersFactory, deps: [] },
    { provide: KeyValueDiffers, useFactory: _keyValueDiffersFactory, deps: [] },
    {
      provide: LOCALE_ID,
      useFactory: _localeFactory,
      deps: [[new Inject(LOCALE_ID), new Optional(), new SkipSelf()]]
    },
    { provide: DEFAULT_CURRENCY_CODE, useValue: USD_CURRENCY_CODE }
  ];
  function zoneSchedulerFactory(ngZone) {
    let queue = [];
    ngZone.onStable.subscribe(() => {
      while (queue.length) {
        queue.pop()();
      }
    });
    return function(fn2) {
      queue.push(fn2);
    };
  }
  var ApplicationModule = class {
    constructor(appRef) {
    }
  };
  ApplicationModule.\u0275fac = function ApplicationModule_Factory(t) {
    return new (t || ApplicationModule)(\u0275\u0275inject(ApplicationRef));
  };
  ApplicationModule.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({ type: ApplicationModule });
  ApplicationModule.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({ providers: APPLICATION_MODULE_PROVIDERS });
  (function() {
    (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApplicationModule, [{
      type: NgModule,
      args: [{ providers: APPLICATION_MODULE_PROVIDERS }]
    }], function() {
      return [{ type: ApplicationRef }];
    }, null);
  })();
  var \u0275ivyEnabled = true;
  function \u0275\u0275ngDeclareDirective(decl) {
    const compiler = getCompilerFacade({ usage: 1, kind: "directive", type: decl.type });
    return compiler.compileDirectiveDeclaration(angularCoreEnv, `ng:///${decl.type.name}/\u0275fac.js`, decl);
  }
  function \u0275\u0275ngDeclareClassMetadata(decl) {
    setClassMetadata(decl.type, decl.decorators, decl.ctorParameters ?? null, decl.propDecorators ?? null);
  }
  function \u0275\u0275ngDeclareComponent(decl) {
    const compiler = getCompilerFacade({ usage: 1, kind: "component", type: decl.type });
    return compiler.compileComponentDeclaration(angularCoreEnv, `ng:///${decl.type.name}/\u0275cmp.js`, decl);
  }
  function \u0275\u0275ngDeclareFactory(decl) {
    const compiler = getCompilerFacade({
      usage: 1,
      kind: getFactoryKind(decl.target),
      type: decl.type
    });
    return compiler.compileFactoryDeclaration(angularCoreEnv, `ng:///${decl.type.name}/\u0275fac.js`, decl);
  }
  function getFactoryKind(target) {
    switch (target) {
      case FactoryTarget.Directive:
        return "directive";
      case FactoryTarget.Component:
        return "component";
      case FactoryTarget.Injectable:
        return "injectable";
      case FactoryTarget.Pipe:
        return "pipe";
      case FactoryTarget.NgModule:
        return "NgModule";
    }
  }
  function \u0275\u0275ngDeclareInjectable(decl) {
    const compiler = getCompilerFacade({ usage: 1, kind: "injectable", type: decl.type });
    return compiler.compileInjectableDeclaration(angularCoreEnv, `ng:///${decl.type.name}/\u0275prov.js`, decl);
  }
  function \u0275\u0275ngDeclareInjector(decl) {
    const compiler = getCompilerFacade({ usage: 1, kind: "NgModule", type: decl.type });
    return compiler.compileInjectorDeclaration(angularCoreEnv, `ng:///${decl.type.name}/\u0275inj.js`, decl);
  }
  function \u0275\u0275ngDeclareNgModule(decl) {
    const compiler = getCompilerFacade({ usage: 1, kind: "NgModule", type: decl.type });
    return compiler.compileNgModuleDeclaration(angularCoreEnv, `ng:///${decl.type.name}/\u0275mod.js`, decl);
  }
  function \u0275\u0275ngDeclarePipe(decl) {
    const compiler = getCompilerFacade({ usage: 1, kind: "pipe", type: decl.type });
    return compiler.compilePipeDeclaration(angularCoreEnv, `ng:///${decl.type.name}/\u0275pipe.js`, decl);
  }
  if (typeof ngDevMode !== "undefined" && ngDevMode) {
    _global2.$localize = _global2.$localize || function() {
      throw new Error("It looks like your application or one of its dependencies is using i18n.\nAngular 9 introduced a global `$localize()` function that needs to be loaded.\nPlease run `ng add @angular/localize` from the Angular CLI.\n(For non-CLI projects, add `import '@angular/localize/init';` to your `polyfills.ts` file.\nFor server-side rendering applications add the import to your `main.server.ts` file.)");
    };
  }

  // node_modules/@angular/compiler/fesm2020/compiler.mjs
  var TagContentType;
  (function(TagContentType2) {
    TagContentType2[TagContentType2["RAW_TEXT"] = 0] = "RAW_TEXT";
    TagContentType2[TagContentType2["ESCAPABLE_RAW_TEXT"] = 1] = "ESCAPABLE_RAW_TEXT";
    TagContentType2[TagContentType2["PARSABLE_DATA"] = 2] = "PARSABLE_DATA";
  })(TagContentType || (TagContentType = {}));
  function splitNsName(elementName) {
    if (elementName[0] != ":") {
      return [null, elementName];
    }
    const colonIndex = elementName.indexOf(":", 1);
    if (colonIndex === -1) {
      throw new Error(`Unsupported format "${elementName}" expecting ":namespace:name"`);
    }
    return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];
  }
  function isNgContainer(tagName) {
    return splitNsName(tagName)[1] === "ng-container";
  }
  function isNgContent(tagName) {
    return splitNsName(tagName)[1] === "ng-content";
  }
  function isNgTemplate(tagName) {
    return splitNsName(tagName)[1] === "ng-template";
  }
  function getNsPrefix(fullName) {
    return fullName === null ? null : splitNsName(fullName)[0];
  }
  function mergeNsAndName(prefix, localName) {
    return prefix ? `:${prefix}:${localName}` : localName;
  }
  var HtmlTagDefinition = class {
    constructor({ closedByChildren, implicitNamespacePrefix, contentType = TagContentType.PARSABLE_DATA, closedByParent = false, isVoid = false, ignoreFirstLf = false, preventNamespaceInheritance = false } = {}) {
      this.closedByChildren = {};
      this.closedByParent = false;
      this.canSelfClose = false;
      if (closedByChildren && closedByChildren.length > 0) {
        closedByChildren.forEach((tagName) => this.closedByChildren[tagName] = true);
      }
      this.isVoid = isVoid;
      this.closedByParent = closedByParent || isVoid;
      this.implicitNamespacePrefix = implicitNamespacePrefix || null;
      this.contentType = contentType;
      this.ignoreFirstLf = ignoreFirstLf;
      this.preventNamespaceInheritance = preventNamespaceInheritance;
    }
    isClosedByChild(name) {
      return this.isVoid || name.toLowerCase() in this.closedByChildren;
    }
    getContentType(prefix) {
      if (typeof this.contentType === "object") {
        const overrideType = prefix === void 0 ? void 0 : this.contentType[prefix];
        return overrideType ?? this.contentType.default;
      }
      return this.contentType;
    }
  };
  var _DEFAULT_TAG_DEFINITION;
  var TAG_DEFINITIONS;
  function getHtmlTagDefinition(tagName) {
    if (!TAG_DEFINITIONS) {
      _DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();
      TAG_DEFINITIONS = {
        "base": new HtmlTagDefinition({ isVoid: true }),
        "meta": new HtmlTagDefinition({ isVoid: true }),
        "area": new HtmlTagDefinition({ isVoid: true }),
        "embed": new HtmlTagDefinition({ isVoid: true }),
        "link": new HtmlTagDefinition({ isVoid: true }),
        "img": new HtmlTagDefinition({ isVoid: true }),
        "input": new HtmlTagDefinition({ isVoid: true }),
        "param": new HtmlTagDefinition({ isVoid: true }),
        "hr": new HtmlTagDefinition({ isVoid: true }),
        "br": new HtmlTagDefinition({ isVoid: true }),
        "source": new HtmlTagDefinition({ isVoid: true }),
        "track": new HtmlTagDefinition({ isVoid: true }),
        "wbr": new HtmlTagDefinition({ isVoid: true }),
        "p": new HtmlTagDefinition({
          closedByChildren: [
            "address",
            "article",
            "aside",
            "blockquote",
            "div",
            "dl",
            "fieldset",
            "footer",
            "form",
            "h1",
            "h2",
            "h3",
            "h4",
            "h5",
            "h6",
            "header",
            "hgroup",
            "hr",
            "main",
            "nav",
            "ol",
            "p",
            "pre",
            "section",
            "table",
            "ul"
          ],
          closedByParent: true
        }),
        "thead": new HtmlTagDefinition({ closedByChildren: ["tbody", "tfoot"] }),
        "tbody": new HtmlTagDefinition({ closedByChildren: ["tbody", "tfoot"], closedByParent: true }),
        "tfoot": new HtmlTagDefinition({ closedByChildren: ["tbody"], closedByParent: true }),
        "tr": new HtmlTagDefinition({ closedByChildren: ["tr"], closedByParent: true }),
        "td": new HtmlTagDefinition({ closedByChildren: ["td", "th"], closedByParent: true }),
        "th": new HtmlTagDefinition({ closedByChildren: ["td", "th"], closedByParent: true }),
        "col": new HtmlTagDefinition({ isVoid: true }),
        "svg": new HtmlTagDefinition({ implicitNamespacePrefix: "svg" }),
        "foreignObject": new HtmlTagDefinition({
          implicitNamespacePrefix: "svg",
          preventNamespaceInheritance: true
        }),
        "math": new HtmlTagDefinition({ implicitNamespacePrefix: "math" }),
        "li": new HtmlTagDefinition({ closedByChildren: ["li"], closedByParent: true }),
        "dt": new HtmlTagDefinition({ closedByChildren: ["dt", "dd"] }),
        "dd": new HtmlTagDefinition({ closedByChildren: ["dt", "dd"], closedByParent: true }),
        "rb": new HtmlTagDefinition({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }),
        "rt": new HtmlTagDefinition({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }),
        "rtc": new HtmlTagDefinition({ closedByChildren: ["rb", "rtc", "rp"], closedByParent: true }),
        "rp": new HtmlTagDefinition({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }),
        "optgroup": new HtmlTagDefinition({ closedByChildren: ["optgroup"], closedByParent: true }),
        "option": new HtmlTagDefinition({ closedByChildren: ["option", "optgroup"], closedByParent: true }),
        "pre": new HtmlTagDefinition({ ignoreFirstLf: true }),
        "listing": new HtmlTagDefinition({ ignoreFirstLf: true }),
        "style": new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),
        "script": new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),
        "title": new HtmlTagDefinition({
          contentType: { default: TagContentType.ESCAPABLE_RAW_TEXT, svg: TagContentType.PARSABLE_DATA }
        }),
        "textarea": new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true })
      };
    }
    return TAG_DEFINITIONS[tagName] ?? TAG_DEFINITIONS[tagName.toLowerCase()] ?? _DEFAULT_TAG_DEFINITION;
  }
  var _SELECTOR_REGEXP = new RegExp(`(\\:not\\()|(([\\.\\#]?)[-\\w]+)|(?:\\[([-.\\w*\\\\$]+)(?:=(["']?)([^\\]"']*)\\5)?\\])|(\\))|(\\s*,\\s*)`, "g");
  var CssSelector = class {
    constructor() {
      this.element = null;
      this.classNames = [];
      this.attrs = [];
      this.notSelectors = [];
    }
    static parse(selector) {
      const results = [];
      const _addResult = (res, cssSel) => {
        if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 && cssSel.attrs.length == 0) {
          cssSel.element = "*";
        }
        res.push(cssSel);
      };
      let cssSelector = new CssSelector();
      let match2;
      let current = cssSelector;
      let inNot = false;
      _SELECTOR_REGEXP.lastIndex = 0;
      while (match2 = _SELECTOR_REGEXP.exec(selector)) {
        if (match2[1]) {
          if (inNot) {
            throw new Error("Nesting :not in a selector is not allowed");
          }
          inNot = true;
          current = new CssSelector();
          cssSelector.notSelectors.push(current);
        }
        const tag = match2[2];
        if (tag) {
          const prefix = match2[3];
          if (prefix === "#") {
            current.addAttribute("id", tag.substr(1));
          } else if (prefix === ".") {
            current.addClassName(tag.substr(1));
          } else {
            current.setElement(tag);
          }
        }
        const attribute = match2[4];
        if (attribute) {
          current.addAttribute(current.unescapeAttribute(attribute), match2[6]);
        }
        if (match2[7]) {
          inNot = false;
          current = cssSelector;
        }
        if (match2[8]) {
          if (inNot) {
            throw new Error("Multiple selectors in :not are not supported");
          }
          _addResult(results, cssSelector);
          cssSelector = current = new CssSelector();
        }
      }
      _addResult(results, cssSelector);
      return results;
    }
    unescapeAttribute(attr) {
      let result = "";
      let escaping = false;
      for (let i = 0; i < attr.length; i++) {
        const char = attr.charAt(i);
        if (char === "\\") {
          escaping = true;
          continue;
        }
        if (char === "$" && !escaping) {
          throw new Error(`Error in attribute selector "${attr}". Unescaped "$" is not supported. Please escape with "\\$".`);
        }
        escaping = false;
        result += char;
      }
      return result;
    }
    escapeAttribute(attr) {
      return attr.replace(/\\/g, "\\\\").replace(/\$/g, "\\$");
    }
    isElementSelector() {
      return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 && this.notSelectors.length === 0;
    }
    hasElementSelector() {
      return !!this.element;
    }
    setElement(element = null) {
      this.element = element;
    }
    getMatchingElementTemplate() {
      const tagName = this.element || "div";
      const classAttr = this.classNames.length > 0 ? ` class="${this.classNames.join(" ")}"` : "";
      let attrs = "";
      for (let i = 0; i < this.attrs.length; i += 2) {
        const attrName = this.attrs[i];
        const attrValue = this.attrs[i + 1] !== "" ? `="${this.attrs[i + 1]}"` : "";
        attrs += ` ${attrName}${attrValue}`;
      }
      return getHtmlTagDefinition(tagName).isVoid ? `<${tagName}${classAttr}${attrs}/>` : `<${tagName}${classAttr}${attrs}></${tagName}>`;
    }
    getAttrs() {
      const result = [];
      if (this.classNames.length > 0) {
        result.push("class", this.classNames.join(" "));
      }
      return result.concat(this.attrs);
    }
    addAttribute(name, value = "") {
      this.attrs.push(name, value && value.toLowerCase() || "");
    }
    addClassName(name) {
      this.classNames.push(name.toLowerCase());
    }
    toString() {
      let res = this.element || "";
      if (this.classNames) {
        this.classNames.forEach((klass) => res += `.${klass}`);
      }
      if (this.attrs) {
        for (let i = 0; i < this.attrs.length; i += 2) {
          const name = this.escapeAttribute(this.attrs[i]);
          const value = this.attrs[i + 1];
          res += `[${name}${value ? "=" + value : ""}]`;
        }
      }
      this.notSelectors.forEach((notSelector) => res += `:not(${notSelector})`);
      return res;
    }
  };
  var SelectorMatcher = class {
    constructor() {
      this._elementMap = /* @__PURE__ */ new Map();
      this._elementPartialMap = /* @__PURE__ */ new Map();
      this._classMap = /* @__PURE__ */ new Map();
      this._classPartialMap = /* @__PURE__ */ new Map();
      this._attrValueMap = /* @__PURE__ */ new Map();
      this._attrValuePartialMap = /* @__PURE__ */ new Map();
      this._listContexts = [];
    }
    static createNotMatcher(notSelectors) {
      const notMatcher = new SelectorMatcher();
      notMatcher.addSelectables(notSelectors, null);
      return notMatcher;
    }
    addSelectables(cssSelectors, callbackCtxt) {
      let listContext = null;
      if (cssSelectors.length > 1) {
        listContext = new SelectorListContext(cssSelectors);
        this._listContexts.push(listContext);
      }
      for (let i = 0; i < cssSelectors.length; i++) {
        this._addSelectable(cssSelectors[i], callbackCtxt, listContext);
      }
    }
    _addSelectable(cssSelector, callbackCtxt, listContext) {
      let matcher = this;
      const element = cssSelector.element;
      const classNames = cssSelector.classNames;
      const attrs = cssSelector.attrs;
      const selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);
      if (element) {
        const isTerminal = attrs.length === 0 && classNames.length === 0;
        if (isTerminal) {
          this._addTerminal(matcher._elementMap, element, selectable);
        } else {
          matcher = this._addPartial(matcher._elementPartialMap, element);
        }
      }
      if (classNames) {
        for (let i = 0; i < classNames.length; i++) {
          const isTerminal = attrs.length === 0 && i === classNames.length - 1;
          const className = classNames[i];
          if (isTerminal) {
            this._addTerminal(matcher._classMap, className, selectable);
          } else {
            matcher = this._addPartial(matcher._classPartialMap, className);
          }
        }
      }
      if (attrs) {
        for (let i = 0; i < attrs.length; i += 2) {
          const isTerminal = i === attrs.length - 2;
          const name = attrs[i];
          const value = attrs[i + 1];
          if (isTerminal) {
            const terminalMap = matcher._attrValueMap;
            let terminalValuesMap = terminalMap.get(name);
            if (!terminalValuesMap) {
              terminalValuesMap = /* @__PURE__ */ new Map();
              terminalMap.set(name, terminalValuesMap);
            }
            this._addTerminal(terminalValuesMap, value, selectable);
          } else {
            const partialMap = matcher._attrValuePartialMap;
            let partialValuesMap = partialMap.get(name);
            if (!partialValuesMap) {
              partialValuesMap = /* @__PURE__ */ new Map();
              partialMap.set(name, partialValuesMap);
            }
            matcher = this._addPartial(partialValuesMap, value);
          }
        }
      }
    }
    _addTerminal(map2, name, selectable) {
      let terminalList = map2.get(name);
      if (!terminalList) {
        terminalList = [];
        map2.set(name, terminalList);
      }
      terminalList.push(selectable);
    }
    _addPartial(map2, name) {
      let matcher = map2.get(name);
      if (!matcher) {
        matcher = new SelectorMatcher();
        map2.set(name, matcher);
      }
      return matcher;
    }
    match(cssSelector, matchedCallback) {
      let result = false;
      const element = cssSelector.element;
      const classNames = cssSelector.classNames;
      const attrs = cssSelector.attrs;
      for (let i = 0; i < this._listContexts.length; i++) {
        this._listContexts[i].alreadyMatched = false;
      }
      result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;
      result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) || result;
      if (classNames) {
        for (let i = 0; i < classNames.length; i++) {
          const className = classNames[i];
          result = this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;
          result = this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) || result;
        }
      }
      if (attrs) {
        for (let i = 0; i < attrs.length; i += 2) {
          const name = attrs[i];
          const value = attrs[i + 1];
          const terminalValuesMap = this._attrValueMap.get(name);
          if (value) {
            result = this._matchTerminal(terminalValuesMap, "", cssSelector, matchedCallback) || result;
          }
          result = this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;
          const partialValuesMap = this._attrValuePartialMap.get(name);
          if (value) {
            result = this._matchPartial(partialValuesMap, "", cssSelector, matchedCallback) || result;
          }
          result = this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;
        }
      }
      return result;
    }
    _matchTerminal(map2, name, cssSelector, matchedCallback) {
      if (!map2 || typeof name !== "string") {
        return false;
      }
      let selectables = map2.get(name) || [];
      const starSelectables = map2.get("*");
      if (starSelectables) {
        selectables = selectables.concat(starSelectables);
      }
      if (selectables.length === 0) {
        return false;
      }
      let selectable;
      let result = false;
      for (let i = 0; i < selectables.length; i++) {
        selectable = selectables[i];
        result = selectable.finalize(cssSelector, matchedCallback) || result;
      }
      return result;
    }
    _matchPartial(map2, name, cssSelector, matchedCallback) {
      if (!map2 || typeof name !== "string") {
        return false;
      }
      const nestedSelector = map2.get(name);
      if (!nestedSelector) {
        return false;
      }
      return nestedSelector.match(cssSelector, matchedCallback);
    }
  };
  var SelectorListContext = class {
    constructor(selectors) {
      this.selectors = selectors;
      this.alreadyMatched = false;
    }
  };
  var SelectorContext = class {
    constructor(selector, cbContext, listContext) {
      this.selector = selector;
      this.cbContext = cbContext;
      this.listContext = listContext;
      this.notSelectors = selector.notSelectors;
    }
    finalize(cssSelector, callback) {
      let result = true;
      if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {
        const notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);
        result = !notMatcher.match(cssSelector, null);
      }
      if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {
        if (this.listContext) {
          this.listContext.alreadyMatched = true;
        }
        callback(this.selector, this.cbContext);
      }
      return result;
    }
  };
  var createInject = makeMetadataFactory("Inject", (token) => ({ token }));
  var createInjectionToken = makeMetadataFactory("InjectionToken", (desc) => ({ _desc: desc, \u0275prov: void 0 }));
  var createAttribute = makeMetadataFactory("Attribute", (attributeName) => ({ attributeName }));
  var emitDistinctChangesOnlyDefaultValue2 = true;
  var createContentChildren = makeMetadataFactory("ContentChildren", (selector, data = {}) => ({
    selector,
    first: false,
    isViewQuery: false,
    descendants: false,
    emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue2,
    ...data
  }));
  var createContentChild = makeMetadataFactory("ContentChild", (selector, data = {}) => ({ selector, first: true, isViewQuery: false, descendants: true, ...data }));
  var createViewChildren = makeMetadataFactory("ViewChildren", (selector, data = {}) => ({
    selector,
    first: false,
    isViewQuery: true,
    descendants: true,
    emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue2,
    ...data
  }));
  var createViewChild = makeMetadataFactory("ViewChild", (selector, data) => ({ selector, first: true, isViewQuery: true, descendants: true, ...data }));
  var createDirective = makeMetadataFactory("Directive", (dir = {}) => dir);
  var ViewEncapsulation2;
  (function(ViewEncapsulation3) {
    ViewEncapsulation3[ViewEncapsulation3["Emulated"] = 0] = "Emulated";
    ViewEncapsulation3[ViewEncapsulation3["None"] = 2] = "None";
    ViewEncapsulation3[ViewEncapsulation3["ShadowDom"] = 3] = "ShadowDom";
  })(ViewEncapsulation2 || (ViewEncapsulation2 = {}));
  var ChangeDetectionStrategy2;
  (function(ChangeDetectionStrategy3) {
    ChangeDetectionStrategy3[ChangeDetectionStrategy3["OnPush"] = 0] = "OnPush";
    ChangeDetectionStrategy3[ChangeDetectionStrategy3["Default"] = 1] = "Default";
  })(ChangeDetectionStrategy2 || (ChangeDetectionStrategy2 = {}));
  var createComponent = makeMetadataFactory("Component", (c = {}) => ({ changeDetection: ChangeDetectionStrategy2.Default, ...c }));
  var createPipe = makeMetadataFactory("Pipe", (p) => ({ pure: true, ...p }));
  var createInput = makeMetadataFactory("Input", (bindingPropertyName) => ({ bindingPropertyName }));
  var createOutput = makeMetadataFactory("Output", (bindingPropertyName) => ({ bindingPropertyName }));
  var createHostBinding = makeMetadataFactory("HostBinding", (hostPropertyName) => ({ hostPropertyName }));
  var createHostListener = makeMetadataFactory("HostListener", (eventName, args) => ({ eventName, args }));
  var createNgModule = makeMetadataFactory("NgModule", (ngModule) => ngModule);
  var createInjectable = makeMetadataFactory("Injectable", (injectable = {}) => injectable);
  var CUSTOM_ELEMENTS_SCHEMA2 = {
    name: "custom-elements"
  };
  var NO_ERRORS_SCHEMA2 = {
    name: "no-errors-schema"
  };
  var createOptional = makeMetadataFactory("Optional");
  var createSelf = makeMetadataFactory("Self");
  var createSkipSelf = makeMetadataFactory("SkipSelf");
  var createHost = makeMetadataFactory("Host");
  var SecurityContext2;
  (function(SecurityContext3) {
    SecurityContext3[SecurityContext3["NONE"] = 0] = "NONE";
    SecurityContext3[SecurityContext3["HTML"] = 1] = "HTML";
    SecurityContext3[SecurityContext3["STYLE"] = 2] = "STYLE";
    SecurityContext3[SecurityContext3["SCRIPT"] = 3] = "SCRIPT";
    SecurityContext3[SecurityContext3["URL"] = 4] = "URL";
    SecurityContext3[SecurityContext3["RESOURCE_URL"] = 5] = "RESOURCE_URL";
  })(SecurityContext2 || (SecurityContext2 = {}));
  var MissingTranslationStrategy2;
  (function(MissingTranslationStrategy3) {
    MissingTranslationStrategy3[MissingTranslationStrategy3["Error"] = 0] = "Error";
    MissingTranslationStrategy3[MissingTranslationStrategy3["Warning"] = 1] = "Warning";
    MissingTranslationStrategy3[MissingTranslationStrategy3["Ignore"] = 2] = "Ignore";
  })(MissingTranslationStrategy2 || (MissingTranslationStrategy2 = {}));
  function makeMetadataFactory(name, props) {
    function factory(...args) {
      const values = props ? props(...args) : {};
      return {
        ngMetadataName: name,
        ...values
      };
    }
    factory.isTypeOf = (obj) => obj && obj.ngMetadataName === name;
    factory.ngMetadataName = name;
    return factory;
  }
  function parserSelectorToSimpleSelector(selector) {
    const classes = selector.classNames && selector.classNames.length ? [8, ...selector.classNames] : [];
    const elementName = selector.element && selector.element !== "*" ? selector.element : "";
    return [elementName, ...selector.attrs, ...classes];
  }
  function parserSelectorToNegativeSelector(selector) {
    const classes = selector.classNames && selector.classNames.length ? [8, ...selector.classNames] : [];
    if (selector.element) {
      return [
        1 | 4,
        selector.element,
        ...selector.attrs,
        ...classes
      ];
    } else if (selector.attrs.length) {
      return [1 | 2, ...selector.attrs, ...classes];
    } else {
      return selector.classNames && selector.classNames.length ? [1 | 8, ...selector.classNames] : [];
    }
  }
  function parserSelectorToR3Selector(selector) {
    const positive = parserSelectorToSimpleSelector(selector);
    const negative = selector.notSelectors && selector.notSelectors.length ? selector.notSelectors.map((notSelector) => parserSelectorToNegativeSelector(notSelector)) : [];
    return positive.concat(...negative);
  }
  function parseSelectorToR3Selector(selector) {
    return selector ? CssSelector.parse(selector).map(parserSelectorToR3Selector) : [];
  }
  var TypeModifier;
  (function(TypeModifier2) {
    TypeModifier2[TypeModifier2["Const"] = 0] = "Const";
  })(TypeModifier || (TypeModifier = {}));
  var Type2 = class {
    constructor(modifiers = []) {
      this.modifiers = modifiers;
    }
    hasModifier(modifier) {
      return this.modifiers.indexOf(modifier) !== -1;
    }
  };
  var BuiltinTypeName;
  (function(BuiltinTypeName2) {
    BuiltinTypeName2[BuiltinTypeName2["Dynamic"] = 0] = "Dynamic";
    BuiltinTypeName2[BuiltinTypeName2["Bool"] = 1] = "Bool";
    BuiltinTypeName2[BuiltinTypeName2["String"] = 2] = "String";
    BuiltinTypeName2[BuiltinTypeName2["Int"] = 3] = "Int";
    BuiltinTypeName2[BuiltinTypeName2["Number"] = 4] = "Number";
    BuiltinTypeName2[BuiltinTypeName2["Function"] = 5] = "Function";
    BuiltinTypeName2[BuiltinTypeName2["Inferred"] = 6] = "Inferred";
    BuiltinTypeName2[BuiltinTypeName2["None"] = 7] = "None";
  })(BuiltinTypeName || (BuiltinTypeName = {}));
  var BuiltinType = class extends Type2 {
    constructor(name, modifiers) {
      super(modifiers);
      this.name = name;
    }
    visitType(visitor, context2) {
      return visitor.visitBuiltinType(this, context2);
    }
  };
  var ExpressionType = class extends Type2 {
    constructor(value, modifiers, typeParams = null) {
      super(modifiers);
      this.value = value;
      this.typeParams = typeParams;
    }
    visitType(visitor, context2) {
      return visitor.visitExpressionType(this, context2);
    }
  };
  var DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);
  var INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);
  var BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);
  var INT_TYPE = new BuiltinType(BuiltinTypeName.Int);
  var NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);
  var STRING_TYPE = new BuiltinType(BuiltinTypeName.String);
  var FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);
  var NONE_TYPE = new BuiltinType(BuiltinTypeName.None);
  var UnaryOperator;
  (function(UnaryOperator2) {
    UnaryOperator2[UnaryOperator2["Minus"] = 0] = "Minus";
    UnaryOperator2[UnaryOperator2["Plus"] = 1] = "Plus";
  })(UnaryOperator || (UnaryOperator = {}));
  var BinaryOperator;
  (function(BinaryOperator2) {
    BinaryOperator2[BinaryOperator2["Equals"] = 0] = "Equals";
    BinaryOperator2[BinaryOperator2["NotEquals"] = 1] = "NotEquals";
    BinaryOperator2[BinaryOperator2["Identical"] = 2] = "Identical";
    BinaryOperator2[BinaryOperator2["NotIdentical"] = 3] = "NotIdentical";
    BinaryOperator2[BinaryOperator2["Minus"] = 4] = "Minus";
    BinaryOperator2[BinaryOperator2["Plus"] = 5] = "Plus";
    BinaryOperator2[BinaryOperator2["Divide"] = 6] = "Divide";
    BinaryOperator2[BinaryOperator2["Multiply"] = 7] = "Multiply";
    BinaryOperator2[BinaryOperator2["Modulo"] = 8] = "Modulo";
    BinaryOperator2[BinaryOperator2["And"] = 9] = "And";
    BinaryOperator2[BinaryOperator2["Or"] = 10] = "Or";
    BinaryOperator2[BinaryOperator2["BitwiseAnd"] = 11] = "BitwiseAnd";
    BinaryOperator2[BinaryOperator2["Lower"] = 12] = "Lower";
    BinaryOperator2[BinaryOperator2["LowerEquals"] = 13] = "LowerEquals";
    BinaryOperator2[BinaryOperator2["Bigger"] = 14] = "Bigger";
    BinaryOperator2[BinaryOperator2["BiggerEquals"] = 15] = "BiggerEquals";
    BinaryOperator2[BinaryOperator2["NullishCoalesce"] = 16] = "NullishCoalesce";
  })(BinaryOperator || (BinaryOperator = {}));
  function nullSafeIsEquivalent(base, other) {
    if (base == null || other == null) {
      return base == other;
    }
    return base.isEquivalent(other);
  }
  function areAllEquivalentPredicate(base, other, equivalentPredicate) {
    const len = base.length;
    if (len !== other.length) {
      return false;
    }
    for (let i = 0; i < len; i++) {
      if (!equivalentPredicate(base[i], other[i])) {
        return false;
      }
    }
    return true;
  }
  function areAllEquivalent(base, other) {
    return areAllEquivalentPredicate(base, other, (baseElement2, otherElement) => baseElement2.isEquivalent(otherElement));
  }
  var Expression = class {
    constructor(type, sourceSpan) {
      this.type = type || null;
      this.sourceSpan = sourceSpan || null;
    }
    prop(name, sourceSpan) {
      return new ReadPropExpr(this, name, null, sourceSpan);
    }
    key(index, type, sourceSpan) {
      return new ReadKeyExpr(this, index, type, sourceSpan);
    }
    callFn(params, sourceSpan, pure) {
      return new InvokeFunctionExpr(this, params, null, sourceSpan, pure);
    }
    instantiate(params, type, sourceSpan) {
      return new InstantiateExpr(this, params, type, sourceSpan);
    }
    conditional(trueCase, falseCase = null, sourceSpan) {
      return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);
    }
    equals(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);
    }
    notEquals(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);
    }
    identical(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);
    }
    notIdentical(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);
    }
    minus(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);
    }
    plus(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);
    }
    divide(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);
    }
    multiply(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);
    }
    modulo(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);
    }
    and(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);
    }
    bitwiseAnd(rhs, sourceSpan, parens = true) {
      return new BinaryOperatorExpr(BinaryOperator.BitwiseAnd, this, rhs, null, sourceSpan, parens);
    }
    or(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);
    }
    lower(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);
    }
    lowerEquals(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);
    }
    bigger(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);
    }
    biggerEquals(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);
    }
    isBlank(sourceSpan) {
      return this.equals(TYPED_NULL_EXPR, sourceSpan);
    }
    cast(type, sourceSpan) {
      return new CastExpr(this, type, sourceSpan);
    }
    nullishCoalesce(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.NullishCoalesce, this, rhs, null, sourceSpan);
    }
    toStmt() {
      return new ExpressionStatement(this, null);
    }
  };
  var BuiltinVar;
  (function(BuiltinVar2) {
    BuiltinVar2[BuiltinVar2["This"] = 0] = "This";
    BuiltinVar2[BuiltinVar2["Super"] = 1] = "Super";
    BuiltinVar2[BuiltinVar2["CatchError"] = 2] = "CatchError";
    BuiltinVar2[BuiltinVar2["CatchStack"] = 3] = "CatchStack";
  })(BuiltinVar || (BuiltinVar = {}));
  var ReadVarExpr = class extends Expression {
    constructor(name, type, sourceSpan) {
      super(type, sourceSpan);
      if (typeof name === "string") {
        this.name = name;
        this.builtin = null;
      } else {
        this.name = null;
        this.builtin = name;
      }
    }
    isEquivalent(e) {
      return e instanceof ReadVarExpr && this.name === e.name && this.builtin === e.builtin;
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context2) {
      return visitor.visitReadVarExpr(this, context2);
    }
    set(value) {
      if (!this.name) {
        throw new Error(`Built in variable ${this.builtin} can not be assigned to.`);
      }
      return new WriteVarExpr(this.name, value, null, this.sourceSpan);
    }
  };
  var TypeofExpr = class extends Expression {
    constructor(expr, type, sourceSpan) {
      super(type, sourceSpan);
      this.expr = expr;
    }
    visitExpression(visitor, context2) {
      return visitor.visitTypeofExpr(this, context2);
    }
    isEquivalent(e) {
      return e instanceof TypeofExpr && e.expr.isEquivalent(this.expr);
    }
    isConstant() {
      return this.expr.isConstant();
    }
  };
  var WrappedNodeExpr = class extends Expression {
    constructor(node, type, sourceSpan) {
      super(type, sourceSpan);
      this.node = node;
    }
    isEquivalent(e) {
      return e instanceof WrappedNodeExpr && this.node === e.node;
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context2) {
      return visitor.visitWrappedNodeExpr(this, context2);
    }
  };
  var WriteVarExpr = class extends Expression {
    constructor(name, value, type, sourceSpan) {
      super(type || value.type, sourceSpan);
      this.name = name;
      this.value = value;
    }
    isEquivalent(e) {
      return e instanceof WriteVarExpr && this.name === e.name && this.value.isEquivalent(e.value);
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context2) {
      return visitor.visitWriteVarExpr(this, context2);
    }
    toDeclStmt(type, modifiers) {
      return new DeclareVarStmt(this.name, this.value, type, modifiers, this.sourceSpan);
    }
    toConstDecl() {
      return this.toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]);
    }
  };
  var WriteKeyExpr = class extends Expression {
    constructor(receiver, index, value, type, sourceSpan) {
      super(type || value.type, sourceSpan);
      this.receiver = receiver;
      this.index = index;
      this.value = value;
    }
    isEquivalent(e) {
      return e instanceof WriteKeyExpr && this.receiver.isEquivalent(e.receiver) && this.index.isEquivalent(e.index) && this.value.isEquivalent(e.value);
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context2) {
      return visitor.visitWriteKeyExpr(this, context2);
    }
  };
  var WritePropExpr = class extends Expression {
    constructor(receiver, name, value, type, sourceSpan) {
      super(type || value.type, sourceSpan);
      this.receiver = receiver;
      this.name = name;
      this.value = value;
    }
    isEquivalent(e) {
      return e instanceof WritePropExpr && this.receiver.isEquivalent(e.receiver) && this.name === e.name && this.value.isEquivalent(e.value);
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context2) {
      return visitor.visitWritePropExpr(this, context2);
    }
  };
  var BuiltinMethod;
  (function(BuiltinMethod2) {
    BuiltinMethod2[BuiltinMethod2["ConcatArray"] = 0] = "ConcatArray";
    BuiltinMethod2[BuiltinMethod2["SubscribeObservable"] = 1] = "SubscribeObservable";
    BuiltinMethod2[BuiltinMethod2["Bind"] = 2] = "Bind";
  })(BuiltinMethod || (BuiltinMethod = {}));
  var InvokeFunctionExpr = class extends Expression {
    constructor(fn2, args, type, sourceSpan, pure = false) {
      super(type, sourceSpan);
      this.fn = fn2;
      this.args = args;
      this.pure = pure;
    }
    isEquivalent(e) {
      return e instanceof InvokeFunctionExpr && this.fn.isEquivalent(e.fn) && areAllEquivalent(this.args, e.args) && this.pure === e.pure;
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context2) {
      return visitor.visitInvokeFunctionExpr(this, context2);
    }
  };
  var TaggedTemplateExpr = class extends Expression {
    constructor(tag, template, type, sourceSpan) {
      super(type, sourceSpan);
      this.tag = tag;
      this.template = template;
    }
    isEquivalent(e) {
      return e instanceof TaggedTemplateExpr && this.tag.isEquivalent(e.tag) && areAllEquivalentPredicate(this.template.elements, e.template.elements, (a, b) => a.text === b.text) && areAllEquivalent(this.template.expressions, e.template.expressions);
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context2) {
      return visitor.visitTaggedTemplateExpr(this, context2);
    }
  };
  var InstantiateExpr = class extends Expression {
    constructor(classExpr, args, type, sourceSpan) {
      super(type, sourceSpan);
      this.classExpr = classExpr;
      this.args = args;
    }
    isEquivalent(e) {
      return e instanceof InstantiateExpr && this.classExpr.isEquivalent(e.classExpr) && areAllEquivalent(this.args, e.args);
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context2) {
      return visitor.visitInstantiateExpr(this, context2);
    }
  };
  var LiteralExpr = class extends Expression {
    constructor(value, type, sourceSpan) {
      super(type, sourceSpan);
      this.value = value;
    }
    isEquivalent(e) {
      return e instanceof LiteralExpr && this.value === e.value;
    }
    isConstant() {
      return true;
    }
    visitExpression(visitor, context2) {
      return visitor.visitLiteralExpr(this, context2);
    }
  };
  var TemplateLiteral = class {
    constructor(elements, expressions) {
      this.elements = elements;
      this.expressions = expressions;
    }
  };
  var TemplateLiteralElement = class {
    constructor(text, sourceSpan, rawText) {
      this.text = text;
      this.sourceSpan = sourceSpan;
      this.rawText = rawText ?? sourceSpan?.toString() ?? escapeForTemplateLiteral(escapeSlashes(text));
    }
  };
  var MessagePiece = class {
    constructor(text, sourceSpan) {
      this.text = text;
      this.sourceSpan = sourceSpan;
    }
  };
  var LiteralPiece = class extends MessagePiece {
  };
  var PlaceholderPiece = class extends MessagePiece {
  };
  var LocalizedString = class extends Expression {
    constructor(metaBlock, messageParts, placeHolderNames, expressions, sourceSpan) {
      super(STRING_TYPE, sourceSpan);
      this.metaBlock = metaBlock;
      this.messageParts = messageParts;
      this.placeHolderNames = placeHolderNames;
      this.expressions = expressions;
    }
    isEquivalent(e) {
      return false;
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context2) {
      return visitor.visitLocalizedString(this, context2);
    }
    serializeI18nHead() {
      const MEANING_SEPARATOR = "|";
      const ID_SEPARATOR = "@@";
      const LEGACY_ID_INDICATOR = "\u241F";
      let metaBlock = this.metaBlock.description || "";
      if (this.metaBlock.meaning) {
        metaBlock = `${this.metaBlock.meaning}${MEANING_SEPARATOR}${metaBlock}`;
      }
      if (this.metaBlock.customId) {
        metaBlock = `${metaBlock}${ID_SEPARATOR}${this.metaBlock.customId}`;
      }
      if (this.metaBlock.legacyIds) {
        this.metaBlock.legacyIds.forEach((legacyId) => {
          metaBlock = `${metaBlock}${LEGACY_ID_INDICATOR}${legacyId}`;
        });
      }
      return createCookedRawString(metaBlock, this.messageParts[0].text, this.getMessagePartSourceSpan(0));
    }
    getMessagePartSourceSpan(i) {
      return this.messageParts[i]?.sourceSpan ?? this.sourceSpan;
    }
    getPlaceholderSourceSpan(i) {
      return this.placeHolderNames[i]?.sourceSpan ?? this.expressions[i]?.sourceSpan ?? this.sourceSpan;
    }
    serializeI18nTemplatePart(partIndex) {
      const placeholderName = this.placeHolderNames[partIndex - 1].text;
      const messagePart = this.messageParts[partIndex];
      return createCookedRawString(placeholderName, messagePart.text, this.getMessagePartSourceSpan(partIndex));
    }
  };
  var escapeSlashes = (str) => str.replace(/\\/g, "\\\\");
  var escapeStartingColon = (str) => str.replace(/^:/, "\\:");
  var escapeColons = (str) => str.replace(/:/g, "\\:");
  var escapeForTemplateLiteral = (str) => str.replace(/`/g, "\\`").replace(/\${/g, "$\\{");
  function createCookedRawString(metaBlock, messagePart, range) {
    if (metaBlock === "") {
      return {
        cooked: messagePart,
        raw: escapeForTemplateLiteral(escapeStartingColon(escapeSlashes(messagePart))),
        range
      };
    } else {
      return {
        cooked: `:${metaBlock}:${messagePart}`,
        raw: escapeForTemplateLiteral(`:${escapeColons(escapeSlashes(metaBlock))}:${escapeSlashes(messagePart)}`),
        range
      };
    }
  }
  var ExternalExpr = class extends Expression {
    constructor(value, type, typeParams = null, sourceSpan) {
      super(type, sourceSpan);
      this.value = value;
      this.typeParams = typeParams;
    }
    isEquivalent(e) {
      return e instanceof ExternalExpr && this.value.name === e.value.name && this.value.moduleName === e.value.moduleName && this.value.runtime === e.value.runtime;
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context2) {
      return visitor.visitExternalExpr(this, context2);
    }
  };
  var ConditionalExpr = class extends Expression {
    constructor(condition, trueCase, falseCase = null, type, sourceSpan) {
      super(type || trueCase.type, sourceSpan);
      this.condition = condition;
      this.falseCase = falseCase;
      this.trueCase = trueCase;
    }
    isEquivalent(e) {
      return e instanceof ConditionalExpr && this.condition.isEquivalent(e.condition) && this.trueCase.isEquivalent(e.trueCase) && nullSafeIsEquivalent(this.falseCase, e.falseCase);
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context2) {
      return visitor.visitConditionalExpr(this, context2);
    }
  };
  var NotExpr = class extends Expression {
    constructor(condition, sourceSpan) {
      super(BOOL_TYPE, sourceSpan);
      this.condition = condition;
    }
    isEquivalent(e) {
      return e instanceof NotExpr && this.condition.isEquivalent(e.condition);
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context2) {
      return visitor.visitNotExpr(this, context2);
    }
  };
  var AssertNotNull = class extends Expression {
    constructor(condition, sourceSpan) {
      super(condition.type, sourceSpan);
      this.condition = condition;
    }
    isEquivalent(e) {
      return e instanceof AssertNotNull && this.condition.isEquivalent(e.condition);
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context2) {
      return visitor.visitAssertNotNullExpr(this, context2);
    }
  };
  var CastExpr = class extends Expression {
    constructor(value, type, sourceSpan) {
      super(type, sourceSpan);
      this.value = value;
    }
    isEquivalent(e) {
      return e instanceof CastExpr && this.value.isEquivalent(e.value);
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context2) {
      return visitor.visitCastExpr(this, context2);
    }
  };
  var FnParam = class {
    constructor(name, type = null) {
      this.name = name;
      this.type = type;
    }
    isEquivalent(param) {
      return this.name === param.name;
    }
  };
  var FunctionExpr = class extends Expression {
    constructor(params, statements, type, sourceSpan, name) {
      super(type, sourceSpan);
      this.params = params;
      this.statements = statements;
      this.name = name;
    }
    isEquivalent(e) {
      return e instanceof FunctionExpr && areAllEquivalent(this.params, e.params) && areAllEquivalent(this.statements, e.statements);
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context2) {
      return visitor.visitFunctionExpr(this, context2);
    }
    toDeclStmt(name, modifiers) {
      return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers, this.sourceSpan);
    }
  };
  var UnaryOperatorExpr = class extends Expression {
    constructor(operator, expr, type, sourceSpan, parens = true) {
      super(type || NUMBER_TYPE, sourceSpan);
      this.operator = operator;
      this.expr = expr;
      this.parens = parens;
    }
    isEquivalent(e) {
      return e instanceof UnaryOperatorExpr && this.operator === e.operator && this.expr.isEquivalent(e.expr);
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context2) {
      return visitor.visitUnaryOperatorExpr(this, context2);
    }
  };
  var BinaryOperatorExpr = class extends Expression {
    constructor(operator, lhs, rhs, type, sourceSpan, parens = true) {
      super(type || lhs.type, sourceSpan);
      this.operator = operator;
      this.rhs = rhs;
      this.parens = parens;
      this.lhs = lhs;
    }
    isEquivalent(e) {
      return e instanceof BinaryOperatorExpr && this.operator === e.operator && this.lhs.isEquivalent(e.lhs) && this.rhs.isEquivalent(e.rhs);
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context2) {
      return visitor.visitBinaryOperatorExpr(this, context2);
    }
  };
  var ReadPropExpr = class extends Expression {
    constructor(receiver, name, type, sourceSpan) {
      super(type, sourceSpan);
      this.receiver = receiver;
      this.name = name;
    }
    isEquivalent(e) {
      return e instanceof ReadPropExpr && this.receiver.isEquivalent(e.receiver) && this.name === e.name;
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context2) {
      return visitor.visitReadPropExpr(this, context2);
    }
    set(value) {
      return new WritePropExpr(this.receiver, this.name, value, null, this.sourceSpan);
    }
  };
  var ReadKeyExpr = class extends Expression {
    constructor(receiver, index, type, sourceSpan) {
      super(type, sourceSpan);
      this.receiver = receiver;
      this.index = index;
    }
    isEquivalent(e) {
      return e instanceof ReadKeyExpr && this.receiver.isEquivalent(e.receiver) && this.index.isEquivalent(e.index);
    }
    isConstant() {
      return false;
    }
    visitExpression(visitor, context2) {
      return visitor.visitReadKeyExpr(this, context2);
    }
    set(value) {
      return new WriteKeyExpr(this.receiver, this.index, value, null, this.sourceSpan);
    }
  };
  var LiteralArrayExpr = class extends Expression {
    constructor(entries, type, sourceSpan) {
      super(type, sourceSpan);
      this.entries = entries;
    }
    isConstant() {
      return this.entries.every((e) => e.isConstant());
    }
    isEquivalent(e) {
      return e instanceof LiteralArrayExpr && areAllEquivalent(this.entries, e.entries);
    }
    visitExpression(visitor, context2) {
      return visitor.visitLiteralArrayExpr(this, context2);
    }
  };
  var LiteralMapEntry = class {
    constructor(key, value, quoted) {
      this.key = key;
      this.value = value;
      this.quoted = quoted;
    }
    isEquivalent(e) {
      return this.key === e.key && this.value.isEquivalent(e.value);
    }
  };
  var LiteralMapExpr = class extends Expression {
    constructor(entries, type, sourceSpan) {
      super(type, sourceSpan);
      this.entries = entries;
      this.valueType = null;
      if (type) {
        this.valueType = type.valueType;
      }
    }
    isEquivalent(e) {
      return e instanceof LiteralMapExpr && areAllEquivalent(this.entries, e.entries);
    }
    isConstant() {
      return this.entries.every((e) => e.value.isConstant());
    }
    visitExpression(visitor, context2) {
      return visitor.visitLiteralMapExpr(this, context2);
    }
  };
  var THIS_EXPR = new ReadVarExpr(BuiltinVar.This, null, null);
  var SUPER_EXPR = new ReadVarExpr(BuiltinVar.Super, null, null);
  var CATCH_ERROR_VAR$2 = new ReadVarExpr(BuiltinVar.CatchError, null, null);
  var CATCH_STACK_VAR$2 = new ReadVarExpr(BuiltinVar.CatchStack, null, null);
  var NULL_EXPR = new LiteralExpr(null, null, null);
  var TYPED_NULL_EXPR = new LiteralExpr(null, INFERRED_TYPE, null);
  var StmtModifier;
  (function(StmtModifier2) {
    StmtModifier2[StmtModifier2["Final"] = 0] = "Final";
    StmtModifier2[StmtModifier2["Private"] = 1] = "Private";
    StmtModifier2[StmtModifier2["Exported"] = 2] = "Exported";
    StmtModifier2[StmtModifier2["Static"] = 3] = "Static";
  })(StmtModifier || (StmtModifier = {}));
  var LeadingComment = class {
    constructor(text, multiline, trailingNewline) {
      this.text = text;
      this.multiline = multiline;
      this.trailingNewline = trailingNewline;
    }
    toString() {
      return this.multiline ? ` ${this.text} ` : this.text;
    }
  };
  var JSDocComment = class extends LeadingComment {
    constructor(tags) {
      super("", true, true);
      this.tags = tags;
    }
    toString() {
      return serializeTags(this.tags);
    }
  };
  var Statement = class {
    constructor(modifiers = [], sourceSpan = null, leadingComments) {
      this.modifiers = modifiers;
      this.sourceSpan = sourceSpan;
      this.leadingComments = leadingComments;
    }
    hasModifier(modifier) {
      return this.modifiers.indexOf(modifier) !== -1;
    }
    addLeadingComment(leadingComment) {
      this.leadingComments = this.leadingComments ?? [];
      this.leadingComments.push(leadingComment);
    }
  };
  var DeclareVarStmt = class extends Statement {
    constructor(name, value, type, modifiers, sourceSpan, leadingComments) {
      super(modifiers, sourceSpan, leadingComments);
      this.name = name;
      this.value = value;
      this.type = type || value && value.type || null;
    }
    isEquivalent(stmt) {
      return stmt instanceof DeclareVarStmt && this.name === stmt.name && (this.value ? !!stmt.value && this.value.isEquivalent(stmt.value) : !stmt.value);
    }
    visitStatement(visitor, context2) {
      return visitor.visitDeclareVarStmt(this, context2);
    }
  };
  var DeclareFunctionStmt = class extends Statement {
    constructor(name, params, statements, type, modifiers, sourceSpan, leadingComments) {
      super(modifiers, sourceSpan, leadingComments);
      this.name = name;
      this.params = params;
      this.statements = statements;
      this.type = type || null;
    }
    isEquivalent(stmt) {
      return stmt instanceof DeclareFunctionStmt && areAllEquivalent(this.params, stmt.params) && areAllEquivalent(this.statements, stmt.statements);
    }
    visitStatement(visitor, context2) {
      return visitor.visitDeclareFunctionStmt(this, context2);
    }
  };
  var ExpressionStatement = class extends Statement {
    constructor(expr, sourceSpan, leadingComments) {
      super([], sourceSpan, leadingComments);
      this.expr = expr;
    }
    isEquivalent(stmt) {
      return stmt instanceof ExpressionStatement && this.expr.isEquivalent(stmt.expr);
    }
    visitStatement(visitor, context2) {
      return visitor.visitExpressionStmt(this, context2);
    }
  };
  var ReturnStatement = class extends Statement {
    constructor(value, sourceSpan = null, leadingComments) {
      super([], sourceSpan, leadingComments);
      this.value = value;
    }
    isEquivalent(stmt) {
      return stmt instanceof ReturnStatement && this.value.isEquivalent(stmt.value);
    }
    visitStatement(visitor, context2) {
      return visitor.visitReturnStmt(this, context2);
    }
  };
  var IfStmt = class extends Statement {
    constructor(condition, trueCase, falseCase = [], sourceSpan, leadingComments) {
      super([], sourceSpan, leadingComments);
      this.condition = condition;
      this.trueCase = trueCase;
      this.falseCase = falseCase;
    }
    isEquivalent(stmt) {
      return stmt instanceof IfStmt && this.condition.isEquivalent(stmt.condition) && areAllEquivalent(this.trueCase, stmt.trueCase) && areAllEquivalent(this.falseCase, stmt.falseCase);
    }
    visitStatement(visitor, context2) {
      return visitor.visitIfStmt(this, context2);
    }
  };
  function jsDocComment(tags = []) {
    return new JSDocComment(tags);
  }
  function variable(name, type, sourceSpan) {
    return new ReadVarExpr(name, type, sourceSpan);
  }
  function importExpr(id, typeParams = null, sourceSpan) {
    return new ExternalExpr(id, null, typeParams, sourceSpan);
  }
  function expressionType(expr, typeModifiers, typeParams) {
    return new ExpressionType(expr, typeModifiers, typeParams);
  }
  function typeofExpr(expr) {
    return new TypeofExpr(expr);
  }
  function literalArr(values, type, sourceSpan) {
    return new LiteralArrayExpr(values, type, sourceSpan);
  }
  function literalMap(values, type = null) {
    return new LiteralMapExpr(values.map((e) => new LiteralMapEntry(e.key, e.value, e.quoted)), type, null);
  }
  function not(expr, sourceSpan) {
    return new NotExpr(expr, sourceSpan);
  }
  function assertNotNull(expr, sourceSpan) {
    return new AssertNotNull(expr, sourceSpan);
  }
  function fn(params, body, type, sourceSpan, name) {
    return new FunctionExpr(params, body, type, sourceSpan, name);
  }
  function ifStmt(condition, thenClause, elseClause, sourceSpan, leadingComments) {
    return new IfStmt(condition, thenClause, elseClause, sourceSpan, leadingComments);
  }
  function taggedTemplate(tag, template, type, sourceSpan) {
    return new TaggedTemplateExpr(tag, template, type, sourceSpan);
  }
  function literal(value, type, sourceSpan) {
    return new LiteralExpr(value, type, sourceSpan);
  }
  function localizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan) {
    return new LocalizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan);
  }
  function isNull(exp) {
    return exp instanceof LiteralExpr && exp.value === null;
  }
  function tagToString(tag) {
    let out = "";
    if (tag.tagName) {
      out += ` @${tag.tagName}`;
    }
    if (tag.text) {
      if (tag.text.match(/\/\*|\*\//)) {
        throw new Error('JSDoc text cannot contain "/*" and "*/"');
      }
      out += " " + tag.text.replace(/@/g, "\\@");
    }
    return out;
  }
  function serializeTags(tags) {
    if (tags.length === 0)
      return "";
    if (tags.length === 1 && tags[0].tagName && !tags[0].text) {
      return `*${tagToString(tags[0])} `;
    }
    let out = "*\n";
    for (const tag of tags) {
      out += " *";
      out += tagToString(tag).replace(/\n/g, "\n * ");
      out += "\n";
    }
    out += " ";
    return out;
  }
  var CONSTANT_PREFIX = "_c";
  var UNKNOWN_VALUE_KEY = variable("<unknown>");
  var KEY_CONTEXT = {};
  var POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS = 50;
  var FixupExpression = class extends Expression {
    constructor(resolved) {
      super(resolved.type);
      this.resolved = resolved;
      this.original = resolved;
    }
    visitExpression(visitor, context2) {
      if (context2 === KEY_CONTEXT) {
        return this.original.visitExpression(visitor, context2);
      } else {
        return this.resolved.visitExpression(visitor, context2);
      }
    }
    isEquivalent(e) {
      return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);
    }
    isConstant() {
      return true;
    }
    fixup(expression) {
      this.resolved = expression;
      this.shared = true;
    }
  };
  var ConstantPool = class {
    constructor(isClosureCompilerEnabled = false) {
      this.isClosureCompilerEnabled = isClosureCompilerEnabled;
      this.statements = [];
      this.literals = /* @__PURE__ */ new Map();
      this.literalFactories = /* @__PURE__ */ new Map();
      this.injectorDefinitions = /* @__PURE__ */ new Map();
      this.directiveDefinitions = /* @__PURE__ */ new Map();
      this.componentDefinitions = /* @__PURE__ */ new Map();
      this.pipeDefinitions = /* @__PURE__ */ new Map();
      this.nextNameIndex = 0;
    }
    getConstLiteral(literal2, forceShared) {
      if (literal2 instanceof LiteralExpr && !isLongStringLiteral(literal2) || literal2 instanceof FixupExpression) {
        return literal2;
      }
      const key = this.keyOf(literal2);
      let fixup = this.literals.get(key);
      let newValue = false;
      if (!fixup) {
        fixup = new FixupExpression(literal2);
        this.literals.set(key, fixup);
        newValue = true;
      }
      if (!newValue && !fixup.shared || newValue && forceShared) {
        const name = this.freshName();
        let definition;
        let usage;
        if (this.isClosureCompilerEnabled && isLongStringLiteral(literal2)) {
          definition = variable(name).set(new FunctionExpr([], [
            new ReturnStatement(literal2)
          ]));
          usage = variable(name).callFn([]);
        } else {
          definition = variable(name).set(literal2);
          usage = variable(name);
        }
        this.statements.push(definition.toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]));
        fixup.fixup(usage);
      }
      return fixup;
    }
    getDefinition(type, kind, ctx, forceShared = false) {
      const definitions = this.definitionsOf(kind);
      let fixup = definitions.get(type);
      let newValue = false;
      if (!fixup) {
        const property = this.propertyNameOf(kind);
        fixup = new FixupExpression(ctx.importExpr(type).prop(property));
        definitions.set(type, fixup);
        newValue = true;
      }
      if (!newValue && !fixup.shared || newValue && forceShared) {
        const name = this.freshName();
        this.statements.push(variable(name).set(fixup.resolved).toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]));
        fixup.fixup(variable(name));
      }
      return fixup;
    }
    getLiteralFactory(literal2) {
      if (literal2 instanceof LiteralArrayExpr) {
        const argumentsForKey = literal2.entries.map((e) => e.isConstant() ? e : UNKNOWN_VALUE_KEY);
        const key = this.keyOf(literalArr(argumentsForKey));
        return this._getLiteralFactory(key, literal2.entries, (entries) => literalArr(entries));
      } else {
        const expressionForKey = literalMap(literal2.entries.map((e) => ({
          key: e.key,
          value: e.value.isConstant() ? e.value : UNKNOWN_VALUE_KEY,
          quoted: e.quoted
        })));
        const key = this.keyOf(expressionForKey);
        return this._getLiteralFactory(key, literal2.entries.map((e) => e.value), (entries) => literalMap(entries.map((value, index) => ({
          key: literal2.entries[index].key,
          value,
          quoted: literal2.entries[index].quoted
        }))));
      }
    }
    _getLiteralFactory(key, values, resultMap) {
      let literalFactory = this.literalFactories.get(key);
      const literalFactoryArguments = values.filter((e) => !e.isConstant());
      if (!literalFactory) {
        const resultExpressions = values.map((e, index) => e.isConstant() ? this.getConstLiteral(e, true) : variable(`a${index}`));
        const parameters = resultExpressions.filter(isVariable).map((e) => new FnParam(e.name, DYNAMIC_TYPE));
        const pureFunctionDeclaration = fn(parameters, [new ReturnStatement(resultMap(resultExpressions))], INFERRED_TYPE);
        const name = this.freshName();
        this.statements.push(variable(name).set(pureFunctionDeclaration).toDeclStmt(INFERRED_TYPE, [
          StmtModifier.Final
        ]));
        literalFactory = variable(name);
        this.literalFactories.set(key, literalFactory);
      }
      return { literalFactory, literalFactoryArguments };
    }
    uniqueName(prefix) {
      return `${prefix}${this.nextNameIndex++}`;
    }
    definitionsOf(kind) {
      switch (kind) {
        case 2:
          return this.componentDefinitions;
        case 1:
          return this.directiveDefinitions;
        case 0:
          return this.injectorDefinitions;
        case 3:
          return this.pipeDefinitions;
      }
    }
    propertyNameOf(kind) {
      switch (kind) {
        case 2:
          return "\u0275cmp";
        case 1:
          return "\u0275dir";
        case 0:
          return "\u0275inj";
        case 3:
          return "\u0275pipe";
      }
    }
    freshName() {
      return this.uniqueName(CONSTANT_PREFIX);
    }
    keyOf(expression) {
      return expression.visitExpression(new KeyVisitor(), KEY_CONTEXT);
    }
  };
  var KeyVisitor = class {
    constructor() {
      this.visitWrappedNodeExpr = invalid$1;
      this.visitWriteVarExpr = invalid$1;
      this.visitWriteKeyExpr = invalid$1;
      this.visitWritePropExpr = invalid$1;
      this.visitInvokeFunctionExpr = invalid$1;
      this.visitTaggedTemplateExpr = invalid$1;
      this.visitInstantiateExpr = invalid$1;
      this.visitConditionalExpr = invalid$1;
      this.visitNotExpr = invalid$1;
      this.visitAssertNotNullExpr = invalid$1;
      this.visitCastExpr = invalid$1;
      this.visitFunctionExpr = invalid$1;
      this.visitUnaryOperatorExpr = invalid$1;
      this.visitBinaryOperatorExpr = invalid$1;
      this.visitReadPropExpr = invalid$1;
      this.visitReadKeyExpr = invalid$1;
      this.visitCommaExpr = invalid$1;
      this.visitLocalizedString = invalid$1;
    }
    visitLiteralExpr(ast) {
      return `${typeof ast.value === "string" ? '"' + ast.value + '"' : ast.value}`;
    }
    visitLiteralArrayExpr(ast, context2) {
      return `[${ast.entries.map((entry) => entry.visitExpression(this, context2)).join(",")}]`;
    }
    visitLiteralMapExpr(ast, context2) {
      const mapKey = (entry) => {
        const quote = entry.quoted ? '"' : "";
        return `${quote}${entry.key}${quote}`;
      };
      const mapEntry = (entry) => `${mapKey(entry)}:${entry.value.visitExpression(this, context2)}`;
      return `{${ast.entries.map(mapEntry).join(",")}`;
    }
    visitExternalExpr(ast) {
      return ast.value.moduleName ? `EX:${ast.value.moduleName}:${ast.value.name}` : `EX:${ast.value.runtime.name}`;
    }
    visitReadVarExpr(node) {
      return `VAR:${node.name}`;
    }
    visitTypeofExpr(node, context2) {
      return `TYPEOF:${node.expr.visitExpression(this, context2)}`;
    }
  };
  function invalid$1(arg) {
    throw new Error(`Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);
  }
  function isVariable(e) {
    return e instanceof ReadVarExpr;
  }
  function isLongStringLiteral(expr) {
    return expr instanceof LiteralExpr && typeof expr.value === "string" && expr.value.length >= POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS;
  }
  var CORE$1 = "@angular/core";
  var Identifiers$1 = class {
  };
  Identifiers$1.NEW_METHOD = "factory";
  Identifiers$1.TRANSFORM_METHOD = "transform";
  Identifiers$1.PATCH_DEPS = "patchedDeps";
  Identifiers$1.core = { name: null, moduleName: CORE$1 };
  Identifiers$1.namespaceHTML = { name: "\u0275\u0275namespaceHTML", moduleName: CORE$1 };
  Identifiers$1.namespaceMathML = { name: "\u0275\u0275namespaceMathML", moduleName: CORE$1 };
  Identifiers$1.namespaceSVG = { name: "\u0275\u0275namespaceSVG", moduleName: CORE$1 };
  Identifiers$1.element = { name: "\u0275\u0275element", moduleName: CORE$1 };
  Identifiers$1.elementStart = { name: "\u0275\u0275elementStart", moduleName: CORE$1 };
  Identifiers$1.elementEnd = { name: "\u0275\u0275elementEnd", moduleName: CORE$1 };
  Identifiers$1.advance = { name: "\u0275\u0275advance", moduleName: CORE$1 };
  Identifiers$1.syntheticHostProperty = { name: "\u0275\u0275syntheticHostProperty", moduleName: CORE$1 };
  Identifiers$1.syntheticHostListener = { name: "\u0275\u0275syntheticHostListener", moduleName: CORE$1 };
  Identifiers$1.attribute = { name: "\u0275\u0275attribute", moduleName: CORE$1 };
  Identifiers$1.attributeInterpolate1 = { name: "\u0275\u0275attributeInterpolate1", moduleName: CORE$1 };
  Identifiers$1.attributeInterpolate2 = { name: "\u0275\u0275attributeInterpolate2", moduleName: CORE$1 };
  Identifiers$1.attributeInterpolate3 = { name: "\u0275\u0275attributeInterpolate3", moduleName: CORE$1 };
  Identifiers$1.attributeInterpolate4 = { name: "\u0275\u0275attributeInterpolate4", moduleName: CORE$1 };
  Identifiers$1.attributeInterpolate5 = { name: "\u0275\u0275attributeInterpolate5", moduleName: CORE$1 };
  Identifiers$1.attributeInterpolate6 = { name: "\u0275\u0275attributeInterpolate6", moduleName: CORE$1 };
  Identifiers$1.attributeInterpolate7 = { name: "\u0275\u0275attributeInterpolate7", moduleName: CORE$1 };
  Identifiers$1.attributeInterpolate8 = { name: "\u0275\u0275attributeInterpolate8", moduleName: CORE$1 };
  Identifiers$1.attributeInterpolateV = { name: "\u0275\u0275attributeInterpolateV", moduleName: CORE$1 };
  Identifiers$1.classProp = { name: "\u0275\u0275classProp", moduleName: CORE$1 };
  Identifiers$1.elementContainerStart = { name: "\u0275\u0275elementContainerStart", moduleName: CORE$1 };
  Identifiers$1.elementContainerEnd = { name: "\u0275\u0275elementContainerEnd", moduleName: CORE$1 };
  Identifiers$1.elementContainer = { name: "\u0275\u0275elementContainer", moduleName: CORE$1 };
  Identifiers$1.styleMap = { name: "\u0275\u0275styleMap", moduleName: CORE$1 };
  Identifiers$1.styleMapInterpolate1 = { name: "\u0275\u0275styleMapInterpolate1", moduleName: CORE$1 };
  Identifiers$1.styleMapInterpolate2 = { name: "\u0275\u0275styleMapInterpolate2", moduleName: CORE$1 };
  Identifiers$1.styleMapInterpolate3 = { name: "\u0275\u0275styleMapInterpolate3", moduleName: CORE$1 };
  Identifiers$1.styleMapInterpolate4 = { name: "\u0275\u0275styleMapInterpolate4", moduleName: CORE$1 };
  Identifiers$1.styleMapInterpolate5 = { name: "\u0275\u0275styleMapInterpolate5", moduleName: CORE$1 };
  Identifiers$1.styleMapInterpolate6 = { name: "\u0275\u0275styleMapInterpolate6", moduleName: CORE$1 };
  Identifiers$1.styleMapInterpolate7 = { name: "\u0275\u0275styleMapInterpolate7", moduleName: CORE$1 };
  Identifiers$1.styleMapInterpolate8 = { name: "\u0275\u0275styleMapInterpolate8", moduleName: CORE$1 };
  Identifiers$1.styleMapInterpolateV = { name: "\u0275\u0275styleMapInterpolateV", moduleName: CORE$1 };
  Identifiers$1.classMap = { name: "\u0275\u0275classMap", moduleName: CORE$1 };
  Identifiers$1.classMapInterpolate1 = { name: "\u0275\u0275classMapInterpolate1", moduleName: CORE$1 };
  Identifiers$1.classMapInterpolate2 = { name: "\u0275\u0275classMapInterpolate2", moduleName: CORE$1 };
  Identifiers$1.classMapInterpolate3 = { name: "\u0275\u0275classMapInterpolate3", moduleName: CORE$1 };
  Identifiers$1.classMapInterpolate4 = { name: "\u0275\u0275classMapInterpolate4", moduleName: CORE$1 };
  Identifiers$1.classMapInterpolate5 = { name: "\u0275\u0275classMapInterpolate5", moduleName: CORE$1 };
  Identifiers$1.classMapInterpolate6 = { name: "\u0275\u0275classMapInterpolate6", moduleName: CORE$1 };
  Identifiers$1.classMapInterpolate7 = { name: "\u0275\u0275classMapInterpolate7", moduleName: CORE$1 };
  Identifiers$1.classMapInterpolate8 = { name: "\u0275\u0275classMapInterpolate8", moduleName: CORE$1 };
  Identifiers$1.classMapInterpolateV = { name: "\u0275\u0275classMapInterpolateV", moduleName: CORE$1 };
  Identifiers$1.styleProp = { name: "\u0275\u0275styleProp", moduleName: CORE$1 };
  Identifiers$1.stylePropInterpolate1 = { name: "\u0275\u0275stylePropInterpolate1", moduleName: CORE$1 };
  Identifiers$1.stylePropInterpolate2 = { name: "\u0275\u0275stylePropInterpolate2", moduleName: CORE$1 };
  Identifiers$1.stylePropInterpolate3 = { name: "\u0275\u0275stylePropInterpolate3", moduleName: CORE$1 };
  Identifiers$1.stylePropInterpolate4 = { name: "\u0275\u0275stylePropInterpolate4", moduleName: CORE$1 };
  Identifiers$1.stylePropInterpolate5 = { name: "\u0275\u0275stylePropInterpolate5", moduleName: CORE$1 };
  Identifiers$1.stylePropInterpolate6 = { name: "\u0275\u0275stylePropInterpolate6", moduleName: CORE$1 };
  Identifiers$1.stylePropInterpolate7 = { name: "\u0275\u0275stylePropInterpolate7", moduleName: CORE$1 };
  Identifiers$1.stylePropInterpolate8 = { name: "\u0275\u0275stylePropInterpolate8", moduleName: CORE$1 };
  Identifiers$1.stylePropInterpolateV = { name: "\u0275\u0275stylePropInterpolateV", moduleName: CORE$1 };
  Identifiers$1.nextContext = { name: "\u0275\u0275nextContext", moduleName: CORE$1 };
  Identifiers$1.templateCreate = { name: "\u0275\u0275template", moduleName: CORE$1 };
  Identifiers$1.text = { name: "\u0275\u0275text", moduleName: CORE$1 };
  Identifiers$1.enableBindings = { name: "\u0275\u0275enableBindings", moduleName: CORE$1 };
  Identifiers$1.disableBindings = { name: "\u0275\u0275disableBindings", moduleName: CORE$1 };
  Identifiers$1.getCurrentView = { name: "\u0275\u0275getCurrentView", moduleName: CORE$1 };
  Identifiers$1.textInterpolate = { name: "\u0275\u0275textInterpolate", moduleName: CORE$1 };
  Identifiers$1.textInterpolate1 = { name: "\u0275\u0275textInterpolate1", moduleName: CORE$1 };
  Identifiers$1.textInterpolate2 = { name: "\u0275\u0275textInterpolate2", moduleName: CORE$1 };
  Identifiers$1.textInterpolate3 = { name: "\u0275\u0275textInterpolate3", moduleName: CORE$1 };
  Identifiers$1.textInterpolate4 = { name: "\u0275\u0275textInterpolate4", moduleName: CORE$1 };
  Identifiers$1.textInterpolate5 = { name: "\u0275\u0275textInterpolate5", moduleName: CORE$1 };
  Identifiers$1.textInterpolate6 = { name: "\u0275\u0275textInterpolate6", moduleName: CORE$1 };
  Identifiers$1.textInterpolate7 = { name: "\u0275\u0275textInterpolate7", moduleName: CORE$1 };
  Identifiers$1.textInterpolate8 = { name: "\u0275\u0275textInterpolate8", moduleName: CORE$1 };
  Identifiers$1.textInterpolateV = { name: "\u0275\u0275textInterpolateV", moduleName: CORE$1 };
  Identifiers$1.restoreView = { name: "\u0275\u0275restoreView", moduleName: CORE$1 };
  Identifiers$1.pureFunction0 = { name: "\u0275\u0275pureFunction0", moduleName: CORE$1 };
  Identifiers$1.pureFunction1 = { name: "\u0275\u0275pureFunction1", moduleName: CORE$1 };
  Identifiers$1.pureFunction2 = { name: "\u0275\u0275pureFunction2", moduleName: CORE$1 };
  Identifiers$1.pureFunction3 = { name: "\u0275\u0275pureFunction3", moduleName: CORE$1 };
  Identifiers$1.pureFunction4 = { name: "\u0275\u0275pureFunction4", moduleName: CORE$1 };
  Identifiers$1.pureFunction5 = { name: "\u0275\u0275pureFunction5", moduleName: CORE$1 };
  Identifiers$1.pureFunction6 = { name: "\u0275\u0275pureFunction6", moduleName: CORE$1 };
  Identifiers$1.pureFunction7 = { name: "\u0275\u0275pureFunction7", moduleName: CORE$1 };
  Identifiers$1.pureFunction8 = { name: "\u0275\u0275pureFunction8", moduleName: CORE$1 };
  Identifiers$1.pureFunctionV = { name: "\u0275\u0275pureFunctionV", moduleName: CORE$1 };
  Identifiers$1.pipeBind1 = { name: "\u0275\u0275pipeBind1", moduleName: CORE$1 };
  Identifiers$1.pipeBind2 = { name: "\u0275\u0275pipeBind2", moduleName: CORE$1 };
  Identifiers$1.pipeBind3 = { name: "\u0275\u0275pipeBind3", moduleName: CORE$1 };
  Identifiers$1.pipeBind4 = { name: "\u0275\u0275pipeBind4", moduleName: CORE$1 };
  Identifiers$1.pipeBindV = { name: "\u0275\u0275pipeBindV", moduleName: CORE$1 };
  Identifiers$1.hostProperty = { name: "\u0275\u0275hostProperty", moduleName: CORE$1 };
  Identifiers$1.property = { name: "\u0275\u0275property", moduleName: CORE$1 };
  Identifiers$1.propertyInterpolate = { name: "\u0275\u0275propertyInterpolate", moduleName: CORE$1 };
  Identifiers$1.propertyInterpolate1 = { name: "\u0275\u0275propertyInterpolate1", moduleName: CORE$1 };
  Identifiers$1.propertyInterpolate2 = { name: "\u0275\u0275propertyInterpolate2", moduleName: CORE$1 };
  Identifiers$1.propertyInterpolate3 = { name: "\u0275\u0275propertyInterpolate3", moduleName: CORE$1 };
  Identifiers$1.propertyInterpolate4 = { name: "\u0275\u0275propertyInterpolate4", moduleName: CORE$1 };
  Identifiers$1.propertyInterpolate5 = { name: "\u0275\u0275propertyInterpolate5", moduleName: CORE$1 };
  Identifiers$1.propertyInterpolate6 = { name: "\u0275\u0275propertyInterpolate6", moduleName: CORE$1 };
  Identifiers$1.propertyInterpolate7 = { name: "\u0275\u0275propertyInterpolate7", moduleName: CORE$1 };
  Identifiers$1.propertyInterpolate8 = { name: "\u0275\u0275propertyInterpolate8", moduleName: CORE$1 };
  Identifiers$1.propertyInterpolateV = { name: "\u0275\u0275propertyInterpolateV", moduleName: CORE$1 };
  Identifiers$1.i18n = { name: "\u0275\u0275i18n", moduleName: CORE$1 };
  Identifiers$1.i18nAttributes = { name: "\u0275\u0275i18nAttributes", moduleName: CORE$1 };
  Identifiers$1.i18nExp = { name: "\u0275\u0275i18nExp", moduleName: CORE$1 };
  Identifiers$1.i18nStart = { name: "\u0275\u0275i18nStart", moduleName: CORE$1 };
  Identifiers$1.i18nEnd = { name: "\u0275\u0275i18nEnd", moduleName: CORE$1 };
  Identifiers$1.i18nApply = { name: "\u0275\u0275i18nApply", moduleName: CORE$1 };
  Identifiers$1.i18nPostprocess = { name: "\u0275\u0275i18nPostprocess", moduleName: CORE$1 };
  Identifiers$1.pipe = { name: "\u0275\u0275pipe", moduleName: CORE$1 };
  Identifiers$1.projection = { name: "\u0275\u0275projection", moduleName: CORE$1 };
  Identifiers$1.projectionDef = { name: "\u0275\u0275projectionDef", moduleName: CORE$1 };
  Identifiers$1.reference = { name: "\u0275\u0275reference", moduleName: CORE$1 };
  Identifiers$1.inject = { name: "\u0275\u0275inject", moduleName: CORE$1 };
  Identifiers$1.injectAttribute = { name: "\u0275\u0275injectAttribute", moduleName: CORE$1 };
  Identifiers$1.directiveInject = { name: "\u0275\u0275directiveInject", moduleName: CORE$1 };
  Identifiers$1.invalidFactory = { name: "\u0275\u0275invalidFactory", moduleName: CORE$1 };
  Identifiers$1.invalidFactoryDep = { name: "\u0275\u0275invalidFactoryDep", moduleName: CORE$1 };
  Identifiers$1.templateRefExtractor = { name: "\u0275\u0275templateRefExtractor", moduleName: CORE$1 };
  Identifiers$1.forwardRef = { name: "forwardRef", moduleName: CORE$1 };
  Identifiers$1.resolveForwardRef = { name: "resolveForwardRef", moduleName: CORE$1 };
  Identifiers$1.\u0275\u0275defineInjectable = { name: "\u0275\u0275defineInjectable", moduleName: CORE$1 };
  Identifiers$1.declareInjectable = { name: "\u0275\u0275ngDeclareInjectable", moduleName: CORE$1 };
  Identifiers$1.InjectableDeclaration = { name: "\u0275\u0275InjectableDeclaration", moduleName: CORE$1 };
  Identifiers$1.resolveWindow = { name: "\u0275\u0275resolveWindow", moduleName: CORE$1 };
  Identifiers$1.resolveDocument = { name: "\u0275\u0275resolveDocument", moduleName: CORE$1 };
  Identifiers$1.resolveBody = { name: "\u0275\u0275resolveBody", moduleName: CORE$1 };
  Identifiers$1.defineComponent = { name: "\u0275\u0275defineComponent", moduleName: CORE$1 };
  Identifiers$1.declareComponent = { name: "\u0275\u0275ngDeclareComponent", moduleName: CORE$1 };
  Identifiers$1.setComponentScope = { name: "\u0275\u0275setComponentScope", moduleName: CORE$1 };
  Identifiers$1.ChangeDetectionStrategy = {
    name: "ChangeDetectionStrategy",
    moduleName: CORE$1
  };
  Identifiers$1.ViewEncapsulation = {
    name: "ViewEncapsulation",
    moduleName: CORE$1
  };
  Identifiers$1.ComponentDeclaration = {
    name: "\u0275\u0275ComponentDeclaration",
    moduleName: CORE$1
  };
  Identifiers$1.FactoryDeclaration = {
    name: "\u0275\u0275FactoryDeclaration",
    moduleName: CORE$1
  };
  Identifiers$1.declareFactory = { name: "\u0275\u0275ngDeclareFactory", moduleName: CORE$1 };
  Identifiers$1.FactoryTarget = { name: "\u0275\u0275FactoryTarget", moduleName: CORE$1 };
  Identifiers$1.defineDirective = { name: "\u0275\u0275defineDirective", moduleName: CORE$1 };
  Identifiers$1.declareDirective = { name: "\u0275\u0275ngDeclareDirective", moduleName: CORE$1 };
  Identifiers$1.DirectiveDeclaration = {
    name: "\u0275\u0275DirectiveDeclaration",
    moduleName: CORE$1
  };
  Identifiers$1.InjectorDef = { name: "\u0275\u0275InjectorDef", moduleName: CORE$1 };
  Identifiers$1.InjectorDeclaration = { name: "\u0275\u0275InjectorDeclaration", moduleName: CORE$1 };
  Identifiers$1.defineInjector = { name: "\u0275\u0275defineInjector", moduleName: CORE$1 };
  Identifiers$1.declareInjector = { name: "\u0275\u0275ngDeclareInjector", moduleName: CORE$1 };
  Identifiers$1.NgModuleDeclaration = {
    name: "\u0275\u0275NgModuleDeclaration",
    moduleName: CORE$1
  };
  Identifiers$1.ModuleWithProviders = {
    name: "ModuleWithProviders",
    moduleName: CORE$1
  };
  Identifiers$1.defineNgModule = { name: "\u0275\u0275defineNgModule", moduleName: CORE$1 };
  Identifiers$1.declareNgModule = { name: "\u0275\u0275ngDeclareNgModule", moduleName: CORE$1 };
  Identifiers$1.setNgModuleScope = { name: "\u0275\u0275setNgModuleScope", moduleName: CORE$1 };
  Identifiers$1.PipeDeclaration = { name: "\u0275\u0275PipeDeclaration", moduleName: CORE$1 };
  Identifiers$1.definePipe = { name: "\u0275\u0275definePipe", moduleName: CORE$1 };
  Identifiers$1.declarePipe = { name: "\u0275\u0275ngDeclarePipe", moduleName: CORE$1 };
  Identifiers$1.declareClassMetadata = { name: "\u0275\u0275ngDeclareClassMetadata", moduleName: CORE$1 };
  Identifiers$1.setClassMetadata = { name: "\u0275setClassMetadata", moduleName: CORE$1 };
  Identifiers$1.queryRefresh = { name: "\u0275\u0275queryRefresh", moduleName: CORE$1 };
  Identifiers$1.viewQuery = { name: "\u0275\u0275viewQuery", moduleName: CORE$1 };
  Identifiers$1.loadQuery = { name: "\u0275\u0275loadQuery", moduleName: CORE$1 };
  Identifiers$1.contentQuery = { name: "\u0275\u0275contentQuery", moduleName: CORE$1 };
  Identifiers$1.NgOnChangesFeature = { name: "\u0275\u0275NgOnChangesFeature", moduleName: CORE$1 };
  Identifiers$1.InheritDefinitionFeature = { name: "\u0275\u0275InheritDefinitionFeature", moduleName: CORE$1 };
  Identifiers$1.CopyDefinitionFeature = { name: "\u0275\u0275CopyDefinitionFeature", moduleName: CORE$1 };
  Identifiers$1.ProvidersFeature = { name: "\u0275\u0275ProvidersFeature", moduleName: CORE$1 };
  Identifiers$1.listener = { name: "\u0275\u0275listener", moduleName: CORE$1 };
  Identifiers$1.getInheritedFactory = {
    name: "\u0275\u0275getInheritedFactory",
    moduleName: CORE$1
  };
  Identifiers$1.sanitizeHtml = { name: "\u0275\u0275sanitizeHtml", moduleName: CORE$1 };
  Identifiers$1.sanitizeStyle = { name: "\u0275\u0275sanitizeStyle", moduleName: CORE$1 };
  Identifiers$1.sanitizeResourceUrl = { name: "\u0275\u0275sanitizeResourceUrl", moduleName: CORE$1 };
  Identifiers$1.sanitizeScript = { name: "\u0275\u0275sanitizeScript", moduleName: CORE$1 };
  Identifiers$1.sanitizeUrl = { name: "\u0275\u0275sanitizeUrl", moduleName: CORE$1 };
  Identifiers$1.sanitizeUrlOrResourceUrl = { name: "\u0275\u0275sanitizeUrlOrResourceUrl", moduleName: CORE$1 };
  Identifiers$1.trustConstantHtml = { name: "\u0275\u0275trustConstantHtml", moduleName: CORE$1 };
  Identifiers$1.trustConstantResourceUrl = { name: "\u0275\u0275trustConstantResourceUrl", moduleName: CORE$1 };
  var DASH_CASE_REGEXP = /-+([a-z0-9])/g;
  function dashCaseToCamelCase(input) {
    return input.replace(DASH_CASE_REGEXP, (...m) => m[1].toUpperCase());
  }
  function splitAtColon(input, defaultValues) {
    return _splitAt(input, ":", defaultValues);
  }
  function splitAtPeriod(input, defaultValues) {
    return _splitAt(input, ".", defaultValues);
  }
  function _splitAt(input, character, defaultValues) {
    const characterIndex = input.indexOf(character);
    if (characterIndex == -1)
      return defaultValues;
    return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];
  }
  function noUndefined(val) {
    return val === void 0 ? null : val;
  }
  function error2(msg) {
    throw new Error(`Internal Error: ${msg}`);
  }
  var STRING_MAP_PROTO = Object.getPrototypeOf({});
  function utf8Encode(str) {
    let encoded = [];
    for (let index = 0; index < str.length; index++) {
      let codePoint = str.charCodeAt(index);
      if (codePoint >= 55296 && codePoint <= 56319 && str.length > index + 1) {
        const low = str.charCodeAt(index + 1);
        if (low >= 56320 && low <= 57343) {
          index++;
          codePoint = (codePoint - 55296 << 10) + low - 56320 + 65536;
        }
      }
      if (codePoint <= 127) {
        encoded.push(codePoint);
      } else if (codePoint <= 2047) {
        encoded.push(codePoint >> 6 & 31 | 192, codePoint & 63 | 128);
      } else if (codePoint <= 65535) {
        encoded.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint <= 2097151) {
        encoded.push(codePoint >> 18 & 7 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      }
    }
    return encoded;
  }
  function stringify2(token) {
    if (typeof token === "string") {
      return token;
    }
    if (Array.isArray(token)) {
      return "[" + token.map(stringify2).join(", ") + "]";
    }
    if (token == null) {
      return "" + token;
    }
    if (token.overriddenName) {
      return `${token.overriddenName}`;
    }
    if (token.name) {
      return `${token.name}`;
    }
    if (!token.toString) {
      return "object";
    }
    const res = token.toString();
    if (res == null) {
      return "" + res;
    }
    const newLineIndex = res.indexOf("\n");
    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
  }
  var Version2 = class {
    constructor(full) {
      this.full = full;
      const splits = full.split(".");
      this.major = splits[0];
      this.minor = splits[1];
      this.patch = splits.slice(2).join(".");
    }
  };
  var __window2 = typeof window !== "undefined" && window;
  var __self2 = typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope && self;
  var __global2 = typeof global !== "undefined" && global;
  var _global3 = __global2 || __window2 || __self2;
  function newArray2(size, value) {
    const list = [];
    for (let i = 0; i < size; i++) {
      list.push(value);
    }
    return list;
  }
  function partitionArray(arr, conditionFn) {
    const truthy = [];
    const falsy = [];
    for (const item of arr) {
      (conditionFn(item) ? truthy : falsy).push(item);
    }
    return [truthy, falsy];
  }
  var VERSION$1 = 3;
  var JS_B64_PREFIX = "# sourceMappingURL=data:application/json;base64,";
  var SourceMapGenerator = class {
    constructor(file = null) {
      this.file = file;
      this.sourcesContent = /* @__PURE__ */ new Map();
      this.lines = [];
      this.lastCol0 = 0;
      this.hasMappings = false;
    }
    addSource(url, content = null) {
      if (!this.sourcesContent.has(url)) {
        this.sourcesContent.set(url, content);
      }
      return this;
    }
    addLine() {
      this.lines.push([]);
      this.lastCol0 = 0;
      return this;
    }
    addMapping(col0, sourceUrl, sourceLine0, sourceCol0) {
      if (!this.currentLine) {
        throw new Error(`A line must be added before mappings can be added`);
      }
      if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {
        throw new Error(`Unknown source file "${sourceUrl}"`);
      }
      if (col0 == null) {
        throw new Error(`The column in the generated code must be provided`);
      }
      if (col0 < this.lastCol0) {
        throw new Error(`Mapping should be added in output order`);
      }
      if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {
        throw new Error(`The source location must be provided when a source url is provided`);
      }
      this.hasMappings = true;
      this.lastCol0 = col0;
      this.currentLine.push({ col0, sourceUrl, sourceLine0, sourceCol0 });
      return this;
    }
    get currentLine() {
      return this.lines.slice(-1)[0];
    }
    toJSON() {
      if (!this.hasMappings) {
        return null;
      }
      const sourcesIndex = /* @__PURE__ */ new Map();
      const sources = [];
      const sourcesContent = [];
      Array.from(this.sourcesContent.keys()).forEach((url, i) => {
        sourcesIndex.set(url, i);
        sources.push(url);
        sourcesContent.push(this.sourcesContent.get(url) || null);
      });
      let mappings = "";
      let lastCol0 = 0;
      let lastSourceIndex = 0;
      let lastSourceLine0 = 0;
      let lastSourceCol0 = 0;
      this.lines.forEach((segments) => {
        lastCol0 = 0;
        mappings += segments.map((segment) => {
          let segAsStr = toBase64VLQ(segment.col0 - lastCol0);
          lastCol0 = segment.col0;
          if (segment.sourceUrl != null) {
            segAsStr += toBase64VLQ(sourcesIndex.get(segment.sourceUrl) - lastSourceIndex);
            lastSourceIndex = sourcesIndex.get(segment.sourceUrl);
            segAsStr += toBase64VLQ(segment.sourceLine0 - lastSourceLine0);
            lastSourceLine0 = segment.sourceLine0;
            segAsStr += toBase64VLQ(segment.sourceCol0 - lastSourceCol0);
            lastSourceCol0 = segment.sourceCol0;
          }
          return segAsStr;
        }).join(",");
        mappings += ";";
      });
      mappings = mappings.slice(0, -1);
      return {
        "file": this.file || "",
        "version": VERSION$1,
        "sourceRoot": "",
        "sources": sources,
        "sourcesContent": sourcesContent,
        "mappings": mappings
      };
    }
    toJsComment() {
      return this.hasMappings ? "//" + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0)) : "";
    }
  };
  function toBase64String(value) {
    let b64 = "";
    const encoded = utf8Encode(value);
    for (let i = 0; i < encoded.length; ) {
      const i1 = encoded[i++];
      const i2 = i < encoded.length ? encoded[i++] : null;
      const i3 = i < encoded.length ? encoded[i++] : null;
      b64 += toBase64Digit(i1 >> 2);
      b64 += toBase64Digit((i1 & 3) << 4 | (i2 === null ? 0 : i2 >> 4));
      b64 += i2 === null ? "=" : toBase64Digit((i2 & 15) << 2 | (i3 === null ? 0 : i3 >> 6));
      b64 += i2 === null || i3 === null ? "=" : toBase64Digit(i3 & 63);
    }
    return b64;
  }
  function toBase64VLQ(value) {
    value = value < 0 ? (-value << 1) + 1 : value << 1;
    let out = "";
    do {
      let digit = value & 31;
      value = value >> 5;
      if (value > 0) {
        digit = digit | 32;
      }
      out += toBase64Digit(digit);
    } while (value > 0);
    return out;
  }
  var B64_DIGITS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  function toBase64Digit(value) {
    if (value < 0 || value >= 64) {
      throw new Error(`Can only encode value in the range [0, 63]`);
    }
    return B64_DIGITS[value];
  }
  var _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\|\n|\r|\$/g;
  var _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;
  var _INDENT_WITH = "  ";
  var CATCH_ERROR_VAR$1 = variable("error", null, null);
  var CATCH_STACK_VAR$1 = variable("stack", null, null);
  var _EmittedLine = class {
    constructor(indent) {
      this.indent = indent;
      this.partsLength = 0;
      this.parts = [];
      this.srcSpans = [];
    }
  };
  var EmitterVisitorContext = class {
    constructor(_indent) {
      this._indent = _indent;
      this._classes = [];
      this._preambleLineCount = 0;
      this._lines = [new _EmittedLine(_indent)];
    }
    static createRoot() {
      return new EmitterVisitorContext(0);
    }
    get _currentLine() {
      return this._lines[this._lines.length - 1];
    }
    println(from2, lastPart = "") {
      this.print(from2 || null, lastPart, true);
    }
    lineIsEmpty() {
      return this._currentLine.parts.length === 0;
    }
    lineLength() {
      return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;
    }
    print(from2, part, newLine = false) {
      if (part.length > 0) {
        this._currentLine.parts.push(part);
        this._currentLine.partsLength += part.length;
        this._currentLine.srcSpans.push(from2 && from2.sourceSpan || null);
      }
      if (newLine) {
        this._lines.push(new _EmittedLine(this._indent));
      }
    }
    removeEmptyLastLine() {
      if (this.lineIsEmpty()) {
        this._lines.pop();
      }
    }
    incIndent() {
      this._indent++;
      if (this.lineIsEmpty()) {
        this._currentLine.indent = this._indent;
      }
    }
    decIndent() {
      this._indent--;
      if (this.lineIsEmpty()) {
        this._currentLine.indent = this._indent;
      }
    }
    pushClass(clazz) {
      this._classes.push(clazz);
    }
    popClass() {
      return this._classes.pop();
    }
    get currentClass() {
      return this._classes.length > 0 ? this._classes[this._classes.length - 1] : null;
    }
    toSource() {
      return this.sourceLines.map((l) => l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join("") : "").join("\n");
    }
    toSourceMapGenerator(genFilePath, startsAtLine = 0) {
      const map2 = new SourceMapGenerator(genFilePath);
      let firstOffsetMapped = false;
      const mapFirstOffsetIfNeeded = () => {
        if (!firstOffsetMapped) {
          map2.addSource(genFilePath, " ").addMapping(0, genFilePath, 0, 0);
          firstOffsetMapped = true;
        }
      };
      for (let i = 0; i < startsAtLine; i++) {
        map2.addLine();
        mapFirstOffsetIfNeeded();
      }
      this.sourceLines.forEach((line, lineIdx) => {
        map2.addLine();
        const spans = line.srcSpans;
        const parts = line.parts;
        let col0 = line.indent * _INDENT_WITH.length;
        let spanIdx = 0;
        while (spanIdx < spans.length && !spans[spanIdx]) {
          col0 += parts[spanIdx].length;
          spanIdx++;
        }
        if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {
          firstOffsetMapped = true;
        } else {
          mapFirstOffsetIfNeeded();
        }
        while (spanIdx < spans.length) {
          const span = spans[spanIdx];
          const source = span.start.file;
          const sourceLine = span.start.line;
          const sourceCol = span.start.col;
          map2.addSource(source.url, source.content).addMapping(col0, source.url, sourceLine, sourceCol);
          col0 += parts[spanIdx].length;
          spanIdx++;
          while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {
            col0 += parts[spanIdx].length;
            spanIdx++;
          }
        }
      });
      return map2;
    }
    setPreambleLineCount(count) {
      return this._preambleLineCount = count;
    }
    spanOf(line, column) {
      const emittedLine = this._lines[line - this._preambleLineCount];
      if (emittedLine) {
        let columnsLeft = column - _createIndent(emittedLine.indent).length;
        for (let partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {
          const part = emittedLine.parts[partIndex];
          if (part.length > columnsLeft) {
            return emittedLine.srcSpans[partIndex];
          }
          columnsLeft -= part.length;
        }
      }
      return null;
    }
    get sourceLines() {
      if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {
        return this._lines.slice(0, -1);
      }
      return this._lines;
    }
  };
  var AbstractEmitterVisitor = class {
    constructor(_escapeDollarInStrings) {
      this._escapeDollarInStrings = _escapeDollarInStrings;
    }
    printLeadingComments(stmt, ctx) {
      if (stmt.leadingComments === void 0) {
        return;
      }
      for (const comment of stmt.leadingComments) {
        if (comment instanceof JSDocComment) {
          ctx.print(stmt, `/*${comment.toString()}*/`, comment.trailingNewline);
        } else {
          if (comment.multiline) {
            ctx.print(stmt, `/* ${comment.text} */`, comment.trailingNewline);
          } else {
            comment.text.split("\n").forEach((line) => {
              ctx.println(stmt, `// ${line}`);
            });
          }
        }
      }
    }
    visitExpressionStmt(stmt, ctx) {
      this.printLeadingComments(stmt, ctx);
      stmt.expr.visitExpression(this, ctx);
      ctx.println(stmt, ";");
      return null;
    }
    visitReturnStmt(stmt, ctx) {
      this.printLeadingComments(stmt, ctx);
      ctx.print(stmt, `return `);
      stmt.value.visitExpression(this, ctx);
      ctx.println(stmt, ";");
      return null;
    }
    visitIfStmt(stmt, ctx) {
      this.printLeadingComments(stmt, ctx);
      ctx.print(stmt, `if (`);
      stmt.condition.visitExpression(this, ctx);
      ctx.print(stmt, `) {`);
      const hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;
      if (stmt.trueCase.length <= 1 && !hasElseCase) {
        ctx.print(stmt, ` `);
        this.visitAllStatements(stmt.trueCase, ctx);
        ctx.removeEmptyLastLine();
        ctx.print(stmt, ` `);
      } else {
        ctx.println();
        ctx.incIndent();
        this.visitAllStatements(stmt.trueCase, ctx);
        ctx.decIndent();
        if (hasElseCase) {
          ctx.println(stmt, `} else {`);
          ctx.incIndent();
          this.visitAllStatements(stmt.falseCase, ctx);
          ctx.decIndent();
        }
      }
      ctx.println(stmt, `}`);
      return null;
    }
    visitThrowStmt(stmt, ctx) {
      this.printLeadingComments(stmt, ctx);
      ctx.print(stmt, `throw `);
      stmt.error.visitExpression(this, ctx);
      ctx.println(stmt, `;`);
      return null;
    }
    visitWriteVarExpr(expr, ctx) {
      const lineWasEmpty = ctx.lineIsEmpty();
      if (!lineWasEmpty) {
        ctx.print(expr, "(");
      }
      ctx.print(expr, `${expr.name} = `);
      expr.value.visitExpression(this, ctx);
      if (!lineWasEmpty) {
        ctx.print(expr, ")");
      }
      return null;
    }
    visitWriteKeyExpr(expr, ctx) {
      const lineWasEmpty = ctx.lineIsEmpty();
      if (!lineWasEmpty) {
        ctx.print(expr, "(");
      }
      expr.receiver.visitExpression(this, ctx);
      ctx.print(expr, `[`);
      expr.index.visitExpression(this, ctx);
      ctx.print(expr, `] = `);
      expr.value.visitExpression(this, ctx);
      if (!lineWasEmpty) {
        ctx.print(expr, ")");
      }
      return null;
    }
    visitWritePropExpr(expr, ctx) {
      const lineWasEmpty = ctx.lineIsEmpty();
      if (!lineWasEmpty) {
        ctx.print(expr, "(");
      }
      expr.receiver.visitExpression(this, ctx);
      ctx.print(expr, `.${expr.name} = `);
      expr.value.visitExpression(this, ctx);
      if (!lineWasEmpty) {
        ctx.print(expr, ")");
      }
      return null;
    }
    visitInvokeFunctionExpr(expr, ctx) {
      expr.fn.visitExpression(this, ctx);
      ctx.print(expr, `(`);
      this.visitAllExpressions(expr.args, ctx, ",");
      ctx.print(expr, `)`);
      return null;
    }
    visitTaggedTemplateExpr(expr, ctx) {
      expr.tag.visitExpression(this, ctx);
      ctx.print(expr, "`" + expr.template.elements[0].rawText);
      for (let i = 1; i < expr.template.elements.length; i++) {
        ctx.print(expr, "${");
        expr.template.expressions[i - 1].visitExpression(this, ctx);
        ctx.print(expr, `}${expr.template.elements[i].rawText}`);
      }
      ctx.print(expr, "`");
      return null;
    }
    visitWrappedNodeExpr(ast, ctx) {
      throw new Error("Abstract emitter cannot visit WrappedNodeExpr.");
    }
    visitTypeofExpr(expr, ctx) {
      ctx.print(expr, "typeof ");
      expr.expr.visitExpression(this, ctx);
    }
    visitReadVarExpr(ast, ctx) {
      let varName = ast.name;
      if (ast.builtin != null) {
        switch (ast.builtin) {
          case BuiltinVar.Super:
            varName = "super";
            break;
          case BuiltinVar.This:
            varName = "this";
            break;
          case BuiltinVar.CatchError:
            varName = CATCH_ERROR_VAR$1.name;
            break;
          case BuiltinVar.CatchStack:
            varName = CATCH_STACK_VAR$1.name;
            break;
          default:
            throw new Error(`Unknown builtin variable ${ast.builtin}`);
        }
      }
      ctx.print(ast, varName);
      return null;
    }
    visitInstantiateExpr(ast, ctx) {
      ctx.print(ast, `new `);
      ast.classExpr.visitExpression(this, ctx);
      ctx.print(ast, `(`);
      this.visitAllExpressions(ast.args, ctx, ",");
      ctx.print(ast, `)`);
      return null;
    }
    visitLiteralExpr(ast, ctx) {
      const value = ast.value;
      if (typeof value === "string") {
        ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));
      } else {
        ctx.print(ast, `${value}`);
      }
      return null;
    }
    visitLocalizedString(ast, ctx) {
      const head = ast.serializeI18nHead();
      ctx.print(ast, "$localize `" + head.raw);
      for (let i = 1; i < ast.messageParts.length; i++) {
        ctx.print(ast, "${");
        ast.expressions[i - 1].visitExpression(this, ctx);
        ctx.print(ast, `}${ast.serializeI18nTemplatePart(i).raw}`);
      }
      ctx.print(ast, "`");
      return null;
    }
    visitConditionalExpr(ast, ctx) {
      ctx.print(ast, `(`);
      ast.condition.visitExpression(this, ctx);
      ctx.print(ast, "? ");
      ast.trueCase.visitExpression(this, ctx);
      ctx.print(ast, ": ");
      ast.falseCase.visitExpression(this, ctx);
      ctx.print(ast, `)`);
      return null;
    }
    visitNotExpr(ast, ctx) {
      ctx.print(ast, "!");
      ast.condition.visitExpression(this, ctx);
      return null;
    }
    visitAssertNotNullExpr(ast, ctx) {
      ast.condition.visitExpression(this, ctx);
      return null;
    }
    visitUnaryOperatorExpr(ast, ctx) {
      let opStr;
      switch (ast.operator) {
        case UnaryOperator.Plus:
          opStr = "+";
          break;
        case UnaryOperator.Minus:
          opStr = "-";
          break;
        default:
          throw new Error(`Unknown operator ${ast.operator}`);
      }
      if (ast.parens)
        ctx.print(ast, `(`);
      ctx.print(ast, opStr);
      ast.expr.visitExpression(this, ctx);
      if (ast.parens)
        ctx.print(ast, `)`);
      return null;
    }
    visitBinaryOperatorExpr(ast, ctx) {
      let opStr;
      switch (ast.operator) {
        case BinaryOperator.Equals:
          opStr = "==";
          break;
        case BinaryOperator.Identical:
          opStr = "===";
          break;
        case BinaryOperator.NotEquals:
          opStr = "!=";
          break;
        case BinaryOperator.NotIdentical:
          opStr = "!==";
          break;
        case BinaryOperator.And:
          opStr = "&&";
          break;
        case BinaryOperator.BitwiseAnd:
          opStr = "&";
          break;
        case BinaryOperator.Or:
          opStr = "||";
          break;
        case BinaryOperator.Plus:
          opStr = "+";
          break;
        case BinaryOperator.Minus:
          opStr = "-";
          break;
        case BinaryOperator.Divide:
          opStr = "/";
          break;
        case BinaryOperator.Multiply:
          opStr = "*";
          break;
        case BinaryOperator.Modulo:
          opStr = "%";
          break;
        case BinaryOperator.Lower:
          opStr = "<";
          break;
        case BinaryOperator.LowerEquals:
          opStr = "<=";
          break;
        case BinaryOperator.Bigger:
          opStr = ">";
          break;
        case BinaryOperator.BiggerEquals:
          opStr = ">=";
          break;
        case BinaryOperator.NullishCoalesce:
          opStr = "??";
          break;
        default:
          throw new Error(`Unknown operator ${ast.operator}`);
      }
      if (ast.parens)
        ctx.print(ast, `(`);
      ast.lhs.visitExpression(this, ctx);
      ctx.print(ast, ` ${opStr} `);
      ast.rhs.visitExpression(this, ctx);
      if (ast.parens)
        ctx.print(ast, `)`);
      return null;
    }
    visitReadPropExpr(ast, ctx) {
      ast.receiver.visitExpression(this, ctx);
      ctx.print(ast, `.`);
      ctx.print(ast, ast.name);
      return null;
    }
    visitReadKeyExpr(ast, ctx) {
      ast.receiver.visitExpression(this, ctx);
      ctx.print(ast, `[`);
      ast.index.visitExpression(this, ctx);
      ctx.print(ast, `]`);
      return null;
    }
    visitLiteralArrayExpr(ast, ctx) {
      ctx.print(ast, `[`);
      this.visitAllExpressions(ast.entries, ctx, ",");
      ctx.print(ast, `]`);
      return null;
    }
    visitLiteralMapExpr(ast, ctx) {
      ctx.print(ast, `{`);
      this.visitAllObjects((entry) => {
        ctx.print(ast, `${escapeIdentifier(entry.key, this._escapeDollarInStrings, entry.quoted)}:`);
        entry.value.visitExpression(this, ctx);
      }, ast.entries, ctx, ",");
      ctx.print(ast, `}`);
      return null;
    }
    visitCommaExpr(ast, ctx) {
      ctx.print(ast, "(");
      this.visitAllExpressions(ast.parts, ctx, ",");
      ctx.print(ast, ")");
      return null;
    }
    visitAllExpressions(expressions, ctx, separator) {
      this.visitAllObjects((expr) => expr.visitExpression(this, ctx), expressions, ctx, separator);
    }
    visitAllObjects(handler, expressions, ctx, separator) {
      let incrementedIndent = false;
      for (let i = 0; i < expressions.length; i++) {
        if (i > 0) {
          if (ctx.lineLength() > 80) {
            ctx.print(null, separator, true);
            if (!incrementedIndent) {
              ctx.incIndent();
              ctx.incIndent();
              incrementedIndent = true;
            }
          } else {
            ctx.print(null, separator, false);
          }
        }
        handler(expressions[i]);
      }
      if (incrementedIndent) {
        ctx.decIndent();
        ctx.decIndent();
      }
    }
    visitAllStatements(statements, ctx) {
      statements.forEach((stmt) => stmt.visitStatement(this, ctx));
    }
  };
  function escapeIdentifier(input, escapeDollar, alwaysQuote = true) {
    if (input == null) {
      return null;
    }
    const body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, (...match2) => {
      if (match2[0] == "$") {
        return escapeDollar ? "\\$" : "$";
      } else if (match2[0] == "\n") {
        return "\\n";
      } else if (match2[0] == "\r") {
        return "\\r";
      } else {
        return `\\${match2[0]}`;
      }
    });
    const requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);
    return requiresQuotes ? `'${body}'` : body;
  }
  function _createIndent(count) {
    let res = "";
    for (let i = 0; i < count; i++) {
      res += _INDENT_WITH;
    }
    return res;
  }
  function typeWithParameters(type, numParams) {
    if (numParams === 0) {
      return expressionType(type);
    }
    const params = [];
    for (let i = 0; i < numParams; i++) {
      params.push(DYNAMIC_TYPE);
    }
    return expressionType(type, void 0, params);
  }
  var ANIMATE_SYMBOL_PREFIX = "@";
  function prepareSyntheticPropertyName(name) {
    return `${ANIMATE_SYMBOL_PREFIX}${name}`;
  }
  function prepareSyntheticListenerName(name, phase) {
    return `${ANIMATE_SYMBOL_PREFIX}${name}.${phase}`;
  }
  function getSafePropertyAccessString(accessor, name) {
    const escapedName = escapeIdentifier(name, false, false);
    return escapedName !== name ? `${accessor}[${escapedName}]` : `${accessor}.${name}`;
  }
  function prepareSyntheticListenerFunctionName(name, phase) {
    return `animation_${name}_${phase}`;
  }
  function jitOnlyGuardedExpression(expr) {
    return guardedExpression("ngJitMode", expr);
  }
  function guardedExpression(guard, expr) {
    const guardExpr = new ExternalExpr({ name: guard, moduleName: null });
    const guardNotDefined = new BinaryOperatorExpr(BinaryOperator.Identical, new TypeofExpr(guardExpr), literal("undefined"));
    const guardUndefinedOrTrue = new BinaryOperatorExpr(BinaryOperator.Or, guardNotDefined, guardExpr, void 0, void 0, true);
    return new BinaryOperatorExpr(BinaryOperator.And, guardUndefinedOrTrue, expr);
  }
  function wrapReference(value) {
    const wrapped = new WrappedNodeExpr(value);
    return { value: wrapped, type: wrapped };
  }
  function refsToArray(refs, shouldForwardDeclare) {
    const values = literalArr(refs.map((ref) => ref.value));
    return shouldForwardDeclare ? fn([], [new ReturnStatement(values)]) : values;
  }
  function createMayBeForwardRefExpression(expression, forwardRef2) {
    return { expression, forwardRef: forwardRef2 };
  }
  function convertFromMaybeForwardRefExpression({ expression, forwardRef: forwardRef2 }) {
    switch (forwardRef2) {
      case 0:
      case 1:
        return expression;
      case 2:
        return generateForwardRef(expression);
    }
  }
  function generateForwardRef(expr) {
    return importExpr(Identifiers$1.forwardRef).callFn([fn([], [new ReturnStatement(expr)])]);
  }
  var R3FactoryDelegateType;
  (function(R3FactoryDelegateType2) {
    R3FactoryDelegateType2[R3FactoryDelegateType2["Class"] = 0] = "Class";
    R3FactoryDelegateType2[R3FactoryDelegateType2["Function"] = 1] = "Function";
  })(R3FactoryDelegateType || (R3FactoryDelegateType = {}));
  var FactoryTarget$1;
  (function(FactoryTarget3) {
    FactoryTarget3[FactoryTarget3["Directive"] = 0] = "Directive";
    FactoryTarget3[FactoryTarget3["Component"] = 1] = "Component";
    FactoryTarget3[FactoryTarget3["Injectable"] = 2] = "Injectable";
    FactoryTarget3[FactoryTarget3["Pipe"] = 3] = "Pipe";
    FactoryTarget3[FactoryTarget3["NgModule"] = 4] = "NgModule";
  })(FactoryTarget$1 || (FactoryTarget$1 = {}));
  function compileFactoryFunction(meta) {
    const t = variable("t");
    let baseFactoryVar = null;
    const typeForCtor = !isDelegatedFactoryMetadata(meta) ? new BinaryOperatorExpr(BinaryOperator.Or, t, meta.internalType) : t;
    let ctorExpr = null;
    if (meta.deps !== null) {
      if (meta.deps !== "invalid") {
        ctorExpr = new InstantiateExpr(typeForCtor, injectDependencies(meta.deps, meta.target));
      }
    } else {
      baseFactoryVar = variable(`\u0275${meta.name}_BaseFactory`);
      ctorExpr = baseFactoryVar.callFn([typeForCtor]);
    }
    const body = [];
    let retExpr = null;
    function makeConditionalFactory(nonCtorExpr) {
      const r = variable("r");
      body.push(r.set(NULL_EXPR).toDeclStmt());
      const ctorStmt = ctorExpr !== null ? r.set(ctorExpr).toStmt() : importExpr(Identifiers$1.invalidFactory).callFn([]).toStmt();
      body.push(ifStmt(t, [ctorStmt], [r.set(nonCtorExpr).toStmt()]));
      return r;
    }
    if (isDelegatedFactoryMetadata(meta)) {
      const delegateArgs = injectDependencies(meta.delegateDeps, meta.target);
      const factoryExpr = new (meta.delegateType === R3FactoryDelegateType.Class ? InstantiateExpr : InvokeFunctionExpr)(meta.delegate, delegateArgs);
      retExpr = makeConditionalFactory(factoryExpr);
    } else if (isExpressionFactoryMetadata(meta)) {
      retExpr = makeConditionalFactory(meta.expression);
    } else {
      retExpr = ctorExpr;
    }
    if (retExpr === null) {
      body.push(importExpr(Identifiers$1.invalidFactory).callFn([]).toStmt());
    } else if (baseFactoryVar !== null) {
      const getInheritedFactoryCall = importExpr(Identifiers$1.getInheritedFactory).callFn([meta.internalType]);
      const baseFactory = new BinaryOperatorExpr(BinaryOperator.Or, baseFactoryVar, baseFactoryVar.set(getInheritedFactoryCall));
      body.push(new ReturnStatement(baseFactory.callFn([typeForCtor])));
    } else {
      body.push(new ReturnStatement(retExpr));
    }
    let factoryFn = fn([new FnParam("t", DYNAMIC_TYPE)], body, INFERRED_TYPE, void 0, `${meta.name}_Factory`);
    if (baseFactoryVar !== null) {
      factoryFn = fn([], [
        new DeclareVarStmt(baseFactoryVar.name),
        new ReturnStatement(factoryFn)
      ]).callFn([], void 0, true);
    }
    return {
      expression: factoryFn,
      statements: [],
      type: createFactoryType(meta)
    };
  }
  function createFactoryType(meta) {
    const ctorDepsType = meta.deps !== null && meta.deps !== "invalid" ? createCtorDepsType(meta.deps) : NONE_TYPE;
    return expressionType(importExpr(Identifiers$1.FactoryDeclaration, [typeWithParameters(meta.type.type, meta.typeArgumentCount), ctorDepsType]));
  }
  function injectDependencies(deps, target) {
    return deps.map((dep, index) => compileInjectDependency(dep, target, index));
  }
  function compileInjectDependency(dep, target, index) {
    if (dep.token === null) {
      return importExpr(Identifiers$1.invalidFactoryDep).callFn([literal(index)]);
    } else if (dep.attributeNameType === null) {
      const flags = 0 | (dep.self ? 2 : 0) | (dep.skipSelf ? 4 : 0) | (dep.host ? 1 : 0) | (dep.optional ? 8 : 0) | (target === FactoryTarget$1.Pipe ? 16 : 0);
      let flagsParam = flags !== 0 || dep.optional ? literal(flags) : null;
      const injectArgs2 = [dep.token];
      if (flagsParam) {
        injectArgs2.push(flagsParam);
      }
      const injectFn = getInjectFn(target);
      return importExpr(injectFn).callFn(injectArgs2);
    } else {
      return importExpr(Identifiers$1.injectAttribute).callFn([dep.token]);
    }
  }
  function createCtorDepsType(deps) {
    let hasTypes = false;
    const attributeTypes = deps.map((dep) => {
      const type = createCtorDepType(dep);
      if (type !== null) {
        hasTypes = true;
        return type;
      } else {
        return literal(null);
      }
    });
    if (hasTypes) {
      return expressionType(literalArr(attributeTypes));
    } else {
      return NONE_TYPE;
    }
  }
  function createCtorDepType(dep) {
    const entries = [];
    if (dep.attributeNameType !== null) {
      entries.push({ key: "attribute", value: dep.attributeNameType, quoted: false });
    }
    if (dep.optional) {
      entries.push({ key: "optional", value: literal(true), quoted: false });
    }
    if (dep.host) {
      entries.push({ key: "host", value: literal(true), quoted: false });
    }
    if (dep.self) {
      entries.push({ key: "self", value: literal(true), quoted: false });
    }
    if (dep.skipSelf) {
      entries.push({ key: "skipSelf", value: literal(true), quoted: false });
    }
    return entries.length > 0 ? literalMap(entries) : null;
  }
  function isDelegatedFactoryMetadata(meta) {
    return meta.delegateType !== void 0;
  }
  function isExpressionFactoryMetadata(meta) {
    return meta.expression !== void 0;
  }
  function getInjectFn(target) {
    switch (target) {
      case FactoryTarget$1.Component:
      case FactoryTarget$1.Directive:
      case FactoryTarget$1.Pipe:
        return Identifiers$1.directiveInject;
      case FactoryTarget$1.NgModule:
      case FactoryTarget$1.Injectable:
      default:
        return Identifiers$1.inject;
    }
  }
  var Comment$1 = class {
    constructor(value, sourceSpan) {
      this.value = value;
      this.sourceSpan = sourceSpan;
    }
    visit(_visitor2) {
      throw new Error("visit() not implemented for Comment");
    }
  };
  var Text$3 = class {
    constructor(value, sourceSpan) {
      this.value = value;
      this.sourceSpan = sourceSpan;
    }
    visit(visitor) {
      return visitor.visitText(this);
    }
  };
  var BoundText = class {
    constructor(value, sourceSpan, i18n) {
      this.value = value;
      this.sourceSpan = sourceSpan;
      this.i18n = i18n;
    }
    visit(visitor) {
      return visitor.visitBoundText(this);
    }
  };
  var TextAttribute = class {
    constructor(name, value, sourceSpan, keySpan, valueSpan, i18n) {
      this.name = name;
      this.value = value;
      this.sourceSpan = sourceSpan;
      this.keySpan = keySpan;
      this.valueSpan = valueSpan;
      this.i18n = i18n;
    }
    visit(visitor) {
      return visitor.visitTextAttribute(this);
    }
  };
  var BoundAttribute = class {
    constructor(name, type, securityContext, value, unit, sourceSpan, keySpan, valueSpan, i18n) {
      this.name = name;
      this.type = type;
      this.securityContext = securityContext;
      this.value = value;
      this.unit = unit;
      this.sourceSpan = sourceSpan;
      this.keySpan = keySpan;
      this.valueSpan = valueSpan;
      this.i18n = i18n;
    }
    static fromBoundElementProperty(prop, i18n) {
      if (prop.keySpan === void 0) {
        throw new Error(`Unexpected state: keySpan must be defined for bound attributes but was not for ${prop.name}: ${prop.sourceSpan}`);
      }
      return new BoundAttribute(prop.name, prop.type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan, prop.keySpan, prop.valueSpan, i18n);
    }
    visit(visitor) {
      return visitor.visitBoundAttribute(this);
    }
  };
  var BoundEvent = class {
    constructor(name, type, handler, target, phase, sourceSpan, handlerSpan, keySpan) {
      this.name = name;
      this.type = type;
      this.handler = handler;
      this.target = target;
      this.phase = phase;
      this.sourceSpan = sourceSpan;
      this.handlerSpan = handlerSpan;
      this.keySpan = keySpan;
    }
    static fromParsedEvent(event) {
      const target = event.type === 0 ? event.targetOrPhase : null;
      const phase = event.type === 1 ? event.targetOrPhase : null;
      if (event.keySpan === void 0) {
        throw new Error(`Unexpected state: keySpan must be defined for bound event but was not for ${event.name}: ${event.sourceSpan}`);
      }
      return new BoundEvent(event.name, event.type, event.handler, target, phase, event.sourceSpan, event.handlerSpan, event.keySpan);
    }
    visit(visitor) {
      return visitor.visitBoundEvent(this);
    }
  };
  var Element$1 = class {
    constructor(name, attributes, inputs, outputs, children, references, sourceSpan, startSourceSpan, endSourceSpan, i18n) {
      this.name = name;
      this.attributes = attributes;
      this.inputs = inputs;
      this.outputs = outputs;
      this.children = children;
      this.references = references;
      this.sourceSpan = sourceSpan;
      this.startSourceSpan = startSourceSpan;
      this.endSourceSpan = endSourceSpan;
      this.i18n = i18n;
    }
    visit(visitor) {
      return visitor.visitElement(this);
    }
  };
  var Template = class {
    constructor(tagName, attributes, inputs, outputs, templateAttrs, children, references, variables, sourceSpan, startSourceSpan, endSourceSpan, i18n) {
      this.tagName = tagName;
      this.attributes = attributes;
      this.inputs = inputs;
      this.outputs = outputs;
      this.templateAttrs = templateAttrs;
      this.children = children;
      this.references = references;
      this.variables = variables;
      this.sourceSpan = sourceSpan;
      this.startSourceSpan = startSourceSpan;
      this.endSourceSpan = endSourceSpan;
      this.i18n = i18n;
    }
    visit(visitor) {
      return visitor.visitTemplate(this);
    }
  };
  var Content = class {
    constructor(selector, attributes, sourceSpan, i18n) {
      this.selector = selector;
      this.attributes = attributes;
      this.sourceSpan = sourceSpan;
      this.i18n = i18n;
      this.name = "ng-content";
    }
    visit(visitor) {
      return visitor.visitContent(this);
    }
  };
  var Variable = class {
    constructor(name, value, sourceSpan, keySpan, valueSpan) {
      this.name = name;
      this.value = value;
      this.sourceSpan = sourceSpan;
      this.keySpan = keySpan;
      this.valueSpan = valueSpan;
    }
    visit(visitor) {
      return visitor.visitVariable(this);
    }
  };
  var Reference = class {
    constructor(name, value, sourceSpan, keySpan, valueSpan) {
      this.name = name;
      this.value = value;
      this.sourceSpan = sourceSpan;
      this.keySpan = keySpan;
      this.valueSpan = valueSpan;
    }
    visit(visitor) {
      return visitor.visitReference(this);
    }
  };
  var Icu$1 = class {
    constructor(vars, placeholders, sourceSpan, i18n) {
      this.vars = vars;
      this.placeholders = placeholders;
      this.sourceSpan = sourceSpan;
      this.i18n = i18n;
    }
    visit(visitor) {
      return visitor.visitIcu(this);
    }
  };
  function visitAll$1(visitor, nodes) {
    const result = [];
    if (visitor.visit) {
      for (const node of nodes) {
        const newNode = visitor.visit(node) || node.visit(visitor);
      }
    } else {
      for (const node of nodes) {
        const newNode = node.visit(visitor);
        if (newNode) {
          result.push(newNode);
        }
      }
    }
    return result;
  }
  var Message = class {
    constructor(nodes, placeholders, placeholderToMessage, meaning, description, customId) {
      this.nodes = nodes;
      this.placeholders = placeholders;
      this.placeholderToMessage = placeholderToMessage;
      this.meaning = meaning;
      this.description = description;
      this.customId = customId;
      this.id = this.customId;
      this.legacyIds = [];
      if (nodes.length) {
        this.sources = [{
          filePath: nodes[0].sourceSpan.start.file.url,
          startLine: nodes[0].sourceSpan.start.line + 1,
          startCol: nodes[0].sourceSpan.start.col + 1,
          endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,
          endCol: nodes[0].sourceSpan.start.col + 1
        }];
      } else {
        this.sources = [];
      }
    }
  };
  var Text$2 = class {
    constructor(value, sourceSpan) {
      this.value = value;
      this.sourceSpan = sourceSpan;
    }
    visit(visitor, context2) {
      return visitor.visitText(this, context2);
    }
  };
  var Container = class {
    constructor(children, sourceSpan) {
      this.children = children;
      this.sourceSpan = sourceSpan;
    }
    visit(visitor, context2) {
      return visitor.visitContainer(this, context2);
    }
  };
  var Icu = class {
    constructor(expression, type, cases, sourceSpan) {
      this.expression = expression;
      this.type = type;
      this.cases = cases;
      this.sourceSpan = sourceSpan;
    }
    visit(visitor, context2) {
      return visitor.visitIcu(this, context2);
    }
  };
  var TagPlaceholder = class {
    constructor(tag, attrs, startName, closeName, children, isVoid, sourceSpan, startSourceSpan, endSourceSpan) {
      this.tag = tag;
      this.attrs = attrs;
      this.startName = startName;
      this.closeName = closeName;
      this.children = children;
      this.isVoid = isVoid;
      this.sourceSpan = sourceSpan;
      this.startSourceSpan = startSourceSpan;
      this.endSourceSpan = endSourceSpan;
    }
    visit(visitor, context2) {
      return visitor.visitTagPlaceholder(this, context2);
    }
  };
  var Placeholder = class {
    constructor(value, name, sourceSpan) {
      this.value = value;
      this.name = name;
      this.sourceSpan = sourceSpan;
    }
    visit(visitor, context2) {
      return visitor.visitPlaceholder(this, context2);
    }
  };
  var IcuPlaceholder = class {
    constructor(value, name, sourceSpan) {
      this.value = value;
      this.name = name;
      this.sourceSpan = sourceSpan;
    }
    visit(visitor, context2) {
      return visitor.visitIcuPlaceholder(this, context2);
    }
  };
  var BigInteger = class {
    constructor(digits) {
      this.digits = digits;
    }
    static zero() {
      return new BigInteger([0]);
    }
    static one() {
      return new BigInteger([1]);
    }
    clone() {
      return new BigInteger(this.digits.slice());
    }
    add(other) {
      const result = this.clone();
      result.addToSelf(other);
      return result;
    }
    addToSelf(other) {
      const maxNrOfDigits = Math.max(this.digits.length, other.digits.length);
      let carry = 0;
      for (let i = 0; i < maxNrOfDigits; i++) {
        let digitSum = carry;
        if (i < this.digits.length) {
          digitSum += this.digits[i];
        }
        if (i < other.digits.length) {
          digitSum += other.digits[i];
        }
        if (digitSum >= 10) {
          this.digits[i] = digitSum - 10;
          carry = 1;
        } else {
          this.digits[i] = digitSum;
          carry = 0;
        }
      }
      if (carry > 0) {
        this.digits[maxNrOfDigits] = 1;
      }
    }
    toString() {
      let res = "";
      for (let i = this.digits.length - 1; i >= 0; i--) {
        res += this.digits[i];
      }
      return res;
    }
  };
  var BigIntForMultiplication = class {
    constructor(value) {
      this.powerOfTwos = [value];
    }
    getValue() {
      return this.powerOfTwos[0];
    }
    multiplyBy(num) {
      const product = BigInteger.zero();
      this.multiplyByAndAddTo(num, product);
      return product;
    }
    multiplyByAndAddTo(num, result) {
      for (let exponent = 0; num !== 0; num = num >>> 1, exponent++) {
        if (num & 1) {
          const value = this.getMultipliedByPowerOfTwo(exponent);
          result.addToSelf(value);
        }
      }
    }
    getMultipliedByPowerOfTwo(exponent) {
      for (let i = this.powerOfTwos.length; i <= exponent; i++) {
        const previousPower = this.powerOfTwos[i - 1];
        this.powerOfTwos[i] = previousPower.add(previousPower);
      }
      return this.powerOfTwos[exponent];
    }
  };
  var BigIntExponentiation = class {
    constructor(base) {
      this.base = base;
      this.exponents = [new BigIntForMultiplication(BigInteger.one())];
    }
    toThePowerOf(exponent) {
      for (let i = this.exponents.length; i <= exponent; i++) {
        const value = this.exponents[i - 1].multiplyBy(this.base);
        this.exponents[i] = new BigIntForMultiplication(value);
      }
      return this.exponents[exponent];
    }
  };
  function computeDigest(message) {
    return sha1(serializeNodes(message.nodes).join("") + `[${message.meaning}]`);
  }
  function decimalDigest(message) {
    return message.id || computeDecimalDigest(message);
  }
  function computeDecimalDigest(message) {
    const visitor = new _SerializerIgnoreIcuExpVisitor();
    const parts = message.nodes.map((a) => a.visit(visitor, null));
    return computeMsgId(parts.join(""), message.meaning);
  }
  var _SerializerVisitor = class {
    visitText(text, context2) {
      return text.value;
    }
    visitContainer(container, context2) {
      return `[${container.children.map((child) => child.visit(this)).join(", ")}]`;
    }
    visitIcu(icu, context2) {
      const strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);
      return `{${icu.expression}, ${icu.type}, ${strCases.join(", ")}}`;
    }
    visitTagPlaceholder(ph, context2) {
      return ph.isVoid ? `<ph tag name="${ph.startName}"/>` : `<ph tag name="${ph.startName}">${ph.children.map((child) => child.visit(this)).join(", ")}</ph name="${ph.closeName}">`;
    }
    visitPlaceholder(ph, context2) {
      return ph.value ? `<ph name="${ph.name}">${ph.value}</ph>` : `<ph name="${ph.name}"/>`;
    }
    visitIcuPlaceholder(ph, context2) {
      return `<ph icu name="${ph.name}">${ph.value.visit(this)}</ph>`;
    }
  };
  var serializerVisitor$2 = new _SerializerVisitor();
  function serializeNodes(nodes) {
    return nodes.map((a) => a.visit(serializerVisitor$2, null));
  }
  var _SerializerIgnoreIcuExpVisitor = class extends _SerializerVisitor {
    visitIcu(icu, context2) {
      let strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);
      return `{${icu.type}, ${strCases.join(", ")}}`;
    }
  };
  function sha1(str) {
    const utf8 = utf8Encode(str);
    const words32 = bytesToWords32(utf8, Endian.Big);
    const len = utf8.length * 8;
    const w = newArray2(80);
    let a = 1732584193, b = 4023233417, c = 2562383102, d = 271733878, e = 3285377520;
    words32[len >> 5] |= 128 << 24 - len % 32;
    words32[(len + 64 >> 9 << 4) + 15] = len;
    for (let i = 0; i < words32.length; i += 16) {
      const h0 = a, h1 = b, h2 = c, h3 = d, h4 = e;
      for (let j = 0; j < 80; j++) {
        if (j < 16) {
          w[j] = words32[i + j];
        } else {
          w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
        }
        const fkVal = fk(j, b, c, d);
        const f = fkVal[0];
        const k = fkVal[1];
        const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);
        e = d;
        d = c;
        c = rol32(b, 30);
        b = a;
        a = temp;
      }
      a = add32(a, h0);
      b = add32(b, h1);
      c = add32(c, h2);
      d = add32(d, h3);
      e = add32(e, h4);
    }
    return bytesToHexString(words32ToByteString([a, b, c, d, e]));
  }
  function fk(index, b, c, d) {
    if (index < 20) {
      return [b & c | ~b & d, 1518500249];
    }
    if (index < 40) {
      return [b ^ c ^ d, 1859775393];
    }
    if (index < 60) {
      return [b & c | b & d | c & d, 2400959708];
    }
    return [b ^ c ^ d, 3395469782];
  }
  function fingerprint(str) {
    const utf8 = utf8Encode(str);
    let hi = hash32(utf8, 0);
    let lo = hash32(utf8, 102072);
    if (hi == 0 && (lo == 0 || lo == 1)) {
      hi = hi ^ 319790063;
      lo = lo ^ -1801410264;
    }
    return [hi, lo];
  }
  function computeMsgId(msg, meaning = "") {
    let msgFingerprint = fingerprint(msg);
    if (meaning) {
      const meaningFingerprint = fingerprint(meaning);
      msgFingerprint = add64(rol64(msgFingerprint, 1), meaningFingerprint);
    }
    const hi = msgFingerprint[0];
    const lo = msgFingerprint[1];
    return wordsToDecimalString(hi & 2147483647, lo);
  }
  function hash32(bytes, c) {
    let a = 2654435769, b = 2654435769;
    let i;
    const len = bytes.length;
    for (i = 0; i + 12 <= len; i += 12) {
      a = add32(a, wordAt(bytes, i, Endian.Little));
      b = add32(b, wordAt(bytes, i + 4, Endian.Little));
      c = add32(c, wordAt(bytes, i + 8, Endian.Little));
      const res = mix(a, b, c);
      a = res[0], b = res[1], c = res[2];
    }
    a = add32(a, wordAt(bytes, i, Endian.Little));
    b = add32(b, wordAt(bytes, i + 4, Endian.Little));
    c = add32(c, len);
    c = add32(c, wordAt(bytes, i + 8, Endian.Little) << 8);
    return mix(a, b, c)[2];
  }
  function mix(a, b, c) {
    a = sub32(a, b);
    a = sub32(a, c);
    a ^= c >>> 13;
    b = sub32(b, c);
    b = sub32(b, a);
    b ^= a << 8;
    c = sub32(c, a);
    c = sub32(c, b);
    c ^= b >>> 13;
    a = sub32(a, b);
    a = sub32(a, c);
    a ^= c >>> 12;
    b = sub32(b, c);
    b = sub32(b, a);
    b ^= a << 16;
    c = sub32(c, a);
    c = sub32(c, b);
    c ^= b >>> 5;
    a = sub32(a, b);
    a = sub32(a, c);
    a ^= c >>> 3;
    b = sub32(b, c);
    b = sub32(b, a);
    b ^= a << 10;
    c = sub32(c, a);
    c = sub32(c, b);
    c ^= b >>> 15;
    return [a, b, c];
  }
  var Endian;
  (function(Endian2) {
    Endian2[Endian2["Little"] = 0] = "Little";
    Endian2[Endian2["Big"] = 1] = "Big";
  })(Endian || (Endian = {}));
  function add32(a, b) {
    return add32to64(a, b)[1];
  }
  function add32to64(a, b) {
    const low = (a & 65535) + (b & 65535);
    const high = (a >>> 16) + (b >>> 16) + (low >>> 16);
    return [high >>> 16, high << 16 | low & 65535];
  }
  function add64(a, b) {
    const ah = a[0], al = a[1];
    const bh = b[0], bl = b[1];
    const result = add32to64(al, bl);
    const carry = result[0];
    const l = result[1];
    const h = add32(add32(ah, bh), carry);
    return [h, l];
  }
  function sub32(a, b) {
    const low = (a & 65535) - (b & 65535);
    const high = (a >> 16) - (b >> 16) + (low >> 16);
    return high << 16 | low & 65535;
  }
  function rol32(a, count) {
    return a << count | a >>> 32 - count;
  }
  function rol64(num, count) {
    const hi = num[0], lo = num[1];
    const h = hi << count | lo >>> 32 - count;
    const l = lo << count | hi >>> 32 - count;
    return [h, l];
  }
  function bytesToWords32(bytes, endian) {
    const size = bytes.length + 3 >>> 2;
    const words32 = [];
    for (let i = 0; i < size; i++) {
      words32[i] = wordAt(bytes, i * 4, endian);
    }
    return words32;
  }
  function byteAt(bytes, index) {
    return index >= bytes.length ? 0 : bytes[index];
  }
  function wordAt(bytes, index, endian) {
    let word = 0;
    if (endian === Endian.Big) {
      for (let i = 0; i < 4; i++) {
        word += byteAt(bytes, index + i) << 24 - 8 * i;
      }
    } else {
      for (let i = 0; i < 4; i++) {
        word += byteAt(bytes, index + i) << 8 * i;
      }
    }
    return word;
  }
  function words32ToByteString(words32) {
    return words32.reduce((bytes, word) => bytes.concat(word32ToByteString(word)), []);
  }
  function word32ToByteString(word) {
    let bytes = [];
    for (let i = 0; i < 4; i++) {
      bytes.push(word >>> 8 * (3 - i) & 255);
    }
    return bytes;
  }
  function bytesToHexString(bytes) {
    let hex = "";
    for (let i = 0; i < bytes.length; i++) {
      const b = byteAt(bytes, i);
      hex += (b >>> 4).toString(16) + (b & 15).toString(16);
    }
    return hex.toLowerCase();
  }
  var base256 = new BigIntExponentiation(256);
  function wordsToDecimalString(hi, lo) {
    const decimal = base256.toThePowerOf(0).multiplyBy(lo);
    base256.toThePowerOf(4).multiplyByAndAddTo(hi, decimal);
    return decimal.toString();
  }
  var _Visitor$2 = class {
    visitTag(tag) {
      const strAttrs = this._serializeAttributes(tag.attrs);
      if (tag.children.length == 0) {
        return `<${tag.name}${strAttrs}/>`;
      }
      const strChildren = tag.children.map((node) => node.visit(this));
      return `<${tag.name}${strAttrs}>${strChildren.join("")}</${tag.name}>`;
    }
    visitText(text) {
      return text.value;
    }
    visitDeclaration(decl) {
      return `<?xml${this._serializeAttributes(decl.attrs)} ?>`;
    }
    _serializeAttributes(attrs) {
      const strAttrs = Object.keys(attrs).map((name) => `${name}="${attrs[name]}"`).join(" ");
      return strAttrs.length > 0 ? " " + strAttrs : "";
    }
    visitDoctype(doctype) {
      return `<!DOCTYPE ${doctype.rootTag} [
${doctype.dtd}
]>`;
    }
  };
  var _visitor = new _Visitor$2();
  function toPublicName(internalName) {
    return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, "_");
  }
  var CLOSURE_TRANSLATION_VAR_PREFIX = "MSG_";
  var TRANSLATION_VAR_PREFIX = "i18n_";
  var I18N_ATTR = "i18n";
  var I18N_ATTR_PREFIX = "i18n-";
  var I18N_ICU_VAR_PREFIX = "VAR_";
  var I18N_ICU_MAPPING_PREFIX = "I18N_EXP_";
  var I18N_PLACEHOLDER_SYMBOL = "\uFFFD";
  function isI18nAttribute(name) {
    return name === I18N_ATTR || name.startsWith(I18N_ATTR_PREFIX);
  }
  function isI18nRootNode(meta) {
    return meta instanceof Message;
  }
  function isSingleI18nIcu(meta) {
    return isI18nRootNode(meta) && meta.nodes.length === 1 && meta.nodes[0] instanceof Icu;
  }
  function hasI18nMeta(node) {
    return !!node.i18n;
  }
  function hasI18nAttrs(element) {
    return element.attrs.some((attr) => isI18nAttribute(attr.name));
  }
  function icuFromI18nMessage(message) {
    return message.nodes[0];
  }
  function wrapI18nPlaceholder(content, contextId = 0) {
    const blockId = contextId > 0 ? `:${contextId}` : "";
    return `${I18N_PLACEHOLDER_SYMBOL}${content}${blockId}${I18N_PLACEHOLDER_SYMBOL}`;
  }
  function assembleI18nBoundString(strings, bindingStartIndex = 0, contextId = 0) {
    if (!strings.length)
      return "";
    let acc = "";
    const lastIdx = strings.length - 1;
    for (let i = 0; i < lastIdx; i++) {
      acc += `${strings[i]}${wrapI18nPlaceholder(bindingStartIndex + i, contextId)}`;
    }
    acc += strings[lastIdx];
    return acc;
  }
  function getSeqNumberGenerator(startsAt = 0) {
    let current = startsAt;
    return () => current++;
  }
  function placeholdersToParams(placeholders) {
    const params = {};
    placeholders.forEach((values, key) => {
      params[key] = literal(values.length > 1 ? `[${values.join("|")}]` : values[0]);
    });
    return params;
  }
  function updatePlaceholderMap(map2, name, ...values) {
    const current = map2.get(name) || [];
    current.push(...values);
    map2.set(name, current);
  }
  function assembleBoundTextPlaceholders(meta, bindingStartIndex = 0, contextId = 0) {
    const startIdx = bindingStartIndex;
    const placeholders = /* @__PURE__ */ new Map();
    const node = meta instanceof Message ? meta.nodes.find((node2) => node2 instanceof Container) : meta;
    if (node) {
      node.children.filter((child) => child instanceof Placeholder).forEach((child, idx) => {
        const content = wrapI18nPlaceholder(startIdx + idx, contextId);
        updatePlaceholderMap(placeholders, child.name, content);
      });
    }
    return placeholders;
  }
  function i18nFormatPlaceholderNames(params = {}, useCamelCase) {
    const _params = {};
    if (params && Object.keys(params).length) {
      Object.keys(params).forEach((key) => _params[formatI18nPlaceholderName(key, useCamelCase)] = params[key]);
    }
    return _params;
  }
  function formatI18nPlaceholderName(name, useCamelCase = true) {
    const publicName = toPublicName(name);
    if (!useCamelCase) {
      return publicName;
    }
    const chunks = publicName.split("_");
    if (chunks.length === 1) {
      return name.toLowerCase();
    }
    let postfix;
    if (/^\d+$/.test(chunks[chunks.length - 1])) {
      postfix = chunks.pop();
    }
    let raw = chunks.shift().toLowerCase();
    if (chunks.length) {
      raw += chunks.map((c) => c.charAt(0).toUpperCase() + c.slice(1).toLowerCase()).join("");
    }
    return postfix ? `${raw}_${postfix}` : raw;
  }
  function getTranslationConstPrefix(extra) {
    return `${CLOSURE_TRANSLATION_VAR_PREFIX}${extra}`.toUpperCase();
  }
  function declareI18nVariable(variable2) {
    return new DeclareVarStmt(variable2.name, void 0, INFERRED_TYPE, void 0, variable2.sourceSpan);
  }
  var UNSAFE_OBJECT_KEY_NAME_REGEXP = /[-.]/;
  var TEMPORARY_NAME = "_t";
  var CONTEXT_NAME = "ctx";
  var RENDER_FLAGS = "rf";
  var REFERENCE_PREFIX = "_r";
  var IMPLICIT_REFERENCE = "$implicit";
  var NON_BINDABLE_ATTR = "ngNonBindable";
  var RESTORED_VIEW_CONTEXT_NAME = "restoredCtx";
  function temporaryAllocator(statements, name) {
    let temp = null;
    return () => {
      if (!temp) {
        statements.push(new DeclareVarStmt(TEMPORARY_NAME, void 0, DYNAMIC_TYPE));
        temp = variable(name);
      }
      return temp;
    };
  }
  function unsupported(feature) {
    if (this) {
      throw new Error(`Builder ${this.constructor.name} doesn't support ${feature} yet`);
    }
    throw new Error(`Feature ${feature} is not supported yet`);
  }
  function invalid(arg) {
    throw new Error(`Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);
  }
  function asLiteral(value) {
    if (Array.isArray(value)) {
      return literalArr(value.map(asLiteral));
    }
    return literal(value, INFERRED_TYPE);
  }
  function conditionallyCreateMapObjectLiteral(keys, keepDeclared) {
    if (Object.getOwnPropertyNames(keys).length > 0) {
      return mapToExpression(keys, keepDeclared);
    }
    return null;
  }
  function mapToExpression(map2, keepDeclared) {
    return literalMap(Object.getOwnPropertyNames(map2).map((key) => {
      const value = map2[key];
      let declaredName;
      let publicName;
      let minifiedName;
      let needsDeclaredName;
      if (Array.isArray(value)) {
        [publicName, declaredName] = value;
        minifiedName = key;
        needsDeclaredName = publicName !== declaredName;
      } else {
        [declaredName, publicName] = splitAtColon(key, [key, value]);
        minifiedName = declaredName;
        needsDeclaredName = publicName !== declaredName && key.includes(":");
      }
      return {
        key: minifiedName,
        quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(minifiedName),
        value: keepDeclared && needsDeclaredName ? literalArr([asLiteral(publicName), asLiteral(declaredName)]) : asLiteral(publicName)
      };
    }));
  }
  function trimTrailingNulls(parameters) {
    while (isNull(parameters[parameters.length - 1])) {
      parameters.pop();
    }
    return parameters;
  }
  function getQueryPredicate(query, constantPool) {
    if (Array.isArray(query.predicate)) {
      let predicate = [];
      query.predicate.forEach((selector) => {
        const selectors = selector.split(",").map((token) => literal(token.trim()));
        predicate.push(...selectors);
      });
      return constantPool.getConstLiteral(literalArr(predicate), true);
    } else {
      switch (query.predicate.forwardRef) {
        case 0:
        case 2:
          return query.predicate.expression;
        case 1:
          return importExpr(Identifiers$1.resolveForwardRef).callFn([query.predicate.expression]);
      }
    }
  }
  var DefinitionMap = class {
    constructor() {
      this.values = [];
    }
    set(key, value) {
      if (value) {
        this.values.push({ key, value, quoted: false });
      }
    }
    toLiteralMap() {
      return literalMap(this.values);
    }
  };
  function getAttrsForDirectiveMatching(elOrTpl) {
    const attributesMap = {};
    if (elOrTpl instanceof Template && elOrTpl.tagName !== "ng-template") {
      elOrTpl.templateAttrs.forEach((a) => attributesMap[a.name] = "");
    } else {
      elOrTpl.attributes.forEach((a) => {
        if (!isI18nAttribute(a.name)) {
          attributesMap[a.name] = a.value;
        }
      });
      elOrTpl.inputs.forEach((i) => {
        attributesMap[i.name] = "";
      });
      elOrTpl.outputs.forEach((o) => {
        attributesMap[o.name] = "";
      });
    }
    return attributesMap;
  }
  function chainedInstruction(reference, calls, span) {
    let expression = importExpr(reference, null, span);
    if (calls.length > 0) {
      for (let i = 0; i < calls.length; i++) {
        expression = expression.callFn(calls[i], span);
      }
    } else {
      expression = expression.callFn([], span);
    }
    return expression;
  }
  function getInterpolationArgsLength(interpolation) {
    const { expressions, strings } = interpolation;
    if (expressions.length === 1 && strings.length === 2 && strings[0] === "" && strings[1] === "") {
      return 1;
    } else {
      return expressions.length + strings.length;
    }
  }
  function compileInjectable2(meta, resolveForwardRefs) {
    let result = null;
    const factoryMeta = {
      name: meta.name,
      type: meta.type,
      internalType: meta.internalType,
      typeArgumentCount: meta.typeArgumentCount,
      deps: [],
      target: FactoryTarget$1.Injectable
    };
    if (meta.useClass !== void 0) {
      const useClassOnSelf = meta.useClass.expression.isEquivalent(meta.internalType);
      let deps = void 0;
      if (meta.deps !== void 0) {
        deps = meta.deps;
      }
      if (deps !== void 0) {
        result = compileFactoryFunction({
          ...factoryMeta,
          delegate: meta.useClass.expression,
          delegateDeps: deps,
          delegateType: R3FactoryDelegateType.Class
        });
      } else if (useClassOnSelf) {
        result = compileFactoryFunction(factoryMeta);
      } else {
        result = {
          statements: [],
          expression: delegateToFactory(meta.type.value, meta.useClass.expression, resolveForwardRefs)
        };
      }
    } else if (meta.useFactory !== void 0) {
      if (meta.deps !== void 0) {
        result = compileFactoryFunction({
          ...factoryMeta,
          delegate: meta.useFactory,
          delegateDeps: meta.deps || [],
          delegateType: R3FactoryDelegateType.Function
        });
      } else {
        result = {
          statements: [],
          expression: fn([], [new ReturnStatement(meta.useFactory.callFn([]))])
        };
      }
    } else if (meta.useValue !== void 0) {
      result = compileFactoryFunction({
        ...factoryMeta,
        expression: meta.useValue.expression
      });
    } else if (meta.useExisting !== void 0) {
      result = compileFactoryFunction({
        ...factoryMeta,
        expression: importExpr(Identifiers$1.inject).callFn([meta.useExisting.expression])
      });
    } else {
      result = {
        statements: [],
        expression: delegateToFactory(meta.type.value, meta.internalType, resolveForwardRefs)
      };
    }
    const token = meta.internalType;
    const injectableProps = new DefinitionMap();
    injectableProps.set("token", token);
    injectableProps.set("factory", result.expression);
    if (meta.providedIn.expression.value !== null) {
      injectableProps.set("providedIn", convertFromMaybeForwardRefExpression(meta.providedIn));
    }
    const expression = importExpr(Identifiers$1.\u0275\u0275defineInjectable).callFn([injectableProps.toLiteralMap()], void 0, true);
    return {
      expression,
      type: createInjectableType(meta),
      statements: result.statements
    };
  }
  function createInjectableType(meta) {
    return new ExpressionType(importExpr(Identifiers$1.InjectableDeclaration, [typeWithParameters(meta.type.type, meta.typeArgumentCount)]));
  }
  function delegateToFactory(type, internalType, unwrapForwardRefs) {
    if (type.node === internalType.node) {
      return internalType.prop("\u0275fac");
    }
    if (!unwrapForwardRefs) {
      return createFactoryFunction(internalType);
    }
    const unwrappedType = importExpr(Identifiers$1.resolveForwardRef).callFn([internalType]);
    return createFactoryFunction(unwrappedType);
  }
  function createFactoryFunction(type) {
    return fn([new FnParam("t", DYNAMIC_TYPE)], [new ReturnStatement(type.prop("\u0275fac").callFn([variable("t")]))]);
  }
  var UNUSABLE_INTERPOLATION_REGEXPS = [
    /^\s*$/,
    /[<>]/,
    /^[{}]$/,
    /&(#|[a-z])/i,
    /^\/\//
  ];
  function assertInterpolationSymbols(identifier, value) {
    if (value != null && !(Array.isArray(value) && value.length == 2)) {
      throw new Error(`Expected '${identifier}' to be an array, [start, end].`);
    } else if (value != null) {
      const start = value[0];
      const end = value[1];
      UNUSABLE_INTERPOLATION_REGEXPS.forEach((regexp) => {
        if (regexp.test(start) || regexp.test(end)) {
          throw new Error(`['${start}', '${end}'] contains unusable interpolation symbol.`);
        }
      });
    }
  }
  var InterpolationConfig = class {
    constructor(start, end) {
      this.start = start;
      this.end = end;
    }
    static fromArray(markers) {
      if (!markers) {
        return DEFAULT_INTERPOLATION_CONFIG;
      }
      assertInterpolationSymbols("interpolation", markers);
      return new InterpolationConfig(markers[0], markers[1]);
    }
  };
  var DEFAULT_INTERPOLATION_CONFIG = new InterpolationConfig("{{", "}}");
  var StaticSymbol = class {
    constructor(filePath, name, members) {
      this.filePath = filePath;
      this.name = name;
      this.members = members;
    }
    assertNoMembers() {
      if (this.members.length) {
        throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);
      }
    }
  };
  var $EOF = 0;
  var $BSPACE = 8;
  var $TAB = 9;
  var $LF = 10;
  var $VTAB = 11;
  var $FF = 12;
  var $CR = 13;
  var $SPACE = 32;
  var $BANG = 33;
  var $DQ = 34;
  var $HASH = 35;
  var $$ = 36;
  var $PERCENT = 37;
  var $AMPERSAND = 38;
  var $SQ = 39;
  var $LPAREN = 40;
  var $RPAREN = 41;
  var $STAR = 42;
  var $PLUS = 43;
  var $COMMA = 44;
  var $MINUS = 45;
  var $PERIOD = 46;
  var $SLASH = 47;
  var $COLON = 58;
  var $SEMICOLON = 59;
  var $LT = 60;
  var $EQ = 61;
  var $GT = 62;
  var $QUESTION = 63;
  var $0 = 48;
  var $7 = 55;
  var $9 = 57;
  var $A = 65;
  var $E = 69;
  var $F = 70;
  var $X = 88;
  var $Z = 90;
  var $LBRACKET = 91;
  var $BACKSLASH = 92;
  var $RBRACKET = 93;
  var $CARET = 94;
  var $_ = 95;
  var $a = 97;
  var $b = 98;
  var $e = 101;
  var $f = 102;
  var $n = 110;
  var $r = 114;
  var $t = 116;
  var $u = 117;
  var $v = 118;
  var $x = 120;
  var $z = 122;
  var $LBRACE = 123;
  var $BAR = 124;
  var $RBRACE = 125;
  var $NBSP = 160;
  var $BT = 96;
  function isWhitespace(code) {
    return code >= $TAB && code <= $SPACE || code == $NBSP;
  }
  function isDigit(code) {
    return $0 <= code && code <= $9;
  }
  function isAsciiLetter(code) {
    return code >= $a && code <= $z || code >= $A && code <= $Z;
  }
  function isAsciiHexDigit(code) {
    return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);
  }
  function isNewLine(code) {
    return code === $LF || code === $CR;
  }
  function isOctalDigit(code) {
    return $0 <= code && code <= $7;
  }
  function isQuote(code) {
    return code === $SQ || code === $DQ || code === $BT;
  }
  var ParseLocation = class {
    constructor(file, offset, line, col) {
      this.file = file;
      this.offset = offset;
      this.line = line;
      this.col = col;
    }
    toString() {
      return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
    }
    moveBy(delta) {
      const source = this.file.content;
      const len = source.length;
      let offset = this.offset;
      let line = this.line;
      let col = this.col;
      while (offset > 0 && delta < 0) {
        offset--;
        delta++;
        const ch = source.charCodeAt(offset);
        if (ch == $LF) {
          line--;
          const priorLine = source.substr(0, offset - 1).lastIndexOf(String.fromCharCode($LF));
          col = priorLine > 0 ? offset - priorLine : offset;
        } else {
          col--;
        }
      }
      while (offset < len && delta > 0) {
        const ch = source.charCodeAt(offset);
        offset++;
        delta--;
        if (ch == $LF) {
          line++;
          col = 0;
        } else {
          col++;
        }
      }
      return new ParseLocation(this.file, offset, line, col);
    }
    getContext(maxChars, maxLines) {
      const content = this.file.content;
      let startOffset = this.offset;
      if (startOffset != null) {
        if (startOffset > content.length - 1) {
          startOffset = content.length - 1;
        }
        let endOffset = startOffset;
        let ctxChars = 0;
        let ctxLines = 0;
        while (ctxChars < maxChars && startOffset > 0) {
          startOffset--;
          ctxChars++;
          if (content[startOffset] == "\n") {
            if (++ctxLines == maxLines) {
              break;
            }
          }
        }
        ctxChars = 0;
        ctxLines = 0;
        while (ctxChars < maxChars && endOffset < content.length - 1) {
          endOffset++;
          ctxChars++;
          if (content[endOffset] == "\n") {
            if (++ctxLines == maxLines) {
              break;
            }
          }
        }
        return {
          before: content.substring(startOffset, this.offset),
          after: content.substring(this.offset, endOffset + 1)
        };
      }
      return null;
    }
  };
  var ParseSourceFile = class {
    constructor(content, url) {
      this.content = content;
      this.url = url;
    }
  };
  var ParseSourceSpan = class {
    constructor(start, end, fullStart = start, details = null) {
      this.start = start;
      this.end = end;
      this.fullStart = fullStart;
      this.details = details;
    }
    toString() {
      return this.start.file.content.substring(this.start.offset, this.end.offset);
    }
  };
  var ParseErrorLevel;
  (function(ParseErrorLevel2) {
    ParseErrorLevel2[ParseErrorLevel2["WARNING"] = 0] = "WARNING";
    ParseErrorLevel2[ParseErrorLevel2["ERROR"] = 1] = "ERROR";
  })(ParseErrorLevel || (ParseErrorLevel = {}));
  var ParseError = class {
    constructor(span, msg, level = ParseErrorLevel.ERROR) {
      this.span = span;
      this.msg = msg;
      this.level = level;
    }
    contextualMessage() {
      const ctx = this.span.start.getContext(100, 3);
      return ctx ? `${this.msg} ("${ctx.before}[${ParseErrorLevel[this.level]} ->]${ctx.after}")` : this.msg;
    }
    toString() {
      const details = this.span.details ? `, ${this.span.details}` : "";
      return `${this.contextualMessage()}: ${this.span.start}${details}`;
    }
  };
  function r3JitTypeSourceSpan(kind, typeName, sourceUrl) {
    const sourceFileName = `in ${kind} ${typeName} in ${sourceUrl}`;
    const sourceFile = new ParseSourceFile("", sourceFileName);
    return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));
  }
  var _anonymousTypeIndex = 0;
  function identifierName(compileIdentifier) {
    if (!compileIdentifier || !compileIdentifier.reference) {
      return null;
    }
    const ref = compileIdentifier.reference;
    if (ref instanceof StaticSymbol) {
      return ref.name;
    }
    if (ref["__anonymousType"]) {
      return ref["__anonymousType"];
    }
    if (ref["__forward_ref__"]) {
      return "__forward_ref__";
    }
    let identifier = stringify2(ref);
    if (identifier.indexOf("(") >= 0) {
      identifier = `anonymous_${_anonymousTypeIndex++}`;
      ref["__anonymousType"] = identifier;
    } else {
      identifier = sanitizeIdentifier(identifier);
    }
    return identifier;
  }
  function sanitizeIdentifier(name) {
    return name.replace(/\W/g, "_");
  }
  var makeTemplateObjectPolyfill = '(this&&this.__makeTemplateObject||function(e,t){return Object.defineProperty?Object.defineProperty(e,"raw",{value:t}):e.raw=t,e})';
  var AbstractJsEmitterVisitor = class extends AbstractEmitterVisitor {
    constructor() {
      super(false);
    }
    visitDeclareClassStmt(stmt, ctx) {
      ctx.pushClass(stmt);
      this._visitClassConstructor(stmt, ctx);
      if (stmt.parent != null) {
        ctx.print(stmt, `${stmt.name}.prototype = Object.create(`);
        stmt.parent.visitExpression(this, ctx);
        ctx.println(stmt, `.prototype);`);
      }
      stmt.getters.forEach((getter) => this._visitClassGetter(stmt, getter, ctx));
      stmt.methods.forEach((method) => this._visitClassMethod(stmt, method, ctx));
      ctx.popClass();
      return null;
    }
    _visitClassConstructor(stmt, ctx) {
      ctx.print(stmt, `function ${stmt.name}(`);
      if (stmt.constructorMethod != null) {
        this._visitParams(stmt.constructorMethod.params, ctx);
      }
      ctx.println(stmt, `) {`);
      ctx.incIndent();
      if (stmt.constructorMethod != null) {
        if (stmt.constructorMethod.body.length > 0) {
          ctx.println(stmt, `var self = this;`);
          this.visitAllStatements(stmt.constructorMethod.body, ctx);
        }
      }
      ctx.decIndent();
      ctx.println(stmt, `}`);
    }
    _visitClassGetter(stmt, getter, ctx) {
      ctx.println(stmt, `Object.defineProperty(${stmt.name}.prototype, '${getter.name}', { get: function() {`);
      ctx.incIndent();
      if (getter.body.length > 0) {
        ctx.println(stmt, `var self = this;`);
        this.visitAllStatements(getter.body, ctx);
      }
      ctx.decIndent();
      ctx.println(stmt, `}});`);
    }
    _visitClassMethod(stmt, method, ctx) {
      ctx.print(stmt, `${stmt.name}.prototype.${method.name} = function(`);
      this._visitParams(method.params, ctx);
      ctx.println(stmt, `) {`);
      ctx.incIndent();
      if (method.body.length > 0) {
        ctx.println(stmt, `var self = this;`);
        this.visitAllStatements(method.body, ctx);
      }
      ctx.decIndent();
      ctx.println(stmt, `};`);
    }
    visitWrappedNodeExpr(ast, ctx) {
      throw new Error("Cannot emit a WrappedNodeExpr in Javascript.");
    }
    visitReadVarExpr(ast, ctx) {
      if (ast.builtin === BuiltinVar.This) {
        ctx.print(ast, "self");
      } else if (ast.builtin === BuiltinVar.Super) {
        throw new Error(`'super' needs to be handled at a parent ast node, not at the variable level!`);
      } else {
        super.visitReadVarExpr(ast, ctx);
      }
      return null;
    }
    visitDeclareVarStmt(stmt, ctx) {
      ctx.print(stmt, `var ${stmt.name}`);
      if (stmt.value) {
        ctx.print(stmt, " = ");
        stmt.value.visitExpression(this, ctx);
      }
      ctx.println(stmt, `;`);
      return null;
    }
    visitCastExpr(ast, ctx) {
      ast.value.visitExpression(this, ctx);
      return null;
    }
    visitInvokeFunctionExpr(expr, ctx) {
      const fnExpr = expr.fn;
      if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {
        ctx.currentClass.parent.visitExpression(this, ctx);
        ctx.print(expr, `.call(this`);
        if (expr.args.length > 0) {
          ctx.print(expr, `, `);
          this.visitAllExpressions(expr.args, ctx, ",");
        }
        ctx.print(expr, `)`);
      } else {
        super.visitInvokeFunctionExpr(expr, ctx);
      }
      return null;
    }
    visitTaggedTemplateExpr(ast, ctx) {
      const elements = ast.template.elements;
      ast.tag.visitExpression(this, ctx);
      ctx.print(ast, `(${makeTemplateObjectPolyfill}(`);
      ctx.print(ast, `[${elements.map((part) => escapeIdentifier(part.text, false)).join(", ")}], `);
      ctx.print(ast, `[${elements.map((part) => escapeIdentifier(part.rawText, false)).join(", ")}])`);
      ast.template.expressions.forEach((expression) => {
        ctx.print(ast, ", ");
        expression.visitExpression(this, ctx);
      });
      ctx.print(ast, ")");
      return null;
    }
    visitFunctionExpr(ast, ctx) {
      ctx.print(ast, `function${ast.name ? " " + ast.name : ""}(`);
      this._visitParams(ast.params, ctx);
      ctx.println(ast, `) {`);
      ctx.incIndent();
      this.visitAllStatements(ast.statements, ctx);
      ctx.decIndent();
      ctx.print(ast, `}`);
      return null;
    }
    visitDeclareFunctionStmt(stmt, ctx) {
      ctx.print(stmt, `function ${stmt.name}(`);
      this._visitParams(stmt.params, ctx);
      ctx.println(stmt, `) {`);
      ctx.incIndent();
      this.visitAllStatements(stmt.statements, ctx);
      ctx.decIndent();
      ctx.println(stmt, `}`);
      return null;
    }
    visitTryCatchStmt(stmt, ctx) {
      ctx.println(stmt, `try {`);
      ctx.incIndent();
      this.visitAllStatements(stmt.bodyStmts, ctx);
      ctx.decIndent();
      ctx.println(stmt, `} catch (${CATCH_ERROR_VAR$1.name}) {`);
      ctx.incIndent();
      const catchStmts = [CATCH_STACK_VAR$1.set(CATCH_ERROR_VAR$1.prop("stack")).toDeclStmt(null, [
        StmtModifier.Final
      ])].concat(stmt.catchStmts);
      this.visitAllStatements(catchStmts, ctx);
      ctx.decIndent();
      ctx.println(stmt, `}`);
      return null;
    }
    visitLocalizedString(ast, ctx) {
      ctx.print(ast, `$localize(${makeTemplateObjectPolyfill}(`);
      const parts = [ast.serializeI18nHead()];
      for (let i = 1; i < ast.messageParts.length; i++) {
        parts.push(ast.serializeI18nTemplatePart(i));
      }
      ctx.print(ast, `[${parts.map((part) => escapeIdentifier(part.cooked, false)).join(", ")}], `);
      ctx.print(ast, `[${parts.map((part) => escapeIdentifier(part.raw, false)).join(", ")}])`);
      ast.expressions.forEach((expression) => {
        ctx.print(ast, ", ");
        expression.visitExpression(this, ctx);
      });
      ctx.print(ast, ")");
      return null;
    }
    _visitParams(params, ctx) {
      this.visitAllObjects((param) => ctx.print(null, param.name), params, ctx, ",");
    }
    getBuiltinMethodName(method) {
      let name;
      switch (method) {
        case BuiltinMethod.ConcatArray:
          name = "concat";
          break;
        case BuiltinMethod.SubscribeObservable:
          name = "subscribe";
          break;
        case BuiltinMethod.Bind:
          name = "bind";
          break;
        default:
          throw new Error(`Unknown builtin method: ${method}`);
      }
      return name;
    }
  };
  var policy2;
  function getPolicy2() {
    if (policy2 === void 0) {
      policy2 = null;
      if (_global3.trustedTypes) {
        try {
          policy2 = _global3.trustedTypes.createPolicy("angular#unsafe-jit", {
            createScript: (s) => s
          });
        } catch {
        }
      }
    }
    return policy2;
  }
  function trustedScriptFromString2(script) {
    return getPolicy2()?.createScript(script) || script;
  }
  function newTrustedFunctionForJIT(...args) {
    if (!_global3.trustedTypes) {
      return new Function(...args);
    }
    const fnArgs = args.slice(0, -1).join(",");
    const fnBody = args[args.length - 1];
    const body = `(function anonymous(${fnArgs}
) { ${fnBody}
})`;
    const fn2 = _global3["eval"](trustedScriptFromString2(body));
    if (fn2.bind === void 0) {
      return new Function(...args);
    }
    fn2.toString = () => body;
    return fn2.bind(_global3);
  }
  var JitEvaluator = class {
    evaluateStatements(sourceUrl, statements, reflector2, createSourceMaps) {
      const converter = new JitEmitterVisitor(reflector2);
      const ctx = EmitterVisitorContext.createRoot();
      if (statements.length > 0 && !isUseStrictStatement(statements[0])) {
        statements = [
          literal("use strict").toStmt(),
          ...statements
        ];
      }
      converter.visitAllStatements(statements, ctx);
      converter.createReturnStmt(ctx);
      return this.evaluateCode(sourceUrl, ctx, converter.getArgs(), createSourceMaps);
    }
    evaluateCode(sourceUrl, ctx, vars, createSourceMap) {
      let fnBody = `"use strict";${ctx.toSource()}
//# sourceURL=${sourceUrl}`;
      const fnArgNames = [];
      const fnArgValues = [];
      for (const argName in vars) {
        fnArgValues.push(vars[argName]);
        fnArgNames.push(argName);
      }
      if (createSourceMap) {
        const emptyFn = newTrustedFunctionForJIT(...fnArgNames.concat("return null;")).toString();
        const headerLines = emptyFn.slice(0, emptyFn.indexOf("return null;")).split("\n").length - 1;
        fnBody += `
${ctx.toSourceMapGenerator(sourceUrl, headerLines).toJsComment()}`;
      }
      const fn2 = newTrustedFunctionForJIT(...fnArgNames.concat(fnBody));
      return this.executeFunction(fn2, fnArgValues);
    }
    executeFunction(fn2, args) {
      return fn2(...args);
    }
  };
  var JitEmitterVisitor = class extends AbstractJsEmitterVisitor {
    constructor(reflector2) {
      super();
      this.reflector = reflector2;
      this._evalArgNames = [];
      this._evalArgValues = [];
      this._evalExportedVars = [];
    }
    createReturnStmt(ctx) {
      const stmt = new ReturnStatement(new LiteralMapExpr(this._evalExportedVars.map((resultVar) => new LiteralMapEntry(resultVar, variable(resultVar), false))));
      stmt.visitStatement(this, ctx);
    }
    getArgs() {
      const result = {};
      for (let i = 0; i < this._evalArgNames.length; i++) {
        result[this._evalArgNames[i]] = this._evalArgValues[i];
      }
      return result;
    }
    visitExternalExpr(ast, ctx) {
      this._emitReferenceToExternal(ast, this.reflector.resolveExternalReference(ast.value), ctx);
      return null;
    }
    visitWrappedNodeExpr(ast, ctx) {
      this._emitReferenceToExternal(ast, ast.node, ctx);
      return null;
    }
    visitDeclareVarStmt(stmt, ctx) {
      if (stmt.hasModifier(StmtModifier.Exported)) {
        this._evalExportedVars.push(stmt.name);
      }
      return super.visitDeclareVarStmt(stmt, ctx);
    }
    visitDeclareFunctionStmt(stmt, ctx) {
      if (stmt.hasModifier(StmtModifier.Exported)) {
        this._evalExportedVars.push(stmt.name);
      }
      return super.visitDeclareFunctionStmt(stmt, ctx);
    }
    visitDeclareClassStmt(stmt, ctx) {
      if (stmt.hasModifier(StmtModifier.Exported)) {
        this._evalExportedVars.push(stmt.name);
      }
      return super.visitDeclareClassStmt(stmt, ctx);
    }
    _emitReferenceToExternal(ast, value, ctx) {
      let id = this._evalArgValues.indexOf(value);
      if (id === -1) {
        id = this._evalArgValues.length;
        this._evalArgValues.push(value);
        const name = identifierName({ reference: value }) || "val";
        this._evalArgNames.push(`jit_${name}_${id}`);
      }
      ctx.print(ast, this._evalArgNames[id]);
    }
  };
  function isUseStrictStatement(statement) {
    return statement.isEquivalent(literal("use strict").toStmt());
  }
  function compileInjector(meta) {
    const definitionMap = new DefinitionMap();
    if (meta.providers !== null) {
      definitionMap.set("providers", meta.providers);
    }
    if (meta.imports.length > 0) {
      definitionMap.set("imports", literalArr(meta.imports));
    }
    const expression = importExpr(Identifiers$1.defineInjector).callFn([definitionMap.toLiteralMap()], void 0, true);
    const type = createInjectorType(meta);
    return { expression, type, statements: [] };
  }
  function createInjectorType(meta) {
    return new ExpressionType(importExpr(Identifiers$1.InjectorDeclaration, [new ExpressionType(meta.type.type)]));
  }
  var R3JitReflector = class {
    constructor(context2) {
      this.context = context2;
    }
    resolveExternalReference(ref) {
      if (ref.moduleName !== "@angular/core") {
        throw new Error(`Cannot resolve external reference to ${ref.moduleName}, only references to @angular/core are supported.`);
      }
      if (!this.context.hasOwnProperty(ref.name)) {
        throw new Error(`No value provided for @angular/core symbol '${ref.name}'.`);
      }
      return this.context[ref.name];
    }
    parameters(typeOrFunc) {
      throw new Error("Not implemented.");
    }
    annotations(typeOrFunc) {
      throw new Error("Not implemented.");
    }
    shallowAnnotations(typeOrFunc) {
      throw new Error("Not implemented.");
    }
    tryAnnotations(typeOrFunc) {
      throw new Error("Not implemented.");
    }
    propMetadata(typeOrFunc) {
      throw new Error("Not implemented.");
    }
    hasLifecycleHook(type, lcProperty) {
      throw new Error("Not implemented.");
    }
    guards(typeOrFunc) {
      throw new Error("Not implemented.");
    }
    componentModuleUrl(type, cmpMetadata) {
      throw new Error("Not implemented.");
    }
  };
  function compileNgModule2(meta) {
    const { internalType, bootstrap, declarations, imports, exports, schemas, containsForwardDecls, emitInline, id } = meta;
    const statements = [];
    const definitionMap = new DefinitionMap();
    definitionMap.set("type", internalType);
    if (bootstrap.length > 0) {
      definitionMap.set("bootstrap", refsToArray(bootstrap, containsForwardDecls));
    }
    if (emitInline) {
      if (declarations.length > 0) {
        definitionMap.set("declarations", refsToArray(declarations, containsForwardDecls));
      }
      if (imports.length > 0) {
        definitionMap.set("imports", refsToArray(imports, containsForwardDecls));
      }
      if (exports.length > 0) {
        definitionMap.set("exports", refsToArray(exports, containsForwardDecls));
      }
    } else {
      const setNgModuleScopeCall = generateSetNgModuleScopeCall(meta);
      if (setNgModuleScopeCall !== null) {
        statements.push(setNgModuleScopeCall);
      }
    }
    if (schemas !== null && schemas.length > 0) {
      definitionMap.set("schemas", literalArr(schemas.map((ref) => ref.value)));
    }
    if (id !== null) {
      definitionMap.set("id", id);
    }
    const expression = importExpr(Identifiers$1.defineNgModule).callFn([definitionMap.toLiteralMap()], void 0, true);
    const type = createNgModuleType(meta);
    return { expression, type, statements };
  }
  function compileNgModuleDeclarationExpression(meta) {
    const definitionMap = new DefinitionMap();
    definitionMap.set("type", new WrappedNodeExpr(meta.type));
    if (meta.bootstrap !== void 0) {
      definitionMap.set("bootstrap", new WrappedNodeExpr(meta.bootstrap));
    }
    if (meta.declarations !== void 0) {
      definitionMap.set("declarations", new WrappedNodeExpr(meta.declarations));
    }
    if (meta.imports !== void 0) {
      definitionMap.set("imports", new WrappedNodeExpr(meta.imports));
    }
    if (meta.exports !== void 0) {
      definitionMap.set("exports", new WrappedNodeExpr(meta.exports));
    }
    if (meta.schemas !== void 0) {
      definitionMap.set("schemas", new WrappedNodeExpr(meta.schemas));
    }
    if (meta.id !== void 0) {
      definitionMap.set("id", new WrappedNodeExpr(meta.id));
    }
    return importExpr(Identifiers$1.defineNgModule).callFn([definitionMap.toLiteralMap()]);
  }
  function createNgModuleType({ type: moduleType, declarations, imports, exports }) {
    return new ExpressionType(importExpr(Identifiers$1.NgModuleDeclaration, [
      new ExpressionType(moduleType.type),
      tupleTypeOf(declarations),
      tupleTypeOf(imports),
      tupleTypeOf(exports)
    ]));
  }
  function generateSetNgModuleScopeCall(meta) {
    const { adjacentType: moduleType, declarations, imports, exports, containsForwardDecls } = meta;
    const scopeMap = new DefinitionMap();
    if (declarations.length > 0) {
      scopeMap.set("declarations", refsToArray(declarations, containsForwardDecls));
    }
    if (imports.length > 0) {
      scopeMap.set("imports", refsToArray(imports, containsForwardDecls));
    }
    if (exports.length > 0) {
      scopeMap.set("exports", refsToArray(exports, containsForwardDecls));
    }
    if (Object.keys(scopeMap.values).length === 0) {
      return null;
    }
    const fnCall = new InvokeFunctionExpr(importExpr(Identifiers$1.setNgModuleScope), [moduleType, scopeMap.toLiteralMap()]);
    const guardedCall = jitOnlyGuardedExpression(fnCall);
    const iife = new FunctionExpr([], [guardedCall.toStmt()]);
    const iifeCall = new InvokeFunctionExpr(iife, []);
    return iifeCall.toStmt();
  }
  function tupleTypeOf(exp) {
    const types = exp.map((ref) => typeofExpr(ref.type));
    return exp.length > 0 ? expressionType(literalArr(types)) : NONE_TYPE;
  }
  function compilePipeFromMetadata(metadata) {
    const definitionMapValues = [];
    definitionMapValues.push({ key: "name", value: literal(metadata.pipeName), quoted: false });
    definitionMapValues.push({ key: "type", value: metadata.type.value, quoted: false });
    definitionMapValues.push({ key: "pure", value: literal(metadata.pure), quoted: false });
    const expression = importExpr(Identifiers$1.definePipe).callFn([literalMap(definitionMapValues)], void 0, true);
    const type = createPipeType(metadata);
    return { expression, type, statements: [] };
  }
  function createPipeType(metadata) {
    return new ExpressionType(importExpr(Identifiers$1.PipeDeclaration, [
      typeWithParameters(metadata.type.type, metadata.typeArgumentCount),
      new ExpressionType(new LiteralExpr(metadata.pipeName))
    ]));
  }
  var ParserError = class {
    constructor(message, input, errLocation, ctxLocation) {
      this.input = input;
      this.errLocation = errLocation;
      this.ctxLocation = ctxLocation;
      this.message = `Parser Error: ${message} ${errLocation} [${input}] in ${ctxLocation}`;
    }
  };
  var ParseSpan = class {
    constructor(start, end) {
      this.start = start;
      this.end = end;
    }
    toAbsolute(absoluteOffset) {
      return new AbsoluteSourceSpan(absoluteOffset + this.start, absoluteOffset + this.end);
    }
  };
  var AST = class {
    constructor(span, sourceSpan) {
      this.span = span;
      this.sourceSpan = sourceSpan;
    }
    toString() {
      return "AST";
    }
  };
  var ASTWithName = class extends AST {
    constructor(span, sourceSpan, nameSpan) {
      super(span, sourceSpan);
      this.nameSpan = nameSpan;
    }
  };
  var Quote = class extends AST {
    constructor(span, sourceSpan, prefix, uninterpretedExpression, location2) {
      super(span, sourceSpan);
      this.prefix = prefix;
      this.uninterpretedExpression = uninterpretedExpression;
      this.location = location2;
    }
    visit(visitor, context2 = null) {
      return visitor.visitQuote(this, context2);
    }
    toString() {
      return "Quote";
    }
  };
  var EmptyExpr = class extends AST {
    visit(visitor, context2 = null) {
    }
  };
  var ImplicitReceiver = class extends AST {
    visit(visitor, context2 = null) {
      return visitor.visitImplicitReceiver(this, context2);
    }
  };
  var ThisReceiver = class extends ImplicitReceiver {
    visit(visitor, context2 = null) {
      return visitor.visitThisReceiver?.(this, context2);
    }
  };
  var Chain = class extends AST {
    constructor(span, sourceSpan, expressions) {
      super(span, sourceSpan);
      this.expressions = expressions;
    }
    visit(visitor, context2 = null) {
      return visitor.visitChain(this, context2);
    }
  };
  var Conditional = class extends AST {
    constructor(span, sourceSpan, condition, trueExp, falseExp) {
      super(span, sourceSpan);
      this.condition = condition;
      this.trueExp = trueExp;
      this.falseExp = falseExp;
    }
    visit(visitor, context2 = null) {
      return visitor.visitConditional(this, context2);
    }
  };
  var PropertyRead = class extends ASTWithName {
    constructor(span, sourceSpan, nameSpan, receiver, name) {
      super(span, sourceSpan, nameSpan);
      this.receiver = receiver;
      this.name = name;
    }
    visit(visitor, context2 = null) {
      return visitor.visitPropertyRead(this, context2);
    }
  };
  var PropertyWrite = class extends ASTWithName {
    constructor(span, sourceSpan, nameSpan, receiver, name, value) {
      super(span, sourceSpan, nameSpan);
      this.receiver = receiver;
      this.name = name;
      this.value = value;
    }
    visit(visitor, context2 = null) {
      return visitor.visitPropertyWrite(this, context2);
    }
  };
  var SafePropertyRead = class extends ASTWithName {
    constructor(span, sourceSpan, nameSpan, receiver, name) {
      super(span, sourceSpan, nameSpan);
      this.receiver = receiver;
      this.name = name;
    }
    visit(visitor, context2 = null) {
      return visitor.visitSafePropertyRead(this, context2);
    }
  };
  var KeyedRead = class extends AST {
    constructor(span, sourceSpan, receiver, key) {
      super(span, sourceSpan);
      this.receiver = receiver;
      this.key = key;
    }
    visit(visitor, context2 = null) {
      return visitor.visitKeyedRead(this, context2);
    }
  };
  var SafeKeyedRead = class extends AST {
    constructor(span, sourceSpan, receiver, key) {
      super(span, sourceSpan);
      this.receiver = receiver;
      this.key = key;
    }
    visit(visitor, context2 = null) {
      return visitor.visitSafeKeyedRead(this, context2);
    }
  };
  var KeyedWrite = class extends AST {
    constructor(span, sourceSpan, receiver, key, value) {
      super(span, sourceSpan);
      this.receiver = receiver;
      this.key = key;
      this.value = value;
    }
    visit(visitor, context2 = null) {
      return visitor.visitKeyedWrite(this, context2);
    }
  };
  var BindingPipe = class extends ASTWithName {
    constructor(span, sourceSpan, exp, name, args, nameSpan) {
      super(span, sourceSpan, nameSpan);
      this.exp = exp;
      this.name = name;
      this.args = args;
    }
    visit(visitor, context2 = null) {
      return visitor.visitPipe(this, context2);
    }
  };
  var LiteralPrimitive = class extends AST {
    constructor(span, sourceSpan, value) {
      super(span, sourceSpan);
      this.value = value;
    }
    visit(visitor, context2 = null) {
      return visitor.visitLiteralPrimitive(this, context2);
    }
  };
  var LiteralArray = class extends AST {
    constructor(span, sourceSpan, expressions) {
      super(span, sourceSpan);
      this.expressions = expressions;
    }
    visit(visitor, context2 = null) {
      return visitor.visitLiteralArray(this, context2);
    }
  };
  var LiteralMap = class extends AST {
    constructor(span, sourceSpan, keys, values) {
      super(span, sourceSpan);
      this.keys = keys;
      this.values = values;
    }
    visit(visitor, context2 = null) {
      return visitor.visitLiteralMap(this, context2);
    }
  };
  var Interpolation = class extends AST {
    constructor(span, sourceSpan, strings, expressions) {
      super(span, sourceSpan);
      this.strings = strings;
      this.expressions = expressions;
    }
    visit(visitor, context2 = null) {
      return visitor.visitInterpolation(this, context2);
    }
  };
  var Binary = class extends AST {
    constructor(span, sourceSpan, operation, left, right) {
      super(span, sourceSpan);
      this.operation = operation;
      this.left = left;
      this.right = right;
    }
    visit(visitor, context2 = null) {
      return visitor.visitBinary(this, context2);
    }
  };
  var Unary = class extends Binary {
    constructor(span, sourceSpan, operator, expr, binaryOp, binaryLeft, binaryRight) {
      super(span, sourceSpan, binaryOp, binaryLeft, binaryRight);
      this.operator = operator;
      this.expr = expr;
      this.left = null;
      this.right = null;
      this.operation = null;
    }
    static createMinus(span, sourceSpan, expr) {
      return new Unary(span, sourceSpan, "-", expr, "-", new LiteralPrimitive(span, sourceSpan, 0), expr);
    }
    static createPlus(span, sourceSpan, expr) {
      return new Unary(span, sourceSpan, "+", expr, "-", expr, new LiteralPrimitive(span, sourceSpan, 0));
    }
    visit(visitor, context2 = null) {
      if (visitor.visitUnary !== void 0) {
        return visitor.visitUnary(this, context2);
      }
      return visitor.visitBinary(this, context2);
    }
  };
  var PrefixNot = class extends AST {
    constructor(span, sourceSpan, expression) {
      super(span, sourceSpan);
      this.expression = expression;
    }
    visit(visitor, context2 = null) {
      return visitor.visitPrefixNot(this, context2);
    }
  };
  var NonNullAssert = class extends AST {
    constructor(span, sourceSpan, expression) {
      super(span, sourceSpan);
      this.expression = expression;
    }
    visit(visitor, context2 = null) {
      return visitor.visitNonNullAssert(this, context2);
    }
  };
  var Call = class extends AST {
    constructor(span, sourceSpan, receiver, args, argumentSpan) {
      super(span, sourceSpan);
      this.receiver = receiver;
      this.args = args;
      this.argumentSpan = argumentSpan;
    }
    visit(visitor, context2 = null) {
      return visitor.visitCall(this, context2);
    }
  };
  var AbsoluteSourceSpan = class {
    constructor(start, end) {
      this.start = start;
      this.end = end;
    }
  };
  var ASTWithSource = class extends AST {
    constructor(ast, source, location2, absoluteOffset, errors) {
      super(new ParseSpan(0, source === null ? 0 : source.length), new AbsoluteSourceSpan(absoluteOffset, source === null ? absoluteOffset : absoluteOffset + source.length));
      this.ast = ast;
      this.source = source;
      this.location = location2;
      this.errors = errors;
    }
    visit(visitor, context2 = null) {
      if (visitor.visitASTWithSource) {
        return visitor.visitASTWithSource(this, context2);
      }
      return this.ast.visit(visitor, context2);
    }
    toString() {
      return `${this.source} in ${this.location}`;
    }
  };
  var VariableBinding = class {
    constructor(sourceSpan, key, value) {
      this.sourceSpan = sourceSpan;
      this.key = key;
      this.value = value;
    }
  };
  var ExpressionBinding = class {
    constructor(sourceSpan, key, value) {
      this.sourceSpan = sourceSpan;
      this.key = key;
      this.value = value;
    }
  };
  var RecursiveAstVisitor = class {
    visit(ast, context2) {
      ast.visit(this, context2);
    }
    visitUnary(ast, context2) {
      this.visit(ast.expr, context2);
    }
    visitBinary(ast, context2) {
      this.visit(ast.left, context2);
      this.visit(ast.right, context2);
    }
    visitChain(ast, context2) {
      this.visitAll(ast.expressions, context2);
    }
    visitConditional(ast, context2) {
      this.visit(ast.condition, context2);
      this.visit(ast.trueExp, context2);
      this.visit(ast.falseExp, context2);
    }
    visitPipe(ast, context2) {
      this.visit(ast.exp, context2);
      this.visitAll(ast.args, context2);
    }
    visitImplicitReceiver(ast, context2) {
    }
    visitThisReceiver(ast, context2) {
    }
    visitInterpolation(ast, context2) {
      this.visitAll(ast.expressions, context2);
    }
    visitKeyedRead(ast, context2) {
      this.visit(ast.receiver, context2);
      this.visit(ast.key, context2);
    }
    visitKeyedWrite(ast, context2) {
      this.visit(ast.receiver, context2);
      this.visit(ast.key, context2);
      this.visit(ast.value, context2);
    }
    visitLiteralArray(ast, context2) {
      this.visitAll(ast.expressions, context2);
    }
    visitLiteralMap(ast, context2) {
      this.visitAll(ast.values, context2);
    }
    visitLiteralPrimitive(ast, context2) {
    }
    visitPrefixNot(ast, context2) {
      this.visit(ast.expression, context2);
    }
    visitNonNullAssert(ast, context2) {
      this.visit(ast.expression, context2);
    }
    visitPropertyRead(ast, context2) {
      this.visit(ast.receiver, context2);
    }
    visitPropertyWrite(ast, context2) {
      this.visit(ast.receiver, context2);
      this.visit(ast.value, context2);
    }
    visitSafePropertyRead(ast, context2) {
      this.visit(ast.receiver, context2);
    }
    visitSafeKeyedRead(ast, context2) {
      this.visit(ast.receiver, context2);
      this.visit(ast.key, context2);
    }
    visitCall(ast, context2) {
      this.visit(ast.receiver, context2);
      this.visitAll(ast.args, context2);
    }
    visitQuote(ast, context2) {
    }
    visitAll(asts, context2) {
      for (const ast of asts) {
        this.visit(ast, context2);
      }
    }
  };
  var AstTransformer = class {
    visitImplicitReceiver(ast, context2) {
      return ast;
    }
    visitThisReceiver(ast, context2) {
      return ast;
    }
    visitInterpolation(ast, context2) {
      return new Interpolation(ast.span, ast.sourceSpan, ast.strings, this.visitAll(ast.expressions));
    }
    visitLiteralPrimitive(ast, context2) {
      return new LiteralPrimitive(ast.span, ast.sourceSpan, ast.value);
    }
    visitPropertyRead(ast, context2) {
      return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);
    }
    visitPropertyWrite(ast, context2) {
      return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name, ast.value.visit(this));
    }
    visitSafePropertyRead(ast, context2) {
      return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);
    }
    visitLiteralArray(ast, context2) {
      return new LiteralArray(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));
    }
    visitLiteralMap(ast, context2) {
      return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, this.visitAll(ast.values));
    }
    visitUnary(ast, context2) {
      switch (ast.operator) {
        case "+":
          return Unary.createPlus(ast.span, ast.sourceSpan, ast.expr.visit(this));
        case "-":
          return Unary.createMinus(ast.span, ast.sourceSpan, ast.expr.visit(this));
        default:
          throw new Error(`Unknown unary operator ${ast.operator}`);
      }
    }
    visitBinary(ast, context2) {
      return new Binary(ast.span, ast.sourceSpan, ast.operation, ast.left.visit(this), ast.right.visit(this));
    }
    visitPrefixNot(ast, context2) {
      return new PrefixNot(ast.span, ast.sourceSpan, ast.expression.visit(this));
    }
    visitNonNullAssert(ast, context2) {
      return new NonNullAssert(ast.span, ast.sourceSpan, ast.expression.visit(this));
    }
    visitConditional(ast, context2) {
      return new Conditional(ast.span, ast.sourceSpan, ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));
    }
    visitPipe(ast, context2) {
      return new BindingPipe(ast.span, ast.sourceSpan, ast.exp.visit(this), ast.name, this.visitAll(ast.args), ast.nameSpan);
    }
    visitKeyedRead(ast, context2) {
      return new KeyedRead(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this));
    }
    visitKeyedWrite(ast, context2) {
      return new KeyedWrite(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this), ast.value.visit(this));
    }
    visitCall(ast, context2) {
      return new Call(ast.span, ast.sourceSpan, ast.receiver.visit(this), this.visitAll(ast.args), ast.argumentSpan);
    }
    visitAll(asts) {
      const res = [];
      for (let i = 0; i < asts.length; ++i) {
        res[i] = asts[i].visit(this);
      }
      return res;
    }
    visitChain(ast, context2) {
      return new Chain(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));
    }
    visitQuote(ast, context2) {
      return new Quote(ast.span, ast.sourceSpan, ast.prefix, ast.uninterpretedExpression, ast.location);
    }
    visitSafeKeyedRead(ast, context2) {
      return new SafeKeyedRead(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this));
    }
  };
  var AstMemoryEfficientTransformer = class {
    visitImplicitReceiver(ast, context2) {
      return ast;
    }
    visitThisReceiver(ast, context2) {
      return ast;
    }
    visitInterpolation(ast, context2) {
      const expressions = this.visitAll(ast.expressions);
      if (expressions !== ast.expressions)
        return new Interpolation(ast.span, ast.sourceSpan, ast.strings, expressions);
      return ast;
    }
    visitLiteralPrimitive(ast, context2) {
      return ast;
    }
    visitPropertyRead(ast, context2) {
      const receiver = ast.receiver.visit(this);
      if (receiver !== ast.receiver) {
        return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);
      }
      return ast;
    }
    visitPropertyWrite(ast, context2) {
      const receiver = ast.receiver.visit(this);
      const value = ast.value.visit(this);
      if (receiver !== ast.receiver || value !== ast.value) {
        return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, value);
      }
      return ast;
    }
    visitSafePropertyRead(ast, context2) {
      const receiver = ast.receiver.visit(this);
      if (receiver !== ast.receiver) {
        return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);
      }
      return ast;
    }
    visitLiteralArray(ast, context2) {
      const expressions = this.visitAll(ast.expressions);
      if (expressions !== ast.expressions) {
        return new LiteralArray(ast.span, ast.sourceSpan, expressions);
      }
      return ast;
    }
    visitLiteralMap(ast, context2) {
      const values = this.visitAll(ast.values);
      if (values !== ast.values) {
        return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, values);
      }
      return ast;
    }
    visitUnary(ast, context2) {
      const expr = ast.expr.visit(this);
      if (expr !== ast.expr) {
        switch (ast.operator) {
          case "+":
            return Unary.createPlus(ast.span, ast.sourceSpan, expr);
          case "-":
            return Unary.createMinus(ast.span, ast.sourceSpan, expr);
          default:
            throw new Error(`Unknown unary operator ${ast.operator}`);
        }
      }
      return ast;
    }
    visitBinary(ast, context2) {
      const left = ast.left.visit(this);
      const right = ast.right.visit(this);
      if (left !== ast.left || right !== ast.right) {
        return new Binary(ast.span, ast.sourceSpan, ast.operation, left, right);
      }
      return ast;
    }
    visitPrefixNot(ast, context2) {
      const expression = ast.expression.visit(this);
      if (expression !== ast.expression) {
        return new PrefixNot(ast.span, ast.sourceSpan, expression);
      }
      return ast;
    }
    visitNonNullAssert(ast, context2) {
      const expression = ast.expression.visit(this);
      if (expression !== ast.expression) {
        return new NonNullAssert(ast.span, ast.sourceSpan, expression);
      }
      return ast;
    }
    visitConditional(ast, context2) {
      const condition = ast.condition.visit(this);
      const trueExp = ast.trueExp.visit(this);
      const falseExp = ast.falseExp.visit(this);
      if (condition !== ast.condition || trueExp !== ast.trueExp || falseExp !== ast.falseExp) {
        return new Conditional(ast.span, ast.sourceSpan, condition, trueExp, falseExp);
      }
      return ast;
    }
    visitPipe(ast, context2) {
      const exp = ast.exp.visit(this);
      const args = this.visitAll(ast.args);
      if (exp !== ast.exp || args !== ast.args) {
        return new BindingPipe(ast.span, ast.sourceSpan, exp, ast.name, args, ast.nameSpan);
      }
      return ast;
    }
    visitKeyedRead(ast, context2) {
      const obj = ast.receiver.visit(this);
      const key = ast.key.visit(this);
      if (obj !== ast.receiver || key !== ast.key) {
        return new KeyedRead(ast.span, ast.sourceSpan, obj, key);
      }
      return ast;
    }
    visitKeyedWrite(ast, context2) {
      const obj = ast.receiver.visit(this);
      const key = ast.key.visit(this);
      const value = ast.value.visit(this);
      if (obj !== ast.receiver || key !== ast.key || value !== ast.value) {
        return new KeyedWrite(ast.span, ast.sourceSpan, obj, key, value);
      }
      return ast;
    }
    visitAll(asts) {
      const res = [];
      let modified = false;
      for (let i = 0; i < asts.length; ++i) {
        const original = asts[i];
        const value = original.visit(this);
        res[i] = value;
        modified = modified || value !== original;
      }
      return modified ? res : asts;
    }
    visitChain(ast, context2) {
      const expressions = this.visitAll(ast.expressions);
      if (expressions !== ast.expressions) {
        return new Chain(ast.span, ast.sourceSpan, expressions);
      }
      return ast;
    }
    visitCall(ast, context2) {
      const receiver = ast.receiver.visit(this);
      const args = this.visitAll(ast.args);
      if (receiver !== ast.receiver || args !== ast.args) {
        return new Call(ast.span, ast.sourceSpan, receiver, args, ast.argumentSpan);
      }
      return ast;
    }
    visitQuote(ast, context2) {
      return ast;
    }
    visitSafeKeyedRead(ast, context2) {
      const obj = ast.receiver.visit(this);
      const key = ast.key.visit(this);
      if (obj !== ast.receiver || key !== ast.key) {
        return new SafeKeyedRead(ast.span, ast.sourceSpan, obj, key);
      }
      return ast;
    }
  };
  var ParsedProperty = class {
    constructor(name, expression, type, sourceSpan, keySpan, valueSpan) {
      this.name = name;
      this.expression = expression;
      this.type = type;
      this.sourceSpan = sourceSpan;
      this.keySpan = keySpan;
      this.valueSpan = valueSpan;
      this.isLiteral = this.type === ParsedPropertyType.LITERAL_ATTR;
      this.isAnimation = this.type === ParsedPropertyType.ANIMATION;
    }
  };
  var ParsedPropertyType;
  (function(ParsedPropertyType2) {
    ParsedPropertyType2[ParsedPropertyType2["DEFAULT"] = 0] = "DEFAULT";
    ParsedPropertyType2[ParsedPropertyType2["LITERAL_ATTR"] = 1] = "LITERAL_ATTR";
    ParsedPropertyType2[ParsedPropertyType2["ANIMATION"] = 2] = "ANIMATION";
  })(ParsedPropertyType || (ParsedPropertyType = {}));
  var ParsedEvent = class {
    constructor(name, targetOrPhase, type, handler, sourceSpan, handlerSpan, keySpan) {
      this.name = name;
      this.targetOrPhase = targetOrPhase;
      this.type = type;
      this.handler = handler;
      this.sourceSpan = sourceSpan;
      this.handlerSpan = handlerSpan;
      this.keySpan = keySpan;
    }
  };
  var ParsedVariable = class {
    constructor(name, value, sourceSpan, keySpan, valueSpan) {
      this.name = name;
      this.value = value;
      this.sourceSpan = sourceSpan;
      this.keySpan = keySpan;
      this.valueSpan = valueSpan;
    }
  };
  var BoundElementProperty = class {
    constructor(name, type, securityContext, value, unit, sourceSpan, keySpan, valueSpan) {
      this.name = name;
      this.type = type;
      this.securityContext = securityContext;
      this.value = value;
      this.unit = unit;
      this.sourceSpan = sourceSpan;
      this.keySpan = keySpan;
      this.valueSpan = valueSpan;
    }
  };
  var CORE = "@angular/core";
  var Identifiers = class {
  };
  Identifiers.ANALYZE_FOR_ENTRY_COMPONENTS = {
    name: "ANALYZE_FOR_ENTRY_COMPONENTS",
    moduleName: CORE
  };
  Identifiers.ElementRef = { name: "ElementRef", moduleName: CORE };
  Identifiers.NgModuleRef = { name: "NgModuleRef", moduleName: CORE };
  Identifiers.ViewContainerRef = { name: "ViewContainerRef", moduleName: CORE };
  Identifiers.ChangeDetectorRef = {
    name: "ChangeDetectorRef",
    moduleName: CORE
  };
  Identifiers.QueryList = { name: "QueryList", moduleName: CORE };
  Identifiers.TemplateRef = { name: "TemplateRef", moduleName: CORE };
  Identifiers.Renderer2 = { name: "Renderer2", moduleName: CORE };
  Identifiers.CodegenComponentFactoryResolver = {
    name: "\u0275CodegenComponentFactoryResolver",
    moduleName: CORE
  };
  Identifiers.ComponentFactoryResolver = {
    name: "ComponentFactoryResolver",
    moduleName: CORE
  };
  Identifiers.ComponentFactory = { name: "ComponentFactory", moduleName: CORE };
  Identifiers.ComponentRef = { name: "ComponentRef", moduleName: CORE };
  Identifiers.NgModuleFactory = { name: "NgModuleFactory", moduleName: CORE };
  Identifiers.createModuleFactory = {
    name: "\u0275cmf",
    moduleName: CORE
  };
  Identifiers.moduleDef = {
    name: "\u0275mod",
    moduleName: CORE
  };
  Identifiers.moduleProviderDef = {
    name: "\u0275mpd",
    moduleName: CORE
  };
  Identifiers.RegisterModuleFactoryFn = {
    name: "\u0275registerModuleFactory",
    moduleName: CORE
  };
  Identifiers.inject = { name: "\u0275\u0275inject", moduleName: CORE };
  Identifiers.directiveInject = { name: "\u0275\u0275directiveInject", moduleName: CORE };
  Identifiers.INJECTOR = { name: "INJECTOR", moduleName: CORE };
  Identifiers.Injector = { name: "Injector", moduleName: CORE };
  Identifiers.ViewEncapsulation = {
    name: "ViewEncapsulation",
    moduleName: CORE
  };
  Identifiers.ChangeDetectionStrategy = {
    name: "ChangeDetectionStrategy",
    moduleName: CORE
  };
  Identifiers.SecurityContext = {
    name: "SecurityContext",
    moduleName: CORE
  };
  Identifiers.LOCALE_ID = { name: "LOCALE_ID", moduleName: CORE };
  Identifiers.TRANSLATIONS_FORMAT = {
    name: "TRANSLATIONS_FORMAT",
    moduleName: CORE
  };
  Identifiers.inlineInterpolate = {
    name: "\u0275inlineInterpolate",
    moduleName: CORE
  };
  Identifiers.interpolate = { name: "\u0275interpolate", moduleName: CORE };
  Identifiers.EMPTY_ARRAY = { name: "\u0275EMPTY_ARRAY", moduleName: CORE };
  Identifiers.EMPTY_MAP = { name: "\u0275EMPTY_MAP", moduleName: CORE };
  Identifiers.Renderer = { name: "Renderer", moduleName: CORE };
  Identifiers.viewDef = { name: "\u0275vid", moduleName: CORE };
  Identifiers.elementDef = { name: "\u0275eld", moduleName: CORE };
  Identifiers.anchorDef = { name: "\u0275and", moduleName: CORE };
  Identifiers.textDef = { name: "\u0275ted", moduleName: CORE };
  Identifiers.directiveDef = { name: "\u0275did", moduleName: CORE };
  Identifiers.providerDef = { name: "\u0275prd", moduleName: CORE };
  Identifiers.queryDef = { name: "\u0275qud", moduleName: CORE };
  Identifiers.pureArrayDef = { name: "\u0275pad", moduleName: CORE };
  Identifiers.pureObjectDef = { name: "\u0275pod", moduleName: CORE };
  Identifiers.purePipeDef = { name: "\u0275ppd", moduleName: CORE };
  Identifiers.pipeDef = { name: "\u0275pid", moduleName: CORE };
  Identifiers.nodeValue = { name: "\u0275nov", moduleName: CORE };
  Identifiers.ngContentDef = { name: "\u0275ncd", moduleName: CORE };
  Identifiers.createRendererType2 = { name: "\u0275crt", moduleName: CORE };
  Identifiers.RendererType2 = {
    name: "RendererType2",
    moduleName: CORE
  };
  Identifiers.ViewDefinition = {
    name: "\u0275ViewDefinition",
    moduleName: CORE
  };
  Identifiers.createComponentFactory = { name: "\u0275ccf", moduleName: CORE };
  var EventHandlerVars = class {
  };
  EventHandlerVars.event = variable("$event");
  var ConvertActionBindingResult = class {
    constructor(stmts, allowDefault) {
      this.stmts = stmts;
      this.allowDefault = allowDefault;
      this.render3Stmts = stmts.map((statement) => {
        if (statement instanceof DeclareVarStmt && statement.name == allowDefault.name && statement.value instanceof BinaryOperatorExpr) {
          const lhs = statement.value.lhs;
          return new ReturnStatement(lhs.value);
        }
        return statement;
      });
    }
  };
  function convertActionBinding(localResolver, implicitReceiver, action, bindingId, interpolationFunction, baseSourceSpan, implicitReceiverAccesses, globals) {
    if (!localResolver) {
      localResolver = new DefaultLocalResolver(globals);
    }
    const actionWithoutBuiltins = convertPropertyBindingBuiltins({
      createLiteralArrayConverter: (argCount) => {
        return (args) => literalArr(args);
      },
      createLiteralMapConverter: (keys) => {
        return (values) => {
          const entries = keys.map((k, i) => ({
            key: k.key,
            value: values[i],
            quoted: k.quoted
          }));
          return literalMap(entries);
        };
      },
      createPipeConverter: (name) => {
        throw new Error(`Illegal State: Actions are not allowed to contain pipes. Pipe: ${name}`);
      }
    }, action);
    const visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction, baseSourceSpan, implicitReceiverAccesses);
    const actionStmts = [];
    flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);
    prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);
    if (visitor.usesImplicitReceiver) {
      localResolver.notifyImplicitReceiverUse();
    }
    const lastIndex = actionStmts.length - 1;
    let preventDefaultVar = null;
    if (lastIndex >= 0) {
      const lastStatement = actionStmts[lastIndex];
      const returnExpr = convertStmtIntoExpression(lastStatement);
      if (returnExpr) {
        preventDefaultVar = createPreventDefaultVar(bindingId);
        actionStmts[lastIndex] = preventDefaultVar.set(returnExpr.cast(DYNAMIC_TYPE).notIdentical(literal(false))).toDeclStmt(null, [StmtModifier.Final]);
      }
    }
    return new ConvertActionBindingResult(actionStmts, preventDefaultVar);
  }
  function convertPropertyBindingBuiltins(converterFactory, ast) {
    return convertBuiltins(converterFactory, ast);
  }
  var ConvertPropertyBindingResult = class {
    constructor(stmts, currValExpr) {
      this.stmts = stmts;
      this.currValExpr = currValExpr;
    }
  };
  var BindingForm;
  (function(BindingForm2) {
    BindingForm2[BindingForm2["General"] = 0] = "General";
    BindingForm2[BindingForm2["TrySimple"] = 1] = "TrySimple";
    BindingForm2[BindingForm2["Expression"] = 2] = "Expression";
  })(BindingForm || (BindingForm = {}));
  function convertPropertyBinding(localResolver, implicitReceiver, expressionWithoutBuiltins, bindingId, form, interpolationFunction) {
    if (!localResolver) {
      localResolver = new DefaultLocalResolver();
    }
    const visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction);
    const outputExpr = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);
    const stmts = getStatementsFromVisitor(visitor, bindingId);
    if (visitor.usesImplicitReceiver) {
      localResolver.notifyImplicitReceiverUse();
    }
    if (visitor.temporaryCount === 0 && form == BindingForm.TrySimple) {
      return new ConvertPropertyBindingResult([], outputExpr);
    } else if (form === BindingForm.Expression) {
      return new ConvertPropertyBindingResult(stmts, outputExpr);
    }
    const currValExpr = createCurrValueExpr(bindingId);
    stmts.push(currValExpr.set(outputExpr).toDeclStmt(DYNAMIC_TYPE, [StmtModifier.Final]));
    return new ConvertPropertyBindingResult(stmts, currValExpr);
  }
  function convertUpdateArguments(localResolver, contextVariableExpression, expressionWithArgumentsToExtract, bindingId) {
    const visitor = new _AstToIrVisitor(localResolver, contextVariableExpression, bindingId, void 0);
    const outputExpr = expressionWithArgumentsToExtract.visit(visitor, _Mode.Expression);
    if (visitor.usesImplicitReceiver) {
      localResolver.notifyImplicitReceiverUse();
    }
    const stmts = getStatementsFromVisitor(visitor, bindingId);
    let args = outputExpr.args.slice(1);
    if (expressionWithArgumentsToExtract instanceof Interpolation) {
      const strings = expressionWithArgumentsToExtract.strings;
      if (args.length === 3 && strings[0] === "" && strings[1] === "") {
        args = [args[1]];
      } else if (args.length >= 19) {
        args = [literalArr(args)];
      }
    }
    return { stmts, args };
  }
  function getStatementsFromVisitor(visitor, bindingId) {
    const stmts = [];
    for (let i = 0; i < visitor.temporaryCount; i++) {
      stmts.push(temporaryDeclaration(bindingId, i));
    }
    return stmts;
  }
  function convertBuiltins(converterFactory, ast) {
    const visitor = new _BuiltinAstConverter(converterFactory);
    return ast.visit(visitor);
  }
  function temporaryName(bindingId, temporaryNumber) {
    return `tmp_${bindingId}_${temporaryNumber}`;
  }
  function temporaryDeclaration(bindingId, temporaryNumber) {
    return new DeclareVarStmt(temporaryName(bindingId, temporaryNumber));
  }
  function prependTemporaryDecls(temporaryCount, bindingId, statements) {
    for (let i = temporaryCount - 1; i >= 0; i--) {
      statements.unshift(temporaryDeclaration(bindingId, i));
    }
  }
  var _Mode;
  (function(_Mode2) {
    _Mode2[_Mode2["Statement"] = 0] = "Statement";
    _Mode2[_Mode2["Expression"] = 1] = "Expression";
  })(_Mode || (_Mode = {}));
  function ensureStatementMode(mode, ast) {
    if (mode !== _Mode.Statement) {
      throw new Error(`Expected a statement, but saw ${ast}`);
    }
  }
  function ensureExpressionMode(mode, ast) {
    if (mode !== _Mode.Expression) {
      throw new Error(`Expected an expression, but saw ${ast}`);
    }
  }
  function convertToStatementIfNeeded(mode, expr) {
    if (mode === _Mode.Statement) {
      return expr.toStmt();
    } else {
      return expr;
    }
  }
  var _BuiltinAstConverter = class extends AstTransformer {
    constructor(_converterFactory) {
      super();
      this._converterFactory = _converterFactory;
    }
    visitPipe(ast, context2) {
      const args = [ast.exp, ...ast.args].map((ast2) => ast2.visit(this, context2));
      return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createPipeConverter(ast.name, args.length));
    }
    visitLiteralArray(ast, context2) {
      const args = ast.expressions.map((ast2) => ast2.visit(this, context2));
      return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralArrayConverter(ast.expressions.length));
    }
    visitLiteralMap(ast, context2) {
      const args = ast.values.map((ast2) => ast2.visit(this, context2));
      return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralMapConverter(ast.keys));
    }
  };
  var _AstToIrVisitor = class {
    constructor(_localResolver, _implicitReceiver, bindingId, interpolationFunction, baseSourceSpan, implicitReceiverAccesses) {
      this._localResolver = _localResolver;
      this._implicitReceiver = _implicitReceiver;
      this.bindingId = bindingId;
      this.interpolationFunction = interpolationFunction;
      this.baseSourceSpan = baseSourceSpan;
      this.implicitReceiverAccesses = implicitReceiverAccesses;
      this._nodeMap = /* @__PURE__ */ new Map();
      this._resultMap = /* @__PURE__ */ new Map();
      this._currentTemporary = 0;
      this.temporaryCount = 0;
      this.usesImplicitReceiver = false;
    }
    visitUnary(ast, mode) {
      let op;
      switch (ast.operator) {
        case "+":
          op = UnaryOperator.Plus;
          break;
        case "-":
          op = UnaryOperator.Minus;
          break;
        default:
          throw new Error(`Unsupported operator ${ast.operator}`);
      }
      return convertToStatementIfNeeded(mode, new UnaryOperatorExpr(op, this._visit(ast.expr, _Mode.Expression), void 0, this.convertSourceSpan(ast.span)));
    }
    visitBinary(ast, mode) {
      let op;
      switch (ast.operation) {
        case "+":
          op = BinaryOperator.Plus;
          break;
        case "-":
          op = BinaryOperator.Minus;
          break;
        case "*":
          op = BinaryOperator.Multiply;
          break;
        case "/":
          op = BinaryOperator.Divide;
          break;
        case "%":
          op = BinaryOperator.Modulo;
          break;
        case "&&":
          op = BinaryOperator.And;
          break;
        case "||":
          op = BinaryOperator.Or;
          break;
        case "==":
          op = BinaryOperator.Equals;
          break;
        case "!=":
          op = BinaryOperator.NotEquals;
          break;
        case "===":
          op = BinaryOperator.Identical;
          break;
        case "!==":
          op = BinaryOperator.NotIdentical;
          break;
        case "<":
          op = BinaryOperator.Lower;
          break;
        case ">":
          op = BinaryOperator.Bigger;
          break;
        case "<=":
          op = BinaryOperator.LowerEquals;
          break;
        case ">=":
          op = BinaryOperator.BiggerEquals;
          break;
        case "??":
          return this.convertNullishCoalesce(ast, mode);
        default:
          throw new Error(`Unsupported operation ${ast.operation}`);
      }
      return convertToStatementIfNeeded(mode, new BinaryOperatorExpr(op, this._visit(ast.left, _Mode.Expression), this._visit(ast.right, _Mode.Expression), void 0, this.convertSourceSpan(ast.span)));
    }
    visitChain(ast, mode) {
      ensureStatementMode(mode, ast);
      return this.visitAll(ast.expressions, mode);
    }
    visitConditional(ast, mode) {
      const value = this._visit(ast.condition, _Mode.Expression);
      return convertToStatementIfNeeded(mode, value.conditional(this._visit(ast.trueExp, _Mode.Expression), this._visit(ast.falseExp, _Mode.Expression), this.convertSourceSpan(ast.span)));
    }
    visitPipe(ast, mode) {
      throw new Error(`Illegal state: Pipes should have been converted into functions. Pipe: ${ast.name}`);
    }
    visitImplicitReceiver(ast, mode) {
      ensureExpressionMode(mode, ast);
      this.usesImplicitReceiver = true;
      return this._implicitReceiver;
    }
    visitThisReceiver(ast, mode) {
      return this.visitImplicitReceiver(ast, mode);
    }
    visitInterpolation(ast, mode) {
      ensureExpressionMode(mode, ast);
      const args = [literal(ast.expressions.length)];
      for (let i = 0; i < ast.strings.length - 1; i++) {
        args.push(literal(ast.strings[i]));
        args.push(this._visit(ast.expressions[i], _Mode.Expression));
      }
      args.push(literal(ast.strings[ast.strings.length - 1]));
      if (this.interpolationFunction) {
        return this.interpolationFunction(args);
      }
      return ast.expressions.length <= 9 ? importExpr(Identifiers.inlineInterpolate).callFn(args) : importExpr(Identifiers.interpolate).callFn([
        args[0],
        literalArr(args.slice(1), void 0, this.convertSourceSpan(ast.span))
      ]);
    }
    visitKeyedRead(ast, mode) {
      const leftMostSafe = this.leftMostSafeNode(ast);
      if (leftMostSafe) {
        return this.convertSafeAccess(ast, leftMostSafe, mode);
      } else {
        return convertToStatementIfNeeded(mode, this._visit(ast.receiver, _Mode.Expression).key(this._visit(ast.key, _Mode.Expression)));
      }
    }
    visitKeyedWrite(ast, mode) {
      const obj = this._visit(ast.receiver, _Mode.Expression);
      const key = this._visit(ast.key, _Mode.Expression);
      const value = this._visit(ast.value, _Mode.Expression);
      if (obj === this._implicitReceiver) {
        this._localResolver.maybeRestoreView();
      }
      return convertToStatementIfNeeded(mode, obj.key(key).set(value));
    }
    visitLiteralArray(ast, mode) {
      throw new Error(`Illegal State: literal arrays should have been converted into functions`);
    }
    visitLiteralMap(ast, mode) {
      throw new Error(`Illegal State: literal maps should have been converted into functions`);
    }
    visitLiteralPrimitive(ast, mode) {
      const type = ast.value === null || ast.value === void 0 || ast.value === true || ast.value === true ? INFERRED_TYPE : void 0;
      return convertToStatementIfNeeded(mode, literal(ast.value, type, this.convertSourceSpan(ast.span)));
    }
    _getLocal(name, receiver) {
      if (this._localResolver.globals?.has(name) && receiver instanceof ThisReceiver) {
        return null;
      }
      return this._localResolver.getLocal(name);
    }
    visitPrefixNot(ast, mode) {
      return convertToStatementIfNeeded(mode, not(this._visit(ast.expression, _Mode.Expression)));
    }
    visitNonNullAssert(ast, mode) {
      return convertToStatementIfNeeded(mode, assertNotNull(this._visit(ast.expression, _Mode.Expression)));
    }
    visitPropertyRead(ast, mode) {
      const leftMostSafe = this.leftMostSafeNode(ast);
      if (leftMostSafe) {
        return this.convertSafeAccess(ast, leftMostSafe, mode);
      } else {
        let result = null;
        const prevUsesImplicitReceiver = this.usesImplicitReceiver;
        const receiver = this._visit(ast.receiver, _Mode.Expression);
        if (receiver === this._implicitReceiver) {
          result = this._getLocal(ast.name, ast.receiver);
          if (result) {
            this.usesImplicitReceiver = prevUsesImplicitReceiver;
            this.addImplicitReceiverAccess(ast.name);
          }
        }
        if (result == null) {
          result = receiver.prop(ast.name, this.convertSourceSpan(ast.span));
        }
        return convertToStatementIfNeeded(mode, result);
      }
    }
    visitPropertyWrite(ast, mode) {
      const receiver = this._visit(ast.receiver, _Mode.Expression);
      const prevUsesImplicitReceiver = this.usesImplicitReceiver;
      let varExpr = null;
      if (receiver === this._implicitReceiver) {
        const localExpr = this._getLocal(ast.name, ast.receiver);
        if (localExpr) {
          if (localExpr instanceof ReadPropExpr) {
            varExpr = localExpr;
            this.usesImplicitReceiver = prevUsesImplicitReceiver;
            this.addImplicitReceiverAccess(ast.name);
          } else {
            const receiver2 = ast.name;
            const value = ast.value instanceof PropertyRead ? ast.value.name : void 0;
            throw new Error(`Cannot assign value "${value}" to template variable "${receiver2}". Template variables are read-only.`);
          }
        }
      }
      if (varExpr === null) {
        varExpr = receiver.prop(ast.name, this.convertSourceSpan(ast.span));
      }
      return convertToStatementIfNeeded(mode, varExpr.set(this._visit(ast.value, _Mode.Expression)));
    }
    visitSafePropertyRead(ast, mode) {
      return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
    }
    visitSafeKeyedRead(ast, mode) {
      return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
    }
    visitAll(asts, mode) {
      return asts.map((ast) => this._visit(ast, mode));
    }
    visitQuote(ast, mode) {
      throw new Error(`Quotes are not supported for evaluation!
        Statement: ${ast.uninterpretedExpression} located at ${ast.location}`);
    }
    visitCall(ast, mode) {
      const leftMostSafe = this.leftMostSafeNode(ast);
      if (leftMostSafe) {
        return this.convertSafeAccess(ast, leftMostSafe, mode);
      }
      const convertedArgs = this.visitAll(ast.args, _Mode.Expression);
      if (ast instanceof BuiltinFunctionCall) {
        return convertToStatementIfNeeded(mode, ast.converter(convertedArgs));
      }
      const receiver = ast.receiver;
      if (receiver instanceof PropertyRead && receiver.receiver instanceof ImplicitReceiver && !(receiver.receiver instanceof ThisReceiver) && receiver.name === "$any") {
        if (convertedArgs.length !== 1) {
          throw new Error(`Invalid call to $any, expected 1 argument but received ${convertedArgs.length || "none"}`);
        }
        return convertToStatementIfNeeded(mode, convertedArgs[0].cast(DYNAMIC_TYPE, this.convertSourceSpan(ast.span)));
      }
      const call = this._visit(receiver, _Mode.Expression).callFn(convertedArgs, this.convertSourceSpan(ast.span));
      return convertToStatementIfNeeded(mode, call);
    }
    _visit(ast, mode) {
      const result = this._resultMap.get(ast);
      if (result)
        return result;
      return (this._nodeMap.get(ast) || ast).visit(this, mode);
    }
    convertSafeAccess(ast, leftMostSafe, mode) {
      let guardedExpression2 = this._visit(leftMostSafe.receiver, _Mode.Expression);
      let temporary = void 0;
      if (this.needsTemporaryInSafeAccess(leftMostSafe.receiver)) {
        temporary = this.allocateTemporary();
        guardedExpression2 = temporary.set(guardedExpression2);
        this._resultMap.set(leftMostSafe.receiver, temporary);
      }
      const condition = guardedExpression2.isBlank();
      if (leftMostSafe instanceof SafeKeyedRead) {
        this._nodeMap.set(leftMostSafe, new KeyedRead(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.receiver, leftMostSafe.key));
      } else {
        this._nodeMap.set(leftMostSafe, new PropertyRead(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.nameSpan, leftMostSafe.receiver, leftMostSafe.name));
      }
      const access = this._visit(ast, _Mode.Expression);
      this._nodeMap.delete(leftMostSafe);
      if (temporary) {
        this.releaseTemporary(temporary);
      }
      return convertToStatementIfNeeded(mode, condition.conditional(NULL_EXPR, access));
    }
    convertNullishCoalesce(ast, mode) {
      const left = this._visit(ast.left, _Mode.Expression);
      const right = this._visit(ast.right, _Mode.Expression);
      const temporary = this.allocateTemporary();
      this.releaseTemporary(temporary);
      return convertToStatementIfNeeded(mode, temporary.set(left).notIdentical(NULL_EXPR).and(temporary.notIdentical(literal(void 0))).conditional(temporary, right));
    }
    leftMostSafeNode(ast) {
      const visit = (visitor, ast2) => {
        return (this._nodeMap.get(ast2) || ast2).visit(visitor);
      };
      return ast.visit({
        visitUnary(ast2) {
          return null;
        },
        visitBinary(ast2) {
          return null;
        },
        visitChain(ast2) {
          return null;
        },
        visitConditional(ast2) {
          return null;
        },
        visitCall(ast2) {
          return visit(this, ast2.receiver);
        },
        visitImplicitReceiver(ast2) {
          return null;
        },
        visitThisReceiver(ast2) {
          return null;
        },
        visitInterpolation(ast2) {
          return null;
        },
        visitKeyedRead(ast2) {
          return visit(this, ast2.receiver);
        },
        visitKeyedWrite(ast2) {
          return null;
        },
        visitLiteralArray(ast2) {
          return null;
        },
        visitLiteralMap(ast2) {
          return null;
        },
        visitLiteralPrimitive(ast2) {
          return null;
        },
        visitPipe(ast2) {
          return null;
        },
        visitPrefixNot(ast2) {
          return null;
        },
        visitNonNullAssert(ast2) {
          return null;
        },
        visitPropertyRead(ast2) {
          return visit(this, ast2.receiver);
        },
        visitPropertyWrite(ast2) {
          return null;
        },
        visitQuote(ast2) {
          return null;
        },
        visitSafePropertyRead(ast2) {
          return visit(this, ast2.receiver) || ast2;
        },
        visitSafeKeyedRead(ast2) {
          return visit(this, ast2.receiver) || ast2;
        }
      });
    }
    needsTemporaryInSafeAccess(ast) {
      const visit = (visitor, ast2) => {
        return ast2 && (this._nodeMap.get(ast2) || ast2).visit(visitor);
      };
      const visitSome = (visitor, ast2) => {
        return ast2.some((ast3) => visit(visitor, ast3));
      };
      return ast.visit({
        visitUnary(ast2) {
          return visit(this, ast2.expr);
        },
        visitBinary(ast2) {
          return visit(this, ast2.left) || visit(this, ast2.right);
        },
        visitChain(ast2) {
          return false;
        },
        visitConditional(ast2) {
          return visit(this, ast2.condition) || visit(this, ast2.trueExp) || visit(this, ast2.falseExp);
        },
        visitCall(ast2) {
          return true;
        },
        visitImplicitReceiver(ast2) {
          return false;
        },
        visitThisReceiver(ast2) {
          return false;
        },
        visitInterpolation(ast2) {
          return visitSome(this, ast2.expressions);
        },
        visitKeyedRead(ast2) {
          return false;
        },
        visitKeyedWrite(ast2) {
          return false;
        },
        visitLiteralArray(ast2) {
          return true;
        },
        visitLiteralMap(ast2) {
          return true;
        },
        visitLiteralPrimitive(ast2) {
          return false;
        },
        visitPipe(ast2) {
          return true;
        },
        visitPrefixNot(ast2) {
          return visit(this, ast2.expression);
        },
        visitNonNullAssert(ast2) {
          return visit(this, ast2.expression);
        },
        visitPropertyRead(ast2) {
          return false;
        },
        visitPropertyWrite(ast2) {
          return false;
        },
        visitQuote(ast2) {
          return false;
        },
        visitSafePropertyRead(ast2) {
          return false;
        },
        visitSafeKeyedRead(ast2) {
          return false;
        }
      });
    }
    allocateTemporary() {
      const tempNumber = this._currentTemporary++;
      this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);
      return new ReadVarExpr(temporaryName(this.bindingId, tempNumber));
    }
    releaseTemporary(temporary) {
      this._currentTemporary--;
      if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {
        throw new Error(`Temporary ${temporary.name} released out of order`);
      }
    }
    convertSourceSpan(span) {
      if (this.baseSourceSpan) {
        const start = this.baseSourceSpan.start.moveBy(span.start);
        const end = this.baseSourceSpan.start.moveBy(span.end);
        const fullStart = this.baseSourceSpan.fullStart.moveBy(span.start);
        return new ParseSourceSpan(start, end, fullStart);
      } else {
        return null;
      }
    }
    addImplicitReceiverAccess(name) {
      if (this.implicitReceiverAccesses) {
        this.implicitReceiverAccesses.add(name);
      }
    }
  };
  function flattenStatements(arg, output) {
    if (Array.isArray(arg)) {
      arg.forEach((entry) => flattenStatements(entry, output));
    } else {
      output.push(arg);
    }
  }
  var DefaultLocalResolver = class {
    constructor(globals) {
      this.globals = globals;
    }
    notifyImplicitReceiverUse() {
    }
    maybeRestoreView() {
    }
    getLocal(name) {
      if (name === EventHandlerVars.event.name) {
        return EventHandlerVars.event;
      }
      return null;
    }
  };
  function createCurrValueExpr(bindingId) {
    return variable(`currVal_${bindingId}`);
  }
  function createPreventDefaultVar(bindingId) {
    return variable(`pd_${bindingId}`);
  }
  function convertStmtIntoExpression(stmt) {
    if (stmt instanceof ExpressionStatement) {
      return stmt.expr;
    } else if (stmt instanceof ReturnStatement) {
      return stmt.value;
    }
    return null;
  }
  var BuiltinFunctionCall = class extends Call {
    constructor(span, sourceSpan, args, converter) {
      super(span, sourceSpan, new EmptyExpr(span, sourceSpan), args, null);
      this.converter = converter;
    }
  };
  var ShadowCss = class {
    constructor() {
      this.strictStyling = true;
    }
    shimCssText(cssText, selector, hostSelector = "") {
      const commentsWithHash = extractCommentsWithHash(cssText);
      cssText = stripComments(cssText);
      cssText = this._insertDirectives(cssText);
      const scopedCssText = this._scopeCssText(cssText, selector, hostSelector);
      return [scopedCssText, ...commentsWithHash].join("\n");
    }
    _insertDirectives(cssText) {
      cssText = this._insertPolyfillDirectivesInCssText(cssText);
      return this._insertPolyfillRulesInCssText(cssText);
    }
    _insertPolyfillDirectivesInCssText(cssText) {
      return cssText.replace(_cssContentNextSelectorRe, function(...m) {
        return m[2] + "{";
      });
    }
    _insertPolyfillRulesInCssText(cssText) {
      return cssText.replace(_cssContentRuleRe, (...m) => {
        const rule = m[0].replace(m[1], "").replace(m[2], "");
        return m[4] + rule;
      });
    }
    _scopeCssText(cssText, scopeSelector, hostSelector) {
      const unscopedRules = this._extractUnscopedRulesFromCssText(cssText);
      cssText = this._insertPolyfillHostInCssText(cssText);
      cssText = this._convertColonHost(cssText);
      cssText = this._convertColonHostContext(cssText);
      cssText = this._convertShadowDOMSelectors(cssText);
      if (scopeSelector) {
        cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);
      }
      cssText = cssText + "\n" + unscopedRules;
      return cssText.trim();
    }
    _extractUnscopedRulesFromCssText(cssText) {
      let r = "";
      let m;
      _cssContentUnscopedRuleRe.lastIndex = 0;
      while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {
        const rule = m[0].replace(m[2], "").replace(m[1], m[4]);
        r += rule + "\n\n";
      }
      return r;
    }
    _convertColonHost(cssText) {
      return cssText.replace(_cssColonHostRe, (_, hostSelectors, otherSelectors) => {
        if (hostSelectors) {
          const convertedSelectors = [];
          const hostSelectorArray = hostSelectors.split(",").map((p) => p.trim());
          for (const hostSelector of hostSelectorArray) {
            if (!hostSelector)
              break;
            const convertedSelector = _polyfillHostNoCombinator + hostSelector.replace(_polyfillHost, "") + otherSelectors;
            convertedSelectors.push(convertedSelector);
          }
          return convertedSelectors.join(",");
        } else {
          return _polyfillHostNoCombinator + otherSelectors;
        }
      });
    }
    _convertColonHostContext(cssText) {
      return cssText.replace(_cssColonHostContextReGlobal, (selectorText) => {
        const contextSelectorGroups = [[]];
        let match2;
        while (match2 = _cssColonHostContextRe.exec(selectorText)) {
          const newContextSelectors = (match2[1] ?? "").trim().split(",").map((m) => m.trim()).filter((m) => m !== "");
          const contextSelectorGroupsLength = contextSelectorGroups.length;
          repeatGroups(contextSelectorGroups, newContextSelectors.length);
          for (let i = 0; i < newContextSelectors.length; i++) {
            for (let j = 0; j < contextSelectorGroupsLength; j++) {
              contextSelectorGroups[j + i * contextSelectorGroupsLength].push(newContextSelectors[i]);
            }
          }
          selectorText = match2[2];
        }
        return contextSelectorGroups.map((contextSelectors) => combineHostContextSelectors(contextSelectors, selectorText)).join(", ");
      });
    }
    _convertShadowDOMSelectors(cssText) {
      return _shadowDOMSelectorsRe.reduce((result, pattern) => result.replace(pattern, " "), cssText);
    }
    _scopeSelectors(cssText, scopeSelector, hostSelector) {
      return processRules(cssText, (rule) => {
        let selector = rule.selector;
        let content = rule.content;
        if (rule.selector[0] !== "@") {
          selector = this._scopeSelector(rule.selector, scopeSelector, hostSelector, this.strictStyling);
        } else if (rule.selector.startsWith("@media") || rule.selector.startsWith("@supports") || rule.selector.startsWith("@document")) {
          content = this._scopeSelectors(rule.content, scopeSelector, hostSelector);
        } else if (rule.selector.startsWith("@font-face") || rule.selector.startsWith("@page")) {
          content = this._stripScopingSelectors(rule.content);
        }
        return new CssRule(selector, content);
      });
    }
    _stripScopingSelectors(cssText) {
      return processRules(cssText, (rule) => {
        const selector = rule.selector.replace(_shadowDeepSelectors, " ").replace(_polyfillHostNoCombinatorRe, " ");
        return new CssRule(selector, rule.content);
      });
    }
    _scopeSelector(selector, scopeSelector, hostSelector, strict) {
      return selector.split(",").map((part) => part.trim().split(_shadowDeepSelectors)).map((deepParts) => {
        const [shallowPart, ...otherParts] = deepParts;
        const applyScope = (shallowPart2) => {
          if (this._selectorNeedsScoping(shallowPart2, scopeSelector)) {
            return strict ? this._applyStrictSelectorScope(shallowPart2, scopeSelector, hostSelector) : this._applySelectorScope(shallowPart2, scopeSelector, hostSelector);
          } else {
            return shallowPart2;
          }
        };
        return [applyScope(shallowPart), ...otherParts].join(" ");
      }).join(", ");
    }
    _selectorNeedsScoping(selector, scopeSelector) {
      const re = this._makeScopeMatcher(scopeSelector);
      return !re.test(selector);
    }
    _makeScopeMatcher(scopeSelector) {
      const lre = /\[/g;
      const rre = /\]/g;
      scopeSelector = scopeSelector.replace(lre, "\\[").replace(rre, "\\]");
      return new RegExp("^(" + scopeSelector + ")" + _selectorReSuffix, "m");
    }
    _applySelectorScope(selector, scopeSelector, hostSelector) {
      return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);
    }
    _applySimpleSelectorScope(selector, scopeSelector, hostSelector) {
      _polyfillHostRe.lastIndex = 0;
      if (_polyfillHostRe.test(selector)) {
        const replaceBy = this.strictStyling ? `[${hostSelector}]` : scopeSelector;
        return selector.replace(_polyfillHostNoCombinatorRe, (hnc, selector2) => {
          return selector2.replace(/([^:]*)(:*)(.*)/, (_, before, colon, after) => {
            return before + replaceBy + colon + after;
          });
        }).replace(_polyfillHostRe, replaceBy + " ");
      }
      return scopeSelector + " " + selector;
    }
    _applyStrictSelectorScope(selector, scopeSelector, hostSelector) {
      const isRe = /\[is=([^\]]*)\]/g;
      scopeSelector = scopeSelector.replace(isRe, (_, ...parts) => parts[0]);
      const attrName = "[" + scopeSelector + "]";
      const _scopeSelectorPart = (p) => {
        let scopedP = p.trim();
        if (!scopedP) {
          return "";
        }
        if (p.indexOf(_polyfillHostNoCombinator) > -1) {
          scopedP = this._applySimpleSelectorScope(p, scopeSelector, hostSelector);
        } else {
          const t = p.replace(_polyfillHostRe, "");
          if (t.length > 0) {
            const matches = t.match(/([^:]*)(:*)(.*)/);
            if (matches) {
              scopedP = matches[1] + attrName + matches[2] + matches[3];
            }
          }
        }
        return scopedP;
      };
      const safeContent = new SafeSelector(selector);
      selector = safeContent.content();
      let scopedSelector = "";
      let startIndex = 0;
      let res;
      const sep = /( |>|\+|~(?!=))\s*/g;
      const hasHost = selector.indexOf(_polyfillHostNoCombinator) > -1;
      let shouldScope = !hasHost;
      while ((res = sep.exec(selector)) !== null) {
        const separator = res[1];
        const part2 = selector.slice(startIndex, res.index).trim();
        shouldScope = shouldScope || part2.indexOf(_polyfillHostNoCombinator) > -1;
        const scopedPart = shouldScope ? _scopeSelectorPart(part2) : part2;
        scopedSelector += `${scopedPart} ${separator} `;
        startIndex = sep.lastIndex;
      }
      const part = selector.substring(startIndex);
      shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;
      scopedSelector += shouldScope ? _scopeSelectorPart(part) : part;
      return safeContent.restore(scopedSelector);
    }
    _insertPolyfillHostInCssText(selector) {
      return selector.replace(_colonHostContextRe, _polyfillHostContext).replace(_colonHostRe, _polyfillHost);
    }
  };
  var SafeSelector = class {
    constructor(selector) {
      this.placeholders = [];
      this.index = 0;
      selector = this._escapeRegexMatches(selector, /(\[[^\]]*\])/g);
      selector = this._escapeRegexMatches(selector, /(\\.)/g);
      this._content = selector.replace(/(:nth-[-\w]+)(\([^)]+\))/g, (_, pseudo, exp) => {
        const replaceBy = `__ph-${this.index}__`;
        this.placeholders.push(exp);
        this.index++;
        return pseudo + replaceBy;
      });
    }
    restore(content) {
      return content.replace(/__ph-(\d+)__/g, (_ph, index) => this.placeholders[+index]);
    }
    content() {
      return this._content;
    }
    _escapeRegexMatches(content, pattern) {
      return content.replace(pattern, (_, keep) => {
        const replaceBy = `__ph-${this.index}__`;
        this.placeholders.push(keep);
        this.index++;
        return replaceBy;
      });
    }
  };
  var _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\s]*?(['"])(.*?)\1[;\s]*}([^{]*?){/gim;
  var _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim;
  var _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim;
  var _polyfillHost = "-shadowcsshost";
  var _polyfillHostContext = "-shadowcsscontext";
  var _parenSuffix = "(?:\\(((?:\\([^)(]*\\)|[^)(]*)+?)\\))?([^,{]*)";
  var _cssColonHostRe = new RegExp(_polyfillHost + _parenSuffix, "gim");
  var _cssColonHostContextReGlobal = new RegExp(_polyfillHostContext + _parenSuffix, "gim");
  var _cssColonHostContextRe = new RegExp(_polyfillHostContext + _parenSuffix, "im");
  var _polyfillHostNoCombinator = _polyfillHost + "-no-combinator";
  var _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\s]*)/;
  var _shadowDOMSelectorsRe = [
    /::shadow/g,
    /::content/g,
    /\/shadow-deep\//g,
    /\/shadow\//g
  ];
  var _shadowDeepSelectors = /(?:>>>)|(?:\/deep\/)|(?:::ng-deep)/g;
  var _selectorReSuffix = "([>\\s~+[.,{:][\\s\\S]*)?$";
  var _polyfillHostRe = /-shadowcsshost/gim;
  var _colonHostRe = /:host/gim;
  var _colonHostContextRe = /:host-context/gim;
  var _commentRe = /\/\*[\s\S]*?\*\//g;
  function stripComments(input) {
    return input.replace(_commentRe, "");
  }
  var _commentWithHashRe = /\/\*\s*#\s*source(Mapping)?URL=[\s\S]+?\*\//g;
  function extractCommentsWithHash(input) {
    return input.match(_commentWithHashRe) || [];
  }
  var BLOCK_PLACEHOLDER = "%BLOCK%";
  var QUOTE_PLACEHOLDER = "%QUOTED%";
  var _ruleRe = /(\s*)([^;\{\}]+?)(\s*)((?:{%BLOCK%}?\s*;?)|(?:\s*;))/g;
  var _quotedRe = /%QUOTED%/g;
  var CONTENT_PAIRS = /* @__PURE__ */ new Map([["{", "}"]]);
  var QUOTE_PAIRS = /* @__PURE__ */ new Map([[`"`, `"`], [`'`, `'`]]);
  var CssRule = class {
    constructor(selector, content) {
      this.selector = selector;
      this.content = content;
    }
  };
  function processRules(input, ruleCallback) {
    const inputWithEscapedQuotes = escapeBlocks(input, QUOTE_PAIRS, QUOTE_PLACEHOLDER);
    const inputWithEscapedBlocks = escapeBlocks(inputWithEscapedQuotes.escapedString, CONTENT_PAIRS, BLOCK_PLACEHOLDER);
    let nextBlockIndex = 0;
    let nextQuoteIndex = 0;
    return inputWithEscapedBlocks.escapedString.replace(_ruleRe, (...m) => {
      const selector = m[2];
      let content = "";
      let suffix = m[4];
      let contentPrefix = "";
      if (suffix && suffix.startsWith("{" + BLOCK_PLACEHOLDER)) {
        content = inputWithEscapedBlocks.blocks[nextBlockIndex++];
        suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);
        contentPrefix = "{";
      }
      const rule = ruleCallback(new CssRule(selector, content));
      return `${m[1]}${rule.selector}${m[3]}${contentPrefix}${rule.content}${suffix}`;
    }).replace(_quotedRe, () => inputWithEscapedQuotes.blocks[nextQuoteIndex++]);
  }
  var StringWithEscapedBlocks = class {
    constructor(escapedString, blocks) {
      this.escapedString = escapedString;
      this.blocks = blocks;
    }
  };
  function escapeBlocks(input, charPairs, placeholder) {
    const resultParts = [];
    const escapedBlocks = [];
    let openCharCount = 0;
    let nonBlockStartIndex = 0;
    let blockStartIndex = -1;
    let openChar;
    let closeChar;
    for (let i = 0; i < input.length; i++) {
      const char = input[i];
      if (char === "\\") {
        i++;
      } else if (char === closeChar) {
        openCharCount--;
        if (openCharCount === 0) {
          escapedBlocks.push(input.substring(blockStartIndex, i));
          resultParts.push(placeholder);
          nonBlockStartIndex = i;
          blockStartIndex = -1;
          openChar = closeChar = void 0;
        }
      } else if (char === openChar) {
        openCharCount++;
      } else if (openCharCount === 0 && charPairs.has(char)) {
        openChar = char;
        closeChar = charPairs.get(char);
        openCharCount = 1;
        blockStartIndex = i + 1;
        resultParts.push(input.substring(nonBlockStartIndex, blockStartIndex));
      }
    }
    if (blockStartIndex !== -1) {
      escapedBlocks.push(input.substring(blockStartIndex));
      resultParts.push(placeholder);
    } else {
      resultParts.push(input.substring(nonBlockStartIndex));
    }
    return new StringWithEscapedBlocks(resultParts.join(""), escapedBlocks);
  }
  function combineHostContextSelectors(contextSelectors, otherSelectors) {
    const hostMarker = _polyfillHostNoCombinator;
    _polyfillHostRe.lastIndex = 0;
    const otherSelectorsHasHost = _polyfillHostRe.test(otherSelectors);
    if (contextSelectors.length === 0) {
      return hostMarker + otherSelectors;
    }
    const combined = [contextSelectors.pop() || ""];
    while (contextSelectors.length > 0) {
      const length = combined.length;
      const contextSelector = contextSelectors.pop();
      for (let i = 0; i < length; i++) {
        const previousSelectors = combined[i];
        combined[length * 2 + i] = previousSelectors + " " + contextSelector;
        combined[length + i] = contextSelector + " " + previousSelectors;
        combined[i] = contextSelector + previousSelectors;
      }
    }
    return combined.map((s) => otherSelectorsHasHost ? `${s}${otherSelectors}` : `${s}${hostMarker}${otherSelectors}, ${s} ${hostMarker}${otherSelectors}`).join(",");
  }
  function repeatGroups(groups, multiples) {
    const length = groups.length;
    for (let i = 1; i < multiples; i++) {
      for (let j = 0; j < length; j++) {
        groups[j + i * length] = groups[j].slice(0);
      }
    }
  }
  var CompileSummaryKind;
  (function(CompileSummaryKind2) {
    CompileSummaryKind2[CompileSummaryKind2["Pipe"] = 0] = "Pipe";
    CompileSummaryKind2[CompileSummaryKind2["Directive"] = 1] = "Directive";
    CompileSummaryKind2[CompileSummaryKind2["NgModule"] = 2] = "NgModule";
    CompileSummaryKind2[CompileSummaryKind2["Injectable"] = 3] = "Injectable";
  })(CompileSummaryKind || (CompileSummaryKind = {}));
  function flatten2(list) {
    return list.reduce((flat, item) => {
      const flatItem = Array.isArray(item) ? flatten2(item) : item;
      return flat.concat(flatItem);
    }, []);
  }
  var COMPONENT_VARIABLE = "%COMP%";
  var HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;
  var CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;
  var NodeWithI18n = class {
    constructor(sourceSpan, i18n) {
      this.sourceSpan = sourceSpan;
      this.i18n = i18n;
    }
  };
  var Text2 = class extends NodeWithI18n {
    constructor(value, sourceSpan, tokens, i18n) {
      super(sourceSpan, i18n);
      this.value = value;
      this.tokens = tokens;
    }
    visit(visitor, context2) {
      return visitor.visitText(this, context2);
    }
  };
  var Expansion = class extends NodeWithI18n {
    constructor(switchValue, type, cases, sourceSpan, switchValueSourceSpan, i18n) {
      super(sourceSpan, i18n);
      this.switchValue = switchValue;
      this.type = type;
      this.cases = cases;
      this.switchValueSourceSpan = switchValueSourceSpan;
    }
    visit(visitor, context2) {
      return visitor.visitExpansion(this, context2);
    }
  };
  var ExpansionCase = class {
    constructor(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {
      this.value = value;
      this.expression = expression;
      this.sourceSpan = sourceSpan;
      this.valueSourceSpan = valueSourceSpan;
      this.expSourceSpan = expSourceSpan;
    }
    visit(visitor, context2) {
      return visitor.visitExpansionCase(this, context2);
    }
  };
  var Attribute2 = class extends NodeWithI18n {
    constructor(name, value, sourceSpan, keySpan, valueSpan, valueTokens, i18n) {
      super(sourceSpan, i18n);
      this.name = name;
      this.value = value;
      this.keySpan = keySpan;
      this.valueSpan = valueSpan;
      this.valueTokens = valueTokens;
    }
    visit(visitor, context2) {
      return visitor.visitAttribute(this, context2);
    }
  };
  var Element2 = class extends NodeWithI18n {
    constructor(name, attrs, children, sourceSpan, startSourceSpan, endSourceSpan = null, i18n) {
      super(sourceSpan, i18n);
      this.name = name;
      this.attrs = attrs;
      this.children = children;
      this.startSourceSpan = startSourceSpan;
      this.endSourceSpan = endSourceSpan;
    }
    visit(visitor, context2) {
      return visitor.visitElement(this, context2);
    }
  };
  var Comment = class {
    constructor(value, sourceSpan) {
      this.value = value;
      this.sourceSpan = sourceSpan;
    }
    visit(visitor, context2) {
      return visitor.visitComment(this, context2);
    }
  };
  function visitAll(visitor, nodes, context2 = null) {
    const result = [];
    const visit = visitor.visit ? (ast) => visitor.visit(ast, context2) || ast.visit(visitor, context2) : (ast) => ast.visit(visitor, context2);
    nodes.forEach((ast) => {
      const astResult = visit(ast);
      if (astResult) {
        result.push(astResult);
      }
    });
    return result;
  }
  var NAMED_ENTITIES = {
    "AElig": "\xC6",
    "AMP": "&",
    "amp": "&",
    "Aacute": "\xC1",
    "Abreve": "\u0102",
    "Acirc": "\xC2",
    "Acy": "\u0410",
    "Afr": "\u{1D504}",
    "Agrave": "\xC0",
    "Alpha": "\u0391",
    "Amacr": "\u0100",
    "And": "\u2A53",
    "Aogon": "\u0104",
    "Aopf": "\u{1D538}",
    "ApplyFunction": "\u2061",
    "af": "\u2061",
    "Aring": "\xC5",
    "angst": "\xC5",
    "Ascr": "\u{1D49C}",
    "Assign": "\u2254",
    "colone": "\u2254",
    "coloneq": "\u2254",
    "Atilde": "\xC3",
    "Auml": "\xC4",
    "Backslash": "\u2216",
    "setminus": "\u2216",
    "setmn": "\u2216",
    "smallsetminus": "\u2216",
    "ssetmn": "\u2216",
    "Barv": "\u2AE7",
    "Barwed": "\u2306",
    "doublebarwedge": "\u2306",
    "Bcy": "\u0411",
    "Because": "\u2235",
    "becaus": "\u2235",
    "because": "\u2235",
    "Bernoullis": "\u212C",
    "Bscr": "\u212C",
    "bernou": "\u212C",
    "Beta": "\u0392",
    "Bfr": "\u{1D505}",
    "Bopf": "\u{1D539}",
    "Breve": "\u02D8",
    "breve": "\u02D8",
    "Bumpeq": "\u224E",
    "HumpDownHump": "\u224E",
    "bump": "\u224E",
    "CHcy": "\u0427",
    "COPY": "\xA9",
    "copy": "\xA9",
    "Cacute": "\u0106",
    "Cap": "\u22D2",
    "CapitalDifferentialD": "\u2145",
    "DD": "\u2145",
    "Cayleys": "\u212D",
    "Cfr": "\u212D",
    "Ccaron": "\u010C",
    "Ccedil": "\xC7",
    "Ccirc": "\u0108",
    "Cconint": "\u2230",
    "Cdot": "\u010A",
    "Cedilla": "\xB8",
    "cedil": "\xB8",
    "CenterDot": "\xB7",
    "centerdot": "\xB7",
    "middot": "\xB7",
    "Chi": "\u03A7",
    "CircleDot": "\u2299",
    "odot": "\u2299",
    "CircleMinus": "\u2296",
    "ominus": "\u2296",
    "CirclePlus": "\u2295",
    "oplus": "\u2295",
    "CircleTimes": "\u2297",
    "otimes": "\u2297",
    "ClockwiseContourIntegral": "\u2232",
    "cwconint": "\u2232",
    "CloseCurlyDoubleQuote": "\u201D",
    "rdquo": "\u201D",
    "rdquor": "\u201D",
    "CloseCurlyQuote": "\u2019",
    "rsquo": "\u2019",
    "rsquor": "\u2019",
    "Colon": "\u2237",
    "Proportion": "\u2237",
    "Colone": "\u2A74",
    "Congruent": "\u2261",
    "equiv": "\u2261",
    "Conint": "\u222F",
    "DoubleContourIntegral": "\u222F",
    "ContourIntegral": "\u222E",
    "conint": "\u222E",
    "oint": "\u222E",
    "Copf": "\u2102",
    "complexes": "\u2102",
    "Coproduct": "\u2210",
    "coprod": "\u2210",
    "CounterClockwiseContourIntegral": "\u2233",
    "awconint": "\u2233",
    "Cross": "\u2A2F",
    "Cscr": "\u{1D49E}",
    "Cup": "\u22D3",
    "CupCap": "\u224D",
    "asympeq": "\u224D",
    "DDotrahd": "\u2911",
    "DJcy": "\u0402",
    "DScy": "\u0405",
    "DZcy": "\u040F",
    "Dagger": "\u2021",
    "ddagger": "\u2021",
    "Darr": "\u21A1",
    "Dashv": "\u2AE4",
    "DoubleLeftTee": "\u2AE4",
    "Dcaron": "\u010E",
    "Dcy": "\u0414",
    "Del": "\u2207",
    "nabla": "\u2207",
    "Delta": "\u0394",
    "Dfr": "\u{1D507}",
    "DiacriticalAcute": "\xB4",
    "acute": "\xB4",
    "DiacriticalDot": "\u02D9",
    "dot": "\u02D9",
    "DiacriticalDoubleAcute": "\u02DD",
    "dblac": "\u02DD",
    "DiacriticalGrave": "`",
    "grave": "`",
    "DiacriticalTilde": "\u02DC",
    "tilde": "\u02DC",
    "Diamond": "\u22C4",
    "diam": "\u22C4",
    "diamond": "\u22C4",
    "DifferentialD": "\u2146",
    "dd": "\u2146",
    "Dopf": "\u{1D53B}",
    "Dot": "\xA8",
    "DoubleDot": "\xA8",
    "die": "\xA8",
    "uml": "\xA8",
    "DotDot": "\u20DC",
    "DotEqual": "\u2250",
    "doteq": "\u2250",
    "esdot": "\u2250",
    "DoubleDownArrow": "\u21D3",
    "Downarrow": "\u21D3",
    "dArr": "\u21D3",
    "DoubleLeftArrow": "\u21D0",
    "Leftarrow": "\u21D0",
    "lArr": "\u21D0",
    "DoubleLeftRightArrow": "\u21D4",
    "Leftrightarrow": "\u21D4",
    "hArr": "\u21D4",
    "iff": "\u21D4",
    "DoubleLongLeftArrow": "\u27F8",
    "Longleftarrow": "\u27F8",
    "xlArr": "\u27F8",
    "DoubleLongLeftRightArrow": "\u27FA",
    "Longleftrightarrow": "\u27FA",
    "xhArr": "\u27FA",
    "DoubleLongRightArrow": "\u27F9",
    "Longrightarrow": "\u27F9",
    "xrArr": "\u27F9",
    "DoubleRightArrow": "\u21D2",
    "Implies": "\u21D2",
    "Rightarrow": "\u21D2",
    "rArr": "\u21D2",
    "DoubleRightTee": "\u22A8",
    "vDash": "\u22A8",
    "DoubleUpArrow": "\u21D1",
    "Uparrow": "\u21D1",
    "uArr": "\u21D1",
    "DoubleUpDownArrow": "\u21D5",
    "Updownarrow": "\u21D5",
    "vArr": "\u21D5",
    "DoubleVerticalBar": "\u2225",
    "par": "\u2225",
    "parallel": "\u2225",
    "shortparallel": "\u2225",
    "spar": "\u2225",
    "DownArrow": "\u2193",
    "ShortDownArrow": "\u2193",
    "darr": "\u2193",
    "downarrow": "\u2193",
    "DownArrowBar": "\u2913",
    "DownArrowUpArrow": "\u21F5",
    "duarr": "\u21F5",
    "DownBreve": "\u0311",
    "DownLeftRightVector": "\u2950",
    "DownLeftTeeVector": "\u295E",
    "DownLeftVector": "\u21BD",
    "leftharpoondown": "\u21BD",
    "lhard": "\u21BD",
    "DownLeftVectorBar": "\u2956",
    "DownRightTeeVector": "\u295F",
    "DownRightVector": "\u21C1",
    "rhard": "\u21C1",
    "rightharpoondown": "\u21C1",
    "DownRightVectorBar": "\u2957",
    "DownTee": "\u22A4",
    "top": "\u22A4",
    "DownTeeArrow": "\u21A7",
    "mapstodown": "\u21A7",
    "Dscr": "\u{1D49F}",
    "Dstrok": "\u0110",
    "ENG": "\u014A",
    "ETH": "\xD0",
    "Eacute": "\xC9",
    "Ecaron": "\u011A",
    "Ecirc": "\xCA",
    "Ecy": "\u042D",
    "Edot": "\u0116",
    "Efr": "\u{1D508}",
    "Egrave": "\xC8",
    "Element": "\u2208",
    "in": "\u2208",
    "isin": "\u2208",
    "isinv": "\u2208",
    "Emacr": "\u0112",
    "EmptySmallSquare": "\u25FB",
    "EmptyVerySmallSquare": "\u25AB",
    "Eogon": "\u0118",
    "Eopf": "\u{1D53C}",
    "Epsilon": "\u0395",
    "Equal": "\u2A75",
    "EqualTilde": "\u2242",
    "eqsim": "\u2242",
    "esim": "\u2242",
    "Equilibrium": "\u21CC",
    "rightleftharpoons": "\u21CC",
    "rlhar": "\u21CC",
    "Escr": "\u2130",
    "expectation": "\u2130",
    "Esim": "\u2A73",
    "Eta": "\u0397",
    "Euml": "\xCB",
    "Exists": "\u2203",
    "exist": "\u2203",
    "ExponentialE": "\u2147",
    "ee": "\u2147",
    "exponentiale": "\u2147",
    "Fcy": "\u0424",
    "Ffr": "\u{1D509}",
    "FilledSmallSquare": "\u25FC",
    "FilledVerySmallSquare": "\u25AA",
    "blacksquare": "\u25AA",
    "squarf": "\u25AA",
    "squf": "\u25AA",
    "Fopf": "\u{1D53D}",
    "ForAll": "\u2200",
    "forall": "\u2200",
    "Fouriertrf": "\u2131",
    "Fscr": "\u2131",
    "GJcy": "\u0403",
    "GT": ">",
    "gt": ">",
    "Gamma": "\u0393",
    "Gammad": "\u03DC",
    "Gbreve": "\u011E",
    "Gcedil": "\u0122",
    "Gcirc": "\u011C",
    "Gcy": "\u0413",
    "Gdot": "\u0120",
    "Gfr": "\u{1D50A}",
    "Gg": "\u22D9",
    "ggg": "\u22D9",
    "Gopf": "\u{1D53E}",
    "GreaterEqual": "\u2265",
    "ge": "\u2265",
    "geq": "\u2265",
    "GreaterEqualLess": "\u22DB",
    "gel": "\u22DB",
    "gtreqless": "\u22DB",
    "GreaterFullEqual": "\u2267",
    "gE": "\u2267",
    "geqq": "\u2267",
    "GreaterGreater": "\u2AA2",
    "GreaterLess": "\u2277",
    "gl": "\u2277",
    "gtrless": "\u2277",
    "GreaterSlantEqual": "\u2A7E",
    "geqslant": "\u2A7E",
    "ges": "\u2A7E",
    "GreaterTilde": "\u2273",
    "gsim": "\u2273",
    "gtrsim": "\u2273",
    "Gscr": "\u{1D4A2}",
    "Gt": "\u226B",
    "NestedGreaterGreater": "\u226B",
    "gg": "\u226B",
    "HARDcy": "\u042A",
    "Hacek": "\u02C7",
    "caron": "\u02C7",
    "Hat": "^",
    "Hcirc": "\u0124",
    "Hfr": "\u210C",
    "Poincareplane": "\u210C",
    "HilbertSpace": "\u210B",
    "Hscr": "\u210B",
    "hamilt": "\u210B",
    "Hopf": "\u210D",
    "quaternions": "\u210D",
    "HorizontalLine": "\u2500",
    "boxh": "\u2500",
    "Hstrok": "\u0126",
    "HumpEqual": "\u224F",
    "bumpe": "\u224F",
    "bumpeq": "\u224F",
    "IEcy": "\u0415",
    "IJlig": "\u0132",
    "IOcy": "\u0401",
    "Iacute": "\xCD",
    "Icirc": "\xCE",
    "Icy": "\u0418",
    "Idot": "\u0130",
    "Ifr": "\u2111",
    "Im": "\u2111",
    "image": "\u2111",
    "imagpart": "\u2111",
    "Igrave": "\xCC",
    "Imacr": "\u012A",
    "ImaginaryI": "\u2148",
    "ii": "\u2148",
    "Int": "\u222C",
    "Integral": "\u222B",
    "int": "\u222B",
    "Intersection": "\u22C2",
    "bigcap": "\u22C2",
    "xcap": "\u22C2",
    "InvisibleComma": "\u2063",
    "ic": "\u2063",
    "InvisibleTimes": "\u2062",
    "it": "\u2062",
    "Iogon": "\u012E",
    "Iopf": "\u{1D540}",
    "Iota": "\u0399",
    "Iscr": "\u2110",
    "imagline": "\u2110",
    "Itilde": "\u0128",
    "Iukcy": "\u0406",
    "Iuml": "\xCF",
    "Jcirc": "\u0134",
    "Jcy": "\u0419",
    "Jfr": "\u{1D50D}",
    "Jopf": "\u{1D541}",
    "Jscr": "\u{1D4A5}",
    "Jsercy": "\u0408",
    "Jukcy": "\u0404",
    "KHcy": "\u0425",
    "KJcy": "\u040C",
    "Kappa": "\u039A",
    "Kcedil": "\u0136",
    "Kcy": "\u041A",
    "Kfr": "\u{1D50E}",
    "Kopf": "\u{1D542}",
    "Kscr": "\u{1D4A6}",
    "LJcy": "\u0409",
    "LT": "<",
    "lt": "<",
    "Lacute": "\u0139",
    "Lambda": "\u039B",
    "Lang": "\u27EA",
    "Laplacetrf": "\u2112",
    "Lscr": "\u2112",
    "lagran": "\u2112",
    "Larr": "\u219E",
    "twoheadleftarrow": "\u219E",
    "Lcaron": "\u013D",
    "Lcedil": "\u013B",
    "Lcy": "\u041B",
    "LeftAngleBracket": "\u27E8",
    "lang": "\u27E8",
    "langle": "\u27E8",
    "LeftArrow": "\u2190",
    "ShortLeftArrow": "\u2190",
    "larr": "\u2190",
    "leftarrow": "\u2190",
    "slarr": "\u2190",
    "LeftArrowBar": "\u21E4",
    "larrb": "\u21E4",
    "LeftArrowRightArrow": "\u21C6",
    "leftrightarrows": "\u21C6",
    "lrarr": "\u21C6",
    "LeftCeiling": "\u2308",
    "lceil": "\u2308",
    "LeftDoubleBracket": "\u27E6",
    "lobrk": "\u27E6",
    "LeftDownTeeVector": "\u2961",
    "LeftDownVector": "\u21C3",
    "dharl": "\u21C3",
    "downharpoonleft": "\u21C3",
    "LeftDownVectorBar": "\u2959",
    "LeftFloor": "\u230A",
    "lfloor": "\u230A",
    "LeftRightArrow": "\u2194",
    "harr": "\u2194",
    "leftrightarrow": "\u2194",
    "LeftRightVector": "\u294E",
    "LeftTee": "\u22A3",
    "dashv": "\u22A3",
    "LeftTeeArrow": "\u21A4",
    "mapstoleft": "\u21A4",
    "LeftTeeVector": "\u295A",
    "LeftTriangle": "\u22B2",
    "vartriangleleft": "\u22B2",
    "vltri": "\u22B2",
    "LeftTriangleBar": "\u29CF",
    "LeftTriangleEqual": "\u22B4",
    "ltrie": "\u22B4",
    "trianglelefteq": "\u22B4",
    "LeftUpDownVector": "\u2951",
    "LeftUpTeeVector": "\u2960",
    "LeftUpVector": "\u21BF",
    "uharl": "\u21BF",
    "upharpoonleft": "\u21BF",
    "LeftUpVectorBar": "\u2958",
    "LeftVector": "\u21BC",
    "leftharpoonup": "\u21BC",
    "lharu": "\u21BC",
    "LeftVectorBar": "\u2952",
    "LessEqualGreater": "\u22DA",
    "leg": "\u22DA",
    "lesseqgtr": "\u22DA",
    "LessFullEqual": "\u2266",
    "lE": "\u2266",
    "leqq": "\u2266",
    "LessGreater": "\u2276",
    "lessgtr": "\u2276",
    "lg": "\u2276",
    "LessLess": "\u2AA1",
    "LessSlantEqual": "\u2A7D",
    "leqslant": "\u2A7D",
    "les": "\u2A7D",
    "LessTilde": "\u2272",
    "lesssim": "\u2272",
    "lsim": "\u2272",
    "Lfr": "\u{1D50F}",
    "Ll": "\u22D8",
    "Lleftarrow": "\u21DA",
    "lAarr": "\u21DA",
    "Lmidot": "\u013F",
    "LongLeftArrow": "\u27F5",
    "longleftarrow": "\u27F5",
    "xlarr": "\u27F5",
    "LongLeftRightArrow": "\u27F7",
    "longleftrightarrow": "\u27F7",
    "xharr": "\u27F7",
    "LongRightArrow": "\u27F6",
    "longrightarrow": "\u27F6",
    "xrarr": "\u27F6",
    "Lopf": "\u{1D543}",
    "LowerLeftArrow": "\u2199",
    "swarr": "\u2199",
    "swarrow": "\u2199",
    "LowerRightArrow": "\u2198",
    "searr": "\u2198",
    "searrow": "\u2198",
    "Lsh": "\u21B0",
    "lsh": "\u21B0",
    "Lstrok": "\u0141",
    "Lt": "\u226A",
    "NestedLessLess": "\u226A",
    "ll": "\u226A",
    "Map": "\u2905",
    "Mcy": "\u041C",
    "MediumSpace": "\u205F",
    "Mellintrf": "\u2133",
    "Mscr": "\u2133",
    "phmmat": "\u2133",
    "Mfr": "\u{1D510}",
    "MinusPlus": "\u2213",
    "mnplus": "\u2213",
    "mp": "\u2213",
    "Mopf": "\u{1D544}",
    "Mu": "\u039C",
    "NJcy": "\u040A",
    "Nacute": "\u0143",
    "Ncaron": "\u0147",
    "Ncedil": "\u0145",
    "Ncy": "\u041D",
    "NegativeMediumSpace": "\u200B",
    "NegativeThickSpace": "\u200B",
    "NegativeThinSpace": "\u200B",
    "NegativeVeryThinSpace": "\u200B",
    "ZeroWidthSpace": "\u200B",
    "NewLine": "\n",
    "Nfr": "\u{1D511}",
    "NoBreak": "\u2060",
    "NonBreakingSpace": "\xA0",
    "nbsp": "\xA0",
    "Nopf": "\u2115",
    "naturals": "\u2115",
    "Not": "\u2AEC",
    "NotCongruent": "\u2262",
    "nequiv": "\u2262",
    "NotCupCap": "\u226D",
    "NotDoubleVerticalBar": "\u2226",
    "npar": "\u2226",
    "nparallel": "\u2226",
    "nshortparallel": "\u2226",
    "nspar": "\u2226",
    "NotElement": "\u2209",
    "notin": "\u2209",
    "notinva": "\u2209",
    "NotEqual": "\u2260",
    "ne": "\u2260",
    "NotEqualTilde": "\u2242\u0338",
    "nesim": "\u2242\u0338",
    "NotExists": "\u2204",
    "nexist": "\u2204",
    "nexists": "\u2204",
    "NotGreater": "\u226F",
    "ngt": "\u226F",
    "ngtr": "\u226F",
    "NotGreaterEqual": "\u2271",
    "nge": "\u2271",
    "ngeq": "\u2271",
    "NotGreaterFullEqual": "\u2267\u0338",
    "ngE": "\u2267\u0338",
    "ngeqq": "\u2267\u0338",
    "NotGreaterGreater": "\u226B\u0338",
    "nGtv": "\u226B\u0338",
    "NotGreaterLess": "\u2279",
    "ntgl": "\u2279",
    "NotGreaterSlantEqual": "\u2A7E\u0338",
    "ngeqslant": "\u2A7E\u0338",
    "nges": "\u2A7E\u0338",
    "NotGreaterTilde": "\u2275",
    "ngsim": "\u2275",
    "NotHumpDownHump": "\u224E\u0338",
    "nbump": "\u224E\u0338",
    "NotHumpEqual": "\u224F\u0338",
    "nbumpe": "\u224F\u0338",
    "NotLeftTriangle": "\u22EA",
    "nltri": "\u22EA",
    "ntriangleleft": "\u22EA",
    "NotLeftTriangleBar": "\u29CF\u0338",
    "NotLeftTriangleEqual": "\u22EC",
    "nltrie": "\u22EC",
    "ntrianglelefteq": "\u22EC",
    "NotLess": "\u226E",
    "nless": "\u226E",
    "nlt": "\u226E",
    "NotLessEqual": "\u2270",
    "nle": "\u2270",
    "nleq": "\u2270",
    "NotLessGreater": "\u2278",
    "ntlg": "\u2278",
    "NotLessLess": "\u226A\u0338",
    "nLtv": "\u226A\u0338",
    "NotLessSlantEqual": "\u2A7D\u0338",
    "nleqslant": "\u2A7D\u0338",
    "nles": "\u2A7D\u0338",
    "NotLessTilde": "\u2274",
    "nlsim": "\u2274",
    "NotNestedGreaterGreater": "\u2AA2\u0338",
    "NotNestedLessLess": "\u2AA1\u0338",
    "NotPrecedes": "\u2280",
    "npr": "\u2280",
    "nprec": "\u2280",
    "NotPrecedesEqual": "\u2AAF\u0338",
    "npre": "\u2AAF\u0338",
    "npreceq": "\u2AAF\u0338",
    "NotPrecedesSlantEqual": "\u22E0",
    "nprcue": "\u22E0",
    "NotReverseElement": "\u220C",
    "notni": "\u220C",
    "notniva": "\u220C",
    "NotRightTriangle": "\u22EB",
    "nrtri": "\u22EB",
    "ntriangleright": "\u22EB",
    "NotRightTriangleBar": "\u29D0\u0338",
    "NotRightTriangleEqual": "\u22ED",
    "nrtrie": "\u22ED",
    "ntrianglerighteq": "\u22ED",
    "NotSquareSubset": "\u228F\u0338",
    "NotSquareSubsetEqual": "\u22E2",
    "nsqsube": "\u22E2",
    "NotSquareSuperset": "\u2290\u0338",
    "NotSquareSupersetEqual": "\u22E3",
    "nsqsupe": "\u22E3",
    "NotSubset": "\u2282\u20D2",
    "nsubset": "\u2282\u20D2",
    "vnsub": "\u2282\u20D2",
    "NotSubsetEqual": "\u2288",
    "nsube": "\u2288",
    "nsubseteq": "\u2288",
    "NotSucceeds": "\u2281",
    "nsc": "\u2281",
    "nsucc": "\u2281",
    "NotSucceedsEqual": "\u2AB0\u0338",
    "nsce": "\u2AB0\u0338",
    "nsucceq": "\u2AB0\u0338",
    "NotSucceedsSlantEqual": "\u22E1",
    "nsccue": "\u22E1",
    "NotSucceedsTilde": "\u227F\u0338",
    "NotSuperset": "\u2283\u20D2",
    "nsupset": "\u2283\u20D2",
    "vnsup": "\u2283\u20D2",
    "NotSupersetEqual": "\u2289",
    "nsupe": "\u2289",
    "nsupseteq": "\u2289",
    "NotTilde": "\u2241",
    "nsim": "\u2241",
    "NotTildeEqual": "\u2244",
    "nsime": "\u2244",
    "nsimeq": "\u2244",
    "NotTildeFullEqual": "\u2247",
    "ncong": "\u2247",
    "NotTildeTilde": "\u2249",
    "nap": "\u2249",
    "napprox": "\u2249",
    "NotVerticalBar": "\u2224",
    "nmid": "\u2224",
    "nshortmid": "\u2224",
    "nsmid": "\u2224",
    "Nscr": "\u{1D4A9}",
    "Ntilde": "\xD1",
    "Nu": "\u039D",
    "OElig": "\u0152",
    "Oacute": "\xD3",
    "Ocirc": "\xD4",
    "Ocy": "\u041E",
    "Odblac": "\u0150",
    "Ofr": "\u{1D512}",
    "Ograve": "\xD2",
    "Omacr": "\u014C",
    "Omega": "\u03A9",
    "ohm": "\u03A9",
    "Omicron": "\u039F",
    "Oopf": "\u{1D546}",
    "OpenCurlyDoubleQuote": "\u201C",
    "ldquo": "\u201C",
    "OpenCurlyQuote": "\u2018",
    "lsquo": "\u2018",
    "Or": "\u2A54",
    "Oscr": "\u{1D4AA}",
    "Oslash": "\xD8",
    "Otilde": "\xD5",
    "Otimes": "\u2A37",
    "Ouml": "\xD6",
    "OverBar": "\u203E",
    "oline": "\u203E",
    "OverBrace": "\u23DE",
    "OverBracket": "\u23B4",
    "tbrk": "\u23B4",
    "OverParenthesis": "\u23DC",
    "PartialD": "\u2202",
    "part": "\u2202",
    "Pcy": "\u041F",
    "Pfr": "\u{1D513}",
    "Phi": "\u03A6",
    "Pi": "\u03A0",
    "PlusMinus": "\xB1",
    "plusmn": "\xB1",
    "pm": "\xB1",
    "Popf": "\u2119",
    "primes": "\u2119",
    "Pr": "\u2ABB",
    "Precedes": "\u227A",
    "pr": "\u227A",
    "prec": "\u227A",
    "PrecedesEqual": "\u2AAF",
    "pre": "\u2AAF",
    "preceq": "\u2AAF",
    "PrecedesSlantEqual": "\u227C",
    "prcue": "\u227C",
    "preccurlyeq": "\u227C",
    "PrecedesTilde": "\u227E",
    "precsim": "\u227E",
    "prsim": "\u227E",
    "Prime": "\u2033",
    "Product": "\u220F",
    "prod": "\u220F",
    "Proportional": "\u221D",
    "prop": "\u221D",
    "propto": "\u221D",
    "varpropto": "\u221D",
    "vprop": "\u221D",
    "Pscr": "\u{1D4AB}",
    "Psi": "\u03A8",
    "QUOT": '"',
    "quot": '"',
    "Qfr": "\u{1D514}",
    "Qopf": "\u211A",
    "rationals": "\u211A",
    "Qscr": "\u{1D4AC}",
    "RBarr": "\u2910",
    "drbkarow": "\u2910",
    "REG": "\xAE",
    "circledR": "\xAE",
    "reg": "\xAE",
    "Racute": "\u0154",
    "Rang": "\u27EB",
    "Rarr": "\u21A0",
    "twoheadrightarrow": "\u21A0",
    "Rarrtl": "\u2916",
    "Rcaron": "\u0158",
    "Rcedil": "\u0156",
    "Rcy": "\u0420",
    "Re": "\u211C",
    "Rfr": "\u211C",
    "real": "\u211C",
    "realpart": "\u211C",
    "ReverseElement": "\u220B",
    "SuchThat": "\u220B",
    "ni": "\u220B",
    "niv": "\u220B",
    "ReverseEquilibrium": "\u21CB",
    "leftrightharpoons": "\u21CB",
    "lrhar": "\u21CB",
    "ReverseUpEquilibrium": "\u296F",
    "duhar": "\u296F",
    "Rho": "\u03A1",
    "RightAngleBracket": "\u27E9",
    "rang": "\u27E9",
    "rangle": "\u27E9",
    "RightArrow": "\u2192",
    "ShortRightArrow": "\u2192",
    "rarr": "\u2192",
    "rightarrow": "\u2192",
    "srarr": "\u2192",
    "RightArrowBar": "\u21E5",
    "rarrb": "\u21E5",
    "RightArrowLeftArrow": "\u21C4",
    "rightleftarrows": "\u21C4",
    "rlarr": "\u21C4",
    "RightCeiling": "\u2309",
    "rceil": "\u2309",
    "RightDoubleBracket": "\u27E7",
    "robrk": "\u27E7",
    "RightDownTeeVector": "\u295D",
    "RightDownVector": "\u21C2",
    "dharr": "\u21C2",
    "downharpoonright": "\u21C2",
    "RightDownVectorBar": "\u2955",
    "RightFloor": "\u230B",
    "rfloor": "\u230B",
    "RightTee": "\u22A2",
    "vdash": "\u22A2",
    "RightTeeArrow": "\u21A6",
    "map": "\u21A6",
    "mapsto": "\u21A6",
    "RightTeeVector": "\u295B",
    "RightTriangle": "\u22B3",
    "vartriangleright": "\u22B3",
    "vrtri": "\u22B3",
    "RightTriangleBar": "\u29D0",
    "RightTriangleEqual": "\u22B5",
    "rtrie": "\u22B5",
    "trianglerighteq": "\u22B5",
    "RightUpDownVector": "\u294F",
    "RightUpTeeVector": "\u295C",
    "RightUpVector": "\u21BE",
    "uharr": "\u21BE",
    "upharpoonright": "\u21BE",
    "RightUpVectorBar": "\u2954",
    "RightVector": "\u21C0",
    "rharu": "\u21C0",
    "rightharpoonup": "\u21C0",
    "RightVectorBar": "\u2953",
    "Ropf": "\u211D",
    "reals": "\u211D",
    "RoundImplies": "\u2970",
    "Rrightarrow": "\u21DB",
    "rAarr": "\u21DB",
    "Rscr": "\u211B",
    "realine": "\u211B",
    "Rsh": "\u21B1",
    "rsh": "\u21B1",
    "RuleDelayed": "\u29F4",
    "SHCHcy": "\u0429",
    "SHcy": "\u0428",
    "SOFTcy": "\u042C",
    "Sacute": "\u015A",
    "Sc": "\u2ABC",
    "Scaron": "\u0160",
    "Scedil": "\u015E",
    "Scirc": "\u015C",
    "Scy": "\u0421",
    "Sfr": "\u{1D516}",
    "ShortUpArrow": "\u2191",
    "UpArrow": "\u2191",
    "uarr": "\u2191",
    "uparrow": "\u2191",
    "Sigma": "\u03A3",
    "SmallCircle": "\u2218",
    "compfn": "\u2218",
    "Sopf": "\u{1D54A}",
    "Sqrt": "\u221A",
    "radic": "\u221A",
    "Square": "\u25A1",
    "squ": "\u25A1",
    "square": "\u25A1",
    "SquareIntersection": "\u2293",
    "sqcap": "\u2293",
    "SquareSubset": "\u228F",
    "sqsub": "\u228F",
    "sqsubset": "\u228F",
    "SquareSubsetEqual": "\u2291",
    "sqsube": "\u2291",
    "sqsubseteq": "\u2291",
    "SquareSuperset": "\u2290",
    "sqsup": "\u2290",
    "sqsupset": "\u2290",
    "SquareSupersetEqual": "\u2292",
    "sqsupe": "\u2292",
    "sqsupseteq": "\u2292",
    "SquareUnion": "\u2294",
    "sqcup": "\u2294",
    "Sscr": "\u{1D4AE}",
    "Star": "\u22C6",
    "sstarf": "\u22C6",
    "Sub": "\u22D0",
    "Subset": "\u22D0",
    "SubsetEqual": "\u2286",
    "sube": "\u2286",
    "subseteq": "\u2286",
    "Succeeds": "\u227B",
    "sc": "\u227B",
    "succ": "\u227B",
    "SucceedsEqual": "\u2AB0",
    "sce": "\u2AB0",
    "succeq": "\u2AB0",
    "SucceedsSlantEqual": "\u227D",
    "sccue": "\u227D",
    "succcurlyeq": "\u227D",
    "SucceedsTilde": "\u227F",
    "scsim": "\u227F",
    "succsim": "\u227F",
    "Sum": "\u2211",
    "sum": "\u2211",
    "Sup": "\u22D1",
    "Supset": "\u22D1",
    "Superset": "\u2283",
    "sup": "\u2283",
    "supset": "\u2283",
    "SupersetEqual": "\u2287",
    "supe": "\u2287",
    "supseteq": "\u2287",
    "THORN": "\xDE",
    "TRADE": "\u2122",
    "trade": "\u2122",
    "TSHcy": "\u040B",
    "TScy": "\u0426",
    "Tab": "	",
    "Tau": "\u03A4",
    "Tcaron": "\u0164",
    "Tcedil": "\u0162",
    "Tcy": "\u0422",
    "Tfr": "\u{1D517}",
    "Therefore": "\u2234",
    "there4": "\u2234",
    "therefore": "\u2234",
    "Theta": "\u0398",
    "ThickSpace": "\u205F\u200A",
    "ThinSpace": "\u2009",
    "thinsp": "\u2009",
    "Tilde": "\u223C",
    "sim": "\u223C",
    "thicksim": "\u223C",
    "thksim": "\u223C",
    "TildeEqual": "\u2243",
    "sime": "\u2243",
    "simeq": "\u2243",
    "TildeFullEqual": "\u2245",
    "cong": "\u2245",
    "TildeTilde": "\u2248",
    "ap": "\u2248",
    "approx": "\u2248",
    "asymp": "\u2248",
    "thickapprox": "\u2248",
    "thkap": "\u2248",
    "Topf": "\u{1D54B}",
    "TripleDot": "\u20DB",
    "tdot": "\u20DB",
    "Tscr": "\u{1D4AF}",
    "Tstrok": "\u0166",
    "Uacute": "\xDA",
    "Uarr": "\u219F",
    "Uarrocir": "\u2949",
    "Ubrcy": "\u040E",
    "Ubreve": "\u016C",
    "Ucirc": "\xDB",
    "Ucy": "\u0423",
    "Udblac": "\u0170",
    "Ufr": "\u{1D518}",
    "Ugrave": "\xD9",
    "Umacr": "\u016A",
    "UnderBar": "_",
    "lowbar": "_",
    "UnderBrace": "\u23DF",
    "UnderBracket": "\u23B5",
    "bbrk": "\u23B5",
    "UnderParenthesis": "\u23DD",
    "Union": "\u22C3",
    "bigcup": "\u22C3",
    "xcup": "\u22C3",
    "UnionPlus": "\u228E",
    "uplus": "\u228E",
    "Uogon": "\u0172",
    "Uopf": "\u{1D54C}",
    "UpArrowBar": "\u2912",
    "UpArrowDownArrow": "\u21C5",
    "udarr": "\u21C5",
    "UpDownArrow": "\u2195",
    "updownarrow": "\u2195",
    "varr": "\u2195",
    "UpEquilibrium": "\u296E",
    "udhar": "\u296E",
    "UpTee": "\u22A5",
    "bot": "\u22A5",
    "bottom": "\u22A5",
    "perp": "\u22A5",
    "UpTeeArrow": "\u21A5",
    "mapstoup": "\u21A5",
    "UpperLeftArrow": "\u2196",
    "nwarr": "\u2196",
    "nwarrow": "\u2196",
    "UpperRightArrow": "\u2197",
    "nearr": "\u2197",
    "nearrow": "\u2197",
    "Upsi": "\u03D2",
    "upsih": "\u03D2",
    "Upsilon": "\u03A5",
    "Uring": "\u016E",
    "Uscr": "\u{1D4B0}",
    "Utilde": "\u0168",
    "Uuml": "\xDC",
    "VDash": "\u22AB",
    "Vbar": "\u2AEB",
    "Vcy": "\u0412",
    "Vdash": "\u22A9",
    "Vdashl": "\u2AE6",
    "Vee": "\u22C1",
    "bigvee": "\u22C1",
    "xvee": "\u22C1",
    "Verbar": "\u2016",
    "Vert": "\u2016",
    "VerticalBar": "\u2223",
    "mid": "\u2223",
    "shortmid": "\u2223",
    "smid": "\u2223",
    "VerticalLine": "|",
    "verbar": "|",
    "vert": "|",
    "VerticalSeparator": "\u2758",
    "VerticalTilde": "\u2240",
    "wr": "\u2240",
    "wreath": "\u2240",
    "VeryThinSpace": "\u200A",
    "hairsp": "\u200A",
    "Vfr": "\u{1D519}",
    "Vopf": "\u{1D54D}",
    "Vscr": "\u{1D4B1}",
    "Vvdash": "\u22AA",
    "Wcirc": "\u0174",
    "Wedge": "\u22C0",
    "bigwedge": "\u22C0",
    "xwedge": "\u22C0",
    "Wfr": "\u{1D51A}",
    "Wopf": "\u{1D54E}",
    "Wscr": "\u{1D4B2}",
    "Xfr": "\u{1D51B}",
    "Xi": "\u039E",
    "Xopf": "\u{1D54F}",
    "Xscr": "\u{1D4B3}",
    "YAcy": "\u042F",
    "YIcy": "\u0407",
    "YUcy": "\u042E",
    "Yacute": "\xDD",
    "Ycirc": "\u0176",
    "Ycy": "\u042B",
    "Yfr": "\u{1D51C}",
    "Yopf": "\u{1D550}",
    "Yscr": "\u{1D4B4}",
    "Yuml": "\u0178",
    "ZHcy": "\u0416",
    "Zacute": "\u0179",
    "Zcaron": "\u017D",
    "Zcy": "\u0417",
    "Zdot": "\u017B",
    "Zeta": "\u0396",
    "Zfr": "\u2128",
    "zeetrf": "\u2128",
    "Zopf": "\u2124",
    "integers": "\u2124",
    "Zscr": "\u{1D4B5}",
    "aacute": "\xE1",
    "abreve": "\u0103",
    "ac": "\u223E",
    "mstpos": "\u223E",
    "acE": "\u223E\u0333",
    "acd": "\u223F",
    "acirc": "\xE2",
    "acy": "\u0430",
    "aelig": "\xE6",
    "afr": "\u{1D51E}",
    "agrave": "\xE0",
    "alefsym": "\u2135",
    "aleph": "\u2135",
    "alpha": "\u03B1",
    "amacr": "\u0101",
    "amalg": "\u2A3F",
    "and": "\u2227",
    "wedge": "\u2227",
    "andand": "\u2A55",
    "andd": "\u2A5C",
    "andslope": "\u2A58",
    "andv": "\u2A5A",
    "ang": "\u2220",
    "angle": "\u2220",
    "ange": "\u29A4",
    "angmsd": "\u2221",
    "measuredangle": "\u2221",
    "angmsdaa": "\u29A8",
    "angmsdab": "\u29A9",
    "angmsdac": "\u29AA",
    "angmsdad": "\u29AB",
    "angmsdae": "\u29AC",
    "angmsdaf": "\u29AD",
    "angmsdag": "\u29AE",
    "angmsdah": "\u29AF",
    "angrt": "\u221F",
    "angrtvb": "\u22BE",
    "angrtvbd": "\u299D",
    "angsph": "\u2222",
    "angzarr": "\u237C",
    "aogon": "\u0105",
    "aopf": "\u{1D552}",
    "apE": "\u2A70",
    "apacir": "\u2A6F",
    "ape": "\u224A",
    "approxeq": "\u224A",
    "apid": "\u224B",
    "apos": "'",
    "aring": "\xE5",
    "ascr": "\u{1D4B6}",
    "ast": "*",
    "midast": "*",
    "atilde": "\xE3",
    "auml": "\xE4",
    "awint": "\u2A11",
    "bNot": "\u2AED",
    "backcong": "\u224C",
    "bcong": "\u224C",
    "backepsilon": "\u03F6",
    "bepsi": "\u03F6",
    "backprime": "\u2035",
    "bprime": "\u2035",
    "backsim": "\u223D",
    "bsim": "\u223D",
    "backsimeq": "\u22CD",
    "bsime": "\u22CD",
    "barvee": "\u22BD",
    "barwed": "\u2305",
    "barwedge": "\u2305",
    "bbrktbrk": "\u23B6",
    "bcy": "\u0431",
    "bdquo": "\u201E",
    "ldquor": "\u201E",
    "bemptyv": "\u29B0",
    "beta": "\u03B2",
    "beth": "\u2136",
    "between": "\u226C",
    "twixt": "\u226C",
    "bfr": "\u{1D51F}",
    "bigcirc": "\u25EF",
    "xcirc": "\u25EF",
    "bigodot": "\u2A00",
    "xodot": "\u2A00",
    "bigoplus": "\u2A01",
    "xoplus": "\u2A01",
    "bigotimes": "\u2A02",
    "xotime": "\u2A02",
    "bigsqcup": "\u2A06",
    "xsqcup": "\u2A06",
    "bigstar": "\u2605",
    "starf": "\u2605",
    "bigtriangledown": "\u25BD",
    "xdtri": "\u25BD",
    "bigtriangleup": "\u25B3",
    "xutri": "\u25B3",
    "biguplus": "\u2A04",
    "xuplus": "\u2A04",
    "bkarow": "\u290D",
    "rbarr": "\u290D",
    "blacklozenge": "\u29EB",
    "lozf": "\u29EB",
    "blacktriangle": "\u25B4",
    "utrif": "\u25B4",
    "blacktriangledown": "\u25BE",
    "dtrif": "\u25BE",
    "blacktriangleleft": "\u25C2",
    "ltrif": "\u25C2",
    "blacktriangleright": "\u25B8",
    "rtrif": "\u25B8",
    "blank": "\u2423",
    "blk12": "\u2592",
    "blk14": "\u2591",
    "blk34": "\u2593",
    "block": "\u2588",
    "bne": "=\u20E5",
    "bnequiv": "\u2261\u20E5",
    "bnot": "\u2310",
    "bopf": "\u{1D553}",
    "bowtie": "\u22C8",
    "boxDL": "\u2557",
    "boxDR": "\u2554",
    "boxDl": "\u2556",
    "boxDr": "\u2553",
    "boxH": "\u2550",
    "boxHD": "\u2566",
    "boxHU": "\u2569",
    "boxHd": "\u2564",
    "boxHu": "\u2567",
    "boxUL": "\u255D",
    "boxUR": "\u255A",
    "boxUl": "\u255C",
    "boxUr": "\u2559",
    "boxV": "\u2551",
    "boxVH": "\u256C",
    "boxVL": "\u2563",
    "boxVR": "\u2560",
    "boxVh": "\u256B",
    "boxVl": "\u2562",
    "boxVr": "\u255F",
    "boxbox": "\u29C9",
    "boxdL": "\u2555",
    "boxdR": "\u2552",
    "boxdl": "\u2510",
    "boxdr": "\u250C",
    "boxhD": "\u2565",
    "boxhU": "\u2568",
    "boxhd": "\u252C",
    "boxhu": "\u2534",
    "boxminus": "\u229F",
    "minusb": "\u229F",
    "boxplus": "\u229E",
    "plusb": "\u229E",
    "boxtimes": "\u22A0",
    "timesb": "\u22A0",
    "boxuL": "\u255B",
    "boxuR": "\u2558",
    "boxul": "\u2518",
    "boxur": "\u2514",
    "boxv": "\u2502",
    "boxvH": "\u256A",
    "boxvL": "\u2561",
    "boxvR": "\u255E",
    "boxvh": "\u253C",
    "boxvl": "\u2524",
    "boxvr": "\u251C",
    "brvbar": "\xA6",
    "bscr": "\u{1D4B7}",
    "bsemi": "\u204F",
    "bsol": "\\",
    "bsolb": "\u29C5",
    "bsolhsub": "\u27C8",
    "bull": "\u2022",
    "bullet": "\u2022",
    "bumpE": "\u2AAE",
    "cacute": "\u0107",
    "cap": "\u2229",
    "capand": "\u2A44",
    "capbrcup": "\u2A49",
    "capcap": "\u2A4B",
    "capcup": "\u2A47",
    "capdot": "\u2A40",
    "caps": "\u2229\uFE00",
    "caret": "\u2041",
    "ccaps": "\u2A4D",
    "ccaron": "\u010D",
    "ccedil": "\xE7",
    "ccirc": "\u0109",
    "ccups": "\u2A4C",
    "ccupssm": "\u2A50",
    "cdot": "\u010B",
    "cemptyv": "\u29B2",
    "cent": "\xA2",
    "cfr": "\u{1D520}",
    "chcy": "\u0447",
    "check": "\u2713",
    "checkmark": "\u2713",
    "chi": "\u03C7",
    "cir": "\u25CB",
    "cirE": "\u29C3",
    "circ": "\u02C6",
    "circeq": "\u2257",
    "cire": "\u2257",
    "circlearrowleft": "\u21BA",
    "olarr": "\u21BA",
    "circlearrowright": "\u21BB",
    "orarr": "\u21BB",
    "circledS": "\u24C8",
    "oS": "\u24C8",
    "circledast": "\u229B",
    "oast": "\u229B",
    "circledcirc": "\u229A",
    "ocir": "\u229A",
    "circleddash": "\u229D",
    "odash": "\u229D",
    "cirfnint": "\u2A10",
    "cirmid": "\u2AEF",
    "cirscir": "\u29C2",
    "clubs": "\u2663",
    "clubsuit": "\u2663",
    "colon": ":",
    "comma": ",",
    "commat": "@",
    "comp": "\u2201",
    "complement": "\u2201",
    "congdot": "\u2A6D",
    "copf": "\u{1D554}",
    "copysr": "\u2117",
    "crarr": "\u21B5",
    "cross": "\u2717",
    "cscr": "\u{1D4B8}",
    "csub": "\u2ACF",
    "csube": "\u2AD1",
    "csup": "\u2AD0",
    "csupe": "\u2AD2",
    "ctdot": "\u22EF",
    "cudarrl": "\u2938",
    "cudarrr": "\u2935",
    "cuepr": "\u22DE",
    "curlyeqprec": "\u22DE",
    "cuesc": "\u22DF",
    "curlyeqsucc": "\u22DF",
    "cularr": "\u21B6",
    "curvearrowleft": "\u21B6",
    "cularrp": "\u293D",
    "cup": "\u222A",
    "cupbrcap": "\u2A48",
    "cupcap": "\u2A46",
    "cupcup": "\u2A4A",
    "cupdot": "\u228D",
    "cupor": "\u2A45",
    "cups": "\u222A\uFE00",
    "curarr": "\u21B7",
    "curvearrowright": "\u21B7",
    "curarrm": "\u293C",
    "curlyvee": "\u22CE",
    "cuvee": "\u22CE",
    "curlywedge": "\u22CF",
    "cuwed": "\u22CF",
    "curren": "\xA4",
    "cwint": "\u2231",
    "cylcty": "\u232D",
    "dHar": "\u2965",
    "dagger": "\u2020",
    "daleth": "\u2138",
    "dash": "\u2010",
    "hyphen": "\u2010",
    "dbkarow": "\u290F",
    "rBarr": "\u290F",
    "dcaron": "\u010F",
    "dcy": "\u0434",
    "ddarr": "\u21CA",
    "downdownarrows": "\u21CA",
    "ddotseq": "\u2A77",
    "eDDot": "\u2A77",
    "deg": "\xB0",
    "delta": "\u03B4",
    "demptyv": "\u29B1",
    "dfisht": "\u297F",
    "dfr": "\u{1D521}",
    "diamondsuit": "\u2666",
    "diams": "\u2666",
    "digamma": "\u03DD",
    "gammad": "\u03DD",
    "disin": "\u22F2",
    "div": "\xF7",
    "divide": "\xF7",
    "divideontimes": "\u22C7",
    "divonx": "\u22C7",
    "djcy": "\u0452",
    "dlcorn": "\u231E",
    "llcorner": "\u231E",
    "dlcrop": "\u230D",
    "dollar": "$",
    "dopf": "\u{1D555}",
    "doteqdot": "\u2251",
    "eDot": "\u2251",
    "dotminus": "\u2238",
    "minusd": "\u2238",
    "dotplus": "\u2214",
    "plusdo": "\u2214",
    "dotsquare": "\u22A1",
    "sdotb": "\u22A1",
    "drcorn": "\u231F",
    "lrcorner": "\u231F",
    "drcrop": "\u230C",
    "dscr": "\u{1D4B9}",
    "dscy": "\u0455",
    "dsol": "\u29F6",
    "dstrok": "\u0111",
    "dtdot": "\u22F1",
    "dtri": "\u25BF",
    "triangledown": "\u25BF",
    "dwangle": "\u29A6",
    "dzcy": "\u045F",
    "dzigrarr": "\u27FF",
    "eacute": "\xE9",
    "easter": "\u2A6E",
    "ecaron": "\u011B",
    "ecir": "\u2256",
    "eqcirc": "\u2256",
    "ecirc": "\xEA",
    "ecolon": "\u2255",
    "eqcolon": "\u2255",
    "ecy": "\u044D",
    "edot": "\u0117",
    "efDot": "\u2252",
    "fallingdotseq": "\u2252",
    "efr": "\u{1D522}",
    "eg": "\u2A9A",
    "egrave": "\xE8",
    "egs": "\u2A96",
    "eqslantgtr": "\u2A96",
    "egsdot": "\u2A98",
    "el": "\u2A99",
    "elinters": "\u23E7",
    "ell": "\u2113",
    "els": "\u2A95",
    "eqslantless": "\u2A95",
    "elsdot": "\u2A97",
    "emacr": "\u0113",
    "empty": "\u2205",
    "emptyset": "\u2205",
    "emptyv": "\u2205",
    "varnothing": "\u2205",
    "emsp13": "\u2004",
    "emsp14": "\u2005",
    "emsp": "\u2003",
    "eng": "\u014B",
    "ensp": "\u2002",
    "eogon": "\u0119",
    "eopf": "\u{1D556}",
    "epar": "\u22D5",
    "eparsl": "\u29E3",
    "eplus": "\u2A71",
    "epsi": "\u03B5",
    "epsilon": "\u03B5",
    "epsiv": "\u03F5",
    "straightepsilon": "\u03F5",
    "varepsilon": "\u03F5",
    "equals": "=",
    "equest": "\u225F",
    "questeq": "\u225F",
    "equivDD": "\u2A78",
    "eqvparsl": "\u29E5",
    "erDot": "\u2253",
    "risingdotseq": "\u2253",
    "erarr": "\u2971",
    "escr": "\u212F",
    "eta": "\u03B7",
    "eth": "\xF0",
    "euml": "\xEB",
    "euro": "\u20AC",
    "excl": "!",
    "fcy": "\u0444",
    "female": "\u2640",
    "ffilig": "\uFB03",
    "fflig": "\uFB00",
    "ffllig": "\uFB04",
    "ffr": "\u{1D523}",
    "filig": "\uFB01",
    "fjlig": "fj",
    "flat": "\u266D",
    "fllig": "\uFB02",
    "fltns": "\u25B1",
    "fnof": "\u0192",
    "fopf": "\u{1D557}",
    "fork": "\u22D4",
    "pitchfork": "\u22D4",
    "forkv": "\u2AD9",
    "fpartint": "\u2A0D",
    "frac12": "\xBD",
    "half": "\xBD",
    "frac13": "\u2153",
    "frac14": "\xBC",
    "frac15": "\u2155",
    "frac16": "\u2159",
    "frac18": "\u215B",
    "frac23": "\u2154",
    "frac25": "\u2156",
    "frac34": "\xBE",
    "frac35": "\u2157",
    "frac38": "\u215C",
    "frac45": "\u2158",
    "frac56": "\u215A",
    "frac58": "\u215D",
    "frac78": "\u215E",
    "frasl": "\u2044",
    "frown": "\u2322",
    "sfrown": "\u2322",
    "fscr": "\u{1D4BB}",
    "gEl": "\u2A8C",
    "gtreqqless": "\u2A8C",
    "gacute": "\u01F5",
    "gamma": "\u03B3",
    "gap": "\u2A86",
    "gtrapprox": "\u2A86",
    "gbreve": "\u011F",
    "gcirc": "\u011D",
    "gcy": "\u0433",
    "gdot": "\u0121",
    "gescc": "\u2AA9",
    "gesdot": "\u2A80",
    "gesdoto": "\u2A82",
    "gesdotol": "\u2A84",
    "gesl": "\u22DB\uFE00",
    "gesles": "\u2A94",
    "gfr": "\u{1D524}",
    "gimel": "\u2137",
    "gjcy": "\u0453",
    "glE": "\u2A92",
    "gla": "\u2AA5",
    "glj": "\u2AA4",
    "gnE": "\u2269",
    "gneqq": "\u2269",
    "gnap": "\u2A8A",
    "gnapprox": "\u2A8A",
    "gne": "\u2A88",
    "gneq": "\u2A88",
    "gnsim": "\u22E7",
    "gopf": "\u{1D558}",
    "gscr": "\u210A",
    "gsime": "\u2A8E",
    "gsiml": "\u2A90",
    "gtcc": "\u2AA7",
    "gtcir": "\u2A7A",
    "gtdot": "\u22D7",
    "gtrdot": "\u22D7",
    "gtlPar": "\u2995",
    "gtquest": "\u2A7C",
    "gtrarr": "\u2978",
    "gvertneqq": "\u2269\uFE00",
    "gvnE": "\u2269\uFE00",
    "hardcy": "\u044A",
    "harrcir": "\u2948",
    "harrw": "\u21AD",
    "leftrightsquigarrow": "\u21AD",
    "hbar": "\u210F",
    "hslash": "\u210F",
    "planck": "\u210F",
    "plankv": "\u210F",
    "hcirc": "\u0125",
    "hearts": "\u2665",
    "heartsuit": "\u2665",
    "hellip": "\u2026",
    "mldr": "\u2026",
    "hercon": "\u22B9",
    "hfr": "\u{1D525}",
    "hksearow": "\u2925",
    "searhk": "\u2925",
    "hkswarow": "\u2926",
    "swarhk": "\u2926",
    "hoarr": "\u21FF",
    "homtht": "\u223B",
    "hookleftarrow": "\u21A9",
    "larrhk": "\u21A9",
    "hookrightarrow": "\u21AA",
    "rarrhk": "\u21AA",
    "hopf": "\u{1D559}",
    "horbar": "\u2015",
    "hscr": "\u{1D4BD}",
    "hstrok": "\u0127",
    "hybull": "\u2043",
    "iacute": "\xED",
    "icirc": "\xEE",
    "icy": "\u0438",
    "iecy": "\u0435",
    "iexcl": "\xA1",
    "ifr": "\u{1D526}",
    "igrave": "\xEC",
    "iiiint": "\u2A0C",
    "qint": "\u2A0C",
    "iiint": "\u222D",
    "tint": "\u222D",
    "iinfin": "\u29DC",
    "iiota": "\u2129",
    "ijlig": "\u0133",
    "imacr": "\u012B",
    "imath": "\u0131",
    "inodot": "\u0131",
    "imof": "\u22B7",
    "imped": "\u01B5",
    "incare": "\u2105",
    "infin": "\u221E",
    "infintie": "\u29DD",
    "intcal": "\u22BA",
    "intercal": "\u22BA",
    "intlarhk": "\u2A17",
    "intprod": "\u2A3C",
    "iprod": "\u2A3C",
    "iocy": "\u0451",
    "iogon": "\u012F",
    "iopf": "\u{1D55A}",
    "iota": "\u03B9",
    "iquest": "\xBF",
    "iscr": "\u{1D4BE}",
    "isinE": "\u22F9",
    "isindot": "\u22F5",
    "isins": "\u22F4",
    "isinsv": "\u22F3",
    "itilde": "\u0129",
    "iukcy": "\u0456",
    "iuml": "\xEF",
    "jcirc": "\u0135",
    "jcy": "\u0439",
    "jfr": "\u{1D527}",
    "jmath": "\u0237",
    "jopf": "\u{1D55B}",
    "jscr": "\u{1D4BF}",
    "jsercy": "\u0458",
    "jukcy": "\u0454",
    "kappa": "\u03BA",
    "kappav": "\u03F0",
    "varkappa": "\u03F0",
    "kcedil": "\u0137",
    "kcy": "\u043A",
    "kfr": "\u{1D528}",
    "kgreen": "\u0138",
    "khcy": "\u0445",
    "kjcy": "\u045C",
    "kopf": "\u{1D55C}",
    "kscr": "\u{1D4C0}",
    "lAtail": "\u291B",
    "lBarr": "\u290E",
    "lEg": "\u2A8B",
    "lesseqqgtr": "\u2A8B",
    "lHar": "\u2962",
    "lacute": "\u013A",
    "laemptyv": "\u29B4",
    "lambda": "\u03BB",
    "langd": "\u2991",
    "lap": "\u2A85",
    "lessapprox": "\u2A85",
    "laquo": "\xAB",
    "larrbfs": "\u291F",
    "larrfs": "\u291D",
    "larrlp": "\u21AB",
    "looparrowleft": "\u21AB",
    "larrpl": "\u2939",
    "larrsim": "\u2973",
    "larrtl": "\u21A2",
    "leftarrowtail": "\u21A2",
    "lat": "\u2AAB",
    "latail": "\u2919",
    "late": "\u2AAD",
    "lates": "\u2AAD\uFE00",
    "lbarr": "\u290C",
    "lbbrk": "\u2772",
    "lbrace": "{",
    "lcub": "{",
    "lbrack": "[",
    "lsqb": "[",
    "lbrke": "\u298B",
    "lbrksld": "\u298F",
    "lbrkslu": "\u298D",
    "lcaron": "\u013E",
    "lcedil": "\u013C",
    "lcy": "\u043B",
    "ldca": "\u2936",
    "ldrdhar": "\u2967",
    "ldrushar": "\u294B",
    "ldsh": "\u21B2",
    "le": "\u2264",
    "leq": "\u2264",
    "leftleftarrows": "\u21C7",
    "llarr": "\u21C7",
    "leftthreetimes": "\u22CB",
    "lthree": "\u22CB",
    "lescc": "\u2AA8",
    "lesdot": "\u2A7F",
    "lesdoto": "\u2A81",
    "lesdotor": "\u2A83",
    "lesg": "\u22DA\uFE00",
    "lesges": "\u2A93",
    "lessdot": "\u22D6",
    "ltdot": "\u22D6",
    "lfisht": "\u297C",
    "lfr": "\u{1D529}",
    "lgE": "\u2A91",
    "lharul": "\u296A",
    "lhblk": "\u2584",
    "ljcy": "\u0459",
    "llhard": "\u296B",
    "lltri": "\u25FA",
    "lmidot": "\u0140",
    "lmoust": "\u23B0",
    "lmoustache": "\u23B0",
    "lnE": "\u2268",
    "lneqq": "\u2268",
    "lnap": "\u2A89",
    "lnapprox": "\u2A89",
    "lne": "\u2A87",
    "lneq": "\u2A87",
    "lnsim": "\u22E6",
    "loang": "\u27EC",
    "loarr": "\u21FD",
    "longmapsto": "\u27FC",
    "xmap": "\u27FC",
    "looparrowright": "\u21AC",
    "rarrlp": "\u21AC",
    "lopar": "\u2985",
    "lopf": "\u{1D55D}",
    "loplus": "\u2A2D",
    "lotimes": "\u2A34",
    "lowast": "\u2217",
    "loz": "\u25CA",
    "lozenge": "\u25CA",
    "lpar": "(",
    "lparlt": "\u2993",
    "lrhard": "\u296D",
    "lrm": "\u200E",
    "lrtri": "\u22BF",
    "lsaquo": "\u2039",
    "lscr": "\u{1D4C1}",
    "lsime": "\u2A8D",
    "lsimg": "\u2A8F",
    "lsquor": "\u201A",
    "sbquo": "\u201A",
    "lstrok": "\u0142",
    "ltcc": "\u2AA6",
    "ltcir": "\u2A79",
    "ltimes": "\u22C9",
    "ltlarr": "\u2976",
    "ltquest": "\u2A7B",
    "ltrPar": "\u2996",
    "ltri": "\u25C3",
    "triangleleft": "\u25C3",
    "lurdshar": "\u294A",
    "luruhar": "\u2966",
    "lvertneqq": "\u2268\uFE00",
    "lvnE": "\u2268\uFE00",
    "mDDot": "\u223A",
    "macr": "\xAF",
    "strns": "\xAF",
    "male": "\u2642",
    "malt": "\u2720",
    "maltese": "\u2720",
    "marker": "\u25AE",
    "mcomma": "\u2A29",
    "mcy": "\u043C",
    "mdash": "\u2014",
    "mfr": "\u{1D52A}",
    "mho": "\u2127",
    "micro": "\xB5",
    "midcir": "\u2AF0",
    "minus": "\u2212",
    "minusdu": "\u2A2A",
    "mlcp": "\u2ADB",
    "models": "\u22A7",
    "mopf": "\u{1D55E}",
    "mscr": "\u{1D4C2}",
    "mu": "\u03BC",
    "multimap": "\u22B8",
    "mumap": "\u22B8",
    "nGg": "\u22D9\u0338",
    "nGt": "\u226B\u20D2",
    "nLeftarrow": "\u21CD",
    "nlArr": "\u21CD",
    "nLeftrightarrow": "\u21CE",
    "nhArr": "\u21CE",
    "nLl": "\u22D8\u0338",
    "nLt": "\u226A\u20D2",
    "nRightarrow": "\u21CF",
    "nrArr": "\u21CF",
    "nVDash": "\u22AF",
    "nVdash": "\u22AE",
    "nacute": "\u0144",
    "nang": "\u2220\u20D2",
    "napE": "\u2A70\u0338",
    "napid": "\u224B\u0338",
    "napos": "\u0149",
    "natur": "\u266E",
    "natural": "\u266E",
    "ncap": "\u2A43",
    "ncaron": "\u0148",
    "ncedil": "\u0146",
    "ncongdot": "\u2A6D\u0338",
    "ncup": "\u2A42",
    "ncy": "\u043D",
    "ndash": "\u2013",
    "neArr": "\u21D7",
    "nearhk": "\u2924",
    "nedot": "\u2250\u0338",
    "nesear": "\u2928",
    "toea": "\u2928",
    "nfr": "\u{1D52B}",
    "nharr": "\u21AE",
    "nleftrightarrow": "\u21AE",
    "nhpar": "\u2AF2",
    "nis": "\u22FC",
    "nisd": "\u22FA",
    "njcy": "\u045A",
    "nlE": "\u2266\u0338",
    "nleqq": "\u2266\u0338",
    "nlarr": "\u219A",
    "nleftarrow": "\u219A",
    "nldr": "\u2025",
    "nopf": "\u{1D55F}",
    "not": "\xAC",
    "notinE": "\u22F9\u0338",
    "notindot": "\u22F5\u0338",
    "notinvb": "\u22F7",
    "notinvc": "\u22F6",
    "notnivb": "\u22FE",
    "notnivc": "\u22FD",
    "nparsl": "\u2AFD\u20E5",
    "npart": "\u2202\u0338",
    "npolint": "\u2A14",
    "nrarr": "\u219B",
    "nrightarrow": "\u219B",
    "nrarrc": "\u2933\u0338",
    "nrarrw": "\u219D\u0338",
    "nscr": "\u{1D4C3}",
    "nsub": "\u2284",
    "nsubE": "\u2AC5\u0338",
    "nsubseteqq": "\u2AC5\u0338",
    "nsup": "\u2285",
    "nsupE": "\u2AC6\u0338",
    "nsupseteqq": "\u2AC6\u0338",
    "ntilde": "\xF1",
    "nu": "\u03BD",
    "num": "#",
    "numero": "\u2116",
    "numsp": "\u2007",
    "nvDash": "\u22AD",
    "nvHarr": "\u2904",
    "nvap": "\u224D\u20D2",
    "nvdash": "\u22AC",
    "nvge": "\u2265\u20D2",
    "nvgt": ">\u20D2",
    "nvinfin": "\u29DE",
    "nvlArr": "\u2902",
    "nvle": "\u2264\u20D2",
    "nvlt": "<\u20D2",
    "nvltrie": "\u22B4\u20D2",
    "nvrArr": "\u2903",
    "nvrtrie": "\u22B5\u20D2",
    "nvsim": "\u223C\u20D2",
    "nwArr": "\u21D6",
    "nwarhk": "\u2923",
    "nwnear": "\u2927",
    "oacute": "\xF3",
    "ocirc": "\xF4",
    "ocy": "\u043E",
    "odblac": "\u0151",
    "odiv": "\u2A38",
    "odsold": "\u29BC",
    "oelig": "\u0153",
    "ofcir": "\u29BF",
    "ofr": "\u{1D52C}",
    "ogon": "\u02DB",
    "ograve": "\xF2",
    "ogt": "\u29C1",
    "ohbar": "\u29B5",
    "olcir": "\u29BE",
    "olcross": "\u29BB",
    "olt": "\u29C0",
    "omacr": "\u014D",
    "omega": "\u03C9",
    "omicron": "\u03BF",
    "omid": "\u29B6",
    "oopf": "\u{1D560}",
    "opar": "\u29B7",
    "operp": "\u29B9",
    "or": "\u2228",
    "vee": "\u2228",
    "ord": "\u2A5D",
    "order": "\u2134",
    "orderof": "\u2134",
    "oscr": "\u2134",
    "ordf": "\xAA",
    "ordm": "\xBA",
    "origof": "\u22B6",
    "oror": "\u2A56",
    "orslope": "\u2A57",
    "orv": "\u2A5B",
    "oslash": "\xF8",
    "osol": "\u2298",
    "otilde": "\xF5",
    "otimesas": "\u2A36",
    "ouml": "\xF6",
    "ovbar": "\u233D",
    "para": "\xB6",
    "parsim": "\u2AF3",
    "parsl": "\u2AFD",
    "pcy": "\u043F",
    "percnt": "%",
    "period": ".",
    "permil": "\u2030",
    "pertenk": "\u2031",
    "pfr": "\u{1D52D}",
    "phi": "\u03C6",
    "phiv": "\u03D5",
    "straightphi": "\u03D5",
    "varphi": "\u03D5",
    "phone": "\u260E",
    "pi": "\u03C0",
    "piv": "\u03D6",
    "varpi": "\u03D6",
    "planckh": "\u210E",
    "plus": "+",
    "plusacir": "\u2A23",
    "pluscir": "\u2A22",
    "plusdu": "\u2A25",
    "pluse": "\u2A72",
    "plussim": "\u2A26",
    "plustwo": "\u2A27",
    "pointint": "\u2A15",
    "popf": "\u{1D561}",
    "pound": "\xA3",
    "prE": "\u2AB3",
    "prap": "\u2AB7",
    "precapprox": "\u2AB7",
    "precnapprox": "\u2AB9",
    "prnap": "\u2AB9",
    "precneqq": "\u2AB5",
    "prnE": "\u2AB5",
    "precnsim": "\u22E8",
    "prnsim": "\u22E8",
    "prime": "\u2032",
    "profalar": "\u232E",
    "profline": "\u2312",
    "profsurf": "\u2313",
    "prurel": "\u22B0",
    "pscr": "\u{1D4C5}",
    "psi": "\u03C8",
    "puncsp": "\u2008",
    "qfr": "\u{1D52E}",
    "qopf": "\u{1D562}",
    "qprime": "\u2057",
    "qscr": "\u{1D4C6}",
    "quatint": "\u2A16",
    "quest": "?",
    "rAtail": "\u291C",
    "rHar": "\u2964",
    "race": "\u223D\u0331",
    "racute": "\u0155",
    "raemptyv": "\u29B3",
    "rangd": "\u2992",
    "range": "\u29A5",
    "raquo": "\xBB",
    "rarrap": "\u2975",
    "rarrbfs": "\u2920",
    "rarrc": "\u2933",
    "rarrfs": "\u291E",
    "rarrpl": "\u2945",
    "rarrsim": "\u2974",
    "rarrtl": "\u21A3",
    "rightarrowtail": "\u21A3",
    "rarrw": "\u219D",
    "rightsquigarrow": "\u219D",
    "ratail": "\u291A",
    "ratio": "\u2236",
    "rbbrk": "\u2773",
    "rbrace": "}",
    "rcub": "}",
    "rbrack": "]",
    "rsqb": "]",
    "rbrke": "\u298C",
    "rbrksld": "\u298E",
    "rbrkslu": "\u2990",
    "rcaron": "\u0159",
    "rcedil": "\u0157",
    "rcy": "\u0440",
    "rdca": "\u2937",
    "rdldhar": "\u2969",
    "rdsh": "\u21B3",
    "rect": "\u25AD",
    "rfisht": "\u297D",
    "rfr": "\u{1D52F}",
    "rharul": "\u296C",
    "rho": "\u03C1",
    "rhov": "\u03F1",
    "varrho": "\u03F1",
    "rightrightarrows": "\u21C9",
    "rrarr": "\u21C9",
    "rightthreetimes": "\u22CC",
    "rthree": "\u22CC",
    "ring": "\u02DA",
    "rlm": "\u200F",
    "rmoust": "\u23B1",
    "rmoustache": "\u23B1",
    "rnmid": "\u2AEE",
    "roang": "\u27ED",
    "roarr": "\u21FE",
    "ropar": "\u2986",
    "ropf": "\u{1D563}",
    "roplus": "\u2A2E",
    "rotimes": "\u2A35",
    "rpar": ")",
    "rpargt": "\u2994",
    "rppolint": "\u2A12",
    "rsaquo": "\u203A",
    "rscr": "\u{1D4C7}",
    "rtimes": "\u22CA",
    "rtri": "\u25B9",
    "triangleright": "\u25B9",
    "rtriltri": "\u29CE",
    "ruluhar": "\u2968",
    "rx": "\u211E",
    "sacute": "\u015B",
    "scE": "\u2AB4",
    "scap": "\u2AB8",
    "succapprox": "\u2AB8",
    "scaron": "\u0161",
    "scedil": "\u015F",
    "scirc": "\u015D",
    "scnE": "\u2AB6",
    "succneqq": "\u2AB6",
    "scnap": "\u2ABA",
    "succnapprox": "\u2ABA",
    "scnsim": "\u22E9",
    "succnsim": "\u22E9",
    "scpolint": "\u2A13",
    "scy": "\u0441",
    "sdot": "\u22C5",
    "sdote": "\u2A66",
    "seArr": "\u21D8",
    "sect": "\xA7",
    "semi": ";",
    "seswar": "\u2929",
    "tosa": "\u2929",
    "sext": "\u2736",
    "sfr": "\u{1D530}",
    "sharp": "\u266F",
    "shchcy": "\u0449",
    "shcy": "\u0448",
    "shy": "\xAD",
    "sigma": "\u03C3",
    "sigmaf": "\u03C2",
    "sigmav": "\u03C2",
    "varsigma": "\u03C2",
    "simdot": "\u2A6A",
    "simg": "\u2A9E",
    "simgE": "\u2AA0",
    "siml": "\u2A9D",
    "simlE": "\u2A9F",
    "simne": "\u2246",
    "simplus": "\u2A24",
    "simrarr": "\u2972",
    "smashp": "\u2A33",
    "smeparsl": "\u29E4",
    "smile": "\u2323",
    "ssmile": "\u2323",
    "smt": "\u2AAA",
    "smte": "\u2AAC",
    "smtes": "\u2AAC\uFE00",
    "softcy": "\u044C",
    "sol": "/",
    "solb": "\u29C4",
    "solbar": "\u233F",
    "sopf": "\u{1D564}",
    "spades": "\u2660",
    "spadesuit": "\u2660",
    "sqcaps": "\u2293\uFE00",
    "sqcups": "\u2294\uFE00",
    "sscr": "\u{1D4C8}",
    "star": "\u2606",
    "sub": "\u2282",
    "subset": "\u2282",
    "subE": "\u2AC5",
    "subseteqq": "\u2AC5",
    "subdot": "\u2ABD",
    "subedot": "\u2AC3",
    "submult": "\u2AC1",
    "subnE": "\u2ACB",
    "subsetneqq": "\u2ACB",
    "subne": "\u228A",
    "subsetneq": "\u228A",
    "subplus": "\u2ABF",
    "subrarr": "\u2979",
    "subsim": "\u2AC7",
    "subsub": "\u2AD5",
    "subsup": "\u2AD3",
    "sung": "\u266A",
    "sup1": "\xB9",
    "sup2": "\xB2",
    "sup3": "\xB3",
    "supE": "\u2AC6",
    "supseteqq": "\u2AC6",
    "supdot": "\u2ABE",
    "supdsub": "\u2AD8",
    "supedot": "\u2AC4",
    "suphsol": "\u27C9",
    "suphsub": "\u2AD7",
    "suplarr": "\u297B",
    "supmult": "\u2AC2",
    "supnE": "\u2ACC",
    "supsetneqq": "\u2ACC",
    "supne": "\u228B",
    "supsetneq": "\u228B",
    "supplus": "\u2AC0",
    "supsim": "\u2AC8",
    "supsub": "\u2AD4",
    "supsup": "\u2AD6",
    "swArr": "\u21D9",
    "swnwar": "\u292A",
    "szlig": "\xDF",
    "target": "\u2316",
    "tau": "\u03C4",
    "tcaron": "\u0165",
    "tcedil": "\u0163",
    "tcy": "\u0442",
    "telrec": "\u2315",
    "tfr": "\u{1D531}",
    "theta": "\u03B8",
    "thetasym": "\u03D1",
    "thetav": "\u03D1",
    "vartheta": "\u03D1",
    "thorn": "\xFE",
    "times": "\xD7",
    "timesbar": "\u2A31",
    "timesd": "\u2A30",
    "topbot": "\u2336",
    "topcir": "\u2AF1",
    "topf": "\u{1D565}",
    "topfork": "\u2ADA",
    "tprime": "\u2034",
    "triangle": "\u25B5",
    "utri": "\u25B5",
    "triangleq": "\u225C",
    "trie": "\u225C",
    "tridot": "\u25EC",
    "triminus": "\u2A3A",
    "triplus": "\u2A39",
    "trisb": "\u29CD",
    "tritime": "\u2A3B",
    "trpezium": "\u23E2",
    "tscr": "\u{1D4C9}",
    "tscy": "\u0446",
    "tshcy": "\u045B",
    "tstrok": "\u0167",
    "uHar": "\u2963",
    "uacute": "\xFA",
    "ubrcy": "\u045E",
    "ubreve": "\u016D",
    "ucirc": "\xFB",
    "ucy": "\u0443",
    "udblac": "\u0171",
    "ufisht": "\u297E",
    "ufr": "\u{1D532}",
    "ugrave": "\xF9",
    "uhblk": "\u2580",
    "ulcorn": "\u231C",
    "ulcorner": "\u231C",
    "ulcrop": "\u230F",
    "ultri": "\u25F8",
    "umacr": "\u016B",
    "uogon": "\u0173",
    "uopf": "\u{1D566}",
    "upsi": "\u03C5",
    "upsilon": "\u03C5",
    "upuparrows": "\u21C8",
    "uuarr": "\u21C8",
    "urcorn": "\u231D",
    "urcorner": "\u231D",
    "urcrop": "\u230E",
    "uring": "\u016F",
    "urtri": "\u25F9",
    "uscr": "\u{1D4CA}",
    "utdot": "\u22F0",
    "utilde": "\u0169",
    "uuml": "\xFC",
    "uwangle": "\u29A7",
    "vBar": "\u2AE8",
    "vBarv": "\u2AE9",
    "vangrt": "\u299C",
    "varsubsetneq": "\u228A\uFE00",
    "vsubne": "\u228A\uFE00",
    "varsubsetneqq": "\u2ACB\uFE00",
    "vsubnE": "\u2ACB\uFE00",
    "varsupsetneq": "\u228B\uFE00",
    "vsupne": "\u228B\uFE00",
    "varsupsetneqq": "\u2ACC\uFE00",
    "vsupnE": "\u2ACC\uFE00",
    "vcy": "\u0432",
    "veebar": "\u22BB",
    "veeeq": "\u225A",
    "vellip": "\u22EE",
    "vfr": "\u{1D533}",
    "vopf": "\u{1D567}",
    "vscr": "\u{1D4CB}",
    "vzigzag": "\u299A",
    "wcirc": "\u0175",
    "wedbar": "\u2A5F",
    "wedgeq": "\u2259",
    "weierp": "\u2118",
    "wp": "\u2118",
    "wfr": "\u{1D534}",
    "wopf": "\u{1D568}",
    "wscr": "\u{1D4CC}",
    "xfr": "\u{1D535}",
    "xi": "\u03BE",
    "xnis": "\u22FB",
    "xopf": "\u{1D569}",
    "xscr": "\u{1D4CD}",
    "yacute": "\xFD",
    "yacy": "\u044F",
    "ycirc": "\u0177",
    "ycy": "\u044B",
    "yen": "\xA5",
    "yfr": "\u{1D536}",
    "yicy": "\u0457",
    "yopf": "\u{1D56A}",
    "yscr": "\u{1D4CE}",
    "yucy": "\u044E",
    "yuml": "\xFF",
    "zacute": "\u017A",
    "zcaron": "\u017E",
    "zcy": "\u0437",
    "zdot": "\u017C",
    "zeta": "\u03B6",
    "zfr": "\u{1D537}",
    "zhcy": "\u0436",
    "zigrarr": "\u21DD",
    "zopf": "\u{1D56B}",
    "zscr": "\u{1D4CF}",
    "zwj": "\u200D",
    "zwnj": "\u200C"
  };
  var NGSP_UNICODE = "\uE500";
  NAMED_ENTITIES["ngsp"] = NGSP_UNICODE;
  var TokenError = class extends ParseError {
    constructor(errorMsg, tokenType, span) {
      super(span, errorMsg);
      this.tokenType = tokenType;
    }
  };
  var TokenizeResult = class {
    constructor(tokens, errors, nonNormalizedIcuExpressions) {
      this.tokens = tokens;
      this.errors = errors;
      this.nonNormalizedIcuExpressions = nonNormalizedIcuExpressions;
    }
  };
  function tokenize(source, url, getTagDefinition, options = {}) {
    const tokenizer = new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, options);
    tokenizer.tokenize();
    return new TokenizeResult(mergeTextTokens(tokenizer.tokens), tokenizer.errors, tokenizer.nonNormalizedIcuExpressions);
  }
  var _CR_OR_CRLF_REGEXP = /\r\n?/g;
  function _unexpectedCharacterErrorMsg(charCode) {
    const char = charCode === $EOF ? "EOF" : String.fromCharCode(charCode);
    return `Unexpected character "${char}"`;
  }
  function _unknownEntityErrorMsg(entitySrc) {
    return `Unknown entity "${entitySrc}" - use the "&#<decimal>;" or  "&#x<hex>;" syntax`;
  }
  function _unparsableEntityErrorMsg(type, entityStr) {
    return `Unable to parse entity "${entityStr}" - ${type} character reference entities must end with ";"`;
  }
  var CharacterReferenceType;
  (function(CharacterReferenceType2) {
    CharacterReferenceType2["HEX"] = "hexadecimal";
    CharacterReferenceType2["DEC"] = "decimal";
  })(CharacterReferenceType || (CharacterReferenceType = {}));
  var _ControlFlowError = class {
    constructor(error3) {
      this.error = error3;
    }
  };
  var _Tokenizer = class {
    constructor(_file, _getTagDefinition, options) {
      this._getTagDefinition = _getTagDefinition;
      this._currentTokenStart = null;
      this._currentTokenType = null;
      this._expansionCaseStack = [];
      this._inInterpolation = false;
      this.tokens = [];
      this.errors = [];
      this.nonNormalizedIcuExpressions = [];
      this._tokenizeIcu = options.tokenizeExpansionForms || false;
      this._interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;
      this._leadingTriviaCodePoints = options.leadingTriviaChars && options.leadingTriviaChars.map((c) => c.codePointAt(0) || 0);
      const range = options.range || { endPos: _file.content.length, startPos: 0, startLine: 0, startCol: 0 };
      this._cursor = options.escapedString ? new EscapedCharacterCursor(_file, range) : new PlainCharacterCursor(_file, range);
      this._preserveLineEndings = options.preserveLineEndings || false;
      this._escapedString = options.escapedString || false;
      this._i18nNormalizeLineEndingsInICUs = options.i18nNormalizeLineEndingsInICUs || false;
      try {
        this._cursor.init();
      } catch (e) {
        this.handleError(e);
      }
    }
    _processCarriageReturns(content) {
      if (this._preserveLineEndings) {
        return content;
      }
      return content.replace(_CR_OR_CRLF_REGEXP, "\n");
    }
    tokenize() {
      while (this._cursor.peek() !== $EOF) {
        const start = this._cursor.clone();
        try {
          if (this._attemptCharCode($LT)) {
            if (this._attemptCharCode($BANG)) {
              if (this._attemptCharCode($LBRACKET)) {
                this._consumeCdata(start);
              } else if (this._attemptCharCode($MINUS)) {
                this._consumeComment(start);
              } else {
                this._consumeDocType(start);
              }
            } else if (this._attemptCharCode($SLASH)) {
              this._consumeTagClose(start);
            } else {
              this._consumeTagOpen(start);
            }
          } else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {
            this._consumeWithInterpolation(5, 8, () => this._isTextEnd(), () => this._isTagStart());
          }
        } catch (e) {
          this.handleError(e);
        }
      }
      this._beginToken(24);
      this._endToken([]);
    }
    _tokenizeExpansionForm() {
      if (this.isExpansionFormStart()) {
        this._consumeExpansionFormStart();
        return true;
      }
      if (isExpansionCaseStart(this._cursor.peek()) && this._isInExpansionForm()) {
        this._consumeExpansionCaseStart();
        return true;
      }
      if (this._cursor.peek() === $RBRACE) {
        if (this._isInExpansionCase()) {
          this._consumeExpansionCaseEnd();
          return true;
        }
        if (this._isInExpansionForm()) {
          this._consumeExpansionFormEnd();
          return true;
        }
      }
      return false;
    }
    _beginToken(type, start = this._cursor.clone()) {
      this._currentTokenStart = start;
      this._currentTokenType = type;
    }
    _endToken(parts, end) {
      if (this._currentTokenStart === null) {
        throw new TokenError("Programming error - attempted to end a token when there was no start to the token", this._currentTokenType, this._cursor.getSpan(end));
      }
      if (this._currentTokenType === null) {
        throw new TokenError("Programming error - attempted to end a token which has no token type", null, this._cursor.getSpan(this._currentTokenStart));
      }
      const token = {
        type: this._currentTokenType,
        parts,
        sourceSpan: (end ?? this._cursor).getSpan(this._currentTokenStart, this._leadingTriviaCodePoints)
      };
      this.tokens.push(token);
      this._currentTokenStart = null;
      this._currentTokenType = null;
      return token;
    }
    _createError(msg, span) {
      if (this._isInExpansionForm()) {
        msg += ` (Do you have an unescaped "{" in your template? Use "{{ '{' }}") to escape it.)`;
      }
      const error3 = new TokenError(msg, this._currentTokenType, span);
      this._currentTokenStart = null;
      this._currentTokenType = null;
      return new _ControlFlowError(error3);
    }
    handleError(e) {
      if (e instanceof CursorError) {
        e = this._createError(e.msg, this._cursor.getSpan(e.cursor));
      }
      if (e instanceof _ControlFlowError) {
        this.errors.push(e.error);
      } else {
        throw e;
      }
    }
    _attemptCharCode(charCode) {
      if (this._cursor.peek() === charCode) {
        this._cursor.advance();
        return true;
      }
      return false;
    }
    _attemptCharCodeCaseInsensitive(charCode) {
      if (compareCharCodeCaseInsensitive(this._cursor.peek(), charCode)) {
        this._cursor.advance();
        return true;
      }
      return false;
    }
    _requireCharCode(charCode) {
      const location2 = this._cursor.clone();
      if (!this._attemptCharCode(charCode)) {
        throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location2));
      }
    }
    _attemptStr(chars) {
      const len = chars.length;
      if (this._cursor.charsLeft() < len) {
        return false;
      }
      const initialPosition = this._cursor.clone();
      for (let i = 0; i < len; i++) {
        if (!this._attemptCharCode(chars.charCodeAt(i))) {
          this._cursor = initialPosition;
          return false;
        }
      }
      return true;
    }
    _attemptStrCaseInsensitive(chars) {
      for (let i = 0; i < chars.length; i++) {
        if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {
          return false;
        }
      }
      return true;
    }
    _requireStr(chars) {
      const location2 = this._cursor.clone();
      if (!this._attemptStr(chars)) {
        throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location2));
      }
    }
    _attemptCharCodeUntilFn(predicate) {
      while (!predicate(this._cursor.peek())) {
        this._cursor.advance();
      }
    }
    _requireCharCodeUntilFn(predicate, len) {
      const start = this._cursor.clone();
      this._attemptCharCodeUntilFn(predicate);
      if (this._cursor.diff(start) < len) {
        throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));
      }
    }
    _attemptUntilChar(char) {
      while (this._cursor.peek() !== char) {
        this._cursor.advance();
      }
    }
    _readChar() {
      const char = String.fromCodePoint(this._cursor.peek());
      this._cursor.advance();
      return char;
    }
    _consumeEntity(textTokenType) {
      this._beginToken(9);
      const start = this._cursor.clone();
      this._cursor.advance();
      if (this._attemptCharCode($HASH)) {
        const isHex = this._attemptCharCode($x) || this._attemptCharCode($X);
        const codeStart = this._cursor.clone();
        this._attemptCharCodeUntilFn(isDigitEntityEnd);
        if (this._cursor.peek() != $SEMICOLON) {
          this._cursor.advance();
          const entityType = isHex ? CharacterReferenceType.HEX : CharacterReferenceType.DEC;
          throw this._createError(_unparsableEntityErrorMsg(entityType, this._cursor.getChars(start)), this._cursor.getSpan());
        }
        const strNum = this._cursor.getChars(codeStart);
        this._cursor.advance();
        try {
          const charCode = parseInt(strNum, isHex ? 16 : 10);
          this._endToken([String.fromCharCode(charCode), this._cursor.getChars(start)]);
        } catch {
          throw this._createError(_unknownEntityErrorMsg(this._cursor.getChars(start)), this._cursor.getSpan());
        }
      } else {
        const nameStart = this._cursor.clone();
        this._attemptCharCodeUntilFn(isNamedEntityEnd);
        if (this._cursor.peek() != $SEMICOLON) {
          this._beginToken(textTokenType, start);
          this._cursor = nameStart;
          this._endToken(["&"]);
        } else {
          const name = this._cursor.getChars(nameStart);
          this._cursor.advance();
          const char = NAMED_ENTITIES[name];
          if (!char) {
            throw this._createError(_unknownEntityErrorMsg(name), this._cursor.getSpan(start));
          }
          this._endToken([char, `&${name};`]);
        }
      }
    }
    _consumeRawText(consumeEntities, endMarkerPredicate) {
      this._beginToken(consumeEntities ? 6 : 7);
      const parts = [];
      while (true) {
        const tagCloseStart = this._cursor.clone();
        const foundEndMarker = endMarkerPredicate();
        this._cursor = tagCloseStart;
        if (foundEndMarker) {
          break;
        }
        if (consumeEntities && this._cursor.peek() === $AMPERSAND) {
          this._endToken([this._processCarriageReturns(parts.join(""))]);
          parts.length = 0;
          this._consumeEntity(6);
          this._beginToken(6);
        } else {
          parts.push(this._readChar());
        }
      }
      this._endToken([this._processCarriageReturns(parts.join(""))]);
    }
    _consumeComment(start) {
      this._beginToken(10, start);
      this._requireCharCode($MINUS);
      this._endToken([]);
      this._consumeRawText(false, () => this._attemptStr("-->"));
      this._beginToken(11);
      this._requireStr("-->");
      this._endToken([]);
    }
    _consumeCdata(start) {
      this._beginToken(12, start);
      this._requireStr("CDATA[");
      this._endToken([]);
      this._consumeRawText(false, () => this._attemptStr("]]>"));
      this._beginToken(13);
      this._requireStr("]]>");
      this._endToken([]);
    }
    _consumeDocType(start) {
      this._beginToken(18, start);
      const contentStart = this._cursor.clone();
      this._attemptUntilChar($GT);
      const content = this._cursor.getChars(contentStart);
      this._cursor.advance();
      this._endToken([content]);
    }
    _consumePrefixAndName() {
      const nameOrPrefixStart = this._cursor.clone();
      let prefix = "";
      while (this._cursor.peek() !== $COLON && !isPrefixEnd(this._cursor.peek())) {
        this._cursor.advance();
      }
      let nameStart;
      if (this._cursor.peek() === $COLON) {
        prefix = this._cursor.getChars(nameOrPrefixStart);
        this._cursor.advance();
        nameStart = this._cursor.clone();
      } else {
        nameStart = nameOrPrefixStart;
      }
      this._requireCharCodeUntilFn(isNameEnd, prefix === "" ? 0 : 1);
      const name = this._cursor.getChars(nameStart);
      return [prefix, name];
    }
    _consumeTagOpen(start) {
      let tagName;
      let prefix;
      let openTagToken;
      try {
        if (!isAsciiLetter(this._cursor.peek())) {
          throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));
        }
        openTagToken = this._consumeTagOpenStart(start);
        prefix = openTagToken.parts[0];
        tagName = openTagToken.parts[1];
        this._attemptCharCodeUntilFn(isNotWhitespace);
        while (this._cursor.peek() !== $SLASH && this._cursor.peek() !== $GT && this._cursor.peek() !== $LT && this._cursor.peek() !== $EOF) {
          this._consumeAttributeName();
          this._attemptCharCodeUntilFn(isNotWhitespace);
          if (this._attemptCharCode($EQ)) {
            this._attemptCharCodeUntilFn(isNotWhitespace);
            this._consumeAttributeValue();
          }
          this._attemptCharCodeUntilFn(isNotWhitespace);
        }
        this._consumeTagOpenEnd();
      } catch (e) {
        if (e instanceof _ControlFlowError) {
          if (openTagToken) {
            openTagToken.type = 4;
          } else {
            this._beginToken(5, start);
            this._endToken(["<"]);
          }
          return;
        }
        throw e;
      }
      const contentTokenType = this._getTagDefinition(tagName).getContentType(prefix);
      if (contentTokenType === TagContentType.RAW_TEXT) {
        this._consumeRawTextWithTagClose(prefix, tagName, false);
      } else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {
        this._consumeRawTextWithTagClose(prefix, tagName, true);
      }
    }
    _consumeRawTextWithTagClose(prefix, tagName, consumeEntities) {
      this._consumeRawText(consumeEntities, () => {
        if (!this._attemptCharCode($LT))
          return false;
        if (!this._attemptCharCode($SLASH))
          return false;
        this._attemptCharCodeUntilFn(isNotWhitespace);
        if (!this._attemptStrCaseInsensitive(tagName))
          return false;
        this._attemptCharCodeUntilFn(isNotWhitespace);
        return this._attemptCharCode($GT);
      });
      this._beginToken(3);
      this._requireCharCodeUntilFn((code) => code === $GT, 3);
      this._cursor.advance();
      this._endToken([prefix, tagName]);
    }
    _consumeTagOpenStart(start) {
      this._beginToken(0, start);
      const parts = this._consumePrefixAndName();
      return this._endToken(parts);
    }
    _consumeAttributeName() {
      const attrNameStart = this._cursor.peek();
      if (attrNameStart === $SQ || attrNameStart === $DQ) {
        throw this._createError(_unexpectedCharacterErrorMsg(attrNameStart), this._cursor.getSpan());
      }
      this._beginToken(14);
      const prefixAndName = this._consumePrefixAndName();
      this._endToken(prefixAndName);
    }
    _consumeAttributeValue() {
      let value;
      if (this._cursor.peek() === $SQ || this._cursor.peek() === $DQ) {
        const quoteChar = this._cursor.peek();
        this._consumeQuote(quoteChar);
        const endPredicate = () => this._cursor.peek() === quoteChar;
        this._consumeWithInterpolation(16, 17, endPredicate, endPredicate);
        this._consumeQuote(quoteChar);
      } else {
        const endPredicate = () => isNameEnd(this._cursor.peek());
        this._consumeWithInterpolation(16, 17, endPredicate, endPredicate);
      }
    }
    _consumeQuote(quoteChar) {
      this._beginToken(15);
      this._requireCharCode(quoteChar);
      this._endToken([String.fromCodePoint(quoteChar)]);
    }
    _consumeTagOpenEnd() {
      const tokenType = this._attemptCharCode($SLASH) ? 2 : 1;
      this._beginToken(tokenType);
      this._requireCharCode($GT);
      this._endToken([]);
    }
    _consumeTagClose(start) {
      this._beginToken(3, start);
      this._attemptCharCodeUntilFn(isNotWhitespace);
      const prefixAndName = this._consumePrefixAndName();
      this._attemptCharCodeUntilFn(isNotWhitespace);
      this._requireCharCode($GT);
      this._endToken(prefixAndName);
    }
    _consumeExpansionFormStart() {
      this._beginToken(19);
      this._requireCharCode($LBRACE);
      this._endToken([]);
      this._expansionCaseStack.push(19);
      this._beginToken(7);
      const condition = this._readUntil($COMMA);
      const normalizedCondition = this._processCarriageReturns(condition);
      if (this._i18nNormalizeLineEndingsInICUs) {
        this._endToken([normalizedCondition]);
      } else {
        const conditionToken = this._endToken([condition]);
        if (normalizedCondition !== condition) {
          this.nonNormalizedIcuExpressions.push(conditionToken);
        }
      }
      this._requireCharCode($COMMA);
      this._attemptCharCodeUntilFn(isNotWhitespace);
      this._beginToken(7);
      const type = this._readUntil($COMMA);
      this._endToken([type]);
      this._requireCharCode($COMMA);
      this._attemptCharCodeUntilFn(isNotWhitespace);
    }
    _consumeExpansionCaseStart() {
      this._beginToken(20);
      const value = this._readUntil($LBRACE).trim();
      this._endToken([value]);
      this._attemptCharCodeUntilFn(isNotWhitespace);
      this._beginToken(21);
      this._requireCharCode($LBRACE);
      this._endToken([]);
      this._attemptCharCodeUntilFn(isNotWhitespace);
      this._expansionCaseStack.push(21);
    }
    _consumeExpansionCaseEnd() {
      this._beginToken(22);
      this._requireCharCode($RBRACE);
      this._endToken([]);
      this._attemptCharCodeUntilFn(isNotWhitespace);
      this._expansionCaseStack.pop();
    }
    _consumeExpansionFormEnd() {
      this._beginToken(23);
      this._requireCharCode($RBRACE);
      this._endToken([]);
      this._expansionCaseStack.pop();
    }
    _consumeWithInterpolation(textTokenType, interpolationTokenType, endPredicate, endInterpolation) {
      this._beginToken(textTokenType);
      const parts = [];
      while (!endPredicate()) {
        const current = this._cursor.clone();
        if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {
          this._endToken([this._processCarriageReturns(parts.join(""))], current);
          parts.length = 0;
          this._consumeInterpolation(interpolationTokenType, current, endInterpolation);
          this._beginToken(textTokenType);
        } else if (this._cursor.peek() === $AMPERSAND) {
          this._endToken([this._processCarriageReturns(parts.join(""))]);
          parts.length = 0;
          this._consumeEntity(textTokenType);
          this._beginToken(textTokenType);
        } else {
          parts.push(this._readChar());
        }
      }
      this._inInterpolation = false;
      this._endToken([this._processCarriageReturns(parts.join(""))]);
    }
    _consumeInterpolation(interpolationTokenType, interpolationStart, prematureEndPredicate) {
      const parts = [];
      this._beginToken(interpolationTokenType, interpolationStart);
      parts.push(this._interpolationConfig.start);
      const expressionStart = this._cursor.clone();
      let inQuote = null;
      let inComment = false;
      while (this._cursor.peek() !== $EOF && (prematureEndPredicate === null || !prematureEndPredicate())) {
        const current = this._cursor.clone();
        if (this._isTagStart()) {
          this._cursor = current;
          parts.push(this._getProcessedChars(expressionStart, current));
          this._endToken(parts);
          return;
        }
        if (inQuote === null) {
          if (this._attemptStr(this._interpolationConfig.end)) {
            parts.push(this._getProcessedChars(expressionStart, current));
            parts.push(this._interpolationConfig.end);
            this._endToken(parts);
            return;
          } else if (this._attemptStr("//")) {
            inComment = true;
          }
        }
        const char = this._cursor.peek();
        this._cursor.advance();
        if (char === $BACKSLASH) {
          this._cursor.advance();
        } else if (char === inQuote) {
          inQuote = null;
        } else if (!inComment && inQuote === null && isQuote(char)) {
          inQuote = char;
        }
      }
      parts.push(this._getProcessedChars(expressionStart, this._cursor));
      this._endToken(parts);
    }
    _getProcessedChars(start, end) {
      return this._processCarriageReturns(end.getChars(start));
    }
    _isTextEnd() {
      if (this._isTagStart() || this._cursor.peek() === $EOF) {
        return true;
      }
      if (this._tokenizeIcu && !this._inInterpolation) {
        if (this.isExpansionFormStart()) {
          return true;
        }
        if (this._cursor.peek() === $RBRACE && this._isInExpansionCase()) {
          return true;
        }
      }
      return false;
    }
    _isTagStart() {
      if (this._cursor.peek() === $LT) {
        const tmp = this._cursor.clone();
        tmp.advance();
        const code = tmp.peek();
        if ($a <= code && code <= $z || $A <= code && code <= $Z || code === $SLASH || code === $BANG) {
          return true;
        }
      }
      return false;
    }
    _readUntil(char) {
      const start = this._cursor.clone();
      this._attemptUntilChar(char);
      return this._cursor.getChars(start);
    }
    _isInExpansionCase() {
      return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 21;
    }
    _isInExpansionForm() {
      return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 19;
    }
    isExpansionFormStart() {
      if (this._cursor.peek() !== $LBRACE) {
        return false;
      }
      if (this._interpolationConfig) {
        const start = this._cursor.clone();
        const isInterpolation = this._attemptStr(this._interpolationConfig.start);
        this._cursor = start;
        return !isInterpolation;
      }
      return true;
    }
  };
  function isNotWhitespace(code) {
    return !isWhitespace(code) || code === $EOF;
  }
  function isNameEnd(code) {
    return isWhitespace(code) || code === $GT || code === $LT || code === $SLASH || code === $SQ || code === $DQ || code === $EQ || code === $EOF;
  }
  function isPrefixEnd(code) {
    return (code < $a || $z < code) && (code < $A || $Z < code) && (code < $0 || code > $9);
  }
  function isDigitEntityEnd(code) {
    return code === $SEMICOLON || code === $EOF || !isAsciiHexDigit(code);
  }
  function isNamedEntityEnd(code) {
    return code === $SEMICOLON || code === $EOF || !isAsciiLetter(code);
  }
  function isExpansionCaseStart(peek) {
    return peek !== $RBRACE;
  }
  function compareCharCodeCaseInsensitive(code1, code2) {
    return toUpperCaseCharCode(code1) === toUpperCaseCharCode(code2);
  }
  function toUpperCaseCharCode(code) {
    return code >= $a && code <= $z ? code - $a + $A : code;
  }
  function mergeTextTokens(srcTokens) {
    const dstTokens = [];
    let lastDstToken = void 0;
    for (let i = 0; i < srcTokens.length; i++) {
      const token = srcTokens[i];
      if (lastDstToken && lastDstToken.type === 5 && token.type === 5 || lastDstToken && lastDstToken.type === 16 && token.type === 16) {
        lastDstToken.parts[0] += token.parts[0];
        lastDstToken.sourceSpan.end = token.sourceSpan.end;
      } else {
        lastDstToken = token;
        dstTokens.push(lastDstToken);
      }
    }
    return dstTokens;
  }
  var PlainCharacterCursor = class {
    constructor(fileOrCursor, range) {
      if (fileOrCursor instanceof PlainCharacterCursor) {
        this.file = fileOrCursor.file;
        this.input = fileOrCursor.input;
        this.end = fileOrCursor.end;
        const state = fileOrCursor.state;
        this.state = {
          peek: state.peek,
          offset: state.offset,
          line: state.line,
          column: state.column
        };
      } else {
        if (!range) {
          throw new Error("Programming error: the range argument must be provided with a file argument.");
        }
        this.file = fileOrCursor;
        this.input = fileOrCursor.content;
        this.end = range.endPos;
        this.state = {
          peek: -1,
          offset: range.startPos,
          line: range.startLine,
          column: range.startCol
        };
      }
    }
    clone() {
      return new PlainCharacterCursor(this);
    }
    peek() {
      return this.state.peek;
    }
    charsLeft() {
      return this.end - this.state.offset;
    }
    diff(other) {
      return this.state.offset - other.state.offset;
    }
    advance() {
      this.advanceState(this.state);
    }
    init() {
      this.updatePeek(this.state);
    }
    getSpan(start, leadingTriviaCodePoints) {
      start = start || this;
      let fullStart = start;
      if (leadingTriviaCodePoints) {
        while (this.diff(start) > 0 && leadingTriviaCodePoints.indexOf(start.peek()) !== -1) {
          if (fullStart === start) {
            start = start.clone();
          }
          start.advance();
        }
      }
      const startLocation = this.locationFromCursor(start);
      const endLocation = this.locationFromCursor(this);
      const fullStartLocation = fullStart !== start ? this.locationFromCursor(fullStart) : startLocation;
      return new ParseSourceSpan(startLocation, endLocation, fullStartLocation);
    }
    getChars(start) {
      return this.input.substring(start.state.offset, this.state.offset);
    }
    charAt(pos) {
      return this.input.charCodeAt(pos);
    }
    advanceState(state) {
      if (state.offset >= this.end) {
        this.state = state;
        throw new CursorError('Unexpected character "EOF"', this);
      }
      const currentChar = this.charAt(state.offset);
      if (currentChar === $LF) {
        state.line++;
        state.column = 0;
      } else if (!isNewLine(currentChar)) {
        state.column++;
      }
      state.offset++;
      this.updatePeek(state);
    }
    updatePeek(state) {
      state.peek = state.offset >= this.end ? $EOF : this.charAt(state.offset);
    }
    locationFromCursor(cursor) {
      return new ParseLocation(cursor.file, cursor.state.offset, cursor.state.line, cursor.state.column);
    }
  };
  var EscapedCharacterCursor = class extends PlainCharacterCursor {
    constructor(fileOrCursor, range) {
      if (fileOrCursor instanceof EscapedCharacterCursor) {
        super(fileOrCursor);
        this.internalState = { ...fileOrCursor.internalState };
      } else {
        super(fileOrCursor, range);
        this.internalState = this.state;
      }
    }
    advance() {
      this.state = this.internalState;
      super.advance();
      this.processEscapeSequence();
    }
    init() {
      super.init();
      this.processEscapeSequence();
    }
    clone() {
      return new EscapedCharacterCursor(this);
    }
    getChars(start) {
      const cursor = start.clone();
      let chars = "";
      while (cursor.internalState.offset < this.internalState.offset) {
        chars += String.fromCodePoint(cursor.peek());
        cursor.advance();
      }
      return chars;
    }
    processEscapeSequence() {
      const peek = () => this.internalState.peek;
      if (peek() === $BACKSLASH) {
        this.internalState = { ...this.state };
        this.advanceState(this.internalState);
        if (peek() === $n) {
          this.state.peek = $LF;
        } else if (peek() === $r) {
          this.state.peek = $CR;
        } else if (peek() === $v) {
          this.state.peek = $VTAB;
        } else if (peek() === $t) {
          this.state.peek = $TAB;
        } else if (peek() === $b) {
          this.state.peek = $BSPACE;
        } else if (peek() === $f) {
          this.state.peek = $FF;
        } else if (peek() === $u) {
          this.advanceState(this.internalState);
          if (peek() === $LBRACE) {
            this.advanceState(this.internalState);
            const digitStart = this.clone();
            let length = 0;
            while (peek() !== $RBRACE) {
              this.advanceState(this.internalState);
              length++;
            }
            this.state.peek = this.decodeHexDigits(digitStart, length);
          } else {
            const digitStart = this.clone();
            this.advanceState(this.internalState);
            this.advanceState(this.internalState);
            this.advanceState(this.internalState);
            this.state.peek = this.decodeHexDigits(digitStart, 4);
          }
        } else if (peek() === $x) {
          this.advanceState(this.internalState);
          const digitStart = this.clone();
          this.advanceState(this.internalState);
          this.state.peek = this.decodeHexDigits(digitStart, 2);
        } else if (isOctalDigit(peek())) {
          let octal = "";
          let length = 0;
          let previous = this.clone();
          while (isOctalDigit(peek()) && length < 3) {
            previous = this.clone();
            octal += String.fromCodePoint(peek());
            this.advanceState(this.internalState);
            length++;
          }
          this.state.peek = parseInt(octal, 8);
          this.internalState = previous.internalState;
        } else if (isNewLine(this.internalState.peek)) {
          this.advanceState(this.internalState);
          this.state = this.internalState;
        } else {
          this.state.peek = this.internalState.peek;
        }
      }
    }
    decodeHexDigits(start, length) {
      const hex = this.input.substr(start.internalState.offset, length);
      const charCode = parseInt(hex, 16);
      if (!isNaN(charCode)) {
        return charCode;
      } else {
        start.state = start.internalState;
        throw new CursorError("Invalid hexadecimal escape sequence", start);
      }
    }
  };
  var CursorError = class {
    constructor(msg, cursor) {
      this.msg = msg;
      this.cursor = cursor;
    }
  };
  var TreeError = class extends ParseError {
    constructor(elementName, span, msg) {
      super(span, msg);
      this.elementName = elementName;
    }
    static create(elementName, span, msg) {
      return new TreeError(elementName, span, msg);
    }
  };
  var ParseTreeResult = class {
    constructor(rootNodes, errors) {
      this.rootNodes = rootNodes;
      this.errors = errors;
    }
  };
  var Parser$1 = class {
    constructor(getTagDefinition) {
      this.getTagDefinition = getTagDefinition;
    }
    parse(source, url, options) {
      const tokenizeResult = tokenize(source, url, this.getTagDefinition, options);
      const parser = new _TreeBuilder(tokenizeResult.tokens, this.getTagDefinition);
      parser.build();
      return new ParseTreeResult(parser.rootNodes, tokenizeResult.errors.concat(parser.errors));
    }
  };
  var _TreeBuilder = class {
    constructor(tokens, getTagDefinition) {
      this.tokens = tokens;
      this.getTagDefinition = getTagDefinition;
      this._index = -1;
      this._elementStack = [];
      this.rootNodes = [];
      this.errors = [];
      this._advance();
    }
    build() {
      while (this._peek.type !== 24) {
        if (this._peek.type === 0 || this._peek.type === 4) {
          this._consumeStartTag(this._advance());
        } else if (this._peek.type === 3) {
          this._consumeEndTag(this._advance());
        } else if (this._peek.type === 12) {
          this._closeVoidElement();
          this._consumeCdata(this._advance());
        } else if (this._peek.type === 10) {
          this._closeVoidElement();
          this._consumeComment(this._advance());
        } else if (this._peek.type === 5 || this._peek.type === 7 || this._peek.type === 6) {
          this._closeVoidElement();
          this._consumeText(this._advance());
        } else if (this._peek.type === 19) {
          this._consumeExpansion(this._advance());
        } else {
          this._advance();
        }
      }
    }
    _advance() {
      const prev = this._peek;
      if (this._index < this.tokens.length - 1) {
        this._index++;
      }
      this._peek = this.tokens[this._index];
      return prev;
    }
    _advanceIf(type) {
      if (this._peek.type === type) {
        return this._advance();
      }
      return null;
    }
    _consumeCdata(_startToken) {
      this._consumeText(this._advance());
      this._advanceIf(13);
    }
    _consumeComment(token) {
      const text = this._advanceIf(7);
      this._advanceIf(11);
      const value = text != null ? text.parts[0].trim() : null;
      this._addToParent(new Comment(value, token.sourceSpan));
    }
    _consumeExpansion(token) {
      const switchValue = this._advance();
      const type = this._advance();
      const cases = [];
      while (this._peek.type === 20) {
        const expCase = this._parseExpansionCase();
        if (!expCase)
          return;
        cases.push(expCase);
      }
      if (this._peek.type !== 23) {
        this.errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '}'.`));
        return;
      }
      const sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end, token.sourceSpan.fullStart);
      this._addToParent(new Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));
      this._advance();
    }
    _parseExpansionCase() {
      const value = this._advance();
      if (this._peek.type !== 21) {
        this.errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '{'.`));
        return null;
      }
      const start = this._advance();
      const exp = this._collectExpansionExpTokens(start);
      if (!exp)
        return null;
      const end = this._advance();
      exp.push({ type: 24, parts: [], sourceSpan: end.sourceSpan });
      const expansionCaseParser = new _TreeBuilder(exp, this.getTagDefinition);
      expansionCaseParser.build();
      if (expansionCaseParser.errors.length > 0) {
        this.errors = this.errors.concat(expansionCaseParser.errors);
        return null;
      }
      const sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end, value.sourceSpan.fullStart);
      const expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end, start.sourceSpan.fullStart);
      return new ExpansionCase(value.parts[0], expansionCaseParser.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);
    }
    _collectExpansionExpTokens(start) {
      const exp = [];
      const expansionFormStack = [21];
      while (true) {
        if (this._peek.type === 19 || this._peek.type === 21) {
          expansionFormStack.push(this._peek.type);
        }
        if (this._peek.type === 22) {
          if (lastOnStack(expansionFormStack, 21)) {
            expansionFormStack.pop();
            if (expansionFormStack.length === 0)
              return exp;
          } else {
            this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));
            return null;
          }
        }
        if (this._peek.type === 23) {
          if (lastOnStack(expansionFormStack, 19)) {
            expansionFormStack.pop();
          } else {
            this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));
            return null;
          }
        }
        if (this._peek.type === 24) {
          this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));
          return null;
        }
        exp.push(this._advance());
      }
    }
    _consumeText(token) {
      const tokens = [token];
      const startSpan = token.sourceSpan;
      let text = token.parts[0];
      if (text.length > 0 && text[0] === "\n") {
        const parent = this._getParentElement();
        if (parent != null && parent.children.length === 0 && this.getTagDefinition(parent.name).ignoreFirstLf) {
          text = text.substring(1);
          tokens[0] = { type: token.type, sourceSpan: token.sourceSpan, parts: [text] };
        }
      }
      while (this._peek.type === 8 || this._peek.type === 5 || this._peek.type === 9) {
        token = this._advance();
        tokens.push(token);
        if (token.type === 8) {
          text += token.parts.join("").replace(/&([^;]+);/g, decodeEntity);
        } else if (token.type === 9) {
          text += token.parts[0];
        } else {
          text += token.parts.join("");
        }
      }
      if (text.length > 0) {
        const endSpan = token.sourceSpan;
        this._addToParent(new Text2(text, new ParseSourceSpan(startSpan.start, endSpan.end, startSpan.fullStart, startSpan.details), tokens));
      }
    }
    _closeVoidElement() {
      const el = this._getParentElement();
      if (el && this.getTagDefinition(el.name).isVoid) {
        this._elementStack.pop();
      }
    }
    _consumeStartTag(startTagToken) {
      const [prefix, name] = startTagToken.parts;
      const attrs = [];
      while (this._peek.type === 14) {
        attrs.push(this._consumeAttr(this._advance()));
      }
      const fullName = this._getElementFullName(prefix, name, this._getParentElement());
      let selfClosing = false;
      if (this._peek.type === 2) {
        this._advance();
        selfClosing = true;
        const tagDef = this.getTagDefinition(fullName);
        if (!(tagDef.canSelfClose || getNsPrefix(fullName) !== null || tagDef.isVoid)) {
          this.errors.push(TreeError.create(fullName, startTagToken.sourceSpan, `Only void and foreign elements can be self closed "${startTagToken.parts[1]}"`));
        }
      } else if (this._peek.type === 1) {
        this._advance();
        selfClosing = false;
      }
      const end = this._peek.sourceSpan.fullStart;
      const span = new ParseSourceSpan(startTagToken.sourceSpan.start, end, startTagToken.sourceSpan.fullStart);
      const startSpan = new ParseSourceSpan(startTagToken.sourceSpan.start, end, startTagToken.sourceSpan.fullStart);
      const el = new Element2(fullName, attrs, [], span, startSpan, void 0);
      this._pushElement(el);
      if (selfClosing) {
        this._popElement(fullName, span);
      } else if (startTagToken.type === 4) {
        this._popElement(fullName, null);
        this.errors.push(TreeError.create(fullName, span, `Opening tag "${fullName}" not terminated.`));
      }
    }
    _pushElement(el) {
      const parentEl = this._getParentElement();
      if (parentEl && this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {
        this._elementStack.pop();
      }
      this._addToParent(el);
      this._elementStack.push(el);
    }
    _consumeEndTag(endTagToken) {
      const fullName = this._getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());
      if (this.getTagDefinition(fullName).isVoid) {
        this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, `Void elements do not have end tags "${endTagToken.parts[1]}"`));
      } else if (!this._popElement(fullName, endTagToken.sourceSpan)) {
        const errMsg = `Unexpected closing tag "${fullName}". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;
        this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));
      }
    }
    _popElement(fullName, endSourceSpan) {
      let unexpectedCloseTagDetected = false;
      for (let stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {
        const el = this._elementStack[stackIndex];
        if (el.name === fullName) {
          el.endSourceSpan = endSourceSpan;
          el.sourceSpan.end = endSourceSpan !== null ? endSourceSpan.end : el.sourceSpan.end;
          this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);
          return !unexpectedCloseTagDetected;
        }
        if (!this.getTagDefinition(el.name).closedByParent) {
          unexpectedCloseTagDetected = true;
        }
      }
      return false;
    }
    _consumeAttr(attrName) {
      const fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);
      let attrEnd = attrName.sourceSpan.end;
      if (this._peek.type === 15) {
        this._advance();
      }
      let value = "";
      const valueTokens = [];
      let valueStartSpan = void 0;
      let valueEnd = void 0;
      const nextTokenType = this._peek.type;
      if (nextTokenType === 16) {
        valueStartSpan = this._peek.sourceSpan;
        valueEnd = this._peek.sourceSpan.end;
        while (this._peek.type === 16 || this._peek.type === 17 || this._peek.type === 9) {
          const valueToken = this._advance();
          valueTokens.push(valueToken);
          if (valueToken.type === 17) {
            value += valueToken.parts.join("").replace(/&([^;]+);/g, decodeEntity);
          } else if (valueToken.type === 9) {
            value += valueToken.parts[0];
          } else {
            value += valueToken.parts.join("");
          }
          valueEnd = attrEnd = valueToken.sourceSpan.end;
        }
      }
      if (this._peek.type === 15) {
        const quoteToken = this._advance();
        attrEnd = quoteToken.sourceSpan.end;
      }
      const valueSpan = valueStartSpan && valueEnd && new ParseSourceSpan(valueStartSpan.start, valueEnd, valueStartSpan.fullStart);
      return new Attribute2(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, attrEnd, attrName.sourceSpan.fullStart), attrName.sourceSpan, valueSpan, valueTokens.length > 0 ? valueTokens : void 0, void 0);
    }
    _getParentElement() {
      return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;
    }
    _addToParent(node) {
      const parent = this._getParentElement();
      if (parent != null) {
        parent.children.push(node);
      } else {
        this.rootNodes.push(node);
      }
    }
    _getElementFullName(prefix, localName, parentElement) {
      if (prefix === "") {
        prefix = this.getTagDefinition(localName).implicitNamespacePrefix || "";
        if (prefix === "" && parentElement != null) {
          const parentTagName = splitNsName(parentElement.name)[1];
          const parentTagDefinition = this.getTagDefinition(parentTagName);
          if (!parentTagDefinition.preventNamespaceInheritance) {
            prefix = getNsPrefix(parentElement.name);
          }
        }
      }
      return mergeNsAndName(prefix, localName);
    }
  };
  function lastOnStack(stack, element) {
    return stack.length > 0 && stack[stack.length - 1] === element;
  }
  function decodeEntity(match2, entity) {
    if (NAMED_ENTITIES[entity] !== void 0) {
      return NAMED_ENTITIES[entity] || match2;
    }
    if (/^#x[a-f0-9]+$/i.test(entity)) {
      return String.fromCodePoint(parseInt(entity.slice(2), 16));
    }
    if (/^#\d+$/.test(entity)) {
      return String.fromCodePoint(parseInt(entity.slice(1), 10));
    }
    return match2;
  }
  var PRESERVE_WS_ATTR_NAME = "ngPreserveWhitespaces";
  var SKIP_WS_TRIM_TAGS = /* @__PURE__ */ new Set(["pre", "template", "textarea", "script", "style"]);
  var WS_CHARS = " \f\n\r	\v\u1680\u180E\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF";
  var NO_WS_REGEXP = new RegExp(`[^${WS_CHARS}]`);
  var WS_REPLACE_REGEXP = new RegExp(`[${WS_CHARS}]{2,}`, "g");
  function hasPreserveWhitespacesAttr(attrs) {
    return attrs.some((attr) => attr.name === PRESERVE_WS_ATTR_NAME);
  }
  function replaceNgsp2(value) {
    return value.replace(new RegExp(NGSP_UNICODE, "g"), " ");
  }
  var WhitespaceVisitor = class {
    visitElement(element, context2) {
      if (SKIP_WS_TRIM_TAGS.has(element.name) || hasPreserveWhitespacesAttr(element.attrs)) {
        return new Element2(element.name, visitAll(this, element.attrs), element.children, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
      }
      return new Element2(element.name, element.attrs, visitAllWithSiblings(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
    }
    visitAttribute(attribute, context2) {
      return attribute.name !== PRESERVE_WS_ATTR_NAME ? attribute : null;
    }
    visitText(text, context2) {
      const isNotBlank = text.value.match(NO_WS_REGEXP);
      const hasExpansionSibling = context2 && (context2.prev instanceof Expansion || context2.next instanceof Expansion);
      if (isNotBlank || hasExpansionSibling) {
        const tokens = text.tokens.map((token) => token.type === 5 ? createWhitespaceProcessedTextToken(token) : token);
        const value = processWhitespace(text.value);
        return new Text2(value, text.sourceSpan, tokens, text.i18n);
      }
      return null;
    }
    visitComment(comment, context2) {
      return comment;
    }
    visitExpansion(expansion, context2) {
      return expansion;
    }
    visitExpansionCase(expansionCase, context2) {
      return expansionCase;
    }
  };
  function createWhitespaceProcessedTextToken({ type, parts, sourceSpan }) {
    return { type, parts: [processWhitespace(parts[0])], sourceSpan };
  }
  function processWhitespace(text) {
    return replaceNgsp2(text).replace(WS_REPLACE_REGEXP, " ");
  }
  function visitAllWithSiblings(visitor, nodes) {
    const result = [];
    nodes.forEach((ast, i) => {
      const context2 = { prev: nodes[i - 1], next: nodes[i + 1] };
      const astResult = ast.visit(visitor, context2);
      if (astResult) {
        result.push(astResult);
      }
    });
    return result;
  }
  var TextAst = class {
    constructor(value, ngContentIndex, sourceSpan) {
      this.value = value;
      this.ngContentIndex = ngContentIndex;
      this.sourceSpan = sourceSpan;
    }
    visit(visitor, context2) {
      return visitor.visitText(this, context2);
    }
  };
  var AttrAst = class {
    constructor(name, value, sourceSpan) {
      this.name = name;
      this.value = value;
      this.sourceSpan = sourceSpan;
    }
    visit(visitor, context2) {
      return visitor.visitAttr(this, context2);
    }
  };
  var BoundPropertyMapping = {
    [4]: 4,
    [1]: 1,
    [2]: 2,
    [0]: 0,
    [3]: 3
  };
  var ElementAst = class {
    constructor(name, attrs, inputs, outputs, references, directives, providers, hasViewContainer, queryMatches, children, ngContentIndex, sourceSpan, endSourceSpan) {
      this.name = name;
      this.attrs = attrs;
      this.inputs = inputs;
      this.outputs = outputs;
      this.references = references;
      this.directives = directives;
      this.providers = providers;
      this.hasViewContainer = hasViewContainer;
      this.queryMatches = queryMatches;
      this.children = children;
      this.ngContentIndex = ngContentIndex;
      this.sourceSpan = sourceSpan;
      this.endSourceSpan = endSourceSpan;
    }
    visit(visitor, context2) {
      return visitor.visitElement(this, context2);
    }
  };
  var ProviderAstType;
  (function(ProviderAstType2) {
    ProviderAstType2[ProviderAstType2["PublicService"] = 0] = "PublicService";
    ProviderAstType2[ProviderAstType2["PrivateService"] = 1] = "PrivateService";
    ProviderAstType2[ProviderAstType2["Component"] = 2] = "Component";
    ProviderAstType2[ProviderAstType2["Directive"] = 3] = "Directive";
    ProviderAstType2[ProviderAstType2["Builtin"] = 4] = "Builtin";
  })(ProviderAstType || (ProviderAstType = {}));
  function isStyleUrlResolvable(url) {
    if (url == null || url.length === 0 || url[0] == "/")
      return false;
    const schemeMatch = url.match(URL_WITH_SCHEMA_REGEXP);
    return schemeMatch === null || schemeMatch[1] == "package" || schemeMatch[1] == "asset";
  }
  var URL_WITH_SCHEMA_REGEXP = /^([^:/?#]+):/;
  var PROPERTY_PARTS_SEPARATOR = ".";
  var ATTRIBUTE_PREFIX = "attr";
  var CLASS_PREFIX = "class";
  var STYLE_PREFIX = "style";
  var TEMPLATE_ATTR_PREFIX$2 = "*";
  var ANIMATE_PROP_PREFIX = "animate-";
  var BindingParser = class {
    constructor(_exprParser, _interpolationConfig, _schemaRegistry, pipes, errors) {
      this._exprParser = _exprParser;
      this._interpolationConfig = _interpolationConfig;
      this._schemaRegistry = _schemaRegistry;
      this.errors = errors;
      this.pipesByName = null;
      this._usedPipes = /* @__PURE__ */ new Map();
      if (pipes) {
        const pipesByName = /* @__PURE__ */ new Map();
        pipes.forEach((pipe) => pipesByName.set(pipe.name, pipe));
        this.pipesByName = pipesByName;
      }
    }
    get interpolationConfig() {
      return this._interpolationConfig;
    }
    getUsedPipes() {
      return Array.from(this._usedPipes.values());
    }
    createBoundHostProperties(dirMeta, sourceSpan) {
      if (dirMeta.hostProperties) {
        const boundProps = [];
        Object.keys(dirMeta.hostProperties).forEach((propName) => {
          const expression = dirMeta.hostProperties[propName];
          if (typeof expression === "string") {
            this.parsePropertyBinding(propName, expression, true, sourceSpan, sourceSpan.start.offset, void 0, [], boundProps, sourceSpan);
          } else {
            this._reportError(`Value of the host property binding "${propName}" needs to be a string representing an expression but got "${expression}" (${typeof expression})`, sourceSpan);
          }
        });
        return boundProps;
      }
      return null;
    }
    createDirectiveHostPropertyAsts(dirMeta, elementSelector, sourceSpan) {
      const boundProps = this.createBoundHostProperties(dirMeta, sourceSpan);
      return boundProps && boundProps.map((prop) => this.createBoundElementProperty(elementSelector, prop));
    }
    createDirectiveHostEventAsts(dirMeta, sourceSpan) {
      if (dirMeta.hostListeners) {
        const targetEvents = [];
        Object.keys(dirMeta.hostListeners).forEach((propName) => {
          const expression = dirMeta.hostListeners[propName];
          if (typeof expression === "string") {
            this.parseEvent(propName, expression, sourceSpan, sourceSpan, [], targetEvents, sourceSpan);
          } else {
            this._reportError(`Value of the host listener "${propName}" needs to be a string representing an expression but got "${expression}" (${typeof expression})`, sourceSpan);
          }
        });
        return targetEvents;
      }
      return null;
    }
    parseInterpolation(value, sourceSpan) {
      const sourceInfo = sourceSpan.start.toString();
      const absoluteOffset = sourceSpan.fullStart.offset;
      try {
        const ast = this._exprParser.parseInterpolation(value, sourceInfo, absoluteOffset, this._interpolationConfig);
        if (ast)
          this._reportExpressionParserErrors(ast.errors, sourceSpan);
        this._checkPipes(ast, sourceSpan);
        return ast;
      } catch (e) {
        this._reportError(`${e}`, sourceSpan);
        return this._exprParser.wrapLiteralPrimitive("ERROR", sourceInfo, absoluteOffset);
      }
    }
    parseInterpolationExpression(expression, sourceSpan) {
      const sourceInfo = sourceSpan.start.toString();
      const absoluteOffset = sourceSpan.start.offset;
      try {
        const ast = this._exprParser.parseInterpolationExpression(expression, sourceInfo, absoluteOffset);
        if (ast)
          this._reportExpressionParserErrors(ast.errors, sourceSpan);
        this._checkPipes(ast, sourceSpan);
        return ast;
      } catch (e) {
        this._reportError(`${e}`, sourceSpan);
        return this._exprParser.wrapLiteralPrimitive("ERROR", sourceInfo, absoluteOffset);
      }
    }
    parseInlineTemplateBinding(tplKey, tplValue, sourceSpan, absoluteValueOffset, targetMatchableAttrs, targetProps, targetVars, isIvyAst) {
      const absoluteKeyOffset = sourceSpan.start.offset + TEMPLATE_ATTR_PREFIX$2.length;
      const bindings = this._parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset);
      for (const binding of bindings) {
        const bindingSpan = moveParseSourceSpan(sourceSpan, binding.sourceSpan);
        const key = binding.key.source;
        const keySpan = moveParseSourceSpan(sourceSpan, binding.key.span);
        if (binding instanceof VariableBinding) {
          const value = binding.value ? binding.value.source : "$implicit";
          const valueSpan = binding.value ? moveParseSourceSpan(sourceSpan, binding.value.span) : void 0;
          targetVars.push(new ParsedVariable(key, value, bindingSpan, keySpan, valueSpan));
        } else if (binding.value) {
          const srcSpan = isIvyAst ? bindingSpan : sourceSpan;
          const valueSpan = moveParseSourceSpan(sourceSpan, binding.value.ast.sourceSpan);
          this._parsePropertyAst(key, binding.value, srcSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);
        } else {
          targetMatchableAttrs.push([key, ""]);
          this.parseLiteralAttr(key, null, keySpan, absoluteValueOffset, void 0, targetMatchableAttrs, targetProps, keySpan);
        }
      }
    }
    _parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset) {
      const sourceInfo = sourceSpan.start.toString();
      try {
        const bindingsResult = this._exprParser.parseTemplateBindings(tplKey, tplValue, sourceInfo, absoluteKeyOffset, absoluteValueOffset);
        this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);
        bindingsResult.templateBindings.forEach((binding) => {
          if (binding.value instanceof ASTWithSource) {
            this._checkPipes(binding.value, sourceSpan);
          }
        });
        bindingsResult.warnings.forEach((warning) => {
          this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING);
        });
        return bindingsResult.templateBindings;
      } catch (e) {
        this._reportError(`${e}`, sourceSpan);
        return [];
      }
    }
    parseLiteralAttr(name, value, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps, keySpan) {
      if (isAnimationLabel(name)) {
        name = name.substring(1);
        if (keySpan !== void 0) {
          keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));
        }
        if (value) {
          this._reportError(`Assigning animation triggers via @prop="exp" attributes with an expression is invalid. Use property bindings (e.g. [@prop]="exp") or use an attribute without a value (e.g. @prop) instead.`, sourceSpan, ParseErrorLevel.ERROR);
        }
        this._parseAnimation(name, value, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps);
      } else {
        targetProps.push(new ParsedProperty(name, this._exprParser.wrapLiteralPrimitive(value, "", absoluteOffset), ParsedPropertyType.LITERAL_ATTR, sourceSpan, keySpan, valueSpan));
      }
    }
    parsePropertyBinding(name, expression, isHost, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps, keySpan) {
      if (name.length === 0) {
        this._reportError(`Property name is missing in binding`, sourceSpan);
      }
      let isAnimationProp2 = false;
      if (name.startsWith(ANIMATE_PROP_PREFIX)) {
        isAnimationProp2 = true;
        name = name.substring(ANIMATE_PROP_PREFIX.length);
        if (keySpan !== void 0) {
          keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + ANIMATE_PROP_PREFIX.length, keySpan.end.offset));
        }
      } else if (isAnimationLabel(name)) {
        isAnimationProp2 = true;
        name = name.substring(1);
        if (keySpan !== void 0) {
          keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));
        }
      }
      if (isAnimationProp2) {
        this._parseAnimation(name, expression, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps);
      } else {
        this._parsePropertyAst(name, this._parseBinding(expression, isHost, valueSpan || sourceSpan, absoluteOffset), sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);
      }
    }
    parsePropertyInterpolation(name, value, sourceSpan, valueSpan, targetMatchableAttrs, targetProps, keySpan) {
      const expr = this.parseInterpolation(value, valueSpan || sourceSpan);
      if (expr) {
        this._parsePropertyAst(name, expr, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);
        return true;
      }
      return false;
    }
    _parsePropertyAst(name, ast, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps) {
      targetMatchableAttrs.push([name, ast.source]);
      targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.DEFAULT, sourceSpan, keySpan, valueSpan));
    }
    _parseAnimation(name, expression, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps) {
      if (name.length === 0) {
        this._reportError("Animation trigger is missing", sourceSpan);
      }
      const ast = this._parseBinding(expression || "undefined", false, valueSpan || sourceSpan, absoluteOffset);
      targetMatchableAttrs.push([name, ast.source]);
      targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.ANIMATION, sourceSpan, keySpan, valueSpan));
    }
    _parseBinding(value, isHostBinding2, sourceSpan, absoluteOffset) {
      const sourceInfo = (sourceSpan && sourceSpan.start || "(unknown)").toString();
      try {
        const ast = isHostBinding2 ? this._exprParser.parseSimpleBinding(value, sourceInfo, absoluteOffset, this._interpolationConfig) : this._exprParser.parseBinding(value, sourceInfo, absoluteOffset, this._interpolationConfig);
        if (ast)
          this._reportExpressionParserErrors(ast.errors, sourceSpan);
        this._checkPipes(ast, sourceSpan);
        return ast;
      } catch (e) {
        this._reportError(`${e}`, sourceSpan);
        return this._exprParser.wrapLiteralPrimitive("ERROR", sourceInfo, absoluteOffset);
      }
    }
    createBoundElementProperty(elementSelector, boundProp, skipValidation = false, mapPropertyName = true) {
      if (boundProp.isAnimation) {
        return new BoundElementProperty(boundProp.name, 4, SecurityContext2.NONE, boundProp.expression, null, boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);
      }
      let unit = null;
      let bindingType = void 0;
      let boundPropertyName = null;
      const parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);
      let securityContexts = void 0;
      if (parts.length > 1) {
        if (parts[0] == ATTRIBUTE_PREFIX) {
          boundPropertyName = parts.slice(1).join(PROPERTY_PARTS_SEPARATOR);
          if (!skipValidation) {
            this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);
          }
          securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, true);
          const nsSeparatorIdx = boundPropertyName.indexOf(":");
          if (nsSeparatorIdx > -1) {
            const ns = boundPropertyName.substring(0, nsSeparatorIdx);
            const name = boundPropertyName.substring(nsSeparatorIdx + 1);
            boundPropertyName = mergeNsAndName(ns, name);
          }
          bindingType = 1;
        } else if (parts[0] == CLASS_PREFIX) {
          boundPropertyName = parts[1];
          bindingType = 2;
          securityContexts = [SecurityContext2.NONE];
        } else if (parts[0] == STYLE_PREFIX) {
          unit = parts.length > 2 ? parts[2] : null;
          boundPropertyName = parts[1];
          bindingType = 3;
          securityContexts = [SecurityContext2.STYLE];
        }
      }
      if (boundPropertyName === null) {
        const mappedPropName = this._schemaRegistry.getMappedPropName(boundProp.name);
        boundPropertyName = mapPropertyName ? mappedPropName : boundProp.name;
        securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, mappedPropName, false);
        bindingType = 0;
        if (!skipValidation) {
          this._validatePropertyOrAttributeName(mappedPropName, boundProp.sourceSpan, false);
        }
      }
      return new BoundElementProperty(boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit, boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);
    }
    parseEvent(name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan) {
      if (name.length === 0) {
        this._reportError(`Event name is missing in binding`, sourceSpan);
      }
      if (isAnimationLabel(name)) {
        name = name.substr(1);
        if (keySpan !== void 0) {
          keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));
        }
        this._parseAnimationEvent(name, expression, sourceSpan, handlerSpan, targetEvents, keySpan);
      } else {
        this._parseRegularEvent(name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan);
      }
    }
    calcPossibleSecurityContexts(selector, propName, isAttribute) {
      const prop = this._schemaRegistry.getMappedPropName(propName);
      return calcPossibleSecurityContexts(this._schemaRegistry, selector, prop, isAttribute);
    }
    _parseAnimationEvent(name, expression, sourceSpan, handlerSpan, targetEvents, keySpan) {
      const matches = splitAtPeriod(name, [name, ""]);
      const eventName = matches[0];
      const phase = matches[1].toLowerCase();
      const ast = this._parseAction(expression, handlerSpan);
      targetEvents.push(new ParsedEvent(eventName, phase, 1, ast, sourceSpan, handlerSpan, keySpan));
      if (eventName.length === 0) {
        this._reportError(`Animation event name is missing in binding`, sourceSpan);
      }
      if (phase) {
        if (phase !== "start" && phase !== "done") {
          this._reportError(`The provided animation output phase value "${phase}" for "@${eventName}" is not supported (use start or done)`, sourceSpan);
        }
      } else {
        this._reportError(`The animation trigger output event (@${eventName}) is missing its phase value name (start or done are currently supported)`, sourceSpan);
      }
    }
    _parseRegularEvent(name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan) {
      const [target, eventName] = splitAtColon(name, [null, name]);
      const ast = this._parseAction(expression, handlerSpan);
      targetMatchableAttrs.push([name, ast.source]);
      targetEvents.push(new ParsedEvent(eventName, target, 0, ast, sourceSpan, handlerSpan, keySpan));
    }
    _parseAction(value, sourceSpan) {
      const sourceInfo = (sourceSpan && sourceSpan.start || "(unknown").toString();
      const absoluteOffset = sourceSpan && sourceSpan.start ? sourceSpan.start.offset : 0;
      try {
        const ast = this._exprParser.parseAction(value, sourceInfo, absoluteOffset, this._interpolationConfig);
        if (ast) {
          this._reportExpressionParserErrors(ast.errors, sourceSpan);
        }
        if (!ast || ast.ast instanceof EmptyExpr) {
          this._reportError(`Empty expressions are not allowed`, sourceSpan);
          return this._exprParser.wrapLiteralPrimitive("ERROR", sourceInfo, absoluteOffset);
        }
        this._checkPipes(ast, sourceSpan);
        return ast;
      } catch (e) {
        this._reportError(`${e}`, sourceSpan);
        return this._exprParser.wrapLiteralPrimitive("ERROR", sourceInfo, absoluteOffset);
      }
    }
    _reportError(message, sourceSpan, level = ParseErrorLevel.ERROR) {
      this.errors.push(new ParseError(sourceSpan, message, level));
    }
    _reportExpressionParserErrors(errors, sourceSpan) {
      for (const error3 of errors) {
        this._reportError(error3.message, sourceSpan);
      }
    }
    _checkPipes(ast, sourceSpan) {
      if (ast && this.pipesByName) {
        const collector = new PipeCollector();
        ast.visit(collector);
        collector.pipes.forEach((ast2, pipeName) => {
          const pipeMeta = this.pipesByName.get(pipeName);
          if (!pipeMeta) {
            this._reportError(`The pipe '${pipeName}' could not be found`, new ParseSourceSpan(sourceSpan.start.moveBy(ast2.span.start), sourceSpan.start.moveBy(ast2.span.end)));
          } else {
            this._usedPipes.set(pipeName, pipeMeta);
          }
        });
      }
    }
    _validatePropertyOrAttributeName(propName, sourceSpan, isAttr) {
      const report = isAttr ? this._schemaRegistry.validateAttribute(propName) : this._schemaRegistry.validateProperty(propName);
      if (report.error) {
        this._reportError(report.msg, sourceSpan, ParseErrorLevel.ERROR);
      }
    }
  };
  var PipeCollector = class extends RecursiveAstVisitor {
    constructor() {
      super(...arguments);
      this.pipes = /* @__PURE__ */ new Map();
    }
    visitPipe(ast, context2) {
      this.pipes.set(ast.name, ast);
      ast.exp.visit(this);
      this.visitAll(ast.args, context2);
      return null;
    }
  };
  function isAnimationLabel(name) {
    return name[0] == "@";
  }
  function calcPossibleSecurityContexts(registry, selector, propName, isAttribute) {
    const ctxs = [];
    CssSelector.parse(selector).forEach((selector2) => {
      const elementNames = selector2.element ? [selector2.element] : registry.allKnownElementNames();
      const notElementNames = new Set(selector2.notSelectors.filter((selector3) => selector3.isElementSelector()).map((selector3) => selector3.element));
      const possibleElementNames = elementNames.filter((elementName) => !notElementNames.has(elementName));
      ctxs.push(...possibleElementNames.map((elementName) => registry.securityContext(elementName, propName, isAttribute)));
    });
    return ctxs.length === 0 ? [SecurityContext2.NONE] : Array.from(new Set(ctxs)).sort();
  }
  function moveParseSourceSpan(sourceSpan, absoluteSpan) {
    const startDiff = absoluteSpan.start - sourceSpan.start.offset;
    const endDiff = absoluteSpan.end - sourceSpan.end.offset;
    return new ParseSourceSpan(sourceSpan.start.moveBy(startDiff), sourceSpan.end.moveBy(endDiff), sourceSpan.fullStart.moveBy(startDiff), sourceSpan.details);
  }
  var NG_CONTENT_SELECT_ATTR$1 = "select";
  var LINK_ELEMENT = "link";
  var LINK_STYLE_REL_ATTR = "rel";
  var LINK_STYLE_HREF_ATTR = "href";
  var LINK_STYLE_REL_VALUE = "stylesheet";
  var STYLE_ELEMENT = "style";
  var SCRIPT_ELEMENT = "script";
  var NG_NON_BINDABLE_ATTR = "ngNonBindable";
  var NG_PROJECT_AS = "ngProjectAs";
  function preparseElement(ast) {
    let selectAttr = null;
    let hrefAttr = null;
    let relAttr = null;
    let nonBindable = false;
    let projectAs = "";
    ast.attrs.forEach((attr) => {
      const lcAttrName = attr.name.toLowerCase();
      if (lcAttrName == NG_CONTENT_SELECT_ATTR$1) {
        selectAttr = attr.value;
      } else if (lcAttrName == LINK_STYLE_HREF_ATTR) {
        hrefAttr = attr.value;
      } else if (lcAttrName == LINK_STYLE_REL_ATTR) {
        relAttr = attr.value;
      } else if (attr.name == NG_NON_BINDABLE_ATTR) {
        nonBindable = true;
      } else if (attr.name == NG_PROJECT_AS) {
        if (attr.value.length > 0) {
          projectAs = attr.value;
        }
      }
    });
    selectAttr = normalizeNgContentSelect(selectAttr);
    const nodeName = ast.name.toLowerCase();
    let type = PreparsedElementType.OTHER;
    if (isNgContent(nodeName)) {
      type = PreparsedElementType.NG_CONTENT;
    } else if (nodeName == STYLE_ELEMENT) {
      type = PreparsedElementType.STYLE;
    } else if (nodeName == SCRIPT_ELEMENT) {
      type = PreparsedElementType.SCRIPT;
    } else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {
      type = PreparsedElementType.STYLESHEET;
    }
    return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);
  }
  var PreparsedElementType;
  (function(PreparsedElementType2) {
    PreparsedElementType2[PreparsedElementType2["NG_CONTENT"] = 0] = "NG_CONTENT";
    PreparsedElementType2[PreparsedElementType2["STYLE"] = 1] = "STYLE";
    PreparsedElementType2[PreparsedElementType2["STYLESHEET"] = 2] = "STYLESHEET";
    PreparsedElementType2[PreparsedElementType2["SCRIPT"] = 3] = "SCRIPT";
    PreparsedElementType2[PreparsedElementType2["OTHER"] = 4] = "OTHER";
  })(PreparsedElementType || (PreparsedElementType = {}));
  var PreparsedElement = class {
    constructor(type, selectAttr, hrefAttr, nonBindable, projectAs) {
      this.type = type;
      this.selectAttr = selectAttr;
      this.hrefAttr = hrefAttr;
      this.nonBindable = nonBindable;
      this.projectAs = projectAs;
    }
  };
  function normalizeNgContentSelect(selectAttr) {
    if (selectAttr === null || selectAttr.length === 0) {
      return "*";
    }
    return selectAttr;
  }
  var CLASS_ATTR$1 = "class";
  var _TEXT_CSS_SELECTOR;
  function TEXT_CSS_SELECTOR() {
    if (!_TEXT_CSS_SELECTOR) {
      _TEXT_CSS_SELECTOR = CssSelector.parse("*")[0];
    }
    return _TEXT_CSS_SELECTOR;
  }
  var NonBindableVisitor$1 = class {
    visitElement(ast, parent) {
      const preparsedElement = preparseElement(ast);
      if (preparsedElement.type === PreparsedElementType.SCRIPT || preparsedElement.type === PreparsedElementType.STYLE || preparsedElement.type === PreparsedElementType.STYLESHEET) {
        return null;
      }
      const attrNameAndValues = ast.attrs.map((attr) => [attr.name, attr.value]);
      const selector = createElementCssSelector(ast.name, attrNameAndValues);
      const ngContentIndex = parent.findNgContentIndex(selector);
      const children = visitAll(this, ast.children, EMPTY_ELEMENT_CONTEXT);
      return new ElementAst(ast.name, visitAll(this, ast.attrs), [], [], [], [], [], false, [], children, ngContentIndex, ast.sourceSpan, ast.endSourceSpan);
    }
    visitComment(comment, context2) {
      return null;
    }
    visitAttribute(attribute, context2) {
      return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);
    }
    visitText(text, parent) {
      const ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR());
      return new TextAst(text.value, ngContentIndex, text.sourceSpan);
    }
    visitExpansion(expansion, context2) {
      return expansion;
    }
    visitExpansionCase(expansionCase, context2) {
      return expansionCase;
    }
  };
  function splitClasses(classAttrValue) {
    return classAttrValue.trim().split(/\s+/g);
  }
  var ElementContext = class {
    constructor(isTemplateElement2, _ngContentIndexMatcher, _wildcardNgContentIndex, providerContext) {
      this.isTemplateElement = isTemplateElement2;
      this._ngContentIndexMatcher = _ngContentIndexMatcher;
      this._wildcardNgContentIndex = _wildcardNgContentIndex;
      this.providerContext = providerContext;
    }
    static create(isTemplateElement2, directives, providerContext) {
      const matcher = new SelectorMatcher();
      let wildcardNgContentIndex = null;
      const component = directives.find((directive) => directive.directive.isComponent);
      if (component) {
        const ngContentSelectors = component.directive.template.ngContentSelectors;
        for (let i = 0; i < ngContentSelectors.length; i++) {
          const selector = ngContentSelectors[i];
          if (selector === "*") {
            wildcardNgContentIndex = i;
          } else {
            matcher.addSelectables(CssSelector.parse(ngContentSelectors[i]), i);
          }
        }
      }
      return new ElementContext(isTemplateElement2, matcher, wildcardNgContentIndex, providerContext);
    }
    findNgContentIndex(selector) {
      const ngContentIndices = [];
      this._ngContentIndexMatcher.match(selector, (selector2, ngContentIndex) => {
        ngContentIndices.push(ngContentIndex);
      });
      ngContentIndices.sort();
      if (this._wildcardNgContentIndex != null) {
        ngContentIndices.push(this._wildcardNgContentIndex);
      }
      return ngContentIndices.length > 0 ? ngContentIndices[0] : null;
    }
  };
  function createElementCssSelector(elementName, attributes) {
    const cssSelector = new CssSelector();
    const elNameNoNs = splitNsName(elementName)[1];
    cssSelector.setElement(elNameNoNs);
    for (let i = 0; i < attributes.length; i++) {
      const attrName = attributes[i][0];
      const attrNameNoNs = splitNsName(attrName)[1];
      const attrValue = attributes[i][1];
      cssSelector.addAttribute(attrNameNoNs, attrValue);
      if (attrName.toLowerCase() == CLASS_ATTR$1) {
        const classes = splitClasses(attrValue);
        classes.forEach((className) => cssSelector.addClassName(className));
      }
    }
    return cssSelector;
  }
  var EMPTY_ELEMENT_CONTEXT = new ElementContext(true, new SelectorMatcher(), null, null);
  var NON_BINDABLE_VISITOR$1 = new NonBindableVisitor$1();
  function isEmptyExpression(ast) {
    if (ast instanceof ASTWithSource) {
      ast = ast.ast;
    }
    return ast instanceof EmptyExpr;
  }
  function parse(value) {
    const styles = [];
    let i = 0;
    let parenDepth = 0;
    let quote = 0;
    let valueStart = 0;
    let propStart = 0;
    let currentProp = null;
    let valueHasQuotes = false;
    while (i < value.length) {
      const token = value.charCodeAt(i++);
      switch (token) {
        case 40:
          parenDepth++;
          break;
        case 41:
          parenDepth--;
          break;
        case 39:
          valueHasQuotes = valueHasQuotes || valueStart > 0;
          if (quote === 0) {
            quote = 39;
          } else if (quote === 39 && value.charCodeAt(i - 1) !== 92) {
            quote = 0;
          }
          break;
        case 34:
          valueHasQuotes = valueHasQuotes || valueStart > 0;
          if (quote === 0) {
            quote = 34;
          } else if (quote === 34 && value.charCodeAt(i - 1) !== 92) {
            quote = 0;
          }
          break;
        case 58:
          if (!currentProp && parenDepth === 0 && quote === 0) {
            currentProp = hyphenate(value.substring(propStart, i - 1).trim());
            valueStart = i;
          }
          break;
        case 59:
          if (currentProp && valueStart > 0 && parenDepth === 0 && quote === 0) {
            const styleVal = value.substring(valueStart, i - 1).trim();
            styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);
            propStart = i;
            valueStart = 0;
            currentProp = null;
            valueHasQuotes = false;
          }
          break;
      }
    }
    if (currentProp && valueStart) {
      const styleVal = value.substr(valueStart).trim();
      styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);
    }
    return styles;
  }
  function stripUnnecessaryQuotes(value) {
    const qS = value.charCodeAt(0);
    const qE = value.charCodeAt(value.length - 1);
    if (qS == qE && (qS == 39 || qS == 34)) {
      const tempValue = value.substring(1, value.length - 1);
      if (tempValue.indexOf("'") == -1 && tempValue.indexOf('"') == -1) {
        value = tempValue;
      }
    }
    return value;
  }
  function hyphenate(value) {
    return value.replace(/[a-z][A-Z]/g, (v) => {
      return v.charAt(0) + "-" + v.charAt(1);
    }).toLowerCase();
  }
  var IMPORTANT_FLAG = "!important";
  var MIN_STYLING_BINDING_SLOTS_REQUIRED = 2;
  var StylingBuilder = class {
    constructor(_directiveExpr) {
      this._directiveExpr = _directiveExpr;
      this._hasInitialValues = false;
      this.hasBindings = false;
      this.hasBindingsWithPipes = false;
      this._classMapInput = null;
      this._styleMapInput = null;
      this._singleStyleInputs = null;
      this._singleClassInputs = null;
      this._lastStylingInput = null;
      this._firstStylingInput = null;
      this._stylesIndex = /* @__PURE__ */ new Map();
      this._classesIndex = /* @__PURE__ */ new Map();
      this._initialStyleValues = [];
      this._initialClassValues = [];
    }
    registerBoundInput(input) {
      let binding = null;
      let name = input.name;
      switch (input.type) {
        case 0:
          binding = this.registerInputBasedOnName(name, input.value, input.sourceSpan);
          break;
        case 3:
          binding = this.registerStyleInput(name, false, input.value, input.sourceSpan, input.unit);
          break;
        case 2:
          binding = this.registerClassInput(name, false, input.value, input.sourceSpan);
          break;
      }
      return binding ? true : false;
    }
    registerInputBasedOnName(name, expression, sourceSpan) {
      let binding = null;
      const prefix = name.substring(0, 6);
      const isStyle = name === "style" || prefix === "style." || prefix === "style!";
      const isClass = !isStyle && (name === "class" || prefix === "class." || prefix === "class!");
      if (isStyle || isClass) {
        const isMapBased = name.charAt(5) !== ".";
        const property = name.substr(isMapBased ? 5 : 6);
        if (isStyle) {
          binding = this.registerStyleInput(property, isMapBased, expression, sourceSpan);
        } else {
          binding = this.registerClassInput(property, isMapBased, expression, sourceSpan);
        }
      }
      return binding;
    }
    registerStyleInput(name, isMapBased, value, sourceSpan, suffix) {
      if (isEmptyExpression(value)) {
        return null;
      }
      if (!isCssCustomProperty(name)) {
        name = hyphenate(name);
      }
      const { property, hasOverrideFlag, suffix: bindingSuffix } = parseProperty(name);
      suffix = typeof suffix === "string" && suffix.length !== 0 ? suffix : bindingSuffix;
      const entry = { name: property, suffix, value, sourceSpan, hasOverrideFlag };
      if (isMapBased) {
        this._styleMapInput = entry;
      } else {
        (this._singleStyleInputs = this._singleStyleInputs || []).push(entry);
        registerIntoMap(this._stylesIndex, property);
      }
      this._lastStylingInput = entry;
      this._firstStylingInput = this._firstStylingInput || entry;
      this._checkForPipes(value);
      this.hasBindings = true;
      return entry;
    }
    registerClassInput(name, isMapBased, value, sourceSpan) {
      if (isEmptyExpression(value)) {
        return null;
      }
      const { property, hasOverrideFlag } = parseProperty(name);
      const entry = { name: property, value, sourceSpan, hasOverrideFlag, suffix: null };
      if (isMapBased) {
        this._classMapInput = entry;
      } else {
        (this._singleClassInputs = this._singleClassInputs || []).push(entry);
        registerIntoMap(this._classesIndex, property);
      }
      this._lastStylingInput = entry;
      this._firstStylingInput = this._firstStylingInput || entry;
      this._checkForPipes(value);
      this.hasBindings = true;
      return entry;
    }
    _checkForPipes(value) {
      if (value instanceof ASTWithSource && value.ast instanceof BindingPipe) {
        this.hasBindingsWithPipes = true;
      }
    }
    registerStyleAttr(value) {
      this._initialStyleValues = parse(value);
      this._hasInitialValues = true;
    }
    registerClassAttr(value) {
      this._initialClassValues = value.trim().split(/\s+/g);
      this._hasInitialValues = true;
    }
    populateInitialStylingAttrs(attrs) {
      if (this._initialClassValues.length) {
        attrs.push(literal(1));
        for (let i = 0; i < this._initialClassValues.length; i++) {
          attrs.push(literal(this._initialClassValues[i]));
        }
      }
      if (this._initialStyleValues.length) {
        attrs.push(literal(2));
        for (let i = 0; i < this._initialStyleValues.length; i += 2) {
          attrs.push(literal(this._initialStyleValues[i]), literal(this._initialStyleValues[i + 1]));
        }
      }
    }
    assignHostAttrs(attrs, definitionMap) {
      if (this._directiveExpr && (attrs.length || this._hasInitialValues)) {
        this.populateInitialStylingAttrs(attrs);
        definitionMap.set("hostAttrs", literalArr(attrs));
      }
    }
    buildClassMapInstruction(valueConverter) {
      if (this._classMapInput) {
        return this._buildMapBasedInstruction(valueConverter, true, this._classMapInput);
      }
      return null;
    }
    buildStyleMapInstruction(valueConverter) {
      if (this._styleMapInput) {
        return this._buildMapBasedInstruction(valueConverter, false, this._styleMapInput);
      }
      return null;
    }
    _buildMapBasedInstruction(valueConverter, isClassBased, stylingInput) {
      let totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED;
      const mapValue = stylingInput.value.visit(valueConverter);
      let reference;
      if (mapValue instanceof Interpolation) {
        totalBindingSlotsRequired += mapValue.expressions.length;
        reference = isClassBased ? getClassMapInterpolationExpression(mapValue) : getStyleMapInterpolationExpression(mapValue);
      } else {
        reference = isClassBased ? Identifiers$1.classMap : Identifiers$1.styleMap;
      }
      return {
        reference,
        calls: [{
          supportsInterpolation: true,
          sourceSpan: stylingInput.sourceSpan,
          allocateBindingSlots: totalBindingSlotsRequired,
          params: (convertFn) => {
            const convertResult = convertFn(mapValue);
            const params = Array.isArray(convertResult) ? convertResult : [convertResult];
            return params;
          }
        }]
      };
    }
    _buildSingleInputs(reference, inputs, valueConverter, getInterpolationExpressionFn, isClassBased) {
      const instructions = [];
      inputs.forEach((input) => {
        const previousInstruction = instructions[instructions.length - 1];
        const value = input.value.visit(valueConverter);
        let referenceForCall = reference;
        let totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED;
        if (value instanceof Interpolation) {
          totalBindingSlotsRequired += value.expressions.length;
          if (getInterpolationExpressionFn) {
            referenceForCall = getInterpolationExpressionFn(value);
          }
        }
        const call = {
          sourceSpan: input.sourceSpan,
          allocateBindingSlots: totalBindingSlotsRequired,
          supportsInterpolation: !!getInterpolationExpressionFn,
          params: (convertFn) => {
            const params = [];
            params.push(literal(input.name));
            const convertResult = convertFn(value);
            if (Array.isArray(convertResult)) {
              params.push(...convertResult);
            } else {
              params.push(convertResult);
            }
            if (!isClassBased && input.suffix !== null) {
              params.push(literal(input.suffix));
            }
            return params;
          }
        };
        if (previousInstruction && previousInstruction.reference === referenceForCall) {
          previousInstruction.calls.push(call);
        } else {
          instructions.push({ reference: referenceForCall, calls: [call] });
        }
      });
      return instructions;
    }
    _buildClassInputs(valueConverter) {
      if (this._singleClassInputs) {
        return this._buildSingleInputs(Identifiers$1.classProp, this._singleClassInputs, valueConverter, null, true);
      }
      return [];
    }
    _buildStyleInputs(valueConverter) {
      if (this._singleStyleInputs) {
        return this._buildSingleInputs(Identifiers$1.styleProp, this._singleStyleInputs, valueConverter, getStylePropInterpolationExpression, false);
      }
      return [];
    }
    buildUpdateLevelInstructions(valueConverter) {
      const instructions = [];
      if (this.hasBindings) {
        const styleMapInstruction = this.buildStyleMapInstruction(valueConverter);
        if (styleMapInstruction) {
          instructions.push(styleMapInstruction);
        }
        const classMapInstruction = this.buildClassMapInstruction(valueConverter);
        if (classMapInstruction) {
          instructions.push(classMapInstruction);
        }
        instructions.push(...this._buildStyleInputs(valueConverter));
        instructions.push(...this._buildClassInputs(valueConverter));
      }
      return instructions;
    }
  };
  function registerIntoMap(map2, key) {
    if (!map2.has(key)) {
      map2.set(key, map2.size);
    }
  }
  function parseProperty(name) {
    let hasOverrideFlag = false;
    const overrideIndex = name.indexOf(IMPORTANT_FLAG);
    if (overrideIndex !== -1) {
      name = overrideIndex > 0 ? name.substring(0, overrideIndex) : "";
      hasOverrideFlag = true;
    }
    let suffix = null;
    let property = name;
    const unitIndex = name.lastIndexOf(".");
    if (unitIndex > 0) {
      suffix = name.substr(unitIndex + 1);
      property = name.substring(0, unitIndex);
    }
    return { property, suffix, hasOverrideFlag };
  }
  function getClassMapInterpolationExpression(interpolation) {
    switch (getInterpolationArgsLength(interpolation)) {
      case 1:
        return Identifiers$1.classMap;
      case 3:
        return Identifiers$1.classMapInterpolate1;
      case 5:
        return Identifiers$1.classMapInterpolate2;
      case 7:
        return Identifiers$1.classMapInterpolate3;
      case 9:
        return Identifiers$1.classMapInterpolate4;
      case 11:
        return Identifiers$1.classMapInterpolate5;
      case 13:
        return Identifiers$1.classMapInterpolate6;
      case 15:
        return Identifiers$1.classMapInterpolate7;
      case 17:
        return Identifiers$1.classMapInterpolate8;
      default:
        return Identifiers$1.classMapInterpolateV;
    }
  }
  function getStyleMapInterpolationExpression(interpolation) {
    switch (getInterpolationArgsLength(interpolation)) {
      case 1:
        return Identifiers$1.styleMap;
      case 3:
        return Identifiers$1.styleMapInterpolate1;
      case 5:
        return Identifiers$1.styleMapInterpolate2;
      case 7:
        return Identifiers$1.styleMapInterpolate3;
      case 9:
        return Identifiers$1.styleMapInterpolate4;
      case 11:
        return Identifiers$1.styleMapInterpolate5;
      case 13:
        return Identifiers$1.styleMapInterpolate6;
      case 15:
        return Identifiers$1.styleMapInterpolate7;
      case 17:
        return Identifiers$1.styleMapInterpolate8;
      default:
        return Identifiers$1.styleMapInterpolateV;
    }
  }
  function getStylePropInterpolationExpression(interpolation) {
    switch (getInterpolationArgsLength(interpolation)) {
      case 1:
        return Identifiers$1.styleProp;
      case 3:
        return Identifiers$1.stylePropInterpolate1;
      case 5:
        return Identifiers$1.stylePropInterpolate2;
      case 7:
        return Identifiers$1.stylePropInterpolate3;
      case 9:
        return Identifiers$1.stylePropInterpolate4;
      case 11:
        return Identifiers$1.stylePropInterpolate5;
      case 13:
        return Identifiers$1.stylePropInterpolate6;
      case 15:
        return Identifiers$1.stylePropInterpolate7;
      case 17:
        return Identifiers$1.stylePropInterpolate8;
      default:
        return Identifiers$1.stylePropInterpolateV;
    }
  }
  function isCssCustomProperty(name) {
    return name.startsWith("--");
  }
  var TokenType;
  (function(TokenType2) {
    TokenType2[TokenType2["Character"] = 0] = "Character";
    TokenType2[TokenType2["Identifier"] = 1] = "Identifier";
    TokenType2[TokenType2["PrivateIdentifier"] = 2] = "PrivateIdentifier";
    TokenType2[TokenType2["Keyword"] = 3] = "Keyword";
    TokenType2[TokenType2["String"] = 4] = "String";
    TokenType2[TokenType2["Operator"] = 5] = "Operator";
    TokenType2[TokenType2["Number"] = 6] = "Number";
    TokenType2[TokenType2["Error"] = 7] = "Error";
  })(TokenType || (TokenType = {}));
  var KEYWORDS = ["var", "let", "as", "null", "undefined", "true", "false", "if", "else", "this"];
  var Lexer = class {
    tokenize(text) {
      const scanner = new _Scanner(text);
      const tokens = [];
      let token = scanner.scanToken();
      while (token != null) {
        tokens.push(token);
        token = scanner.scanToken();
      }
      return tokens;
    }
  };
  var Token = class {
    constructor(index, end, type, numValue, strValue) {
      this.index = index;
      this.end = end;
      this.type = type;
      this.numValue = numValue;
      this.strValue = strValue;
    }
    isCharacter(code) {
      return this.type == TokenType.Character && this.numValue == code;
    }
    isNumber() {
      return this.type == TokenType.Number;
    }
    isString() {
      return this.type == TokenType.String;
    }
    isOperator(operator) {
      return this.type == TokenType.Operator && this.strValue == operator;
    }
    isIdentifier() {
      return this.type == TokenType.Identifier;
    }
    isPrivateIdentifier() {
      return this.type == TokenType.PrivateIdentifier;
    }
    isKeyword() {
      return this.type == TokenType.Keyword;
    }
    isKeywordLet() {
      return this.type == TokenType.Keyword && this.strValue == "let";
    }
    isKeywordAs() {
      return this.type == TokenType.Keyword && this.strValue == "as";
    }
    isKeywordNull() {
      return this.type == TokenType.Keyword && this.strValue == "null";
    }
    isKeywordUndefined() {
      return this.type == TokenType.Keyword && this.strValue == "undefined";
    }
    isKeywordTrue() {
      return this.type == TokenType.Keyword && this.strValue == "true";
    }
    isKeywordFalse() {
      return this.type == TokenType.Keyword && this.strValue == "false";
    }
    isKeywordThis() {
      return this.type == TokenType.Keyword && this.strValue == "this";
    }
    isError() {
      return this.type == TokenType.Error;
    }
    toNumber() {
      return this.type == TokenType.Number ? this.numValue : -1;
    }
    toString() {
      switch (this.type) {
        case TokenType.Character:
        case TokenType.Identifier:
        case TokenType.Keyword:
        case TokenType.Operator:
        case TokenType.PrivateIdentifier:
        case TokenType.String:
        case TokenType.Error:
          return this.strValue;
        case TokenType.Number:
          return this.numValue.toString();
        default:
          return null;
      }
    }
  };
  function newCharacterToken(index, end, code) {
    return new Token(index, end, TokenType.Character, code, String.fromCharCode(code));
  }
  function newIdentifierToken(index, end, text) {
    return new Token(index, end, TokenType.Identifier, 0, text);
  }
  function newPrivateIdentifierToken(index, end, text) {
    return new Token(index, end, TokenType.PrivateIdentifier, 0, text);
  }
  function newKeywordToken(index, end, text) {
    return new Token(index, end, TokenType.Keyword, 0, text);
  }
  function newOperatorToken(index, end, text) {
    return new Token(index, end, TokenType.Operator, 0, text);
  }
  function newStringToken(index, end, text) {
    return new Token(index, end, TokenType.String, 0, text);
  }
  function newNumberToken(index, end, n) {
    return new Token(index, end, TokenType.Number, n, "");
  }
  function newErrorToken(index, end, message) {
    return new Token(index, end, TokenType.Error, 0, message);
  }
  var EOF = new Token(-1, -1, TokenType.Character, 0, "");
  var _Scanner = class {
    constructor(input) {
      this.input = input;
      this.peek = 0;
      this.index = -1;
      this.length = input.length;
      this.advance();
    }
    advance() {
      this.peek = ++this.index >= this.length ? $EOF : this.input.charCodeAt(this.index);
    }
    scanToken() {
      const input = this.input, length = this.length;
      let peek = this.peek, index = this.index;
      while (peek <= $SPACE) {
        if (++index >= length) {
          peek = $EOF;
          break;
        } else {
          peek = input.charCodeAt(index);
        }
      }
      this.peek = peek;
      this.index = index;
      if (index >= length) {
        return null;
      }
      if (isIdentifierStart(peek))
        return this.scanIdentifier();
      if (isDigit(peek))
        return this.scanNumber(index);
      const start = index;
      switch (peek) {
        case $PERIOD:
          this.advance();
          return isDigit(this.peek) ? this.scanNumber(start) : newCharacterToken(start, this.index, $PERIOD);
        case $LPAREN:
        case $RPAREN:
        case $LBRACE:
        case $RBRACE:
        case $LBRACKET:
        case $RBRACKET:
        case $COMMA:
        case $COLON:
        case $SEMICOLON:
          return this.scanCharacter(start, peek);
        case $SQ:
        case $DQ:
          return this.scanString();
        case $HASH:
          return this.scanPrivateIdentifier();
        case $PLUS:
        case $MINUS:
        case $STAR:
        case $SLASH:
        case $PERCENT:
        case $CARET:
          return this.scanOperator(start, String.fromCharCode(peek));
        case $QUESTION:
          return this.scanQuestion(start);
        case $LT:
        case $GT:
          return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, "=");
        case $BANG:
        case $EQ:
          return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, "=", $EQ, "=");
        case $AMPERSAND:
          return this.scanComplexOperator(start, "&", $AMPERSAND, "&");
        case $BAR:
          return this.scanComplexOperator(start, "|", $BAR, "|");
        case $NBSP:
          while (isWhitespace(this.peek))
            this.advance();
          return this.scanToken();
      }
      this.advance();
      return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);
    }
    scanCharacter(start, code) {
      this.advance();
      return newCharacterToken(start, this.index, code);
    }
    scanOperator(start, str) {
      this.advance();
      return newOperatorToken(start, this.index, str);
    }
    scanComplexOperator(start, one, twoCode, two, threeCode, three) {
      this.advance();
      let str = one;
      if (this.peek == twoCode) {
        this.advance();
        str += two;
      }
      if (threeCode != null && this.peek == threeCode) {
        this.advance();
        str += three;
      }
      return newOperatorToken(start, this.index, str);
    }
    scanIdentifier() {
      const start = this.index;
      this.advance();
      while (isIdentifierPart(this.peek))
        this.advance();
      const str = this.input.substring(start, this.index);
      return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, this.index, str) : newIdentifierToken(start, this.index, str);
    }
    scanPrivateIdentifier() {
      const start = this.index;
      this.advance();
      if (!isIdentifierStart(this.peek)) {
        return this.error("Invalid character [#]", -1);
      }
      while (isIdentifierPart(this.peek))
        this.advance();
      const identifierName2 = this.input.substring(start, this.index);
      return newPrivateIdentifierToken(start, this.index, identifierName2);
    }
    scanNumber(start) {
      let simple = this.index === start;
      let hasSeparators = false;
      this.advance();
      while (true) {
        if (isDigit(this.peek)) {
        } else if (this.peek === $_) {
          if (!isDigit(this.input.charCodeAt(this.index - 1)) || !isDigit(this.input.charCodeAt(this.index + 1))) {
            return this.error("Invalid numeric separator", 0);
          }
          hasSeparators = true;
        } else if (this.peek === $PERIOD) {
          simple = false;
        } else if (isExponentStart(this.peek)) {
          this.advance();
          if (isExponentSign(this.peek))
            this.advance();
          if (!isDigit(this.peek))
            return this.error("Invalid exponent", -1);
          simple = false;
        } else {
          break;
        }
        this.advance();
      }
      let str = this.input.substring(start, this.index);
      if (hasSeparators) {
        str = str.replace(/_/g, "");
      }
      const value = simple ? parseIntAutoRadix(str) : parseFloat(str);
      return newNumberToken(start, this.index, value);
    }
    scanString() {
      const start = this.index;
      const quote = this.peek;
      this.advance();
      let buffer = "";
      let marker = this.index;
      const input = this.input;
      while (this.peek != quote) {
        if (this.peek == $BACKSLASH) {
          buffer += input.substring(marker, this.index);
          this.advance();
          let unescapedCode;
          this.peek = this.peek;
          if (this.peek == $u) {
            const hex = input.substring(this.index + 1, this.index + 5);
            if (/^[0-9a-f]+$/i.test(hex)) {
              unescapedCode = parseInt(hex, 16);
            } else {
              return this.error(`Invalid unicode escape [\\u${hex}]`, 0);
            }
            for (let i = 0; i < 5; i++) {
              this.advance();
            }
          } else {
            unescapedCode = unescape(this.peek);
            this.advance();
          }
          buffer += String.fromCharCode(unescapedCode);
          marker = this.index;
        } else if (this.peek == $EOF) {
          return this.error("Unterminated quote", 0);
        } else {
          this.advance();
        }
      }
      const last4 = input.substring(marker, this.index);
      this.advance();
      return newStringToken(start, this.index, buffer + last4);
    }
    scanQuestion(start) {
      this.advance();
      let str = "?";
      if (this.peek === $QUESTION || this.peek === $PERIOD) {
        str += this.peek === $PERIOD ? "." : "?";
        this.advance();
      }
      return newOperatorToken(start, this.index, str);
    }
    error(message, offset) {
      const position = this.index + offset;
      return newErrorToken(position, this.index, `Lexer Error: ${message} at column ${position} in expression [${this.input}]`);
    }
  };
  function isIdentifierStart(code) {
    return $a <= code && code <= $z || $A <= code && code <= $Z || code == $_ || code == $$;
  }
  function isIdentifier(input) {
    if (input.length == 0)
      return false;
    const scanner = new _Scanner(input);
    if (!isIdentifierStart(scanner.peek))
      return false;
    scanner.advance();
    while (scanner.peek !== $EOF) {
      if (!isIdentifierPart(scanner.peek))
        return false;
      scanner.advance();
    }
    return true;
  }
  function isIdentifierPart(code) {
    return isAsciiLetter(code) || isDigit(code) || code == $_ || code == $$;
  }
  function isExponentStart(code) {
    return code == $e || code == $E;
  }
  function isExponentSign(code) {
    return code == $MINUS || code == $PLUS;
  }
  function unescape(code) {
    switch (code) {
      case $n:
        return $LF;
      case $f:
        return $FF;
      case $r:
        return $CR;
      case $t:
        return $TAB;
      case $v:
        return $VTAB;
      default:
        return code;
    }
  }
  function parseIntAutoRadix(text) {
    const result = parseInt(text);
    if (isNaN(result)) {
      throw new Error("Invalid integer literal when parsing " + text);
    }
    return result;
  }
  var SplitInterpolation = class {
    constructor(strings, expressions, offsets) {
      this.strings = strings;
      this.expressions = expressions;
      this.offsets = offsets;
    }
  };
  var TemplateBindingParseResult = class {
    constructor(templateBindings, warnings, errors) {
      this.templateBindings = templateBindings;
      this.warnings = warnings;
      this.errors = errors;
    }
  };
  var Parser = class {
    constructor(_lexer) {
      this._lexer = _lexer;
      this.errors = [];
      this.simpleExpressionChecker = SimpleExpressionChecker;
    }
    parseAction(input, location2, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
      this._checkNoInterpolation(input, location2, interpolationConfig);
      const sourceToLex = this._stripComments(input);
      const tokens = this._lexer.tokenize(this._stripComments(input));
      const ast = new _ParseAST(input, location2, absoluteOffset, tokens, sourceToLex.length, true, this.errors, input.length - sourceToLex.length).parseChain();
      return new ASTWithSource(ast, input, location2, absoluteOffset, this.errors);
    }
    parseBinding(input, location2, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
      const ast = this._parseBindingAst(input, location2, absoluteOffset, interpolationConfig);
      return new ASTWithSource(ast, input, location2, absoluteOffset, this.errors);
    }
    checkSimpleExpression(ast) {
      const checker = new this.simpleExpressionChecker();
      ast.visit(checker);
      return checker.errors;
    }
    parseSimpleBinding(input, location2, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
      const ast = this._parseBindingAst(input, location2, absoluteOffset, interpolationConfig);
      const errors = this.checkSimpleExpression(ast);
      if (errors.length > 0) {
        this._reportError(`Host binding expression cannot contain ${errors.join(" ")}`, input, location2);
      }
      return new ASTWithSource(ast, input, location2, absoluteOffset, this.errors);
    }
    _reportError(message, input, errLocation, ctxLocation) {
      this.errors.push(new ParserError(message, input, errLocation, ctxLocation));
    }
    _parseBindingAst(input, location2, absoluteOffset, interpolationConfig) {
      const quote = this._parseQuote(input, location2, absoluteOffset);
      if (quote != null) {
        return quote;
      }
      this._checkNoInterpolation(input, location2, interpolationConfig);
      const sourceToLex = this._stripComments(input);
      const tokens = this._lexer.tokenize(sourceToLex);
      return new _ParseAST(input, location2, absoluteOffset, tokens, sourceToLex.length, false, this.errors, input.length - sourceToLex.length).parseChain();
    }
    _parseQuote(input, location2, absoluteOffset) {
      if (input == null)
        return null;
      const prefixSeparatorIndex = input.indexOf(":");
      if (prefixSeparatorIndex == -1)
        return null;
      const prefix = input.substring(0, prefixSeparatorIndex).trim();
      if (!isIdentifier(prefix))
        return null;
      const uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);
      const span = new ParseSpan(0, input.length);
      return new Quote(span, span.toAbsolute(absoluteOffset), prefix, uninterpretedExpression, location2);
    }
    parseTemplateBindings(templateKey, templateValue, templateUrl, absoluteKeyOffset, absoluteValueOffset) {
      const tokens = this._lexer.tokenize(templateValue);
      const parser = new _ParseAST(templateValue, templateUrl, absoluteValueOffset, tokens, templateValue.length, false, this.errors, 0);
      return parser.parseTemplateBindings({
        source: templateKey,
        span: new AbsoluteSourceSpan(absoluteKeyOffset, absoluteKeyOffset + templateKey.length)
      });
    }
    parseInterpolation(input, location2, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
      const { strings, expressions, offsets } = this.splitInterpolation(input, location2, interpolationConfig);
      if (expressions.length === 0)
        return null;
      const expressionNodes = [];
      for (let i = 0; i < expressions.length; ++i) {
        const expressionText = expressions[i].text;
        const sourceToLex = this._stripComments(expressionText);
        const tokens = this._lexer.tokenize(sourceToLex);
        const ast = new _ParseAST(input, location2, absoluteOffset, tokens, sourceToLex.length, false, this.errors, offsets[i] + (expressionText.length - sourceToLex.length)).parseChain();
        expressionNodes.push(ast);
      }
      return this.createInterpolationAst(strings.map((s) => s.text), expressionNodes, input, location2, absoluteOffset);
    }
    parseInterpolationExpression(expression, location2, absoluteOffset) {
      const sourceToLex = this._stripComments(expression);
      const tokens = this._lexer.tokenize(sourceToLex);
      const ast = new _ParseAST(expression, location2, absoluteOffset, tokens, sourceToLex.length, false, this.errors, 0).parseChain();
      const strings = ["", ""];
      return this.createInterpolationAst(strings, [ast], expression, location2, absoluteOffset);
    }
    createInterpolationAst(strings, expressions, input, location2, absoluteOffset) {
      const span = new ParseSpan(0, input.length);
      const interpolation = new Interpolation(span, span.toAbsolute(absoluteOffset), strings, expressions);
      return new ASTWithSource(interpolation, input, location2, absoluteOffset, this.errors);
    }
    splitInterpolation(input, location2, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
      const strings = [];
      const expressions = [];
      const offsets = [];
      let i = 0;
      let atInterpolation = false;
      let extendLastString = false;
      let { start: interpStart, end: interpEnd } = interpolationConfig;
      while (i < input.length) {
        if (!atInterpolation) {
          const start = i;
          i = input.indexOf(interpStart, i);
          if (i === -1) {
            i = input.length;
          }
          const text = input.substring(start, i);
          strings.push({ text, start, end: i });
          atInterpolation = true;
        } else {
          const fullStart = i;
          const exprStart = fullStart + interpStart.length;
          const exprEnd = this._getInterpolationEndIndex(input, interpEnd, exprStart);
          if (exprEnd === -1) {
            atInterpolation = false;
            extendLastString = true;
            break;
          }
          const fullEnd = exprEnd + interpEnd.length;
          const text = input.substring(exprStart, exprEnd);
          if (text.trim().length === 0) {
            this._reportError("Blank expressions are not allowed in interpolated strings", input, `at column ${i} in`, location2);
          }
          expressions.push({ text, start: fullStart, end: fullEnd });
          offsets.push(exprStart);
          i = fullEnd;
          atInterpolation = false;
        }
      }
      if (!atInterpolation) {
        if (extendLastString) {
          const piece = strings[strings.length - 1];
          piece.text += input.substring(i);
          piece.end = input.length;
        } else {
          strings.push({ text: input.substring(i), start: i, end: input.length });
        }
      }
      return new SplitInterpolation(strings, expressions, offsets);
    }
    wrapLiteralPrimitive(input, location2, absoluteOffset) {
      const span = new ParseSpan(0, input == null ? 0 : input.length);
      return new ASTWithSource(new LiteralPrimitive(span, span.toAbsolute(absoluteOffset), input), input, location2, absoluteOffset, this.errors);
    }
    _stripComments(input) {
      const i = this._commentStart(input);
      return i != null ? input.substring(0, i).trim() : input;
    }
    _commentStart(input) {
      let outerQuote = null;
      for (let i = 0; i < input.length - 1; i++) {
        const char = input.charCodeAt(i);
        const nextChar = input.charCodeAt(i + 1);
        if (char === $SLASH && nextChar == $SLASH && outerQuote == null)
          return i;
        if (outerQuote === char) {
          outerQuote = null;
        } else if (outerQuote == null && isQuote(char)) {
          outerQuote = char;
        }
      }
      return null;
    }
    _checkNoInterpolation(input, location2, { start, end }) {
      let startIndex = -1;
      let endIndex = -1;
      for (const charIndex of this._forEachUnquotedChar(input, 0)) {
        if (startIndex === -1) {
          if (input.startsWith(start)) {
            startIndex = charIndex;
          }
        } else {
          endIndex = this._getInterpolationEndIndex(input, end, charIndex);
          if (endIndex > -1) {
            break;
          }
        }
      }
      if (startIndex > -1 && endIndex > -1) {
        this._reportError(`Got interpolation (${start}${end}) where expression was expected`, input, `at column ${startIndex} in`, location2);
      }
    }
    _getInterpolationEndIndex(input, expressionEnd, start) {
      for (const charIndex of this._forEachUnquotedChar(input, start)) {
        if (input.startsWith(expressionEnd, charIndex)) {
          return charIndex;
        }
        if (input.startsWith("//", charIndex)) {
          return input.indexOf(expressionEnd, charIndex);
        }
      }
      return -1;
    }
    *_forEachUnquotedChar(input, start) {
      let currentQuote = null;
      let escapeCount = 0;
      for (let i = start; i < input.length; i++) {
        const char = input[i];
        if (isQuote(input.charCodeAt(i)) && (currentQuote === null || currentQuote === char) && escapeCount % 2 === 0) {
          currentQuote = currentQuote === null ? char : null;
        } else if (currentQuote === null) {
          yield i;
        }
        escapeCount = char === "\\" ? escapeCount + 1 : 0;
      }
    }
  };
  var IvyParser = class extends Parser {
    constructor() {
      super(...arguments);
      this.simpleExpressionChecker = IvySimpleExpressionChecker;
    }
  };
  var ParseContextFlags;
  (function(ParseContextFlags2) {
    ParseContextFlags2[ParseContextFlags2["None"] = 0] = "None";
    ParseContextFlags2[ParseContextFlags2["Writable"] = 1] = "Writable";
  })(ParseContextFlags || (ParseContextFlags = {}));
  var _ParseAST = class {
    constructor(input, location2, absoluteOffset, tokens, inputLength, parseAction, errors, offset) {
      this.input = input;
      this.location = location2;
      this.absoluteOffset = absoluteOffset;
      this.tokens = tokens;
      this.inputLength = inputLength;
      this.parseAction = parseAction;
      this.errors = errors;
      this.offset = offset;
      this.rparensExpected = 0;
      this.rbracketsExpected = 0;
      this.rbracesExpected = 0;
      this.context = ParseContextFlags.None;
      this.sourceSpanCache = /* @__PURE__ */ new Map();
      this.index = 0;
    }
    peek(offset) {
      const i = this.index + offset;
      return i < this.tokens.length ? this.tokens[i] : EOF;
    }
    get next() {
      return this.peek(0);
    }
    get atEOF() {
      return this.index >= this.tokens.length;
    }
    get inputIndex() {
      return this.atEOF ? this.currentEndIndex : this.next.index + this.offset;
    }
    get currentEndIndex() {
      if (this.index > 0) {
        const curToken = this.peek(-1);
        return curToken.end + this.offset;
      }
      if (this.tokens.length === 0) {
        return this.inputLength + this.offset;
      }
      return this.next.index + this.offset;
    }
    get currentAbsoluteOffset() {
      return this.absoluteOffset + this.inputIndex;
    }
    span(start, artificialEndIndex) {
      let endIndex = this.currentEndIndex;
      if (artificialEndIndex !== void 0 && artificialEndIndex > this.currentEndIndex) {
        endIndex = artificialEndIndex;
      }
      if (start > endIndex) {
        const tmp = endIndex;
        endIndex = start;
        start = tmp;
      }
      return new ParseSpan(start, endIndex);
    }
    sourceSpan(start, artificialEndIndex) {
      const serial = `${start}@${this.inputIndex}:${artificialEndIndex}`;
      if (!this.sourceSpanCache.has(serial)) {
        this.sourceSpanCache.set(serial, this.span(start, artificialEndIndex).toAbsolute(this.absoluteOffset));
      }
      return this.sourceSpanCache.get(serial);
    }
    advance() {
      this.index++;
    }
    withContext(context2, cb) {
      this.context |= context2;
      const ret = cb();
      this.context ^= context2;
      return ret;
    }
    consumeOptionalCharacter(code) {
      if (this.next.isCharacter(code)) {
        this.advance();
        return true;
      } else {
        return false;
      }
    }
    peekKeywordLet() {
      return this.next.isKeywordLet();
    }
    peekKeywordAs() {
      return this.next.isKeywordAs();
    }
    expectCharacter(code) {
      if (this.consumeOptionalCharacter(code))
        return;
      this.error(`Missing expected ${String.fromCharCode(code)}`);
    }
    consumeOptionalOperator(op) {
      if (this.next.isOperator(op)) {
        this.advance();
        return true;
      } else {
        return false;
      }
    }
    expectOperator(operator) {
      if (this.consumeOptionalOperator(operator))
        return;
      this.error(`Missing expected operator ${operator}`);
    }
    prettyPrintToken(tok) {
      return tok === EOF ? "end of input" : `token ${tok}`;
    }
    expectIdentifierOrKeyword() {
      const n = this.next;
      if (!n.isIdentifier() && !n.isKeyword()) {
        if (n.isPrivateIdentifier()) {
          this._reportErrorForPrivateIdentifier(n, "expected identifier or keyword");
        } else {
          this.error(`Unexpected ${this.prettyPrintToken(n)}, expected identifier or keyword`);
        }
        return null;
      }
      this.advance();
      return n.toString();
    }
    expectIdentifierOrKeywordOrString() {
      const n = this.next;
      if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {
        if (n.isPrivateIdentifier()) {
          this._reportErrorForPrivateIdentifier(n, "expected identifier, keyword or string");
        } else {
          this.error(`Unexpected ${this.prettyPrintToken(n)}, expected identifier, keyword, or string`);
        }
        return "";
      }
      this.advance();
      return n.toString();
    }
    parseChain() {
      const exprs = [];
      const start = this.inputIndex;
      while (this.index < this.tokens.length) {
        const expr = this.parsePipe();
        exprs.push(expr);
        if (this.consumeOptionalCharacter($SEMICOLON)) {
          if (!this.parseAction) {
            this.error("Binding expression cannot contain chained expression");
          }
          while (this.consumeOptionalCharacter($SEMICOLON)) {
          }
        } else if (this.index < this.tokens.length) {
          this.error(`Unexpected token '${this.next}'`);
        }
      }
      if (exprs.length == 0) {
        const artificialStart = this.offset;
        const artificialEnd = this.offset + this.inputLength;
        return new EmptyExpr(this.span(artificialStart, artificialEnd), this.sourceSpan(artificialStart, artificialEnd));
      }
      if (exprs.length == 1)
        return exprs[0];
      return new Chain(this.span(start), this.sourceSpan(start), exprs);
    }
    parsePipe() {
      const start = this.inputIndex;
      let result = this.parseExpression();
      if (this.consumeOptionalOperator("|")) {
        if (this.parseAction) {
          this.error("Cannot have a pipe in an action expression");
        }
        do {
          const nameStart = this.inputIndex;
          let nameId = this.expectIdentifierOrKeyword();
          let nameSpan;
          let fullSpanEnd = void 0;
          if (nameId !== null) {
            nameSpan = this.sourceSpan(nameStart);
          } else {
            nameId = "";
            fullSpanEnd = this.next.index !== -1 ? this.next.index : this.inputLength + this.offset;
            nameSpan = new ParseSpan(fullSpanEnd, fullSpanEnd).toAbsolute(this.absoluteOffset);
          }
          const args = [];
          while (this.consumeOptionalCharacter($COLON)) {
            args.push(this.parseExpression());
          }
          result = new BindingPipe(this.span(start), this.sourceSpan(start, fullSpanEnd), result, nameId, args, nameSpan);
        } while (this.consumeOptionalOperator("|"));
      }
      return result;
    }
    parseExpression() {
      return this.parseConditional();
    }
    parseConditional() {
      const start = this.inputIndex;
      const result = this.parseLogicalOr();
      if (this.consumeOptionalOperator("?")) {
        const yes = this.parsePipe();
        let no;
        if (!this.consumeOptionalCharacter($COLON)) {
          const end = this.inputIndex;
          const expression = this.input.substring(start, end);
          this.error(`Conditional expression ${expression} requires all 3 expressions`);
          no = new EmptyExpr(this.span(start), this.sourceSpan(start));
        } else {
          no = this.parsePipe();
        }
        return new Conditional(this.span(start), this.sourceSpan(start), result, yes, no);
      } else {
        return result;
      }
    }
    parseLogicalOr() {
      const start = this.inputIndex;
      let result = this.parseLogicalAnd();
      while (this.consumeOptionalOperator("||")) {
        const right = this.parseLogicalAnd();
        result = new Binary(this.span(start), this.sourceSpan(start), "||", result, right);
      }
      return result;
    }
    parseLogicalAnd() {
      const start = this.inputIndex;
      let result = this.parseNullishCoalescing();
      while (this.consumeOptionalOperator("&&")) {
        const right = this.parseNullishCoalescing();
        result = new Binary(this.span(start), this.sourceSpan(start), "&&", result, right);
      }
      return result;
    }
    parseNullishCoalescing() {
      const start = this.inputIndex;
      let result = this.parseEquality();
      while (this.consumeOptionalOperator("??")) {
        const right = this.parseEquality();
        result = new Binary(this.span(start), this.sourceSpan(start), "??", result, right);
      }
      return result;
    }
    parseEquality() {
      const start = this.inputIndex;
      let result = this.parseRelational();
      while (this.next.type == TokenType.Operator) {
        const operator = this.next.strValue;
        switch (operator) {
          case "==":
          case "===":
          case "!=":
          case "!==":
            this.advance();
            const right = this.parseRelational();
            result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);
            continue;
        }
        break;
      }
      return result;
    }
    parseRelational() {
      const start = this.inputIndex;
      let result = this.parseAdditive();
      while (this.next.type == TokenType.Operator) {
        const operator = this.next.strValue;
        switch (operator) {
          case "<":
          case ">":
          case "<=":
          case ">=":
            this.advance();
            const right = this.parseAdditive();
            result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);
            continue;
        }
        break;
      }
      return result;
    }
    parseAdditive() {
      const start = this.inputIndex;
      let result = this.parseMultiplicative();
      while (this.next.type == TokenType.Operator) {
        const operator = this.next.strValue;
        switch (operator) {
          case "+":
          case "-":
            this.advance();
            let right = this.parseMultiplicative();
            result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);
            continue;
        }
        break;
      }
      return result;
    }
    parseMultiplicative() {
      const start = this.inputIndex;
      let result = this.parsePrefix();
      while (this.next.type == TokenType.Operator) {
        const operator = this.next.strValue;
        switch (operator) {
          case "*":
          case "%":
          case "/":
            this.advance();
            let right = this.parsePrefix();
            result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);
            continue;
        }
        break;
      }
      return result;
    }
    parsePrefix() {
      if (this.next.type == TokenType.Operator) {
        const start = this.inputIndex;
        const operator = this.next.strValue;
        let result;
        switch (operator) {
          case "+":
            this.advance();
            result = this.parsePrefix();
            return Unary.createPlus(this.span(start), this.sourceSpan(start), result);
          case "-":
            this.advance();
            result = this.parsePrefix();
            return Unary.createMinus(this.span(start), this.sourceSpan(start), result);
          case "!":
            this.advance();
            result = this.parsePrefix();
            return new PrefixNot(this.span(start), this.sourceSpan(start), result);
        }
      }
      return this.parseCallChain();
    }
    parseCallChain() {
      const start = this.inputIndex;
      let result = this.parsePrimary();
      while (true) {
        if (this.consumeOptionalCharacter($PERIOD)) {
          result = this.parseAccessMemberOrCall(result, start, false);
        } else if (this.consumeOptionalOperator("?.")) {
          result = this.consumeOptionalCharacter($LBRACKET) ? this.parseKeyedReadOrWrite(result, start, true) : this.parseAccessMemberOrCall(result, start, true);
        } else if (this.consumeOptionalCharacter($LBRACKET)) {
          result = this.parseKeyedReadOrWrite(result, start, false);
        } else if (this.consumeOptionalCharacter($LPAREN)) {
          const argumentStart = this.inputIndex;
          this.rparensExpected++;
          const args = this.parseCallArguments();
          const argumentSpan = this.span(argumentStart, this.inputIndex).toAbsolute(this.absoluteOffset);
          this.rparensExpected--;
          this.expectCharacter($RPAREN);
          result = new Call(this.span(start), this.sourceSpan(start), result, args, argumentSpan);
        } else if (this.consumeOptionalOperator("!")) {
          result = new NonNullAssert(this.span(start), this.sourceSpan(start), result);
        } else {
          return result;
        }
      }
    }
    parsePrimary() {
      const start = this.inputIndex;
      if (this.consumeOptionalCharacter($LPAREN)) {
        this.rparensExpected++;
        const result = this.parsePipe();
        this.rparensExpected--;
        this.expectCharacter($RPAREN);
        return result;
      } else if (this.next.isKeywordNull()) {
        this.advance();
        return new LiteralPrimitive(this.span(start), this.sourceSpan(start), null);
      } else if (this.next.isKeywordUndefined()) {
        this.advance();
        return new LiteralPrimitive(this.span(start), this.sourceSpan(start), void 0);
      } else if (this.next.isKeywordTrue()) {
        this.advance();
        return new LiteralPrimitive(this.span(start), this.sourceSpan(start), true);
      } else if (this.next.isKeywordFalse()) {
        this.advance();
        return new LiteralPrimitive(this.span(start), this.sourceSpan(start), false);
      } else if (this.next.isKeywordThis()) {
        this.advance();
        return new ThisReceiver(this.span(start), this.sourceSpan(start));
      } else if (this.consumeOptionalCharacter($LBRACKET)) {
        this.rbracketsExpected++;
        const elements = this.parseExpressionList($RBRACKET);
        this.rbracketsExpected--;
        this.expectCharacter($RBRACKET);
        return new LiteralArray(this.span(start), this.sourceSpan(start), elements);
      } else if (this.next.isCharacter($LBRACE)) {
        return this.parseLiteralMap();
      } else if (this.next.isIdentifier()) {
        return this.parseAccessMemberOrCall(new ImplicitReceiver(this.span(start), this.sourceSpan(start)), start, false);
      } else if (this.next.isNumber()) {
        const value = this.next.toNumber();
        this.advance();
        return new LiteralPrimitive(this.span(start), this.sourceSpan(start), value);
      } else if (this.next.isString()) {
        const literalValue = this.next.toString();
        this.advance();
        return new LiteralPrimitive(this.span(start), this.sourceSpan(start), literalValue);
      } else if (this.next.isPrivateIdentifier()) {
        this._reportErrorForPrivateIdentifier(this.next, null);
        return new EmptyExpr(this.span(start), this.sourceSpan(start));
      } else if (this.index >= this.tokens.length) {
        this.error(`Unexpected end of expression: ${this.input}`);
        return new EmptyExpr(this.span(start), this.sourceSpan(start));
      } else {
        this.error(`Unexpected token ${this.next}`);
        return new EmptyExpr(this.span(start), this.sourceSpan(start));
      }
    }
    parseExpressionList(terminator) {
      const result = [];
      do {
        if (!this.next.isCharacter(terminator)) {
          result.push(this.parsePipe());
        } else {
          break;
        }
      } while (this.consumeOptionalCharacter($COMMA));
      return result;
    }
    parseLiteralMap() {
      const keys = [];
      const values = [];
      const start = this.inputIndex;
      this.expectCharacter($LBRACE);
      if (!this.consumeOptionalCharacter($RBRACE)) {
        this.rbracesExpected++;
        do {
          const keyStart = this.inputIndex;
          const quoted = this.next.isString();
          const key = this.expectIdentifierOrKeywordOrString();
          keys.push({ key, quoted });
          if (quoted) {
            this.expectCharacter($COLON);
            values.push(this.parsePipe());
          } else if (this.consumeOptionalCharacter($COLON)) {
            values.push(this.parsePipe());
          } else {
            const span = this.span(keyStart);
            const sourceSpan = this.sourceSpan(keyStart);
            values.push(new PropertyRead(span, sourceSpan, sourceSpan, new ImplicitReceiver(span, sourceSpan), key));
          }
        } while (this.consumeOptionalCharacter($COMMA));
        this.rbracesExpected--;
        this.expectCharacter($RBRACE);
      }
      return new LiteralMap(this.span(start), this.sourceSpan(start), keys, values);
    }
    parseAccessMemberOrCall(readReceiver, start, isSafe) {
      const nameStart = this.inputIndex;
      const id = this.withContext(ParseContextFlags.Writable, () => {
        const id2 = this.expectIdentifierOrKeyword() ?? "";
        if (id2.length === 0) {
          this.error(`Expected identifier for property access`, readReceiver.span.end);
        }
        return id2;
      });
      const nameSpan = this.sourceSpan(nameStart);
      let receiver;
      if (isSafe) {
        if (this.consumeOptionalOperator("=")) {
          this.error("The '?.' operator cannot be used in the assignment");
          receiver = new EmptyExpr(this.span(start), this.sourceSpan(start));
        } else {
          receiver = new SafePropertyRead(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id);
        }
      } else {
        if (this.consumeOptionalOperator("=")) {
          if (!this.parseAction) {
            this.error("Bindings cannot contain assignments");
            return new EmptyExpr(this.span(start), this.sourceSpan(start));
          }
          const value = this.parseConditional();
          receiver = new PropertyWrite(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id, value);
        } else {
          receiver = new PropertyRead(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id);
        }
      }
      if (this.consumeOptionalCharacter($LPAREN)) {
        const argumentStart = this.inputIndex;
        this.rparensExpected++;
        const args = this.parseCallArguments();
        const argumentSpan = this.span(argumentStart, this.inputIndex).toAbsolute(this.absoluteOffset);
        this.expectCharacter($RPAREN);
        this.rparensExpected--;
        const span = this.span(start);
        const sourceSpan = this.sourceSpan(start);
        return new Call(span, sourceSpan, receiver, args, argumentSpan);
      }
      return receiver;
    }
    parseCallArguments() {
      if (this.next.isCharacter($RPAREN))
        return [];
      const positionals = [];
      do {
        positionals.push(this.parsePipe());
      } while (this.consumeOptionalCharacter($COMMA));
      return positionals;
    }
    expectTemplateBindingKey() {
      let result = "";
      let operatorFound = false;
      const start = this.currentAbsoluteOffset;
      do {
        result += this.expectIdentifierOrKeywordOrString();
        operatorFound = this.consumeOptionalOperator("-");
        if (operatorFound) {
          result += "-";
        }
      } while (operatorFound);
      return {
        source: result,
        span: new AbsoluteSourceSpan(start, start + result.length)
      };
    }
    parseTemplateBindings(templateKey) {
      const bindings = [];
      bindings.push(...this.parseDirectiveKeywordBindings(templateKey));
      while (this.index < this.tokens.length) {
        const letBinding = this.parseLetBinding();
        if (letBinding) {
          bindings.push(letBinding);
        } else {
          const key = this.expectTemplateBindingKey();
          const binding = this.parseAsBinding(key);
          if (binding) {
            bindings.push(binding);
          } else {
            key.source = templateKey.source + key.source.charAt(0).toUpperCase() + key.source.substring(1);
            bindings.push(...this.parseDirectiveKeywordBindings(key));
          }
        }
        this.consumeStatementTerminator();
      }
      return new TemplateBindingParseResult(bindings, [], this.errors);
    }
    parseKeyedReadOrWrite(receiver, start, isSafe) {
      return this.withContext(ParseContextFlags.Writable, () => {
        this.rbracketsExpected++;
        const key = this.parsePipe();
        if (key instanceof EmptyExpr) {
          this.error(`Key access cannot be empty`);
        }
        this.rbracketsExpected--;
        this.expectCharacter($RBRACKET);
        if (this.consumeOptionalOperator("=")) {
          if (isSafe) {
            this.error("The '?.' operator cannot be used in the assignment");
          } else {
            const value = this.parseConditional();
            return new KeyedWrite(this.span(start), this.sourceSpan(start), receiver, key, value);
          }
        } else {
          return isSafe ? new SafeKeyedRead(this.span(start), this.sourceSpan(start), receiver, key) : new KeyedRead(this.span(start), this.sourceSpan(start), receiver, key);
        }
        return new EmptyExpr(this.span(start), this.sourceSpan(start));
      });
    }
    parseDirectiveKeywordBindings(key) {
      const bindings = [];
      this.consumeOptionalCharacter($COLON);
      const value = this.getDirectiveBoundTarget();
      let spanEnd = this.currentAbsoluteOffset;
      const asBinding = this.parseAsBinding(key);
      if (!asBinding) {
        this.consumeStatementTerminator();
        spanEnd = this.currentAbsoluteOffset;
      }
      const sourceSpan = new AbsoluteSourceSpan(key.span.start, spanEnd);
      bindings.push(new ExpressionBinding(sourceSpan, key, value));
      if (asBinding) {
        bindings.push(asBinding);
      }
      return bindings;
    }
    getDirectiveBoundTarget() {
      if (this.next === EOF || this.peekKeywordAs() || this.peekKeywordLet()) {
        return null;
      }
      const ast = this.parsePipe();
      const { start, end } = ast.span;
      const value = this.input.substring(start, end);
      return new ASTWithSource(ast, value, this.location, this.absoluteOffset + start, this.errors);
    }
    parseAsBinding(value) {
      if (!this.peekKeywordAs()) {
        return null;
      }
      this.advance();
      const key = this.expectTemplateBindingKey();
      this.consumeStatementTerminator();
      const sourceSpan = new AbsoluteSourceSpan(value.span.start, this.currentAbsoluteOffset);
      return new VariableBinding(sourceSpan, key, value);
    }
    parseLetBinding() {
      if (!this.peekKeywordLet()) {
        return null;
      }
      const spanStart = this.currentAbsoluteOffset;
      this.advance();
      const key = this.expectTemplateBindingKey();
      let value = null;
      if (this.consumeOptionalOperator("=")) {
        value = this.expectTemplateBindingKey();
      }
      this.consumeStatementTerminator();
      const sourceSpan = new AbsoluteSourceSpan(spanStart, this.currentAbsoluteOffset);
      return new VariableBinding(sourceSpan, key, value);
    }
    consumeStatementTerminator() {
      this.consumeOptionalCharacter($SEMICOLON) || this.consumeOptionalCharacter($COMMA);
    }
    error(message, index = null) {
      this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));
      this.skip();
    }
    locationText(index = null) {
      if (index == null)
        index = this.index;
      return index < this.tokens.length ? `at column ${this.tokens[index].index + 1} in` : `at the end of the expression`;
    }
    _reportErrorForPrivateIdentifier(token, extraMessage) {
      let errorMessage = `Private identifiers are not supported. Unexpected private identifier: ${token}`;
      if (extraMessage !== null) {
        errorMessage += `, ${extraMessage}`;
      }
      this.error(errorMessage);
    }
    skip() {
      let n = this.next;
      while (this.index < this.tokens.length && !n.isCharacter($SEMICOLON) && !n.isOperator("|") && (this.rparensExpected <= 0 || !n.isCharacter($RPAREN)) && (this.rbracesExpected <= 0 || !n.isCharacter($RBRACE)) && (this.rbracketsExpected <= 0 || !n.isCharacter($RBRACKET)) && (!(this.context & ParseContextFlags.Writable) || !n.isOperator("="))) {
        if (this.next.isError()) {
          this.errors.push(new ParserError(this.next.toString(), this.input, this.locationText(), this.location));
        }
        this.advance();
        n = this.next;
      }
    }
  };
  var SimpleExpressionChecker = class {
    constructor() {
      this.errors = [];
    }
    visitImplicitReceiver(ast, context2) {
    }
    visitThisReceiver(ast, context2) {
    }
    visitInterpolation(ast, context2) {
    }
    visitLiteralPrimitive(ast, context2) {
    }
    visitPropertyRead(ast, context2) {
    }
    visitPropertyWrite(ast, context2) {
    }
    visitSafePropertyRead(ast, context2) {
    }
    visitCall(ast, context2) {
    }
    visitLiteralArray(ast, context2) {
      this.visitAll(ast.expressions, context2);
    }
    visitLiteralMap(ast, context2) {
      this.visitAll(ast.values, context2);
    }
    visitUnary(ast, context2) {
    }
    visitBinary(ast, context2) {
    }
    visitPrefixNot(ast, context2) {
    }
    visitNonNullAssert(ast, context2) {
    }
    visitConditional(ast, context2) {
    }
    visitPipe(ast, context2) {
      this.errors.push("pipes");
    }
    visitKeyedRead(ast, context2) {
    }
    visitKeyedWrite(ast, context2) {
    }
    visitAll(asts, context2) {
      return asts.map((node) => node.visit(this, context2));
    }
    visitChain(ast, context2) {
    }
    visitQuote(ast, context2) {
    }
    visitSafeKeyedRead(ast, context2) {
    }
  };
  var IvySimpleExpressionChecker = class extends RecursiveAstVisitor {
    constructor() {
      super(...arguments);
      this.errors = [];
    }
    visitPipe() {
      this.errors.push("pipes");
    }
  };
  var HtmlParser = class extends Parser$1 {
    constructor() {
      super(getHtmlTagDefinition);
    }
    parse(source, url, options) {
      return super.parse(source, url, options);
    }
  };
  function mapLiteral(obj, quoted = false) {
    return literalMap(Object.keys(obj).map((key) => ({
      key,
      quoted,
      value: obj[key]
    })));
  }
  var _SECURITY_SCHEMA;
  function SECURITY_SCHEMA() {
    if (!_SECURITY_SCHEMA) {
      _SECURITY_SCHEMA = {};
      registerContext(SecurityContext2.HTML, [
        "iframe|srcdoc",
        "*|innerHTML",
        "*|outerHTML"
      ]);
      registerContext(SecurityContext2.STYLE, ["*|style"]);
      registerContext(SecurityContext2.URL, [
        "*|formAction",
        "area|href",
        "area|ping",
        "audio|src",
        "a|href",
        "a|ping",
        "blockquote|cite",
        "body|background",
        "del|cite",
        "form|action",
        "img|src",
        "img|srcset",
        "input|src",
        "ins|cite",
        "q|cite",
        "source|src",
        "source|srcset",
        "track|src",
        "video|poster",
        "video|src"
      ]);
      registerContext(SecurityContext2.RESOURCE_URL, [
        "applet|code",
        "applet|codebase",
        "base|href",
        "embed|src",
        "frame|src",
        "head|profile",
        "html|manifest",
        "iframe|src",
        "link|href",
        "media|src",
        "object|codebase",
        "object|data",
        "script|src"
      ]);
    }
    return _SECURITY_SCHEMA;
  }
  function registerContext(ctx, specs) {
    for (const spec of specs)
      _SECURITY_SCHEMA[spec.toLowerCase()] = ctx;
  }
  var ElementSchemaRegistry = class {
  };
  var BOOLEAN = "boolean";
  var NUMBER = "number";
  var STRING = "string";
  var OBJECT = "object";
  var SCHEMA = [
    "[Element]|textContent,%classList,className,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*copy,*cut,*paste,*search,*selectstart,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerHTML,#scrollLeft,#scrollTop,slot,*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored",
    "[HTMLElement]^[Element]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate",
    "abbr,address,article,aside,b,bdi,bdo,cite,code,dd,dfn,dt,em,figcaption,figure,footer,header,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate",
    "media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,src,%srcObject,#volume",
    ":svg:^[HTMLElement]|*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,%style,#tabIndex",
    ":svg:graphics^:svg:|",
    ":svg:animation^:svg:|*begin,*end,*repeat",
    ":svg:geometry^:svg:|",
    ":svg:componentTransferFunction^:svg:|",
    ":svg:gradient^:svg:|",
    ":svg:textContent^:svg:graphics|",
    ":svg:textPositioning^:svg:textContent|",
    "a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,rev,search,shape,target,text,type,username",
    "area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,search,shape,target,username",
    "audio^media|",
    "br^[HTMLElement]|clear",
    "base^[HTMLElement]|href,target",
    "body^[HTMLElement]|aLink,background,bgColor,link,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink",
    "button^[HTMLElement]|!autofocus,!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value",
    "canvas^[HTMLElement]|#height,#width",
    "content^[HTMLElement]|select",
    "dl^[HTMLElement]|!compact",
    "datalist^[HTMLElement]|",
    "details^[HTMLElement]|!open",
    "dialog^[HTMLElement]|!open,returnValue",
    "dir^[HTMLElement]|!compact",
    "div^[HTMLElement]|align",
    "embed^[HTMLElement]|align,height,name,src,type,width",
    "fieldset^[HTMLElement]|!disabled,name",
    "font^[HTMLElement]|color,face,size",
    "form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target",
    "frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src",
    "frameset^[HTMLElement]|cols,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows",
    "hr^[HTMLElement]|align,color,!noShade,size,width",
    "head^[HTMLElement]|",
    "h1,h2,h3,h4,h5,h6^[HTMLElement]|align",
    "html^[HTMLElement]|version",
    "iframe^[HTMLElement]|align,!allowFullscreen,frameBorder,height,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width",
    "img^[HTMLElement]|align,alt,border,%crossOrigin,#height,#hspace,!isMap,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width",
    "input^[HTMLElement]|accept,align,alt,autocapitalize,autocomplete,!autofocus,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width",
    "li^[HTMLElement]|type,#value",
    "label^[HTMLElement]|htmlFor",
    "legend^[HTMLElement]|align",
    "link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type",
    "map^[HTMLElement]|name",
    "marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width",
    "menu^[HTMLElement]|!compact",
    "meta^[HTMLElement]|content,httpEquiv,name,scheme",
    "meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value",
    "ins,del^[HTMLElement]|cite,dateTime",
    "ol^[HTMLElement]|!compact,!reversed,#start,type",
    "object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width",
    "optgroup^[HTMLElement]|!disabled,label",
    "option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value",
    "output^[HTMLElement]|defaultValue,%htmlFor,name,value",
    "p^[HTMLElement]|align",
    "param^[HTMLElement]|name,type,value,valueType",
    "picture^[HTMLElement]|",
    "pre^[HTMLElement]|#width",
    "progress^[HTMLElement]|#max,#value",
    "q,blockquote,cite^[HTMLElement]|",
    "script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,src,text,type",
    "select^[HTMLElement]|autocomplete,!autofocus,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value",
    "shadow^[HTMLElement]|",
    "slot^[HTMLElement]|name",
    "source^[HTMLElement]|media,sizes,src,srcset,type",
    "span^[HTMLElement]|",
    "style^[HTMLElement]|!disabled,media,type",
    "caption^[HTMLElement]|align",
    "th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width",
    "col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width",
    "table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width",
    "tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign",
    "tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign",
    "template^[HTMLElement]|",
    "textarea^[HTMLElement]|autocapitalize,autocomplete,!autofocus,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap",
    "title^[HTMLElement]|text",
    "track^[HTMLElement]|!default,kind,label,src,srclang",
    "ul^[HTMLElement]|!compact,type",
    "unknown^[HTMLElement]|",
    "video^media|#height,poster,#width",
    ":svg:a^:svg:graphics|",
    ":svg:animate^:svg:animation|",
    ":svg:animateMotion^:svg:animation|",
    ":svg:animateTransform^:svg:animation|",
    ":svg:circle^:svg:geometry|",
    ":svg:clipPath^:svg:graphics|",
    ":svg:defs^:svg:graphics|",
    ":svg:desc^:svg:|",
    ":svg:discard^:svg:|",
    ":svg:ellipse^:svg:geometry|",
    ":svg:feBlend^:svg:|",
    ":svg:feColorMatrix^:svg:|",
    ":svg:feComponentTransfer^:svg:|",
    ":svg:feComposite^:svg:|",
    ":svg:feConvolveMatrix^:svg:|",
    ":svg:feDiffuseLighting^:svg:|",
    ":svg:feDisplacementMap^:svg:|",
    ":svg:feDistantLight^:svg:|",
    ":svg:feDropShadow^:svg:|",
    ":svg:feFlood^:svg:|",
    ":svg:feFuncA^:svg:componentTransferFunction|",
    ":svg:feFuncB^:svg:componentTransferFunction|",
    ":svg:feFuncG^:svg:componentTransferFunction|",
    ":svg:feFuncR^:svg:componentTransferFunction|",
    ":svg:feGaussianBlur^:svg:|",
    ":svg:feImage^:svg:|",
    ":svg:feMerge^:svg:|",
    ":svg:feMergeNode^:svg:|",
    ":svg:feMorphology^:svg:|",
    ":svg:feOffset^:svg:|",
    ":svg:fePointLight^:svg:|",
    ":svg:feSpecularLighting^:svg:|",
    ":svg:feSpotLight^:svg:|",
    ":svg:feTile^:svg:|",
    ":svg:feTurbulence^:svg:|",
    ":svg:filter^:svg:|",
    ":svg:foreignObject^:svg:graphics|",
    ":svg:g^:svg:graphics|",
    ":svg:image^:svg:graphics|",
    ":svg:line^:svg:geometry|",
    ":svg:linearGradient^:svg:gradient|",
    ":svg:mpath^:svg:|",
    ":svg:marker^:svg:|",
    ":svg:mask^:svg:|",
    ":svg:metadata^:svg:|",
    ":svg:path^:svg:geometry|",
    ":svg:pattern^:svg:|",
    ":svg:polygon^:svg:geometry|",
    ":svg:polyline^:svg:geometry|",
    ":svg:radialGradient^:svg:gradient|",
    ":svg:rect^:svg:geometry|",
    ":svg:svg^:svg:graphics|#currentScale,#zoomAndPan",
    ":svg:script^:svg:|type",
    ":svg:set^:svg:animation|",
    ":svg:stop^:svg:|",
    ":svg:style^:svg:|!disabled,media,title,type",
    ":svg:switch^:svg:graphics|",
    ":svg:symbol^:svg:|",
    ":svg:tspan^:svg:textPositioning|",
    ":svg:text^:svg:textPositioning|",
    ":svg:textPath^:svg:textContent|",
    ":svg:title^:svg:|",
    ":svg:use^:svg:graphics|",
    ":svg:view^:svg:|#zoomAndPan",
    "data^[HTMLElement]|value",
    "keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name",
    "menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default",
    "summary^[HTMLElement]|",
    "time^[HTMLElement]|dateTime",
    ":svg:cursor^:svg:|"
  ];
  var _ATTR_TO_PROP = {
    "class": "className",
    "for": "htmlFor",
    "formaction": "formAction",
    "innerHtml": "innerHTML",
    "readonly": "readOnly",
    "tabindex": "tabIndex"
  };
  var _PROP_TO_ATTR = Object.keys(_ATTR_TO_PROP).reduce((inverted, attr) => {
    inverted[_ATTR_TO_PROP[attr]] = attr;
    return inverted;
  }, {});
  var DomElementSchemaRegistry = class extends ElementSchemaRegistry {
    constructor() {
      super();
      this._schema = {};
      this._eventSchema = {};
      SCHEMA.forEach((encodedType) => {
        const type = {};
        const events = /* @__PURE__ */ new Set();
        const [strType, strProperties] = encodedType.split("|");
        const properties = strProperties.split(",");
        const [typeNames, superName] = strType.split("^");
        typeNames.split(",").forEach((tag) => {
          this._schema[tag.toLowerCase()] = type;
          this._eventSchema[tag.toLowerCase()] = events;
        });
        const superType = superName && this._schema[superName.toLowerCase()];
        if (superType) {
          Object.keys(superType).forEach((prop) => {
            type[prop] = superType[prop];
          });
          for (const superEvent of this._eventSchema[superName.toLowerCase()]) {
            events.add(superEvent);
          }
        }
        properties.forEach((property) => {
          if (property.length > 0) {
            switch (property[0]) {
              case "*":
                events.add(property.substring(1));
                break;
              case "!":
                type[property.substring(1)] = BOOLEAN;
                break;
              case "#":
                type[property.substring(1)] = NUMBER;
                break;
              case "%":
                type[property.substring(1)] = OBJECT;
                break;
              default:
                type[property] = STRING;
            }
          }
        });
      });
    }
    hasProperty(tagName, propName, schemaMetas) {
      if (schemaMetas.some((schema) => schema.name === NO_ERRORS_SCHEMA2.name)) {
        return true;
      }
      if (tagName.indexOf("-") > -1) {
        if (isNgContainer(tagName) || isNgContent(tagName)) {
          return false;
        }
        if (schemaMetas.some((schema) => schema.name === CUSTOM_ELEMENTS_SCHEMA2.name)) {
          return true;
        }
      }
      const elementProperties = this._schema[tagName.toLowerCase()] || this._schema["unknown"];
      return !!elementProperties[propName];
    }
    hasElement(tagName, schemaMetas) {
      if (schemaMetas.some((schema) => schema.name === NO_ERRORS_SCHEMA2.name)) {
        return true;
      }
      if (tagName.indexOf("-") > -1) {
        if (isNgContainer(tagName) || isNgContent(tagName)) {
          return true;
        }
        if (schemaMetas.some((schema) => schema.name === CUSTOM_ELEMENTS_SCHEMA2.name)) {
          return true;
        }
      }
      return !!this._schema[tagName.toLowerCase()];
    }
    securityContext(tagName, propName, isAttribute) {
      if (isAttribute) {
        propName = this.getMappedPropName(propName);
      }
      tagName = tagName.toLowerCase();
      propName = propName.toLowerCase();
      let ctx = SECURITY_SCHEMA()[tagName + "|" + propName];
      if (ctx) {
        return ctx;
      }
      ctx = SECURITY_SCHEMA()["*|" + propName];
      return ctx ? ctx : SecurityContext2.NONE;
    }
    getMappedPropName(propName) {
      return _ATTR_TO_PROP[propName] || propName;
    }
    getDefaultComponentElementName() {
      return "ng-component";
    }
    validateProperty(name) {
      if (name.toLowerCase().startsWith("on")) {
        const msg = `Binding to event property '${name}' is disallowed for security reasons, please use (${name.slice(2)})=...
If '${name}' is a directive input, make sure the directive is imported by the current module.`;
        return { error: true, msg };
      } else {
        return { error: false };
      }
    }
    validateAttribute(name) {
      if (name.toLowerCase().startsWith("on")) {
        const msg = `Binding to event attribute '${name}' is disallowed for security reasons, please use (${name.slice(2)})=...`;
        return { error: true, msg };
      } else {
        return { error: false };
      }
    }
    allKnownElementNames() {
      return Object.keys(this._schema);
    }
    allKnownAttributesOfElement(tagName) {
      const elementProperties = this._schema[tagName.toLowerCase()] || this._schema["unknown"];
      return Object.keys(elementProperties).map((prop) => _PROP_TO_ATTR[prop] ?? prop);
    }
    allKnownEventsOfElement(tagName) {
      return Array.from(this._eventSchema[tagName.toLowerCase()] ?? []);
    }
    normalizeAnimationStyleProperty(propName) {
      return dashCaseToCamelCase(propName);
    }
    normalizeAnimationStyleValue(camelCaseProp, userProvidedProp, val) {
      let unit = "";
      const strVal = val.toString().trim();
      let errorMsg = null;
      if (_isPixelDimensionStyle(camelCaseProp) && val !== 0 && val !== "0") {
        if (typeof val === "number") {
          unit = "px";
        } else {
          const valAndSuffixMatch = val.match(/^[+-]?[\d\.]+([a-z]*)$/);
          if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {
            errorMsg = `Please provide a CSS unit value for ${userProvidedProp}:${val}`;
          }
        }
      }
      return { error: errorMsg, value: strVal + unit };
    }
  };
  function _isPixelDimensionStyle(prop) {
    switch (prop) {
      case "width":
      case "height":
      case "minWidth":
      case "minHeight":
      case "maxWidth":
      case "maxHeight":
      case "left":
      case "top":
      case "bottom":
      case "right":
      case "fontSize":
      case "outlineWidth":
      case "outlineOffset":
      case "paddingTop":
      case "paddingLeft":
      case "paddingBottom":
      case "paddingRight":
      case "marginTop":
      case "marginLeft":
      case "marginBottom":
      case "marginRight":
      case "borderRadius":
      case "borderWidth":
      case "borderTopWidth":
      case "borderLeftWidth":
      case "borderRightWidth":
      case "borderBottomWidth":
      case "textIndent":
        return true;
      default:
        return false;
    }
  }
  var TRUSTED_TYPES_SINKS = /* @__PURE__ */ new Set([
    "iframe|srcdoc",
    "*|innerhtml",
    "*|outerhtml",
    "embed|src",
    "object|codebase",
    "object|data"
  ]);
  function isTrustedTypesSink(tagName, propName) {
    tagName = tagName.toLowerCase();
    propName = propName.toLowerCase();
    return TRUSTED_TYPES_SINKS.has(tagName + "|" + propName) || TRUSTED_TYPES_SINKS.has("*|" + propName);
  }
  var BIND_NAME_REGEXP = /^(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*)$/;
  var KW_BIND_IDX = 1;
  var KW_LET_IDX = 2;
  var KW_REF_IDX = 3;
  var KW_ON_IDX = 4;
  var KW_BINDON_IDX = 5;
  var KW_AT_IDX = 6;
  var IDENT_KW_IDX = 7;
  var BINDING_DELIMS = {
    BANANA_BOX: { start: "[(", end: ")]" },
    PROPERTY: { start: "[", end: "]" },
    EVENT: { start: "(", end: ")" }
  };
  var TEMPLATE_ATTR_PREFIX = "*";
  function htmlAstToRender3Ast(htmlNodes, bindingParser, options) {
    const transformer = new HtmlAstToIvyAst(bindingParser, options);
    const ivyNodes = visitAll(transformer, htmlNodes);
    const allErrors = bindingParser.errors.concat(transformer.errors);
    const result = {
      nodes: ivyNodes,
      errors: allErrors,
      styleUrls: transformer.styleUrls,
      styles: transformer.styles,
      ngContentSelectors: transformer.ngContentSelectors
    };
    if (options.collectCommentNodes) {
      result.commentNodes = transformer.commentNodes;
    }
    return result;
  }
  var HtmlAstToIvyAst = class {
    constructor(bindingParser, options) {
      this.bindingParser = bindingParser;
      this.options = options;
      this.errors = [];
      this.styles = [];
      this.styleUrls = [];
      this.ngContentSelectors = [];
      this.commentNodes = [];
      this.inI18nBlock = false;
    }
    visitElement(element) {
      const isI18nRootElement = isI18nRootNode(element.i18n);
      if (isI18nRootElement) {
        if (this.inI18nBlock) {
          this.reportError("Cannot mark an element as translatable inside of a translatable section. Please remove the nested i18n marker.", element.sourceSpan);
        }
        this.inI18nBlock = true;
      }
      const preparsedElement = preparseElement(element);
      if (preparsedElement.type === PreparsedElementType.SCRIPT) {
        return null;
      } else if (preparsedElement.type === PreparsedElementType.STYLE) {
        const contents = textContents(element);
        if (contents !== null) {
          this.styles.push(contents);
        }
        return null;
      } else if (preparsedElement.type === PreparsedElementType.STYLESHEET && isStyleUrlResolvable(preparsedElement.hrefAttr)) {
        this.styleUrls.push(preparsedElement.hrefAttr);
        return null;
      }
      const isTemplateElement2 = isNgTemplate(element.name);
      const parsedProperties = [];
      const boundEvents = [];
      const variables = [];
      const references = [];
      const attributes = [];
      const i18nAttrsMeta = {};
      const templateParsedProperties = [];
      const templateVariables = [];
      let elementHasInlineTemplate = false;
      for (const attribute of element.attrs) {
        let hasBinding = false;
        const normalizedName = normalizeAttributeName(attribute.name);
        let isTemplateBinding = false;
        if (attribute.i18n) {
          i18nAttrsMeta[attribute.name] = attribute.i18n;
        }
        if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX)) {
          if (elementHasInlineTemplate) {
            this.reportError(`Can't have multiple template bindings on one element. Use only one attribute prefixed with *`, attribute.sourceSpan);
          }
          isTemplateBinding = true;
          elementHasInlineTemplate = true;
          const templateValue = attribute.value;
          const templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX.length);
          const parsedVariables = [];
          const absoluteValueOffset = attribute.valueSpan ? attribute.valueSpan.start.offset : attribute.sourceSpan.start.offset + attribute.name.length;
          this.bindingParser.parseInlineTemplateBinding(templateKey, templateValue, attribute.sourceSpan, absoluteValueOffset, [], templateParsedProperties, parsedVariables, true);
          templateVariables.push(...parsedVariables.map((v) => new Variable(v.name, v.value, v.sourceSpan, v.keySpan, v.valueSpan)));
        } else {
          hasBinding = this.parseAttribute(isTemplateElement2, attribute, [], parsedProperties, boundEvents, variables, references);
        }
        if (!hasBinding && !isTemplateBinding) {
          attributes.push(this.visitAttribute(attribute));
        }
      }
      const children = visitAll(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children);
      let parsedElement;
      if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {
        if (element.children && !element.children.every((node) => isEmptyTextNode(node) || isCommentNode(node))) {
          this.reportError(`<ng-content> element cannot have content.`, element.sourceSpan);
        }
        const selector = preparsedElement.selectAttr;
        const attrs = element.attrs.map((attr) => this.visitAttribute(attr));
        parsedElement = new Content(selector, attrs, element.sourceSpan, element.i18n);
        this.ngContentSelectors.push(selector);
      } else if (isTemplateElement2) {
        const attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);
        parsedElement = new Template(element.name, attributes, attrs.bound, boundEvents, [], children, references, variables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
      } else {
        const attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);
        parsedElement = new Element$1(element.name, attributes, attrs.bound, boundEvents, children, references, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
      }
      if (elementHasInlineTemplate) {
        const attrs = this.extractAttributes("ng-template", templateParsedProperties, i18nAttrsMeta);
        const templateAttrs = [];
        attrs.literal.forEach((attr) => templateAttrs.push(attr));
        attrs.bound.forEach((attr) => templateAttrs.push(attr));
        const hoistedAttrs = parsedElement instanceof Element$1 ? {
          attributes: parsedElement.attributes,
          inputs: parsedElement.inputs,
          outputs: parsedElement.outputs
        } : { attributes: [], inputs: [], outputs: [] };
        const i18n = isTemplateElement2 && isI18nRootElement ? void 0 : element.i18n;
        parsedElement = new Template(parsedElement.name, hoistedAttrs.attributes, hoistedAttrs.inputs, hoistedAttrs.outputs, templateAttrs, [parsedElement], [], templateVariables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, i18n);
      }
      if (isI18nRootElement) {
        this.inI18nBlock = false;
      }
      return parsedElement;
    }
    visitAttribute(attribute) {
      return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan, attribute.valueSpan, attribute.i18n);
    }
    visitText(text) {
      return this._visitTextWithInterpolation(text.value, text.sourceSpan, text.i18n);
    }
    visitExpansion(expansion) {
      if (!expansion.i18n) {
        return null;
      }
      if (!isI18nRootNode(expansion.i18n)) {
        throw new Error(`Invalid type "${expansion.i18n.constructor}" for "i18n" property of ${expansion.sourceSpan.toString()}. Expected a "Message"`);
      }
      const message = expansion.i18n;
      const vars = {};
      const placeholders = {};
      Object.keys(message.placeholders).forEach((key) => {
        const value = message.placeholders[key];
        if (key.startsWith(I18N_ICU_VAR_PREFIX)) {
          const formattedKey = key.trim();
          const ast = this.bindingParser.parseInterpolationExpression(value.text, value.sourceSpan);
          vars[formattedKey] = new BoundText(ast, value.sourceSpan);
        } else {
          placeholders[key] = this._visitTextWithInterpolation(value.text, value.sourceSpan);
        }
      });
      return new Icu$1(vars, placeholders, expansion.sourceSpan, message);
    }
    visitExpansionCase(expansionCase) {
      return null;
    }
    visitComment(comment) {
      if (this.options.collectCommentNodes) {
        this.commentNodes.push(new Comment$1(comment.value || "", comment.sourceSpan));
      }
      return null;
    }
    extractAttributes(elementName, properties, i18nPropsMeta) {
      const bound = [];
      const literal2 = [];
      properties.forEach((prop) => {
        const i18n = i18nPropsMeta[prop.name];
        if (prop.isLiteral) {
          literal2.push(new TextAttribute(prop.name, prop.expression.source || "", prop.sourceSpan, prop.keySpan, prop.valueSpan, i18n));
        } else {
          const bep = this.bindingParser.createBoundElementProperty(elementName, prop, true, false);
          bound.push(BoundAttribute.fromBoundElementProperty(bep, i18n));
        }
      });
      return { bound, literal: literal2 };
    }
    parseAttribute(isTemplateElement2, attribute, matchableAttributes, parsedProperties, boundEvents, variables, references) {
      const name = normalizeAttributeName(attribute.name);
      const value = attribute.value;
      const srcSpan = attribute.sourceSpan;
      const absoluteOffset = attribute.valueSpan ? attribute.valueSpan.start.offset : srcSpan.start.offset;
      function createKeySpan(srcSpan2, prefix, identifier) {
        const normalizationAdjustment = attribute.name.length - name.length;
        const keySpanStart = srcSpan2.start.moveBy(prefix.length + normalizationAdjustment);
        const keySpanEnd = keySpanStart.moveBy(identifier.length);
        return new ParseSourceSpan(keySpanStart, keySpanEnd, keySpanStart, identifier);
      }
      const bindParts = name.match(BIND_NAME_REGEXP);
      if (bindParts) {
        if (bindParts[KW_BIND_IDX] != null) {
          const identifier = bindParts[IDENT_KW_IDX];
          const keySpan2 = createKeySpan(srcSpan, bindParts[KW_BIND_IDX], identifier);
          this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan2);
        } else if (bindParts[KW_LET_IDX]) {
          if (isTemplateElement2) {
            const identifier = bindParts[IDENT_KW_IDX];
            const keySpan2 = createKeySpan(srcSpan, bindParts[KW_LET_IDX], identifier);
            this.parseVariable(identifier, value, srcSpan, keySpan2, attribute.valueSpan, variables);
          } else {
            this.reportError(`"let-" is only supported on ng-template elements.`, srcSpan);
          }
        } else if (bindParts[KW_REF_IDX]) {
          const identifier = bindParts[IDENT_KW_IDX];
          const keySpan2 = createKeySpan(srcSpan, bindParts[KW_REF_IDX], identifier);
          this.parseReference(identifier, value, srcSpan, keySpan2, attribute.valueSpan, references);
        } else if (bindParts[KW_ON_IDX]) {
          const events = [];
          const identifier = bindParts[IDENT_KW_IDX];
          const keySpan2 = createKeySpan(srcSpan, bindParts[KW_ON_IDX], identifier);
          this.bindingParser.parseEvent(identifier, value, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events, keySpan2);
          addEvents(events, boundEvents);
        } else if (bindParts[KW_BINDON_IDX]) {
          const identifier = bindParts[IDENT_KW_IDX];
          const keySpan2 = createKeySpan(srcSpan, bindParts[KW_BINDON_IDX], identifier);
          this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan2);
          this.parseAssignmentEvent(identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents, keySpan2);
        } else if (bindParts[KW_AT_IDX]) {
          const keySpan2 = createKeySpan(srcSpan, "", name);
          this.bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan2);
        }
        return true;
      }
      let delims = null;
      if (name.startsWith(BINDING_DELIMS.BANANA_BOX.start)) {
        delims = BINDING_DELIMS.BANANA_BOX;
      } else if (name.startsWith(BINDING_DELIMS.PROPERTY.start)) {
        delims = BINDING_DELIMS.PROPERTY;
      } else if (name.startsWith(BINDING_DELIMS.EVENT.start)) {
        delims = BINDING_DELIMS.EVENT;
      }
      if (delims !== null && name.endsWith(delims.end) && name.length > delims.start.length + delims.end.length) {
        const identifier = name.substring(delims.start.length, name.length - delims.end.length);
        const keySpan2 = createKeySpan(srcSpan, delims.start, identifier);
        if (delims.start === BINDING_DELIMS.BANANA_BOX.start) {
          this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan2);
          this.parseAssignmentEvent(identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents, keySpan2);
        } else if (delims.start === BINDING_DELIMS.PROPERTY.start) {
          this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan2);
        } else {
          const events = [];
          this.bindingParser.parseEvent(identifier, value, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events, keySpan2);
          addEvents(events, boundEvents);
        }
        return true;
      }
      const keySpan = createKeySpan(srcSpan, "", name);
      const hasBinding = this.bindingParser.parsePropertyInterpolation(name, value, srcSpan, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);
      return hasBinding;
    }
    _visitTextWithInterpolation(value, sourceSpan, i18n) {
      const valueNoNgsp = replaceNgsp2(value);
      const expr = this.bindingParser.parseInterpolation(valueNoNgsp, sourceSpan);
      return expr ? new BoundText(expr, sourceSpan, i18n) : new Text$3(valueNoNgsp, sourceSpan);
    }
    parseVariable(identifier, value, sourceSpan, keySpan, valueSpan, variables) {
      if (identifier.indexOf("-") > -1) {
        this.reportError(`"-" is not allowed in variable names`, sourceSpan);
      } else if (identifier.length === 0) {
        this.reportError(`Variable does not have a name`, sourceSpan);
      }
      variables.push(new Variable(identifier, value, sourceSpan, keySpan, valueSpan));
    }
    parseReference(identifier, value, sourceSpan, keySpan, valueSpan, references) {
      if (identifier.indexOf("-") > -1) {
        this.reportError(`"-" is not allowed in reference names`, sourceSpan);
      } else if (identifier.length === 0) {
        this.reportError(`Reference does not have a name`, sourceSpan);
      } else if (references.some((reference) => reference.name === identifier)) {
        this.reportError(`Reference "#${identifier}" is defined more than once`, sourceSpan);
      }
      references.push(new Reference(identifier, value, sourceSpan, keySpan, valueSpan));
    }
    parseAssignmentEvent(name, expression, sourceSpan, valueSpan, targetMatchableAttrs, boundEvents, keySpan) {
      const events = [];
      this.bindingParser.parseEvent(`${name}Change`, `${expression}=$event`, sourceSpan, valueSpan || sourceSpan, targetMatchableAttrs, events, keySpan);
      addEvents(events, boundEvents);
    }
    reportError(message, sourceSpan, level = ParseErrorLevel.ERROR) {
      this.errors.push(new ParseError(sourceSpan, message, level));
    }
  };
  var NonBindableVisitor = class {
    visitElement(ast) {
      const preparsedElement = preparseElement(ast);
      if (preparsedElement.type === PreparsedElementType.SCRIPT || preparsedElement.type === PreparsedElementType.STYLE || preparsedElement.type === PreparsedElementType.STYLESHEET) {
        return null;
      }
      const children = visitAll(this, ast.children, null);
      return new Element$1(ast.name, visitAll(this, ast.attrs), [], [], children, [], ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan);
    }
    visitComment(comment) {
      return null;
    }
    visitAttribute(attribute) {
      return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan, attribute.valueSpan, attribute.i18n);
    }
    visitText(text) {
      return new Text$3(text.value, text.sourceSpan);
    }
    visitExpansion(expansion) {
      return null;
    }
    visitExpansionCase(expansionCase) {
      return null;
    }
  };
  var NON_BINDABLE_VISITOR = new NonBindableVisitor();
  function normalizeAttributeName(attrName) {
    return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;
  }
  function addEvents(events, boundEvents) {
    boundEvents.push(...events.map((e) => BoundEvent.fromParsedEvent(e)));
  }
  function isEmptyTextNode(node) {
    return node instanceof Text2 && node.value.trim().length == 0;
  }
  function isCommentNode(node) {
    return node instanceof Comment;
  }
  function textContents(node) {
    if (node.children.length !== 1 || !(node.children[0] instanceof Text2)) {
      return null;
    } else {
      return node.children[0].value;
    }
  }
  var TagType;
  (function(TagType2) {
    TagType2[TagType2["ELEMENT"] = 0] = "ELEMENT";
    TagType2[TagType2["TEMPLATE"] = 1] = "TEMPLATE";
  })(TagType || (TagType = {}));
  function setupRegistry() {
    return { getUniqueId: getSeqNumberGenerator(), icus: /* @__PURE__ */ new Map() };
  }
  var I18nContext = class {
    constructor(index, ref, level = 0, templateIndex = null, meta, registry) {
      this.index = index;
      this.ref = ref;
      this.level = level;
      this.templateIndex = templateIndex;
      this.meta = meta;
      this.registry = registry;
      this.bindings = /* @__PURE__ */ new Set();
      this.placeholders = /* @__PURE__ */ new Map();
      this.isEmitted = false;
      this._unresolvedCtxCount = 0;
      this._registry = registry || setupRegistry();
      this.id = this._registry.getUniqueId();
    }
    appendTag(type, node, index, closed) {
      if (node.isVoid && closed) {
        return;
      }
      const ph = node.isVoid || !closed ? node.startName : node.closeName;
      const content = { type, index, ctx: this.id, isVoid: node.isVoid, closed };
      updatePlaceholderMap(this.placeholders, ph, content);
    }
    get icus() {
      return this._registry.icus;
    }
    get isRoot() {
      return this.level === 0;
    }
    get isResolved() {
      return this._unresolvedCtxCount === 0;
    }
    getSerializedPlaceholders() {
      const result = /* @__PURE__ */ new Map();
      this.placeholders.forEach((values, key) => result.set(key, values.map(serializePlaceholderValue)));
      return result;
    }
    appendBinding(binding) {
      this.bindings.add(binding);
    }
    appendIcu(name, ref) {
      updatePlaceholderMap(this._registry.icus, name, ref);
    }
    appendBoundText(node) {
      const phs = assembleBoundTextPlaceholders(node, this.bindings.size, this.id);
      phs.forEach((values, key) => updatePlaceholderMap(this.placeholders, key, ...values));
    }
    appendTemplate(node, index) {
      this.appendTag(TagType.TEMPLATE, node, index, false);
      this.appendTag(TagType.TEMPLATE, node, index, true);
      this._unresolvedCtxCount++;
    }
    appendElement(node, index, closed) {
      this.appendTag(TagType.ELEMENT, node, index, closed);
    }
    appendProjection(node, index) {
      this.appendTag(TagType.ELEMENT, node, index, false);
      this.appendTag(TagType.ELEMENT, node, index, true);
    }
    forkChildContext(index, templateIndex, meta) {
      return new I18nContext(index, this.ref, this.level + 1, templateIndex, meta, this._registry);
    }
    reconcileChildContext(context2) {
      ["start", "close"].forEach((op) => {
        const key = context2.meta[`${op}Name`];
        const phs = this.placeholders.get(key) || [];
        const tag = phs.find(findTemplateFn(this.id, context2.templateIndex));
        if (tag) {
          tag.ctx = context2.id;
        }
      });
      const childPhs = context2.placeholders;
      childPhs.forEach((values, key) => {
        const phs = this.placeholders.get(key);
        if (!phs) {
          this.placeholders.set(key, values);
          return;
        }
        const tmplIdx = phs.findIndex(findTemplateFn(context2.id, context2.templateIndex));
        if (tmplIdx >= 0) {
          const isCloseTag = key.startsWith("CLOSE");
          const isTemplateTag = key.endsWith("NG-TEMPLATE");
          if (isTemplateTag) {
            phs.splice(tmplIdx + (isCloseTag ? 0 : 1), 0, ...values);
          } else {
            const idx = isCloseTag ? values.length - 1 : 0;
            values[idx].tmpl = phs[tmplIdx];
            phs.splice(tmplIdx, 1, ...values);
          }
        } else {
          phs.push(...values);
        }
        this.placeholders.set(key, phs);
      });
      this._unresolvedCtxCount--;
    }
  };
  function wrap(symbol, index, contextId, closed) {
    const state = closed ? "/" : "";
    return wrapI18nPlaceholder(`${state}${symbol}${index}`, contextId);
  }
  function wrapTag(symbol, { index, ctx, isVoid }, closed) {
    return isVoid ? wrap(symbol, index, ctx) + wrap(symbol, index, ctx, true) : wrap(symbol, index, ctx, closed);
  }
  function findTemplateFn(ctx, templateIndex) {
    return (token) => typeof token === "object" && token.type === TagType.TEMPLATE && token.index === templateIndex && token.ctx === ctx;
  }
  function serializePlaceholderValue(value) {
    const element = (data, closed) => wrapTag("#", data, closed);
    const template = (data, closed) => wrapTag("*", data, closed);
    const projection = (data, closed) => wrapTag("!", data, closed);
    switch (value.type) {
      case TagType.ELEMENT:
        if (value.closed) {
          return element(value, true) + (value.tmpl ? template(value.tmpl, true) : "");
        }
        if (value.tmpl) {
          return template(value.tmpl) + element(value) + (value.isVoid ? template(value.tmpl, true) : "");
        }
        return element(value);
      case TagType.TEMPLATE:
        return template(value, value.closed);
      default:
        return value;
    }
  }
  var IcuSerializerVisitor = class {
    visitText(text) {
      return text.value;
    }
    visitContainer(container) {
      return container.children.map((child) => child.visit(this)).join("");
    }
    visitIcu(icu) {
      const strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);
      const result = `{${icu.expressionPlaceholder}, ${icu.type}, ${strCases.join(" ")}}`;
      return result;
    }
    visitTagPlaceholder(ph) {
      return ph.isVoid ? this.formatPh(ph.startName) : `${this.formatPh(ph.startName)}${ph.children.map((child) => child.visit(this)).join("")}${this.formatPh(ph.closeName)}`;
    }
    visitPlaceholder(ph) {
      return this.formatPh(ph.name);
    }
    visitIcuPlaceholder(ph, context2) {
      return this.formatPh(ph.name);
    }
    formatPh(value) {
      return `{${formatI18nPlaceholderName(value, false)}}`;
    }
  };
  var serializer = new IcuSerializerVisitor();
  function serializeIcuNode(icu) {
    return icu.visit(serializer);
  }
  var TAG_TO_PLACEHOLDER_NAMES = {
    "A": "LINK",
    "B": "BOLD_TEXT",
    "BR": "LINE_BREAK",
    "EM": "EMPHASISED_TEXT",
    "H1": "HEADING_LEVEL1",
    "H2": "HEADING_LEVEL2",
    "H3": "HEADING_LEVEL3",
    "H4": "HEADING_LEVEL4",
    "H5": "HEADING_LEVEL5",
    "H6": "HEADING_LEVEL6",
    "HR": "HORIZONTAL_RULE",
    "I": "ITALIC_TEXT",
    "LI": "LIST_ITEM",
    "LINK": "MEDIA_LINK",
    "OL": "ORDERED_LIST",
    "P": "PARAGRAPH",
    "Q": "QUOTATION",
    "S": "STRIKETHROUGH_TEXT",
    "SMALL": "SMALL_TEXT",
    "SUB": "SUBSTRIPT",
    "SUP": "SUPERSCRIPT",
    "TBODY": "TABLE_BODY",
    "TD": "TABLE_CELL",
    "TFOOT": "TABLE_FOOTER",
    "TH": "TABLE_HEADER_CELL",
    "THEAD": "TABLE_HEADER",
    "TR": "TABLE_ROW",
    "TT": "MONOSPACED_TEXT",
    "U": "UNDERLINED_TEXT",
    "UL": "UNORDERED_LIST"
  };
  var PlaceholderRegistry = class {
    constructor() {
      this._placeHolderNameCounts = {};
      this._signatureToName = {};
    }
    getStartTagPlaceholderName(tag, attrs, isVoid) {
      const signature = this._hashTag(tag, attrs, isVoid);
      if (this._signatureToName[signature]) {
        return this._signatureToName[signature];
      }
      const upperTag = tag.toUpperCase();
      const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;
      const name = this._generateUniqueName(isVoid ? baseName : `START_${baseName}`);
      this._signatureToName[signature] = name;
      return name;
    }
    getCloseTagPlaceholderName(tag) {
      const signature = this._hashClosingTag(tag);
      if (this._signatureToName[signature]) {
        return this._signatureToName[signature];
      }
      const upperTag = tag.toUpperCase();
      const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;
      const name = this._generateUniqueName(`CLOSE_${baseName}`);
      this._signatureToName[signature] = name;
      return name;
    }
    getPlaceholderName(name, content) {
      const upperName = name.toUpperCase();
      const signature = `PH: ${upperName}=${content}`;
      if (this._signatureToName[signature]) {
        return this._signatureToName[signature];
      }
      const uniqueName = this._generateUniqueName(upperName);
      this._signatureToName[signature] = uniqueName;
      return uniqueName;
    }
    getUniquePlaceholder(name) {
      return this._generateUniqueName(name.toUpperCase());
    }
    _hashTag(tag, attrs, isVoid) {
      const start = `<${tag}`;
      const strAttrs = Object.keys(attrs).sort().map((name) => ` ${name}=${attrs[name]}`).join("");
      const end = isVoid ? "/>" : `></${tag}>`;
      return start + strAttrs + end;
    }
    _hashClosingTag(tag) {
      return this._hashTag(`/${tag}`, {}, false);
    }
    _generateUniqueName(base) {
      const seen = this._placeHolderNameCounts.hasOwnProperty(base);
      if (!seen) {
        this._placeHolderNameCounts[base] = 1;
        return base;
      }
      const id = this._placeHolderNameCounts[base];
      this._placeHolderNameCounts[base] = id + 1;
      return `${base}_${id}`;
    }
  };
  var _expParser = new Parser(new Lexer());
  function createI18nMessageFactory(interpolationConfig) {
    const visitor = new _I18nVisitor(_expParser, interpolationConfig);
    return (nodes, meaning, description, customId, visitNodeFn) => visitor.toI18nMessage(nodes, meaning, description, customId, visitNodeFn);
  }
  function noopVisitNodeFn(_html, i18n) {
    return i18n;
  }
  var _I18nVisitor = class {
    constructor(_expressionParser, _interpolationConfig) {
      this._expressionParser = _expressionParser;
      this._interpolationConfig = _interpolationConfig;
    }
    toI18nMessage(nodes, meaning = "", description = "", customId = "", visitNodeFn) {
      const context2 = {
        isIcu: nodes.length == 1 && nodes[0] instanceof Expansion,
        icuDepth: 0,
        placeholderRegistry: new PlaceholderRegistry(),
        placeholderToContent: {},
        placeholderToMessage: {},
        visitNodeFn: visitNodeFn || noopVisitNodeFn
      };
      const i18nodes = visitAll(this, nodes, context2);
      return new Message(i18nodes, context2.placeholderToContent, context2.placeholderToMessage, meaning, description, customId);
    }
    visitElement(el, context2) {
      const children = visitAll(this, el.children, context2);
      const attrs = {};
      el.attrs.forEach((attr) => {
        attrs[attr.name] = attr.value;
      });
      const isVoid = getHtmlTagDefinition(el.name).isVoid;
      const startPhName = context2.placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);
      context2.placeholderToContent[startPhName] = {
        text: el.startSourceSpan.toString(),
        sourceSpan: el.startSourceSpan
      };
      let closePhName = "";
      if (!isVoid) {
        closePhName = context2.placeholderRegistry.getCloseTagPlaceholderName(el.name);
        context2.placeholderToContent[closePhName] = {
          text: `</${el.name}>`,
          sourceSpan: el.endSourceSpan ?? el.sourceSpan
        };
      }
      const node = new TagPlaceholder(el.name, attrs, startPhName, closePhName, children, isVoid, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);
      return context2.visitNodeFn(el, node);
    }
    visitAttribute(attribute, context2) {
      const node = attribute.valueTokens === void 0 || attribute.valueTokens.length === 1 ? new Text$2(attribute.value, attribute.valueSpan || attribute.sourceSpan) : this._visitTextWithInterpolation(attribute.valueTokens, attribute.valueSpan || attribute.sourceSpan, context2, attribute.i18n);
      return context2.visitNodeFn(attribute, node);
    }
    visitText(text, context2) {
      const node = text.tokens.length === 1 ? new Text$2(text.value, text.sourceSpan) : this._visitTextWithInterpolation(text.tokens, text.sourceSpan, context2, text.i18n);
      return context2.visitNodeFn(text, node);
    }
    visitComment(comment, context2) {
      return null;
    }
    visitExpansion(icu, context2) {
      context2.icuDepth++;
      const i18nIcuCases = {};
      const i18nIcu = new Icu(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);
      icu.cases.forEach((caze) => {
        i18nIcuCases[caze.value] = new Container(caze.expression.map((node2) => node2.visit(this, context2)), caze.expSourceSpan);
      });
      context2.icuDepth--;
      if (context2.isIcu || context2.icuDepth > 0) {
        const expPh = context2.placeholderRegistry.getUniquePlaceholder(`VAR_${icu.type}`);
        i18nIcu.expressionPlaceholder = expPh;
        context2.placeholderToContent[expPh] = {
          text: icu.switchValue,
          sourceSpan: icu.switchValueSourceSpan
        };
        return context2.visitNodeFn(icu, i18nIcu);
      }
      const phName = context2.placeholderRegistry.getPlaceholderName("ICU", icu.sourceSpan.toString());
      context2.placeholderToMessage[phName] = this.toI18nMessage([icu], "", "", "", void 0);
      const node = new IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);
      return context2.visitNodeFn(icu, node);
    }
    visitExpansionCase(_icuCase, _context) {
      throw new Error("Unreachable code");
    }
    _visitTextWithInterpolation(tokens, sourceSpan, context2, previousI18n) {
      const nodes = [];
      let hasInterpolation = false;
      for (const token of tokens) {
        switch (token.type) {
          case 8:
          case 17:
            hasInterpolation = true;
            const expression = token.parts[1];
            const baseName = extractPlaceholderName(expression) || "INTERPOLATION";
            const phName = context2.placeholderRegistry.getPlaceholderName(baseName, expression);
            context2.placeholderToContent[phName] = {
              text: token.parts.join(""),
              sourceSpan: token.sourceSpan
            };
            nodes.push(new Placeholder(expression, phName, token.sourceSpan));
            break;
          default:
            if (token.parts[0].length > 0) {
              const previous = nodes[nodes.length - 1];
              if (previous instanceof Text$2) {
                previous.value += token.parts[0];
                previous.sourceSpan = new ParseSourceSpan(previous.sourceSpan.start, token.sourceSpan.end, previous.sourceSpan.fullStart, previous.sourceSpan.details);
              } else {
                nodes.push(new Text$2(token.parts[0], token.sourceSpan));
              }
            }
            break;
        }
      }
      if (hasInterpolation) {
        reusePreviousSourceSpans(nodes, previousI18n);
        return new Container(nodes, sourceSpan);
      } else {
        return nodes[0];
      }
    }
  };
  function reusePreviousSourceSpans(nodes, previousI18n) {
    if (previousI18n instanceof Message) {
      assertSingleContainerMessage(previousI18n);
      previousI18n = previousI18n.nodes[0];
    }
    if (previousI18n instanceof Container) {
      assertEquivalentNodes(previousI18n.children, nodes);
      for (let i = 0; i < nodes.length; i++) {
        nodes[i].sourceSpan = previousI18n.children[i].sourceSpan;
      }
    }
  }
  function assertSingleContainerMessage(message) {
    const nodes = message.nodes;
    if (nodes.length !== 1 || !(nodes[0] instanceof Container)) {
      throw new Error("Unexpected previous i18n message - expected it to consist of only a single `Container` node.");
    }
  }
  function assertEquivalentNodes(previousNodes, nodes) {
    if (previousNodes.length !== nodes.length) {
      throw new Error("The number of i18n message children changed between first and second pass.");
    }
    if (previousNodes.some((node, i) => nodes[i].constructor !== node.constructor)) {
      throw new Error("The types of the i18n message children changed between first and second pass.");
    }
  }
  var _CUSTOM_PH_EXP = /\/\/[\s\S]*i18n[\s\S]*\([\s\S]*ph[\s\S]*=[\s\S]*("|')([\s\S]*?)\1[\s\S]*\)/g;
  function extractPlaceholderName(input) {
    return input.split(_CUSTOM_PH_EXP)[2];
  }
  var I18nError = class extends ParseError {
    constructor(span, msg) {
      super(span, msg);
    }
  };
  var setI18nRefs = (htmlNode, i18nNode) => {
    if (htmlNode instanceof NodeWithI18n) {
      if (i18nNode instanceof IcuPlaceholder && htmlNode.i18n instanceof Message) {
        i18nNode.previousMessage = htmlNode.i18n;
      }
      htmlNode.i18n = i18nNode;
    }
    return i18nNode;
  };
  var I18nMetaVisitor = class {
    constructor(interpolationConfig = DEFAULT_INTERPOLATION_CONFIG, keepI18nAttrs = false, enableI18nLegacyMessageIdFormat = false) {
      this.interpolationConfig = interpolationConfig;
      this.keepI18nAttrs = keepI18nAttrs;
      this.enableI18nLegacyMessageIdFormat = enableI18nLegacyMessageIdFormat;
      this.hasI18nMeta = false;
      this._errors = [];
      this._createI18nMessage = createI18nMessageFactory(this.interpolationConfig);
    }
    _generateI18nMessage(nodes, meta = "", visitNodeFn) {
      const { meaning, description, customId } = this._parseMetadata(meta);
      const message = this._createI18nMessage(nodes, meaning, description, customId, visitNodeFn);
      this._setMessageId(message, meta);
      this._setLegacyIds(message, meta);
      return message;
    }
    visitAllWithErrors(nodes) {
      const result = nodes.map((node) => node.visit(this, null));
      return new ParseTreeResult(result, this._errors);
    }
    visitElement(element) {
      if (hasI18nAttrs(element)) {
        this.hasI18nMeta = true;
        const attrs = [];
        const attrsMeta = {};
        for (const attr of element.attrs) {
          if (attr.name === I18N_ATTR) {
            const i18n = element.i18n || attr.value;
            const message = this._generateI18nMessage(element.children, i18n, setI18nRefs);
            if (message.nodes.length) {
              element.i18n = message;
            }
          } else if (attr.name.startsWith(I18N_ATTR_PREFIX)) {
            const name = attr.name.slice(I18N_ATTR_PREFIX.length);
            if (isTrustedTypesSink(element.name, name)) {
              this._reportError(attr, `Translating attribute '${name}' is disallowed for security reasons.`);
            } else {
              attrsMeta[name] = attr.value;
            }
          } else {
            attrs.push(attr);
          }
        }
        if (Object.keys(attrsMeta).length) {
          for (const attr of attrs) {
            const meta = attrsMeta[attr.name];
            if (meta !== void 0 && attr.value) {
              attr.i18n = this._generateI18nMessage([attr], attr.i18n || meta);
            }
          }
        }
        if (!this.keepI18nAttrs) {
          element.attrs = attrs;
        }
      }
      visitAll(this, element.children, element.i18n);
      return element;
    }
    visitExpansion(expansion, currentMessage) {
      let message;
      const meta = expansion.i18n;
      this.hasI18nMeta = true;
      if (meta instanceof IcuPlaceholder) {
        const name = meta.name;
        message = this._generateI18nMessage([expansion], meta);
        const icu = icuFromI18nMessage(message);
        icu.name = name;
      } else {
        message = this._generateI18nMessage([expansion], currentMessage || meta);
      }
      expansion.i18n = message;
      return expansion;
    }
    visitText(text) {
      return text;
    }
    visitAttribute(attribute) {
      return attribute;
    }
    visitComment(comment) {
      return comment;
    }
    visitExpansionCase(expansionCase) {
      return expansionCase;
    }
    _parseMetadata(meta) {
      return typeof meta === "string" ? parseI18nMeta(meta) : meta instanceof Message ? meta : {};
    }
    _setMessageId(message, meta) {
      if (!message.id) {
        message.id = meta instanceof Message && meta.id || decimalDigest(message);
      }
    }
    _setLegacyIds(message, meta) {
      if (this.enableI18nLegacyMessageIdFormat) {
        message.legacyIds = [computeDigest(message), computeDecimalDigest(message)];
      } else if (typeof meta !== "string") {
        const previousMessage = meta instanceof Message ? meta : meta instanceof IcuPlaceholder ? meta.previousMessage : void 0;
        message.legacyIds = previousMessage ? previousMessage.legacyIds : [];
      }
    }
    _reportError(node, msg) {
      this._errors.push(new I18nError(node.sourceSpan, msg));
    }
  };
  var I18N_MEANING_SEPARATOR = "|";
  var I18N_ID_SEPARATOR = "@@";
  function parseI18nMeta(meta = "") {
    let customId;
    let meaning;
    let description;
    meta = meta.trim();
    if (meta) {
      const idIndex = meta.indexOf(I18N_ID_SEPARATOR);
      const descIndex = meta.indexOf(I18N_MEANING_SEPARATOR);
      let meaningAndDesc;
      [meaningAndDesc, customId] = idIndex > -1 ? [meta.slice(0, idIndex), meta.slice(idIndex + 2)] : [meta, ""];
      [meaning, description] = descIndex > -1 ? [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] : ["", meaningAndDesc];
    }
    return { customId, meaning, description };
  }
  function i18nMetaToJSDoc(meta) {
    const tags = [];
    if (meta.description) {
      tags.push({ tagName: "desc", text: meta.description });
    }
    if (meta.meaning) {
      tags.push({ tagName: "meaning", text: meta.meaning });
    }
    return tags.length == 0 ? null : jsDocComment(tags);
  }
  var GOOG_GET_MSG = "goog.getMsg";
  function createGoogleGetMsgStatements(variable$1, message, closureVar, params) {
    const messageString = serializeI18nMessageForGetMsg(message);
    const args = [literal(messageString)];
    if (Object.keys(params).length) {
      args.push(mapLiteral(params, true));
    }
    const googGetMsgStmt = closureVar.set(variable(GOOG_GET_MSG).callFn(args)).toConstDecl();
    const metaComment = i18nMetaToJSDoc(message);
    if (metaComment !== null) {
      googGetMsgStmt.addLeadingComment(metaComment);
    }
    const i18nAssignmentStmt = new ExpressionStatement(variable$1.set(closureVar));
    return [googGetMsgStmt, i18nAssignmentStmt];
  }
  var GetMsgSerializerVisitor = class {
    formatPh(value) {
      return `{$${formatI18nPlaceholderName(value)}}`;
    }
    visitText(text) {
      return text.value;
    }
    visitContainer(container) {
      return container.children.map((child) => child.visit(this)).join("");
    }
    visitIcu(icu) {
      return serializeIcuNode(icu);
    }
    visitTagPlaceholder(ph) {
      return ph.isVoid ? this.formatPh(ph.startName) : `${this.formatPh(ph.startName)}${ph.children.map((child) => child.visit(this)).join("")}${this.formatPh(ph.closeName)}`;
    }
    visitPlaceholder(ph) {
      return this.formatPh(ph.name);
    }
    visitIcuPlaceholder(ph, context2) {
      return this.formatPh(ph.name);
    }
  };
  var serializerVisitor$1 = new GetMsgSerializerVisitor();
  function serializeI18nMessageForGetMsg(message) {
    return message.nodes.map((node) => node.visit(serializerVisitor$1, null)).join("");
  }
  function createLocalizeStatements(variable2, message, params) {
    const { messageParts, placeHolders } = serializeI18nMessageForLocalize(message);
    const sourceSpan = getSourceSpan(message);
    const expressions = placeHolders.map((ph) => params[ph.text]);
    const localizedString$1 = localizedString(message, messageParts, placeHolders, expressions, sourceSpan);
    const variableInitialization = variable2.set(localizedString$1);
    return [new ExpressionStatement(variableInitialization)];
  }
  var LocalizeSerializerVisitor = class {
    visitText(text, context2) {
      if (context2[context2.length - 1] instanceof LiteralPiece) {
        context2[context2.length - 1].text += text.value;
      } else {
        const sourceSpan = new ParseSourceSpan(text.sourceSpan.fullStart, text.sourceSpan.end, text.sourceSpan.fullStart, text.sourceSpan.details);
        context2.push(new LiteralPiece(text.value, sourceSpan));
      }
    }
    visitContainer(container, context2) {
      container.children.forEach((child) => child.visit(this, context2));
    }
    visitIcu(icu, context2) {
      context2.push(new LiteralPiece(serializeIcuNode(icu), icu.sourceSpan));
    }
    visitTagPlaceholder(ph, context2) {
      context2.push(this.createPlaceholderPiece(ph.startName, ph.startSourceSpan ?? ph.sourceSpan));
      if (!ph.isVoid) {
        ph.children.forEach((child) => child.visit(this, context2));
        context2.push(this.createPlaceholderPiece(ph.closeName, ph.endSourceSpan ?? ph.sourceSpan));
      }
    }
    visitPlaceholder(ph, context2) {
      context2.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan));
    }
    visitIcuPlaceholder(ph, context2) {
      context2.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan));
    }
    createPlaceholderPiece(name, sourceSpan) {
      return new PlaceholderPiece(formatI18nPlaceholderName(name, false), sourceSpan);
    }
  };
  var serializerVisitor = new LocalizeSerializerVisitor();
  function serializeI18nMessageForLocalize(message) {
    const pieces = [];
    message.nodes.forEach((node) => node.visit(serializerVisitor, pieces));
    return processMessagePieces(pieces);
  }
  function getSourceSpan(message) {
    const startNode = message.nodes[0];
    const endNode = message.nodes[message.nodes.length - 1];
    return new ParseSourceSpan(startNode.sourceSpan.fullStart, endNode.sourceSpan.end, startNode.sourceSpan.fullStart, startNode.sourceSpan.details);
  }
  function processMessagePieces(pieces) {
    const messageParts = [];
    const placeHolders = [];
    if (pieces[0] instanceof PlaceholderPiece) {
      messageParts.push(createEmptyMessagePart(pieces[0].sourceSpan.start));
    }
    for (let i = 0; i < pieces.length; i++) {
      const part = pieces[i];
      if (part instanceof LiteralPiece) {
        messageParts.push(part);
      } else {
        placeHolders.push(part);
        if (pieces[i - 1] instanceof PlaceholderPiece) {
          messageParts.push(createEmptyMessagePart(pieces[i - 1].sourceSpan.end));
        }
      }
    }
    if (pieces[pieces.length - 1] instanceof PlaceholderPiece) {
      messageParts.push(createEmptyMessagePart(pieces[pieces.length - 1].sourceSpan.end));
    }
    return { messageParts, placeHolders };
  }
  function createEmptyMessagePart(location2) {
    return new LiteralPiece("", new ParseSourceSpan(location2, location2));
  }
  var NG_CONTENT_SELECT_ATTR = "select";
  var NG_PROJECT_AS_ATTR_NAME = "ngProjectAs";
  var EVENT_BINDING_SCOPE_GLOBALS = /* @__PURE__ */ new Set(["$event"]);
  var GLOBAL_TARGET_RESOLVERS = /* @__PURE__ */ new Map([["window", Identifiers$1.resolveWindow], ["document", Identifiers$1.resolveDocument], ["body", Identifiers$1.resolveBody]]);
  var LEADING_TRIVIA_CHARS = [" ", "\n", "\r", "	"];
  function renderFlagCheckIfStmt(flags, statements) {
    return ifStmt(variable(RENDER_FLAGS).bitwiseAnd(literal(flags), null, false), statements);
  }
  function prepareEventListenerParameters(eventAst, handlerName = null, scope = null) {
    const { type, name, target, phase, handler } = eventAst;
    if (target && !GLOBAL_TARGET_RESOLVERS.has(target)) {
      throw new Error(`Unexpected global target '${target}' defined for '${name}' event.
        Supported list of global targets: ${Array.from(GLOBAL_TARGET_RESOLVERS.keys())}.`);
    }
    const eventArgumentName = "$event";
    const implicitReceiverAccesses = /* @__PURE__ */ new Set();
    const implicitReceiverExpr = scope === null || scope.bindingLevel === 0 ? variable(CONTEXT_NAME) : scope.getOrCreateSharedContextVar(0);
    const bindingExpr = convertActionBinding(scope, implicitReceiverExpr, handler, "b", () => error2("Unexpected interpolation"), eventAst.handlerSpan, implicitReceiverAccesses, EVENT_BINDING_SCOPE_GLOBALS);
    const statements = [];
    if (scope) {
      statements.push(...scope.variableDeclarations());
      statements.unshift(...scope.restoreViewStatement());
    }
    statements.push(...bindingExpr.render3Stmts);
    const eventName = type === 1 ? prepareSyntheticListenerName(name, phase) : name;
    const fnName = handlerName && sanitizeIdentifier(handlerName);
    const fnArgs = [];
    if (implicitReceiverAccesses.has(eventArgumentName)) {
      fnArgs.push(new FnParam(eventArgumentName, DYNAMIC_TYPE));
    }
    const handlerFn = fn(fnArgs, statements, INFERRED_TYPE, null, fnName);
    const params = [literal(eventName), handlerFn];
    if (target) {
      params.push(literal(false), importExpr(GLOBAL_TARGET_RESOLVERS.get(target)));
    }
    return params;
  }
  function createComponentDefConsts() {
    return {
      prepareStatements: [],
      constExpressions: [],
      i18nVarRefsCache: /* @__PURE__ */ new Map()
    };
  }
  var TemplateDefinitionBuilder = class {
    constructor(constantPool, parentBindingScope, level = 0, contextName, i18nContext, templateIndex, templateName, directiveMatcher, directives, pipeTypeByName, pipes, _namespace, relativeContextFilePath, i18nUseExternalIds, _constants = createComponentDefConsts()) {
      this.constantPool = constantPool;
      this.level = level;
      this.contextName = contextName;
      this.i18nContext = i18nContext;
      this.templateIndex = templateIndex;
      this.templateName = templateName;
      this.directiveMatcher = directiveMatcher;
      this.directives = directives;
      this.pipeTypeByName = pipeTypeByName;
      this.pipes = pipes;
      this._namespace = _namespace;
      this.i18nUseExternalIds = i18nUseExternalIds;
      this._constants = _constants;
      this._dataIndex = 0;
      this._bindingContext = 0;
      this._prefixCode = [];
      this._creationCodeFns = [];
      this._updateCodeFns = [];
      this._currentIndex = 0;
      this._tempVariables = [];
      this._nestedTemplateFns = [];
      this._unsupported = unsupported;
      this.i18n = null;
      this._pureFunctionSlots = 0;
      this._bindingSlots = 0;
      this._ngContentReservedSlots = [];
      this._ngContentSelectorsOffset = 0;
      this._implicitReceiverExpr = null;
      this.visitReference = invalid;
      this.visitVariable = invalid;
      this.visitTextAttribute = invalid;
      this.visitBoundAttribute = invalid;
      this.visitBoundEvent = invalid;
      this._bindingScope = parentBindingScope.nestedScope(level);
      this.fileBasedI18nSuffix = relativeContextFilePath.replace(/[^A-Za-z0-9]/g, "_") + "_";
      this._valueConverter = new ValueConverter(constantPool, () => this.allocateDataSlot(), (numSlots) => this.allocatePureFunctionSlots(numSlots), (name, localName, slot, value) => {
        const pipeType = pipeTypeByName.get(name);
        if (pipeType) {
          this.pipes.add(pipeType);
        }
        this._bindingScope.set(this.level, localName, value);
        this.creationInstruction(null, Identifiers$1.pipe, [literal(slot), literal(name)]);
      });
    }
    buildTemplateFunction(nodes, variables, ngContentSelectorsOffset = 0, i18n) {
      this._ngContentSelectorsOffset = ngContentSelectorsOffset;
      if (this._namespace !== Identifiers$1.namespaceHTML) {
        this.creationInstruction(null, this._namespace);
      }
      variables.forEach((v) => this.registerContextVariables(v));
      const initI18nContext = this.i18nContext || isI18nRootNode(i18n) && !isSingleI18nIcu(i18n) && !(isSingleElementTemplate(nodes) && nodes[0].i18n === i18n);
      const selfClosingI18nInstruction = hasTextChildrenOnly(nodes);
      if (initI18nContext) {
        this.i18nStart(null, i18n, selfClosingI18nInstruction);
      }
      visitAll$1(this, nodes);
      this._pureFunctionSlots += this._bindingSlots;
      this._valueConverter.updatePipeSlotOffsets(this._bindingSlots);
      this._nestedTemplateFns.forEach((buildTemplateFn) => buildTemplateFn());
      if (this.level === 0 && this._ngContentReservedSlots.length) {
        const parameters = [];
        if (this._ngContentReservedSlots.length > 1 || this._ngContentReservedSlots[0] !== "*") {
          const r3ReservedSlots = this._ngContentReservedSlots.map((s) => s !== "*" ? parseSelectorToR3Selector(s) : s);
          parameters.push(this.constantPool.getConstLiteral(asLiteral(r3ReservedSlots), true));
        }
        this.creationInstruction(null, Identifiers$1.projectionDef, parameters, true);
      }
      if (initI18nContext) {
        this.i18nEnd(null, selfClosingI18nInstruction);
      }
      const creationStatements = this._creationCodeFns.map((fn2) => fn2());
      const updateStatements = this._updateCodeFns.map((fn2) => fn2());
      const creationVariables = this._bindingScope.viewSnapshotStatements();
      const updateVariables = this._bindingScope.variableDeclarations().concat(this._tempVariables);
      const creationBlock = creationStatements.length > 0 ? [renderFlagCheckIfStmt(1, creationVariables.concat(creationStatements))] : [];
      const updateBlock = updateStatements.length > 0 ? [renderFlagCheckIfStmt(2, updateVariables.concat(updateStatements))] : [];
      return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], [
        ...this._prefixCode,
        ...creationBlock,
        ...updateBlock
      ], INFERRED_TYPE, null, this.templateName);
    }
    getLocal(name) {
      return this._bindingScope.get(name);
    }
    notifyImplicitReceiverUse() {
      this._bindingScope.notifyImplicitReceiverUse();
    }
    maybeRestoreView() {
      this._bindingScope.maybeRestoreView();
    }
    i18nTranslate(message, params = {}, ref, transformFn) {
      const _ref = ref || this.i18nGenerateMainBlockVar();
      const closureVar = this.i18nGenerateClosureVar(message.id);
      const statements = getTranslationDeclStmts(message, _ref, closureVar, params, transformFn);
      this._constants.prepareStatements.push(...statements);
      return _ref;
    }
    registerContextVariables(variable$1) {
      const scopedName = this._bindingScope.freshReferenceName();
      const retrievalLevel = this.level;
      const lhs = variable(variable$1.name + scopedName);
      this._bindingScope.set(retrievalLevel, variable$1.name, lhs, 1, (scope, relativeLevel) => {
        let rhs;
        if (scope.bindingLevel === retrievalLevel) {
          if (scope.isListenerScope() && scope.hasRestoreViewVariable()) {
            rhs = variable(RESTORED_VIEW_CONTEXT_NAME);
            scope.notifyRestoredViewContextUse();
          } else {
            rhs = variable(CONTEXT_NAME);
          }
        } else {
          const sharedCtxVar = scope.getSharedContextName(retrievalLevel);
          rhs = sharedCtxVar ? sharedCtxVar : generateNextContextExpr(relativeLevel);
        }
        return [lhs.set(rhs.prop(variable$1.value || IMPLICIT_REFERENCE)).toConstDecl()];
      });
    }
    i18nAppendBindings(expressions) {
      if (expressions.length > 0) {
        expressions.forEach((expression) => this.i18n.appendBinding(expression));
      }
    }
    i18nBindProps(props) {
      const bound = {};
      Object.keys(props).forEach((key) => {
        const prop = props[key];
        if (prop instanceof Text$3) {
          bound[key] = literal(prop.value);
        } else {
          const value = prop.value.visit(this._valueConverter);
          this.allocateBindingSlots(value);
          if (value instanceof Interpolation) {
            const { strings, expressions } = value;
            const { id, bindings } = this.i18n;
            const label = assembleI18nBoundString(strings, bindings.size, id);
            this.i18nAppendBindings(expressions);
            bound[key] = literal(label);
          }
        }
      });
      return bound;
    }
    i18nGenerateMainBlockVar() {
      return variable(this.constantPool.uniqueName(TRANSLATION_VAR_PREFIX));
    }
    i18nGenerateClosureVar(messageId) {
      let name;
      const suffix = this.fileBasedI18nSuffix.toUpperCase();
      if (this.i18nUseExternalIds) {
        const prefix = getTranslationConstPrefix(`EXTERNAL_`);
        const uniqueSuffix = this.constantPool.uniqueName(suffix);
        name = `${prefix}${sanitizeIdentifier(messageId)}$$${uniqueSuffix}`;
      } else {
        const prefix = getTranslationConstPrefix(suffix);
        name = this.constantPool.uniqueName(prefix);
      }
      return variable(name);
    }
    i18nUpdateRef(context2) {
      const { icus, meta, isRoot, isResolved, isEmitted } = context2;
      if (isRoot && isResolved && !isEmitted && !isSingleI18nIcu(meta)) {
        context2.isEmitted = true;
        const placeholders = context2.getSerializedPlaceholders();
        let icuMapping = {};
        let params = placeholders.size ? placeholdersToParams(placeholders) : {};
        if (icus.size) {
          icus.forEach((refs, key) => {
            if (refs.length === 1) {
              params[key] = refs[0];
            } else {
              const placeholder = wrapI18nPlaceholder(`${I18N_ICU_MAPPING_PREFIX}${key}`);
              params[key] = literal(placeholder);
              icuMapping[key] = literalArr(refs);
            }
          });
        }
        const needsPostprocessing = Array.from(placeholders.values()).some((value) => value.length > 1) || Object.keys(icuMapping).length;
        let transformFn;
        if (needsPostprocessing) {
          transformFn = (raw) => {
            const args = [raw];
            if (Object.keys(icuMapping).length) {
              args.push(mapLiteral(icuMapping, true));
            }
            return instruction(null, Identifiers$1.i18nPostprocess, args);
          };
        }
        this.i18nTranslate(meta, params, context2.ref, transformFn);
      }
    }
    i18nStart(span = null, meta, selfClosing) {
      const index = this.allocateDataSlot();
      this.i18n = this.i18nContext ? this.i18nContext.forkChildContext(index, this.templateIndex, meta) : new I18nContext(index, this.i18nGenerateMainBlockVar(), 0, this.templateIndex, meta);
      const { id, ref } = this.i18n;
      const params = [literal(index), this.addToConsts(ref)];
      if (id > 0) {
        params.push(literal(id));
      }
      this.creationInstruction(span, selfClosing ? Identifiers$1.i18n : Identifiers$1.i18nStart, params);
    }
    i18nEnd(span = null, selfClosing) {
      if (!this.i18n) {
        throw new Error("i18nEnd is executed with no i18n context present");
      }
      if (this.i18nContext) {
        this.i18nContext.reconcileChildContext(this.i18n);
        this.i18nUpdateRef(this.i18nContext);
      } else {
        this.i18nUpdateRef(this.i18n);
      }
      const { index, bindings } = this.i18n;
      if (bindings.size) {
        const chainBindings = [];
        bindings.forEach((binding) => {
          chainBindings.push({ sourceSpan: span, value: () => this.convertPropertyBinding(binding) });
        });
        this.updateInstructionChainWithAdvance(this.getConstCount() - 1, Identifiers$1.i18nExp, chainBindings);
        this.updateInstruction(span, Identifiers$1.i18nApply, [literal(index)]);
      }
      if (!selfClosing) {
        this.creationInstruction(span, Identifiers$1.i18nEnd);
      }
      this.i18n = null;
    }
    i18nAttributesInstruction(nodeIndex, attrs, sourceSpan) {
      let hasBindings = false;
      const i18nAttrArgs = [];
      const bindings = [];
      attrs.forEach((attr) => {
        const message = attr.i18n;
        const converted = attr.value.visit(this._valueConverter);
        this.allocateBindingSlots(converted);
        if (converted instanceof Interpolation) {
          const placeholders = assembleBoundTextPlaceholders(message);
          const params = placeholdersToParams(placeholders);
          i18nAttrArgs.push(literal(attr.name), this.i18nTranslate(message, params));
          converted.expressions.forEach((expression) => {
            hasBindings = true;
            bindings.push({
              sourceSpan,
              value: () => this.convertPropertyBinding(expression)
            });
          });
        }
      });
      if (bindings.length > 0) {
        this.updateInstructionChainWithAdvance(nodeIndex, Identifiers$1.i18nExp, bindings);
      }
      if (i18nAttrArgs.length > 0) {
        const index = literal(this.allocateDataSlot());
        const constIndex = this.addToConsts(literalArr(i18nAttrArgs));
        this.creationInstruction(sourceSpan, Identifiers$1.i18nAttributes, [index, constIndex]);
        if (hasBindings) {
          this.updateInstruction(sourceSpan, Identifiers$1.i18nApply, [index]);
        }
      }
    }
    getNamespaceInstruction(namespaceKey) {
      switch (namespaceKey) {
        case "math":
          return Identifiers$1.namespaceMathML;
        case "svg":
          return Identifiers$1.namespaceSVG;
        default:
          return Identifiers$1.namespaceHTML;
      }
    }
    addNamespaceInstruction(nsInstruction, element) {
      this._namespace = nsInstruction;
      this.creationInstruction(element.startSourceSpan, nsInstruction);
    }
    interpolatedUpdateInstruction(instruction2, elementIndex, attrName, input, value, params) {
      this.updateInstructionWithAdvance(elementIndex, input.sourceSpan, instruction2, () => [literal(attrName), ...this.getUpdateInstructionArguments(value), ...params]);
    }
    visitContent(ngContent) {
      const slot = this.allocateDataSlot();
      const projectionSlotIdx = this._ngContentSelectorsOffset + this._ngContentReservedSlots.length;
      const parameters = [literal(slot)];
      this._ngContentReservedSlots.push(ngContent.selector);
      const nonContentSelectAttributes = ngContent.attributes.filter((attr) => attr.name.toLowerCase() !== NG_CONTENT_SELECT_ATTR);
      const attributes = this.getAttributeExpressions(ngContent.name, nonContentSelectAttributes, [], []);
      if (attributes.length > 0) {
        parameters.push(literal(projectionSlotIdx), literalArr(attributes));
      } else if (projectionSlotIdx !== 0) {
        parameters.push(literal(projectionSlotIdx));
      }
      this.creationInstruction(ngContent.sourceSpan, Identifiers$1.projection, parameters);
      if (this.i18n) {
        this.i18n.appendProjection(ngContent.i18n, slot);
      }
    }
    visitElement(element) {
      const elementIndex = this.allocateDataSlot();
      const stylingBuilder = new StylingBuilder(null);
      let isNonBindableMode = false;
      const isI18nRootElement = isI18nRootNode(element.i18n) && !isSingleI18nIcu(element.i18n);
      const outputAttrs = [];
      const [namespaceKey, elementName] = splitNsName(element.name);
      const isNgContainer$1 = isNgContainer(element.name);
      for (const attr of element.attributes) {
        const { name, value } = attr;
        if (name === NON_BINDABLE_ATTR) {
          isNonBindableMode = true;
        } else if (name === "style") {
          stylingBuilder.registerStyleAttr(value);
        } else if (name === "class") {
          stylingBuilder.registerClassAttr(value);
        } else {
          outputAttrs.push(attr);
        }
      }
      this.matchDirectives(element.name, element);
      const parameters = [literal(elementIndex)];
      if (!isNgContainer$1) {
        parameters.push(literal(elementName));
      }
      const allOtherInputs = [];
      const boundI18nAttrs = [];
      element.inputs.forEach((input) => {
        const stylingInputWasSet = stylingBuilder.registerBoundInput(input);
        if (!stylingInputWasSet) {
          if (input.type === 0 && input.i18n) {
            boundI18nAttrs.push(input);
          } else {
            allOtherInputs.push(input);
          }
        }
      });
      const attributes = this.getAttributeExpressions(element.name, outputAttrs, allOtherInputs, element.outputs, stylingBuilder, [], boundI18nAttrs);
      parameters.push(this.addAttrsToConsts(attributes));
      const refs = this.prepareRefsArray(element.references);
      parameters.push(this.addToConsts(refs));
      const wasInNamespace = this._namespace;
      const currentNamespace = this.getNamespaceInstruction(namespaceKey);
      if (currentNamespace !== wasInNamespace) {
        this.addNamespaceInstruction(currentNamespace, element);
      }
      if (this.i18n) {
        this.i18n.appendElement(element.i18n, elementIndex);
      }
      const hasChildren = !isI18nRootElement && this.i18n ? !hasTextChildrenOnly(element.children) : element.children.length > 0;
      const createSelfClosingInstruction = !stylingBuilder.hasBindingsWithPipes && element.outputs.length === 0 && boundI18nAttrs.length === 0 && !hasChildren;
      const createSelfClosingI18nInstruction = !createSelfClosingInstruction && hasTextChildrenOnly(element.children);
      if (createSelfClosingInstruction) {
        this.creationInstruction(element.sourceSpan, isNgContainer$1 ? Identifiers$1.elementContainer : Identifiers$1.element, trimTrailingNulls(parameters));
      } else {
        this.creationInstruction(element.startSourceSpan, isNgContainer$1 ? Identifiers$1.elementContainerStart : Identifiers$1.elementStart, trimTrailingNulls(parameters));
        if (isNonBindableMode) {
          this.creationInstruction(element.startSourceSpan, Identifiers$1.disableBindings);
        }
        if (boundI18nAttrs.length > 0) {
          this.i18nAttributesInstruction(elementIndex, boundI18nAttrs, element.startSourceSpan ?? element.sourceSpan);
        }
        if (element.outputs.length > 0) {
          const listeners = element.outputs.map((outputAst) => ({
            sourceSpan: outputAst.sourceSpan,
            params: this.prepareListenerParameter(element.name, outputAst, elementIndex)
          }));
          this.creationInstructionChain(Identifiers$1.listener, listeners);
        }
        if (isI18nRootElement) {
          this.i18nStart(element.startSourceSpan, element.i18n, createSelfClosingI18nInstruction);
        }
      }
      const stylingInstructions = stylingBuilder.buildUpdateLevelInstructions(this._valueConverter);
      const limit = stylingInstructions.length - 1;
      for (let i = 0; i <= limit; i++) {
        const instruction2 = stylingInstructions[i];
        this._bindingSlots += this.processStylingUpdateInstruction(elementIndex, instruction2);
      }
      const emptyValueBindInstruction = literal(void 0);
      const propertyBindings = [];
      const attributeBindings = [];
      allOtherInputs.forEach((input) => {
        const inputType = input.type;
        if (inputType === 4) {
          const value = input.value.visit(this._valueConverter);
          const hasValue = value instanceof LiteralPrimitive ? !!value.value : true;
          this.allocateBindingSlots(value);
          propertyBindings.push({
            name: prepareSyntheticPropertyName(input.name),
            sourceSpan: input.sourceSpan,
            value: () => hasValue ? this.convertPropertyBinding(value) : emptyValueBindInstruction
          });
        } else {
          if (input.i18n)
            return;
          const value = input.value.visit(this._valueConverter);
          if (value !== void 0) {
            const params = [];
            const [attrNamespace, attrName] = splitNsName(input.name);
            const isAttributeBinding = inputType === 1;
            const sanitizationRef = resolveSanitizationFn(input.securityContext, isAttributeBinding);
            if (sanitizationRef)
              params.push(sanitizationRef);
            if (attrNamespace) {
              const namespaceLiteral = literal(attrNamespace);
              if (sanitizationRef) {
                params.push(namespaceLiteral);
              } else {
                params.push(literal(null), namespaceLiteral);
              }
            }
            this.allocateBindingSlots(value);
            if (inputType === 0) {
              if (value instanceof Interpolation) {
                this.interpolatedUpdateInstruction(getPropertyInterpolationExpression(value), elementIndex, attrName, input, value, params);
              } else {
                propertyBindings.push({
                  name: attrName,
                  sourceSpan: input.sourceSpan,
                  value: () => this.convertPropertyBinding(value),
                  params
                });
              }
            } else if (inputType === 1) {
              if (value instanceof Interpolation && getInterpolationArgsLength(value) > 1) {
                this.interpolatedUpdateInstruction(getAttributeInterpolationExpression(value), elementIndex, attrName, input, value, params);
              } else {
                const boundValue = value instanceof Interpolation ? value.expressions[0] : value;
                attributeBindings.push({
                  name: attrName,
                  sourceSpan: input.sourceSpan,
                  value: () => this.convertPropertyBinding(boundValue),
                  params
                });
              }
            } else {
              this.updateInstructionWithAdvance(elementIndex, input.sourceSpan, Identifiers$1.classProp, () => {
                return [
                  literal(elementIndex),
                  literal(attrName),
                  this.convertPropertyBinding(value),
                  ...params
                ];
              });
            }
          }
        }
      });
      if (propertyBindings.length > 0) {
        this.updateInstructionChainWithAdvance(elementIndex, Identifiers$1.property, propertyBindings);
      }
      if (attributeBindings.length > 0) {
        this.updateInstructionChainWithAdvance(elementIndex, Identifiers$1.attribute, attributeBindings);
      }
      visitAll$1(this, element.children);
      if (!isI18nRootElement && this.i18n) {
        this.i18n.appendElement(element.i18n, elementIndex, true);
      }
      if (!createSelfClosingInstruction) {
        const span = element.endSourceSpan ?? element.sourceSpan;
        if (isI18nRootElement) {
          this.i18nEnd(span, createSelfClosingI18nInstruction);
        }
        if (isNonBindableMode) {
          this.creationInstruction(span, Identifiers$1.enableBindings);
        }
        this.creationInstruction(span, isNgContainer$1 ? Identifiers$1.elementContainerEnd : Identifiers$1.elementEnd);
      }
    }
    visitTemplate(template) {
      const NG_TEMPLATE_TAG_NAME = "ng-template";
      const templateIndex = this.allocateDataSlot();
      if (this.i18n) {
        this.i18n.appendTemplate(template.i18n, templateIndex);
      }
      const tagNameWithoutNamespace = template.tagName ? splitNsName(template.tagName)[1] : template.tagName;
      const contextName = `${this.contextName}${template.tagName ? "_" + sanitizeIdentifier(template.tagName) : ""}_${templateIndex}`;
      const templateName = `${contextName}_Template`;
      const parameters = [
        literal(templateIndex),
        variable(templateName),
        literal(tagNameWithoutNamespace)
      ];
      this.matchDirectives(NG_TEMPLATE_TAG_NAME, template);
      const attrsExprs = this.getAttributeExpressions(NG_TEMPLATE_TAG_NAME, template.attributes, template.inputs, template.outputs, void 0, template.templateAttrs);
      parameters.push(this.addAttrsToConsts(attrsExprs));
      if (template.references && template.references.length) {
        const refs = this.prepareRefsArray(template.references);
        parameters.push(this.addToConsts(refs));
        parameters.push(importExpr(Identifiers$1.templateRefExtractor));
      }
      const templateVisitor = new TemplateDefinitionBuilder(this.constantPool, this._bindingScope, this.level + 1, contextName, this.i18n, templateIndex, templateName, this.directiveMatcher, this.directives, this.pipeTypeByName, this.pipes, this._namespace, this.fileBasedI18nSuffix, this.i18nUseExternalIds, this._constants);
      this._nestedTemplateFns.push(() => {
        const templateFunctionExpr = templateVisitor.buildTemplateFunction(template.children, template.variables, this._ngContentReservedSlots.length + this._ngContentSelectorsOffset, template.i18n);
        this.constantPool.statements.push(templateFunctionExpr.toDeclStmt(templateName));
        if (templateVisitor._ngContentReservedSlots.length) {
          this._ngContentReservedSlots.push(...templateVisitor._ngContentReservedSlots);
        }
      });
      this.creationInstruction(template.sourceSpan, Identifiers$1.templateCreate, () => {
        parameters.splice(2, 0, literal(templateVisitor.getConstCount()), literal(templateVisitor.getVarCount()));
        return trimTrailingNulls(parameters);
      });
      this.templatePropertyBindings(templateIndex, template.templateAttrs);
      if (tagNameWithoutNamespace === NG_TEMPLATE_TAG_NAME) {
        const [i18nInputs, inputs] = partitionArray(template.inputs, hasI18nMeta);
        if (i18nInputs.length > 0) {
          this.i18nAttributesInstruction(templateIndex, i18nInputs, template.startSourceSpan ?? template.sourceSpan);
        }
        if (inputs.length > 0) {
          this.templatePropertyBindings(templateIndex, inputs);
        }
        if (template.outputs.length > 0) {
          const listeners = template.outputs.map((outputAst) => ({
            sourceSpan: outputAst.sourceSpan,
            params: this.prepareListenerParameter("ng_template", outputAst, templateIndex)
          }));
          this.creationInstructionChain(Identifiers$1.listener, listeners);
        }
      }
    }
    visitBoundText(text) {
      if (this.i18n) {
        const value2 = text.value.visit(this._valueConverter);
        this.allocateBindingSlots(value2);
        if (value2 instanceof Interpolation) {
          this.i18n.appendBoundText(text.i18n);
          this.i18nAppendBindings(value2.expressions);
        }
        return;
      }
      const nodeIndex = this.allocateDataSlot();
      this.creationInstruction(text.sourceSpan, Identifiers$1.text, [literal(nodeIndex)]);
      const value = text.value.visit(this._valueConverter);
      this.allocateBindingSlots(value);
      if (value instanceof Interpolation) {
        this.updateInstructionWithAdvance(nodeIndex, text.sourceSpan, getTextInterpolationExpression(value), () => this.getUpdateInstructionArguments(value));
      } else {
        error2("Text nodes should be interpolated and never bound directly.");
      }
    }
    visitText(text) {
      if (!this.i18n) {
        this.creationInstruction(text.sourceSpan, Identifiers$1.text, [literal(this.allocateDataSlot()), literal(text.value)]);
      }
    }
    visitIcu(icu) {
      let initWasInvoked = false;
      if (!this.i18n) {
        initWasInvoked = true;
        this.i18nStart(null, icu.i18n, true);
      }
      const i18n = this.i18n;
      const vars = this.i18nBindProps(icu.vars);
      const placeholders = this.i18nBindProps(icu.placeholders);
      const message = icu.i18n;
      const transformFn = (raw) => {
        const params = { ...vars, ...placeholders };
        const formatted = i18nFormatPlaceholderNames(params, false);
        return instruction(null, Identifiers$1.i18nPostprocess, [raw, mapLiteral(formatted, true)]);
      };
      if (isSingleI18nIcu(i18n.meta)) {
        this.i18nTranslate(message, {}, i18n.ref, transformFn);
      } else {
        const ref = this.i18nTranslate(message, {}, void 0, transformFn);
        i18n.appendIcu(icuFromI18nMessage(message).name, ref);
      }
      if (initWasInvoked) {
        this.i18nEnd(null, true);
      }
      return null;
    }
    allocateDataSlot() {
      return this._dataIndex++;
    }
    getConstCount() {
      return this._dataIndex;
    }
    getVarCount() {
      return this._pureFunctionSlots;
    }
    getConsts() {
      return this._constants;
    }
    getNgContentSelectors() {
      return this._ngContentReservedSlots.length ? this.constantPool.getConstLiteral(asLiteral(this._ngContentReservedSlots), true) : null;
    }
    bindingContext() {
      return `${this._bindingContext++}`;
    }
    templatePropertyBindings(templateIndex, attrs) {
      const propertyBindings = [];
      attrs.forEach((input) => {
        if (input instanceof BoundAttribute) {
          const value = input.value.visit(this._valueConverter);
          if (value !== void 0) {
            this.allocateBindingSlots(value);
            if (value instanceof Interpolation) {
              const params = [];
              this.interpolatedUpdateInstruction(getPropertyInterpolationExpression(value), templateIndex, input.name, input, value, params);
            } else {
              propertyBindings.push({
                name: input.name,
                sourceSpan: input.sourceSpan,
                value: () => this.convertPropertyBinding(value)
              });
            }
          }
        }
      });
      if (propertyBindings.length > 0) {
        this.updateInstructionChainWithAdvance(templateIndex, Identifiers$1.property, propertyBindings);
      }
    }
    instructionFn(fns, span, reference, paramsOrFn, prepend = false) {
      fns[prepend ? "unshift" : "push"](() => {
        const params = Array.isArray(paramsOrFn) ? paramsOrFn : paramsOrFn();
        return instruction(span, reference, params).toStmt();
      });
    }
    processStylingUpdateInstruction(elementIndex, instruction2) {
      let allocateBindingSlots = 0;
      if (instruction2) {
        const calls = [];
        instruction2.calls.forEach((call) => {
          allocateBindingSlots += call.allocateBindingSlots;
          calls.push({
            sourceSpan: call.sourceSpan,
            value: () => {
              return call.params((value) => call.supportsInterpolation && value instanceof Interpolation ? this.getUpdateInstructionArguments(value) : this.convertPropertyBinding(value));
            }
          });
        });
        this.updateInstructionChainWithAdvance(elementIndex, instruction2.reference, calls);
      }
      return allocateBindingSlots;
    }
    creationInstruction(span, reference, paramsOrFn, prepend) {
      this.instructionFn(this._creationCodeFns, span, reference, paramsOrFn || [], prepend);
    }
    creationInstructionChain(reference, calls) {
      const span = calls.length ? calls[0].sourceSpan : null;
      this._creationCodeFns.push(() => {
        return chainedInstruction(reference, calls.map((call) => call.params()), span).toStmt();
      });
    }
    updateInstructionWithAdvance(nodeIndex, span, reference, paramsOrFn) {
      this.addAdvanceInstructionIfNecessary(nodeIndex, span);
      this.updateInstruction(span, reference, paramsOrFn);
    }
    updateInstruction(span, reference, paramsOrFn) {
      this.instructionFn(this._updateCodeFns, span, reference, paramsOrFn || []);
    }
    updateInstructionChain(reference, bindings) {
      const span = bindings.length ? bindings[0].sourceSpan : null;
      this._updateCodeFns.push(() => {
        const calls = bindings.map((property) => {
          const value = property.value();
          const fnParams = Array.isArray(value) ? value : [value];
          if (property.params) {
            fnParams.push(...property.params);
          }
          if (property.name) {
            fnParams.unshift(literal(property.name));
          }
          return fnParams;
        });
        return chainedInstruction(reference, calls, span).toStmt();
      });
    }
    updateInstructionChainWithAdvance(nodeIndex, reference, bindings) {
      this.addAdvanceInstructionIfNecessary(nodeIndex, bindings.length ? bindings[0].sourceSpan : null);
      this.updateInstructionChain(reference, bindings);
    }
    addAdvanceInstructionIfNecessary(nodeIndex, span) {
      if (nodeIndex !== this._currentIndex) {
        const delta = nodeIndex - this._currentIndex;
        if (delta < 1) {
          throw new Error("advance instruction can only go forwards");
        }
        this.instructionFn(this._updateCodeFns, span, Identifiers$1.advance, [literal(delta)]);
        this._currentIndex = nodeIndex;
      }
    }
    allocatePureFunctionSlots(numSlots) {
      const originalSlots = this._pureFunctionSlots;
      this._pureFunctionSlots += numSlots;
      return originalSlots;
    }
    allocateBindingSlots(value) {
      this._bindingSlots += value instanceof Interpolation ? value.expressions.length : 1;
    }
    getImplicitReceiverExpr() {
      if (this._implicitReceiverExpr) {
        return this._implicitReceiverExpr;
      }
      return this._implicitReceiverExpr = this.level === 0 ? variable(CONTEXT_NAME) : this._bindingScope.getOrCreateSharedContextVar(0);
    }
    convertPropertyBinding(value) {
      const convertedPropertyBinding = convertPropertyBinding(this, this.getImplicitReceiverExpr(), value, this.bindingContext(), BindingForm.Expression, () => error2("Unexpected interpolation"));
      const valExpr = convertedPropertyBinding.currValExpr;
      this._tempVariables.push(...convertedPropertyBinding.stmts);
      return valExpr;
    }
    getUpdateInstructionArguments(value) {
      const { args, stmts } = convertUpdateArguments(this, this.getImplicitReceiverExpr(), value, this.bindingContext());
      this._tempVariables.push(...stmts);
      return args;
    }
    matchDirectives(elementName, elOrTpl) {
      if (this.directiveMatcher) {
        const selector = createCssSelector(elementName, getAttrsForDirectiveMatching(elOrTpl));
        this.directiveMatcher.match(selector, (cssSelector, staticType) => {
          this.directives.add(staticType);
        });
      }
    }
    getAttributeExpressions(elementName, renderAttributes, inputs, outputs, styles, templateAttrs = [], boundI18nAttrs = []) {
      const alreadySeen = /* @__PURE__ */ new Set();
      const attrExprs = [];
      let ngProjectAsAttr;
      for (const attr of renderAttributes) {
        if (attr.name === NG_PROJECT_AS_ATTR_NAME) {
          ngProjectAsAttr = attr;
        }
        if (attr.i18n) {
          const { i18nVarRefsCache } = this._constants;
          let i18nVarRef;
          if (i18nVarRefsCache.has(attr.i18n)) {
            i18nVarRef = i18nVarRefsCache.get(attr.i18n);
          } else {
            i18nVarRef = this.i18nTranslate(attr.i18n);
            i18nVarRefsCache.set(attr.i18n, i18nVarRef);
          }
          attrExprs.push(literal(attr.name), i18nVarRef);
        } else {
          attrExprs.push(...getAttributeNameLiterals(attr.name), trustedConstAttribute(elementName, attr));
        }
      }
      if (ngProjectAsAttr) {
        attrExprs.push(...getNgProjectAsLiteral(ngProjectAsAttr));
      }
      function addAttrExpr(key, value) {
        if (typeof key === "string") {
          if (!alreadySeen.has(key)) {
            attrExprs.push(...getAttributeNameLiterals(key));
            value !== void 0 && attrExprs.push(value);
            alreadySeen.add(key);
          }
        } else {
          attrExprs.push(literal(key));
        }
      }
      if (styles) {
        styles.populateInitialStylingAttrs(attrExprs);
      }
      if (inputs.length || outputs.length) {
        const attrsLengthBeforeInputs = attrExprs.length;
        for (let i = 0; i < inputs.length; i++) {
          const input = inputs[i];
          if (input.type !== 4 && input.type !== 1) {
            addAttrExpr(input.name);
          }
        }
        for (let i = 0; i < outputs.length; i++) {
          const output = outputs[i];
          if (output.type !== 1) {
            addAttrExpr(output.name);
          }
        }
        if (attrExprs.length !== attrsLengthBeforeInputs) {
          attrExprs.splice(attrsLengthBeforeInputs, 0, literal(3));
        }
      }
      if (templateAttrs.length) {
        attrExprs.push(literal(4));
        templateAttrs.forEach((attr) => addAttrExpr(attr.name));
      }
      if (boundI18nAttrs.length) {
        attrExprs.push(literal(6));
        boundI18nAttrs.forEach((attr) => addAttrExpr(attr.name));
      }
      return attrExprs;
    }
    addToConsts(expression) {
      if (isNull(expression)) {
        return TYPED_NULL_EXPR;
      }
      const consts = this._constants.constExpressions;
      for (let i = 0; i < consts.length; i++) {
        if (consts[i].isEquivalent(expression)) {
          return literal(i);
        }
      }
      return literal(consts.push(expression) - 1);
    }
    addAttrsToConsts(attrs) {
      return attrs.length > 0 ? this.addToConsts(literalArr(attrs)) : TYPED_NULL_EXPR;
    }
    prepareRefsArray(references) {
      if (!references || references.length === 0) {
        return TYPED_NULL_EXPR;
      }
      const refsParam = flatten2(references.map((reference) => {
        const slot = this.allocateDataSlot();
        const variableName = this._bindingScope.freshReferenceName();
        const retrievalLevel = this.level;
        const lhs = variable(variableName);
        this._bindingScope.set(retrievalLevel, reference.name, lhs, 0, (scope, relativeLevel) => {
          const nextContextStmt = relativeLevel > 0 ? [generateNextContextExpr(relativeLevel).toStmt()] : [];
          const refExpr = lhs.set(importExpr(Identifiers$1.reference).callFn([literal(slot)]));
          return nextContextStmt.concat(refExpr.toConstDecl());
        }, true);
        return [reference.name, reference.value];
      }));
      return asLiteral(refsParam);
    }
    prepareListenerParameter(tagName, outputAst, index) {
      return () => {
        const eventName = outputAst.name;
        const bindingFnName = outputAst.type === 1 ? prepareSyntheticListenerFunctionName(eventName, outputAst.phase) : sanitizeIdentifier(eventName);
        const handlerName = `${this.templateName}_${tagName}_${bindingFnName}_${index}_listener`;
        const scope = this._bindingScope.nestedScope(this._bindingScope.bindingLevel, EVENT_BINDING_SCOPE_GLOBALS);
        return prepareEventListenerParameters(outputAst, handlerName, scope);
      };
    }
  };
  var ValueConverter = class extends AstMemoryEfficientTransformer {
    constructor(constantPool, allocateSlot, allocatePureFunctionSlots, definePipe) {
      super();
      this.constantPool = constantPool;
      this.allocateSlot = allocateSlot;
      this.allocatePureFunctionSlots = allocatePureFunctionSlots;
      this.definePipe = definePipe;
      this._pipeBindExprs = [];
    }
    visitPipe(pipe, context2) {
      const slot = this.allocateSlot();
      const slotPseudoLocal = `PIPE:${slot}`;
      const pureFunctionSlot = this.allocatePureFunctionSlots(2 + pipe.args.length);
      const target = new PropertyRead(pipe.span, pipe.sourceSpan, pipe.nameSpan, new ImplicitReceiver(pipe.span, pipe.sourceSpan), slotPseudoLocal);
      const { identifier, isVarLength } = pipeBindingCallInfo(pipe.args);
      this.definePipe(pipe.name, slotPseudoLocal, slot, importExpr(identifier));
      const args = [pipe.exp, ...pipe.args];
      const convertedArgs = isVarLength ? this.visitAll([new LiteralArray(pipe.span, pipe.sourceSpan, args)]) : this.visitAll(args);
      const pipeBindExpr = new Call(pipe.span, pipe.sourceSpan, target, [
        new LiteralPrimitive(pipe.span, pipe.sourceSpan, slot),
        new LiteralPrimitive(pipe.span, pipe.sourceSpan, pureFunctionSlot),
        ...convertedArgs
      ], null);
      this._pipeBindExprs.push(pipeBindExpr);
      return pipeBindExpr;
    }
    updatePipeSlotOffsets(bindingSlots) {
      this._pipeBindExprs.forEach((pipe) => {
        const slotOffset = pipe.args[1];
        slotOffset.value += bindingSlots;
      });
    }
    visitLiteralArray(array, context2) {
      return new BuiltinFunctionCall(array.span, array.sourceSpan, this.visitAll(array.expressions), (values) => {
        const literal2 = literalArr(values);
        return getLiteralFactory(this.constantPool, literal2, this.allocatePureFunctionSlots);
      });
    }
    visitLiteralMap(map2, context2) {
      return new BuiltinFunctionCall(map2.span, map2.sourceSpan, this.visitAll(map2.values), (values) => {
        const literal2 = literalMap(values.map((value, index) => ({ key: map2.keys[index].key, value, quoted: map2.keys[index].quoted })));
        return getLiteralFactory(this.constantPool, literal2, this.allocatePureFunctionSlots);
      });
    }
  };
  var pipeBindingIdentifiers = [Identifiers$1.pipeBind1, Identifiers$1.pipeBind2, Identifiers$1.pipeBind3, Identifiers$1.pipeBind4];
  function pipeBindingCallInfo(args) {
    const identifier = pipeBindingIdentifiers[args.length];
    return {
      identifier: identifier || Identifiers$1.pipeBindV,
      isVarLength: !identifier
    };
  }
  var pureFunctionIdentifiers = [
    Identifiers$1.pureFunction0,
    Identifiers$1.pureFunction1,
    Identifiers$1.pureFunction2,
    Identifiers$1.pureFunction3,
    Identifiers$1.pureFunction4,
    Identifiers$1.pureFunction5,
    Identifiers$1.pureFunction6,
    Identifiers$1.pureFunction7,
    Identifiers$1.pureFunction8
  ];
  function pureFunctionCallInfo(args) {
    const identifier = pureFunctionIdentifiers[args.length];
    return {
      identifier: identifier || Identifiers$1.pureFunctionV,
      isVarLength: !identifier
    };
  }
  function instruction(span, reference, params) {
    return importExpr(reference, null, span).callFn(params, span);
  }
  function generateNextContextExpr(relativeLevelDiff) {
    return importExpr(Identifiers$1.nextContext).callFn(relativeLevelDiff > 1 ? [literal(relativeLevelDiff)] : []);
  }
  function getLiteralFactory(constantPool, literal$1, allocateSlots) {
    const { literalFactory, literalFactoryArguments } = constantPool.getLiteralFactory(literal$1);
    const startSlot = allocateSlots(1 + literalFactoryArguments.length);
    const { identifier, isVarLength } = pureFunctionCallInfo(literalFactoryArguments);
    const args = [literal(startSlot), literalFactory];
    if (isVarLength) {
      args.push(literalArr(literalFactoryArguments));
    } else {
      args.push(...literalFactoryArguments);
    }
    return importExpr(identifier).callFn(args);
  }
  function getAttributeNameLiterals(name) {
    const [attributeNamespace, attributeName] = splitNsName(name);
    const nameLiteral = literal(attributeName);
    if (attributeNamespace) {
      return [
        literal(0),
        literal(attributeNamespace),
        nameLiteral
      ];
    }
    return [nameLiteral];
  }
  var SHARED_CONTEXT_KEY = "$$shared_ctx$$";
  var BindingScope$1 = class {
    constructor(bindingLevel = 0, parent = null, globals) {
      this.bindingLevel = bindingLevel;
      this.parent = parent;
      this.globals = globals;
      this.map = /* @__PURE__ */ new Map();
      this.referenceNameIndex = 0;
      this.restoreViewVariable = null;
      this.usesRestoredViewContext = false;
      if (globals !== void 0) {
        for (const name of globals) {
          this.set(0, name, variable(name));
        }
      }
    }
    static createRootScope() {
      return new BindingScope$1();
    }
    get(name) {
      let current = this;
      while (current) {
        let value = current.map.get(name);
        if (value != null) {
          if (current !== this) {
            value = {
              retrievalLevel: value.retrievalLevel,
              lhs: value.lhs,
              declareLocalCallback: value.declareLocalCallback,
              declare: false,
              priority: value.priority
            };
            this.map.set(name, value);
            this.maybeGenerateSharedContextVar(value);
            this.maybeRestoreView();
          }
          if (value.declareLocalCallback && !value.declare) {
            value.declare = true;
          }
          return value.lhs;
        }
        current = current.parent;
      }
      return this.bindingLevel === 0 ? null : this.getComponentProperty(name);
    }
    set(retrievalLevel, name, lhs, priority = 0, declareLocalCallback, localRef) {
      if (this.map.has(name)) {
        if (localRef) {
          return this;
        }
        error2(`The name ${name} is already defined in scope to be ${this.map.get(name)}`);
      }
      this.map.set(name, {
        retrievalLevel,
        lhs,
        declare: false,
        declareLocalCallback,
        priority
      });
      return this;
    }
    getLocal(name) {
      return this.get(name);
    }
    notifyImplicitReceiverUse() {
      if (this.bindingLevel !== 0) {
        this.map.get(SHARED_CONTEXT_KEY + 0).declare = true;
      }
    }
    nestedScope(level, globals) {
      const newScope = new BindingScope$1(level, this, globals);
      if (level > 0)
        newScope.generateSharedContextVar(0);
      return newScope;
    }
    getOrCreateSharedContextVar(retrievalLevel) {
      const bindingKey = SHARED_CONTEXT_KEY + retrievalLevel;
      if (!this.map.has(bindingKey)) {
        this.generateSharedContextVar(retrievalLevel);
      }
      return this.map.get(bindingKey).lhs;
    }
    getSharedContextName(retrievalLevel) {
      const sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + retrievalLevel);
      return sharedCtxObj && sharedCtxObj.declare ? sharedCtxObj.lhs : null;
    }
    maybeGenerateSharedContextVar(value) {
      if (value.priority === 1 && value.retrievalLevel < this.bindingLevel) {
        const sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + value.retrievalLevel);
        if (sharedCtxObj) {
          sharedCtxObj.declare = true;
        } else {
          this.generateSharedContextVar(value.retrievalLevel);
        }
      }
    }
    generateSharedContextVar(retrievalLevel) {
      const lhs = variable(CONTEXT_NAME + this.freshReferenceName());
      this.map.set(SHARED_CONTEXT_KEY + retrievalLevel, {
        retrievalLevel,
        lhs,
        declareLocalCallback: (scope, relativeLevel) => {
          return [lhs.set(generateNextContextExpr(relativeLevel)).toConstDecl()];
        },
        declare: false,
        priority: 2
      });
    }
    getComponentProperty(name) {
      const componentValue = this.map.get(SHARED_CONTEXT_KEY + 0);
      componentValue.declare = true;
      this.maybeRestoreView();
      return componentValue.lhs.prop(name);
    }
    maybeRestoreView() {
      if (this.isListenerScope()) {
        if (!this.parent.restoreViewVariable) {
          this.parent.restoreViewVariable = variable(this.parent.freshReferenceName());
        }
        this.restoreViewVariable = this.parent.restoreViewVariable;
      }
    }
    restoreViewStatement() {
      const statements = [];
      if (this.restoreViewVariable) {
        const restoreCall = instruction(null, Identifiers$1.restoreView, [this.restoreViewVariable]);
        statements.push(this.usesRestoredViewContext ? variable(RESTORED_VIEW_CONTEXT_NAME).set(restoreCall).toConstDecl() : restoreCall.toStmt());
      }
      return statements;
    }
    viewSnapshotStatements() {
      return this.restoreViewVariable ? [this.restoreViewVariable.set(instruction(null, Identifiers$1.getCurrentView, [])).toConstDecl()] : [];
    }
    isListenerScope() {
      return this.parent && this.parent.bindingLevel === this.bindingLevel;
    }
    variableDeclarations() {
      let currentContextLevel = 0;
      return Array.from(this.map.values()).filter((value) => value.declare).sort((a, b) => b.retrievalLevel - a.retrievalLevel || b.priority - a.priority).reduce((stmts, value) => {
        const levelDiff = this.bindingLevel - value.retrievalLevel;
        const currStmts = value.declareLocalCallback(this, levelDiff - currentContextLevel);
        currentContextLevel = levelDiff;
        return stmts.concat(currStmts);
      }, []);
    }
    freshReferenceName() {
      let current = this;
      while (current.parent)
        current = current.parent;
      const ref = `${REFERENCE_PREFIX}${current.referenceNameIndex++}`;
      return ref;
    }
    hasRestoreViewVariable() {
      return !!this.restoreViewVariable;
    }
    notifyRestoredViewContextUse() {
      this.usesRestoredViewContext = true;
    }
  };
  function createCssSelector(elementName, attributes) {
    const cssSelector = new CssSelector();
    const elementNameNoNs = splitNsName(elementName)[1];
    cssSelector.setElement(elementNameNoNs);
    Object.getOwnPropertyNames(attributes).forEach((name) => {
      const nameNoNs = splitNsName(name)[1];
      const value = attributes[name];
      cssSelector.addAttribute(nameNoNs, value);
      if (name.toLowerCase() === "class") {
        const classes = value.trim().split(/\s+/);
        classes.forEach((className) => cssSelector.addClassName(className));
      }
    });
    return cssSelector;
  }
  function getNgProjectAsLiteral(attribute) {
    const parsedR3Selector = parseSelectorToR3Selector(attribute.value)[0];
    return [literal(5), asLiteral(parsedR3Selector)];
  }
  function getPropertyInterpolationExpression(interpolation) {
    switch (getInterpolationArgsLength(interpolation)) {
      case 1:
        return Identifiers$1.propertyInterpolate;
      case 3:
        return Identifiers$1.propertyInterpolate1;
      case 5:
        return Identifiers$1.propertyInterpolate2;
      case 7:
        return Identifiers$1.propertyInterpolate3;
      case 9:
        return Identifiers$1.propertyInterpolate4;
      case 11:
        return Identifiers$1.propertyInterpolate5;
      case 13:
        return Identifiers$1.propertyInterpolate6;
      case 15:
        return Identifiers$1.propertyInterpolate7;
      case 17:
        return Identifiers$1.propertyInterpolate8;
      default:
        return Identifiers$1.propertyInterpolateV;
    }
  }
  function getAttributeInterpolationExpression(interpolation) {
    switch (getInterpolationArgsLength(interpolation)) {
      case 3:
        return Identifiers$1.attributeInterpolate1;
      case 5:
        return Identifiers$1.attributeInterpolate2;
      case 7:
        return Identifiers$1.attributeInterpolate3;
      case 9:
        return Identifiers$1.attributeInterpolate4;
      case 11:
        return Identifiers$1.attributeInterpolate5;
      case 13:
        return Identifiers$1.attributeInterpolate6;
      case 15:
        return Identifiers$1.attributeInterpolate7;
      case 17:
        return Identifiers$1.attributeInterpolate8;
      default:
        return Identifiers$1.attributeInterpolateV;
    }
  }
  function getTextInterpolationExpression(interpolation) {
    switch (getInterpolationArgsLength(interpolation)) {
      case 1:
        return Identifiers$1.textInterpolate;
      case 3:
        return Identifiers$1.textInterpolate1;
      case 5:
        return Identifiers$1.textInterpolate2;
      case 7:
        return Identifiers$1.textInterpolate3;
      case 9:
        return Identifiers$1.textInterpolate4;
      case 11:
        return Identifiers$1.textInterpolate5;
      case 13:
        return Identifiers$1.textInterpolate6;
      case 15:
        return Identifiers$1.textInterpolate7;
      case 17:
        return Identifiers$1.textInterpolate8;
      default:
        return Identifiers$1.textInterpolateV;
    }
  }
  function parseTemplate(template, templateUrl, options = {}) {
    const { interpolationConfig, preserveWhitespaces, enableI18nLegacyMessageIdFormat } = options;
    const bindingParser = makeBindingParser(interpolationConfig);
    const htmlParser = new HtmlParser();
    const parseResult = htmlParser.parse(template, templateUrl, { leadingTriviaChars: LEADING_TRIVIA_CHARS, ...options, tokenizeExpansionForms: true });
    if (!options.alwaysAttemptHtmlToR3AstConversion && parseResult.errors && parseResult.errors.length > 0) {
      const parsedTemplate2 = {
        interpolationConfig,
        preserveWhitespaces,
        errors: parseResult.errors,
        nodes: [],
        styleUrls: [],
        styles: [],
        ngContentSelectors: []
      };
      if (options.collectCommentNodes) {
        parsedTemplate2.commentNodes = [];
      }
      return parsedTemplate2;
    }
    let rootNodes = parseResult.rootNodes;
    const i18nMetaVisitor = new I18nMetaVisitor(interpolationConfig, !preserveWhitespaces, enableI18nLegacyMessageIdFormat);
    const i18nMetaResult = i18nMetaVisitor.visitAllWithErrors(rootNodes);
    if (!options.alwaysAttemptHtmlToR3AstConversion && i18nMetaResult.errors && i18nMetaResult.errors.length > 0) {
      const parsedTemplate2 = {
        interpolationConfig,
        preserveWhitespaces,
        errors: i18nMetaResult.errors,
        nodes: [],
        styleUrls: [],
        styles: [],
        ngContentSelectors: []
      };
      if (options.collectCommentNodes) {
        parsedTemplate2.commentNodes = [];
      }
      return parsedTemplate2;
    }
    rootNodes = i18nMetaResult.rootNodes;
    if (!preserveWhitespaces) {
      rootNodes = visitAll(new WhitespaceVisitor(), rootNodes);
      if (i18nMetaVisitor.hasI18nMeta) {
        rootNodes = visitAll(new I18nMetaVisitor(interpolationConfig, false), rootNodes);
      }
    }
    const { nodes, errors, styleUrls, styles, ngContentSelectors, commentNodes } = htmlAstToRender3Ast(rootNodes, bindingParser, { collectCommentNodes: !!options.collectCommentNodes });
    errors.push(...parseResult.errors, ...i18nMetaResult.errors);
    const parsedTemplate = {
      interpolationConfig,
      preserveWhitespaces,
      errors: errors.length > 0 ? errors : null,
      nodes,
      styleUrls,
      styles,
      ngContentSelectors
    };
    if (options.collectCommentNodes) {
      parsedTemplate.commentNodes = commentNodes;
    }
    return parsedTemplate;
  }
  var elementRegistry = new DomElementSchemaRegistry();
  function makeBindingParser(interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
    return new BindingParser(new IvyParser(new Lexer()), interpolationConfig, elementRegistry, null, []);
  }
  function resolveSanitizationFn(context2, isAttribute) {
    switch (context2) {
      case SecurityContext2.HTML:
        return importExpr(Identifiers$1.sanitizeHtml);
      case SecurityContext2.SCRIPT:
        return importExpr(Identifiers$1.sanitizeScript);
      case SecurityContext2.STYLE:
        return isAttribute ? importExpr(Identifiers$1.sanitizeStyle) : null;
      case SecurityContext2.URL:
        return importExpr(Identifiers$1.sanitizeUrl);
      case SecurityContext2.RESOURCE_URL:
        return importExpr(Identifiers$1.sanitizeResourceUrl);
      default:
        return null;
    }
  }
  function trustedConstAttribute(tagName, attr) {
    const value = asLiteral(attr.value);
    if (isTrustedTypesSink(tagName, attr.name)) {
      switch (elementRegistry.securityContext(tagName, attr.name, true)) {
        case SecurityContext2.HTML:
          return taggedTemplate(importExpr(Identifiers$1.trustConstantHtml), new TemplateLiteral([new TemplateLiteralElement(attr.value)], []), void 0, attr.valueSpan);
        case SecurityContext2.RESOURCE_URL:
          return taggedTemplate(importExpr(Identifiers$1.trustConstantResourceUrl), new TemplateLiteral([new TemplateLiteralElement(attr.value)], []), void 0, attr.valueSpan);
        default:
          return value;
      }
    } else {
      return value;
    }
  }
  function isSingleElementTemplate(children) {
    return children.length === 1 && children[0] instanceof Element$1;
  }
  function isTextNode(node) {
    return node instanceof Text$3 || node instanceof BoundText || node instanceof Icu$1;
  }
  function hasTextChildrenOnly(children) {
    return children.every(isTextNode);
  }
  var NG_I18N_CLOSURE_MODE = "ngI18nClosureMode";
  function getTranslationDeclStmts(message, variable2, closureVar, params = {}, transformFn) {
    const statements = [
      declareI18nVariable(variable2),
      ifStmt(createClosureModeGuard(), createGoogleGetMsgStatements(variable2, message, closureVar, i18nFormatPlaceholderNames(params, true)), createLocalizeStatements(variable2, message, i18nFormatPlaceholderNames(params, false)))
    ];
    if (transformFn) {
      statements.push(new ExpressionStatement(variable2.set(transformFn(variable2))));
    }
    return statements;
  }
  function createClosureModeGuard() {
    return typeofExpr(variable(NG_I18N_CLOSURE_MODE)).notIdentical(literal("undefined", STRING_TYPE)).and(variable(NG_I18N_CLOSURE_MODE));
  }
  var ATTR_REGEX = /attr\.([^\]]+)/;
  function baseDirectiveFields(meta, constantPool, bindingParser) {
    const definitionMap = new DefinitionMap();
    const selectors = parseSelectorToR3Selector(meta.selector);
    definitionMap.set("type", meta.internalType);
    if (selectors.length > 0) {
      definitionMap.set("selectors", asLiteral(selectors));
    }
    if (meta.queries.length > 0) {
      definitionMap.set("contentQueries", createContentQueriesFunction(meta.queries, constantPool, meta.name));
    }
    if (meta.viewQueries.length) {
      definitionMap.set("viewQuery", createViewQueriesFunction(meta.viewQueries, constantPool, meta.name));
    }
    definitionMap.set("hostBindings", createHostBindingsFunction(meta.host, meta.typeSourceSpan, bindingParser, constantPool, meta.selector || "", meta.name, definitionMap));
    definitionMap.set("inputs", conditionallyCreateMapObjectLiteral(meta.inputs, true));
    definitionMap.set("outputs", conditionallyCreateMapObjectLiteral(meta.outputs));
    if (meta.exportAs !== null) {
      definitionMap.set("exportAs", literalArr(meta.exportAs.map((e) => literal(e))));
    }
    return definitionMap;
  }
  function addFeatures(definitionMap, meta) {
    const features = [];
    const providers = meta.providers;
    const viewProviders = meta.viewProviders;
    if (providers || viewProviders) {
      const args = [providers || new LiteralArrayExpr([])];
      if (viewProviders) {
        args.push(viewProviders);
      }
      features.push(importExpr(Identifiers$1.ProvidersFeature).callFn(args));
    }
    if (meta.usesInheritance) {
      features.push(importExpr(Identifiers$1.InheritDefinitionFeature));
    }
    if (meta.fullInheritance) {
      features.push(importExpr(Identifiers$1.CopyDefinitionFeature));
    }
    if (meta.lifecycle.usesOnChanges) {
      features.push(importExpr(Identifiers$1.NgOnChangesFeature));
    }
    if (features.length) {
      definitionMap.set("features", literalArr(features));
    }
  }
  function compileDirectiveFromMetadata(meta, constantPool, bindingParser) {
    const definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);
    addFeatures(definitionMap, meta);
    const expression = importExpr(Identifiers$1.defineDirective).callFn([definitionMap.toLiteralMap()], void 0, true);
    const type = createDirectiveType(meta);
    return { expression, type, statements: [] };
  }
  function compileComponentFromMetadata(meta, constantPool, bindingParser) {
    const definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);
    addFeatures(definitionMap, meta);
    const selector = meta.selector && CssSelector.parse(meta.selector);
    const firstSelector = selector && selector[0];
    if (firstSelector) {
      const selectorAttributes = firstSelector.getAttrs();
      if (selectorAttributes.length) {
        definitionMap.set("attrs", constantPool.getConstLiteral(literalArr(selectorAttributes.map((value) => value != null ? literal(value) : literal(void 0))), true));
      }
    }
    let directiveMatcher = null;
    if (meta.directives.length > 0) {
      const matcher = new SelectorMatcher();
      for (const { selector: selector2, type: type2 } of meta.directives) {
        matcher.addSelectables(CssSelector.parse(selector2), type2);
      }
      directiveMatcher = matcher;
    }
    const templateTypeName = meta.name;
    const templateName = templateTypeName ? `${templateTypeName}_Template` : null;
    const directivesUsed = /* @__PURE__ */ new Set();
    const pipesUsed = /* @__PURE__ */ new Set();
    const changeDetection = meta.changeDetection;
    const template = meta.template;
    const templateBuilder = new TemplateDefinitionBuilder(constantPool, BindingScope$1.createRootScope(), 0, templateTypeName, null, null, templateName, directiveMatcher, directivesUsed, meta.pipes, pipesUsed, Identifiers$1.namespaceHTML, meta.relativeContextFilePath, meta.i18nUseExternalIds);
    const templateFunctionExpression = templateBuilder.buildTemplateFunction(template.nodes, []);
    const ngContentSelectors = templateBuilder.getNgContentSelectors();
    if (ngContentSelectors) {
      definitionMap.set("ngContentSelectors", ngContentSelectors);
    }
    definitionMap.set("decls", literal(templateBuilder.getConstCount()));
    definitionMap.set("vars", literal(templateBuilder.getVarCount()));
    const { constExpressions, prepareStatements } = templateBuilder.getConsts();
    if (constExpressions.length > 0) {
      let constsExpr = literalArr(constExpressions);
      if (prepareStatements.length > 0) {
        constsExpr = fn([], [...prepareStatements, new ReturnStatement(constsExpr)]);
      }
      definitionMap.set("consts", constsExpr);
    }
    definitionMap.set("template", templateFunctionExpression);
    if (directivesUsed.size) {
      const directivesList = literalArr(Array.from(directivesUsed));
      const directivesExpr = compileDeclarationList(directivesList, meta.declarationListEmitMode);
      definitionMap.set("directives", directivesExpr);
    }
    if (pipesUsed.size) {
      const pipesList = literalArr(Array.from(pipesUsed));
      const pipesExpr = compileDeclarationList(pipesList, meta.declarationListEmitMode);
      definitionMap.set("pipes", pipesExpr);
    }
    if (meta.encapsulation === null) {
      meta.encapsulation = ViewEncapsulation2.Emulated;
    }
    if (meta.styles && meta.styles.length) {
      const styleValues = meta.encapsulation == ViewEncapsulation2.Emulated ? compileStyles(meta.styles, CONTENT_ATTR, HOST_ATTR) : meta.styles;
      const strings = styleValues.map((str) => constantPool.getConstLiteral(literal(str)));
      definitionMap.set("styles", literalArr(strings));
    } else if (meta.encapsulation === ViewEncapsulation2.Emulated) {
      meta.encapsulation = ViewEncapsulation2.None;
    }
    if (meta.encapsulation !== ViewEncapsulation2.Emulated) {
      definitionMap.set("encapsulation", literal(meta.encapsulation));
    }
    if (meta.animations !== null) {
      definitionMap.set("data", literalMap([{ key: "animation", value: meta.animations, quoted: false }]));
    }
    if (changeDetection != null && changeDetection !== ChangeDetectionStrategy2.Default) {
      definitionMap.set("changeDetection", literal(changeDetection));
    }
    const expression = importExpr(Identifiers$1.defineComponent).callFn([definitionMap.toLiteralMap()], void 0, true);
    const type = createComponentType(meta);
    return { expression, type, statements: [] };
  }
  function createComponentType(meta) {
    const typeParams = createDirectiveTypeParams(meta);
    typeParams.push(stringArrayAsType(meta.template.ngContentSelectors));
    return expressionType(importExpr(Identifiers$1.ComponentDeclaration, typeParams));
  }
  function compileDeclarationList(list, mode) {
    switch (mode) {
      case 0:
        return list;
      case 1:
        return fn([], [new ReturnStatement(list)]);
      case 2:
        const resolvedList = list.prop("map").callFn([importExpr(Identifiers$1.resolveForwardRef)]);
        return fn([], [new ReturnStatement(resolvedList)]);
    }
  }
  function prepareQueryParams(query, constantPool) {
    const parameters = [getQueryPredicate(query, constantPool), literal(toQueryFlags(query))];
    if (query.read) {
      parameters.push(query.read);
    }
    return parameters;
  }
  function toQueryFlags(query) {
    return (query.descendants ? 1 : 0) | (query.static ? 2 : 0) | (query.emitDistinctChangesOnly ? 4 : 0);
  }
  function convertAttributesToExpressions(attributes) {
    const values = [];
    for (let key of Object.getOwnPropertyNames(attributes)) {
      const value = attributes[key];
      values.push(literal(key), value);
    }
    return values;
  }
  function createContentQueriesFunction(queries, constantPool, name) {
    const createStatements = [];
    const updateStatements = [];
    const tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);
    for (const query of queries) {
      createStatements.push(importExpr(Identifiers$1.contentQuery).callFn([variable("dirIndex"), ...prepareQueryParams(query, constantPool)]).toStmt());
      const temporary = tempAllocator();
      const getQueryList = importExpr(Identifiers$1.loadQuery).callFn([]);
      const refresh = importExpr(Identifiers$1.queryRefresh).callFn([temporary.set(getQueryList)]);
      const updateDirective = variable(CONTEXT_NAME).prop(query.propertyName).set(query.first ? temporary.prop("first") : temporary);
      updateStatements.push(refresh.and(updateDirective).toStmt());
    }
    const contentQueriesFnName = name ? `${name}_ContentQueries` : null;
    return fn([
      new FnParam(RENDER_FLAGS, NUMBER_TYPE),
      new FnParam(CONTEXT_NAME, null),
      new FnParam("dirIndex", null)
    ], [
      renderFlagCheckIfStmt(1, createStatements),
      renderFlagCheckIfStmt(2, updateStatements)
    ], INFERRED_TYPE, null, contentQueriesFnName);
  }
  function stringAsType(str) {
    return expressionType(literal(str));
  }
  function stringMapAsType(map2) {
    const mapValues = Object.keys(map2).map((key) => {
      const value = Array.isArray(map2[key]) ? map2[key][0] : map2[key];
      return {
        key,
        value: literal(value),
        quoted: true
      };
    });
    return expressionType(literalMap(mapValues));
  }
  function stringArrayAsType(arr) {
    return arr.length > 0 ? expressionType(literalArr(arr.map((value) => literal(value)))) : NONE_TYPE;
  }
  function createDirectiveTypeParams(meta) {
    const selectorForType = meta.selector !== null ? meta.selector.replace(/\n/g, "") : null;
    return [
      typeWithParameters(meta.type.type, meta.typeArgumentCount),
      selectorForType !== null ? stringAsType(selectorForType) : NONE_TYPE,
      meta.exportAs !== null ? stringArrayAsType(meta.exportAs) : NONE_TYPE,
      stringMapAsType(meta.inputs),
      stringMapAsType(meta.outputs),
      stringArrayAsType(meta.queries.map((q) => q.propertyName))
    ];
  }
  function createDirectiveType(meta) {
    const typeParams = createDirectiveTypeParams(meta);
    return expressionType(importExpr(Identifiers$1.DirectiveDeclaration, typeParams));
  }
  function createViewQueriesFunction(viewQueries, constantPool, name) {
    const createStatements = [];
    const updateStatements = [];
    const tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);
    viewQueries.forEach((query) => {
      const queryDefinition = importExpr(Identifiers$1.viewQuery).callFn(prepareQueryParams(query, constantPool));
      createStatements.push(queryDefinition.toStmt());
      const temporary = tempAllocator();
      const getQueryList = importExpr(Identifiers$1.loadQuery).callFn([]);
      const refresh = importExpr(Identifiers$1.queryRefresh).callFn([temporary.set(getQueryList)]);
      const updateDirective = variable(CONTEXT_NAME).prop(query.propertyName).set(query.first ? temporary.prop("first") : temporary);
      updateStatements.push(refresh.and(updateDirective).toStmt());
    });
    const viewQueryFnName = name ? `${name}_Query` : null;
    return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], [
      renderFlagCheckIfStmt(1, createStatements),
      renderFlagCheckIfStmt(2, updateStatements)
    ], INFERRED_TYPE, null, viewQueryFnName);
  }
  function createHostBindingsFunction(hostBindingsMetadata, typeSourceSpan, bindingParser, constantPool, selector, name, definitionMap) {
    const bindingContext = variable(CONTEXT_NAME);
    const styleBuilder = new StylingBuilder(bindingContext);
    const { styleAttr, classAttr } = hostBindingsMetadata.specialAttributes;
    if (styleAttr !== void 0) {
      styleBuilder.registerStyleAttr(styleAttr);
    }
    if (classAttr !== void 0) {
      styleBuilder.registerClassAttr(classAttr);
    }
    const createStatements = [];
    const updateStatements = [];
    const hostBindingSourceSpan = typeSourceSpan;
    const directiveSummary = metadataAsSummary(hostBindingsMetadata);
    const eventBindings = bindingParser.createDirectiveHostEventAsts(directiveSummary, hostBindingSourceSpan);
    if (eventBindings && eventBindings.length) {
      const listeners = createHostListeners(eventBindings, name);
      createStatements.push(...listeners);
    }
    const bindings = bindingParser.createBoundHostProperties(directiveSummary, hostBindingSourceSpan);
    const allOtherBindings = [];
    let totalHostVarsCount = 0;
    bindings && bindings.forEach((binding) => {
      const stylingInputWasSet = styleBuilder.registerInputBasedOnName(binding.name, binding.expression, hostBindingSourceSpan);
      if (stylingInputWasSet) {
        totalHostVarsCount += MIN_STYLING_BINDING_SLOTS_REQUIRED;
      } else {
        allOtherBindings.push(binding);
        totalHostVarsCount++;
      }
    });
    let valueConverter;
    const getValueConverter = () => {
      if (!valueConverter) {
        const hostVarsCountFn = (numSlots) => {
          const originalVarsCount = totalHostVarsCount;
          totalHostVarsCount += numSlots;
          return originalVarsCount;
        };
        valueConverter = new ValueConverter(constantPool, () => error2("Unexpected node"), hostVarsCountFn, () => error2("Unexpected pipe"));
      }
      return valueConverter;
    };
    const propertyBindings = [];
    const attributeBindings = [];
    const syntheticHostBindings = [];
    allOtherBindings.forEach((binding) => {
      const value = binding.expression.visit(getValueConverter());
      const bindingExpr = bindingFn(bindingContext, value);
      const { bindingName, instruction: instruction2, isAttribute } = getBindingNameAndInstruction(binding);
      const securityContexts = bindingParser.calcPossibleSecurityContexts(selector, bindingName, isAttribute).filter((context2) => context2 !== SecurityContext2.NONE);
      let sanitizerFn = null;
      if (securityContexts.length) {
        if (securityContexts.length === 2 && securityContexts.indexOf(SecurityContext2.URL) > -1 && securityContexts.indexOf(SecurityContext2.RESOURCE_URL) > -1) {
          sanitizerFn = importExpr(Identifiers$1.sanitizeUrlOrResourceUrl);
        } else {
          sanitizerFn = resolveSanitizationFn(securityContexts[0], isAttribute);
        }
      }
      const instructionParams = [literal(bindingName), bindingExpr.currValExpr];
      if (sanitizerFn) {
        instructionParams.push(sanitizerFn);
      }
      updateStatements.push(...bindingExpr.stmts);
      if (instruction2 === Identifiers$1.hostProperty) {
        propertyBindings.push(instructionParams);
      } else if (instruction2 === Identifiers$1.attribute) {
        attributeBindings.push(instructionParams);
      } else if (instruction2 === Identifiers$1.syntheticHostProperty) {
        syntheticHostBindings.push(instructionParams);
      } else {
        updateStatements.push(importExpr(instruction2).callFn(instructionParams).toStmt());
      }
    });
    if (propertyBindings.length > 0) {
      updateStatements.push(chainedInstruction(Identifiers$1.hostProperty, propertyBindings).toStmt());
    }
    if (attributeBindings.length > 0) {
      updateStatements.push(chainedInstruction(Identifiers$1.attribute, attributeBindings).toStmt());
    }
    if (syntheticHostBindings.length > 0) {
      updateStatements.push(chainedInstruction(Identifiers$1.syntheticHostProperty, syntheticHostBindings).toStmt());
    }
    const hostAttrs = convertAttributesToExpressions(hostBindingsMetadata.attributes);
    styleBuilder.assignHostAttrs(hostAttrs, definitionMap);
    if (styleBuilder.hasBindings) {
      styleBuilder.buildUpdateLevelInstructions(getValueConverter()).forEach((instruction2) => {
        if (instruction2.calls.length > 0) {
          const calls = [];
          instruction2.calls.forEach((call) => {
            totalHostVarsCount += Math.max(call.allocateBindingSlots - MIN_STYLING_BINDING_SLOTS_REQUIRED, 0);
            calls.push(convertStylingCall(call, bindingContext, bindingFn));
          });
          updateStatements.push(chainedInstruction(instruction2.reference, calls).toStmt());
        }
      });
    }
    if (totalHostVarsCount) {
      definitionMap.set("hostVars", literal(totalHostVarsCount));
    }
    if (createStatements.length > 0 || updateStatements.length > 0) {
      const hostBindingsFnName = name ? `${name}_HostBindings` : null;
      const statements = [];
      if (createStatements.length > 0) {
        statements.push(renderFlagCheckIfStmt(1, createStatements));
      }
      if (updateStatements.length > 0) {
        statements.push(renderFlagCheckIfStmt(2, updateStatements));
      }
      return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], statements, INFERRED_TYPE, null, hostBindingsFnName);
    }
    return null;
  }
  function bindingFn(implicit, value) {
    return convertPropertyBinding(null, implicit, value, "b", BindingForm.Expression, () => error2("Unexpected interpolation"));
  }
  function convertStylingCall(call, bindingContext, bindingFn2) {
    return call.params((value) => bindingFn2(bindingContext, value).currValExpr);
  }
  function getBindingNameAndInstruction(binding) {
    let bindingName = binding.name;
    let instruction2;
    const attrMatches = bindingName.match(ATTR_REGEX);
    if (attrMatches) {
      bindingName = attrMatches[1];
      instruction2 = Identifiers$1.attribute;
    } else {
      if (binding.isAnimation) {
        bindingName = prepareSyntheticPropertyName(bindingName);
        instruction2 = Identifiers$1.syntheticHostProperty;
      } else {
        instruction2 = Identifiers$1.hostProperty;
      }
    }
    return { bindingName, instruction: instruction2, isAttribute: !!attrMatches };
  }
  function createHostListeners(eventBindings, name) {
    const listeners = [];
    const syntheticListeners = [];
    const instructions = [];
    eventBindings.forEach((binding) => {
      let bindingName = binding.name && sanitizeIdentifier(binding.name);
      const bindingFnName = binding.type === 1 ? prepareSyntheticListenerFunctionName(bindingName, binding.targetOrPhase) : bindingName;
      const handlerName = name && bindingName ? `${name}_${bindingFnName}_HostBindingHandler` : null;
      const params = prepareEventListenerParameters(BoundEvent.fromParsedEvent(binding), handlerName);
      if (binding.type == 1) {
        syntheticListeners.push(params);
      } else {
        listeners.push(params);
      }
    });
    if (syntheticListeners.length > 0) {
      instructions.push(chainedInstruction(Identifiers$1.syntheticHostListener, syntheticListeners).toStmt());
    }
    if (listeners.length > 0) {
      instructions.push(chainedInstruction(Identifiers$1.listener, listeners).toStmt());
    }
    return instructions;
  }
  function metadataAsSummary(meta) {
    return {
      hostAttributes: {},
      hostListeners: meta.listeners,
      hostProperties: meta.properties
    };
  }
  var HOST_REG_EXP = /^(?:\[([^\]]+)\])|(?:\(([^\)]+)\))$/;
  function parseHostBindings(host) {
    const attributes = {};
    const listeners = {};
    const properties = {};
    const specialAttributes = {};
    for (const key of Object.keys(host)) {
      const value = host[key];
      const matches = key.match(HOST_REG_EXP);
      if (matches === null) {
        switch (key) {
          case "class":
            if (typeof value !== "string") {
              throw new Error(`Class binding must be string`);
            }
            specialAttributes.classAttr = value;
            break;
          case "style":
            if (typeof value !== "string") {
              throw new Error(`Style binding must be string`);
            }
            specialAttributes.styleAttr = value;
            break;
          default:
            if (typeof value === "string") {
              attributes[key] = literal(value);
            } else {
              attributes[key] = value;
            }
        }
      } else if (matches[1] != null) {
        if (typeof value !== "string") {
          throw new Error(`Property binding must be string`);
        }
        properties[matches[1]] = value;
      } else if (matches[2] != null) {
        if (typeof value !== "string") {
          throw new Error(`Event binding must be string`);
        }
        listeners[matches[2]] = value;
      }
    }
    return { attributes, listeners, properties, specialAttributes };
  }
  function verifyHostBindings(bindings, sourceSpan) {
    const summary = metadataAsSummary(bindings);
    const bindingParser = makeBindingParser();
    bindingParser.createDirectiveHostEventAsts(summary, sourceSpan);
    bindingParser.createBoundHostProperties(summary, sourceSpan);
    return bindingParser.errors;
  }
  function compileStyles(styles, selector, hostSelector) {
    const shadowCss = new ShadowCss();
    return styles.map((style) => {
      return shadowCss.shimCssText(style, selector, hostSelector);
    });
  }
  var ResourceLoader = class {
  };
  var CompilerFacadeImpl = class {
    constructor(jitEvaluator = new JitEvaluator()) {
      this.jitEvaluator = jitEvaluator;
      this.FactoryTarget = FactoryTarget$1;
      this.ResourceLoader = ResourceLoader;
      this.elementSchemaRegistry = new DomElementSchemaRegistry();
    }
    compilePipe(angularCoreEnv2, sourceMapUrl, facade) {
      const metadata = {
        name: facade.name,
        type: wrapReference(facade.type),
        internalType: new WrappedNodeExpr(facade.type),
        typeArgumentCount: 0,
        deps: null,
        pipeName: facade.pipeName,
        pure: facade.pure
      };
      const res = compilePipeFromMetadata(metadata);
      return this.jitExpression(res.expression, angularCoreEnv2, sourceMapUrl, []);
    }
    compilePipeDeclaration(angularCoreEnv2, sourceMapUrl, declaration) {
      const meta = convertDeclarePipeFacadeToMetadata(declaration);
      const res = compilePipeFromMetadata(meta);
      return this.jitExpression(res.expression, angularCoreEnv2, sourceMapUrl, []);
    }
    compileInjectable(angularCoreEnv2, sourceMapUrl, facade) {
      const { expression, statements } = compileInjectable2({
        name: facade.name,
        type: wrapReference(facade.type),
        internalType: new WrappedNodeExpr(facade.type),
        typeArgumentCount: facade.typeArgumentCount,
        providedIn: computeProvidedIn(facade.providedIn),
        useClass: convertToProviderExpression(facade, USE_CLASS),
        useFactory: wrapExpression(facade, USE_FACTORY),
        useValue: convertToProviderExpression(facade, USE_VALUE$12),
        useExisting: convertToProviderExpression(facade, USE_EXISTING),
        deps: facade.deps?.map(convertR3DependencyMetadata)
      }, true);
      return this.jitExpression(expression, angularCoreEnv2, sourceMapUrl, statements);
    }
    compileInjectableDeclaration(angularCoreEnv2, sourceMapUrl, facade) {
      const { expression, statements } = compileInjectable2({
        name: facade.type.name,
        type: wrapReference(facade.type),
        internalType: new WrappedNodeExpr(facade.type),
        typeArgumentCount: 0,
        providedIn: computeProvidedIn(facade.providedIn),
        useClass: convertToProviderExpression(facade, USE_CLASS),
        useFactory: wrapExpression(facade, USE_FACTORY),
        useValue: convertToProviderExpression(facade, USE_VALUE$12),
        useExisting: convertToProviderExpression(facade, USE_EXISTING),
        deps: facade.deps?.map(convertR3DeclareDependencyMetadata)
      }, true);
      return this.jitExpression(expression, angularCoreEnv2, sourceMapUrl, statements);
    }
    compileInjector(angularCoreEnv2, sourceMapUrl, facade) {
      const meta = {
        name: facade.name,
        type: wrapReference(facade.type),
        internalType: new WrappedNodeExpr(facade.type),
        providers: new WrappedNodeExpr(facade.providers),
        imports: facade.imports.map((i) => new WrappedNodeExpr(i))
      };
      const res = compileInjector(meta);
      return this.jitExpression(res.expression, angularCoreEnv2, sourceMapUrl, []);
    }
    compileInjectorDeclaration(angularCoreEnv2, sourceMapUrl, declaration) {
      const meta = convertDeclareInjectorFacadeToMetadata(declaration);
      const res = compileInjector(meta);
      return this.jitExpression(res.expression, angularCoreEnv2, sourceMapUrl, []);
    }
    compileNgModule(angularCoreEnv2, sourceMapUrl, facade) {
      const meta = {
        type: wrapReference(facade.type),
        internalType: new WrappedNodeExpr(facade.type),
        adjacentType: new WrappedNodeExpr(facade.type),
        bootstrap: facade.bootstrap.map(wrapReference),
        declarations: facade.declarations.map(wrapReference),
        imports: facade.imports.map(wrapReference),
        exports: facade.exports.map(wrapReference),
        emitInline: true,
        containsForwardDecls: false,
        schemas: facade.schemas ? facade.schemas.map(wrapReference) : null,
        id: facade.id ? new WrappedNodeExpr(facade.id) : null
      };
      const res = compileNgModule2(meta);
      return this.jitExpression(res.expression, angularCoreEnv2, sourceMapUrl, []);
    }
    compileNgModuleDeclaration(angularCoreEnv2, sourceMapUrl, declaration) {
      const expression = compileNgModuleDeclarationExpression(declaration);
      return this.jitExpression(expression, angularCoreEnv2, sourceMapUrl, []);
    }
    compileDirective(angularCoreEnv2, sourceMapUrl, facade) {
      const meta = convertDirectiveFacadeToMetadata(facade);
      return this.compileDirectiveFromMeta(angularCoreEnv2, sourceMapUrl, meta);
    }
    compileDirectiveDeclaration(angularCoreEnv2, sourceMapUrl, declaration) {
      const typeSourceSpan = this.createParseSourceSpan("Directive", declaration.type.name, sourceMapUrl);
      const meta = convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan);
      return this.compileDirectiveFromMeta(angularCoreEnv2, sourceMapUrl, meta);
    }
    compileDirectiveFromMeta(angularCoreEnv2, sourceMapUrl, meta) {
      const constantPool = new ConstantPool();
      const bindingParser = makeBindingParser();
      const res = compileDirectiveFromMetadata(meta, constantPool, bindingParser);
      return this.jitExpression(res.expression, angularCoreEnv2, sourceMapUrl, constantPool.statements);
    }
    compileComponent(angularCoreEnv2, sourceMapUrl, facade) {
      const { template, interpolation } = parseJitTemplate(facade.template, facade.name, sourceMapUrl, facade.preserveWhitespaces, facade.interpolation);
      const meta = {
        ...facade,
        ...convertDirectiveFacadeToMetadata(facade),
        selector: facade.selector || this.elementSchemaRegistry.getDefaultComponentElementName(),
        template,
        declarationListEmitMode: 0,
        styles: [...facade.styles, ...template.styles],
        encapsulation: facade.encapsulation,
        interpolation,
        changeDetection: facade.changeDetection,
        animations: facade.animations != null ? new WrappedNodeExpr(facade.animations) : null,
        viewProviders: facade.viewProviders != null ? new WrappedNodeExpr(facade.viewProviders) : null,
        relativeContextFilePath: "",
        i18nUseExternalIds: true
      };
      const jitExpressionSourceMap = `ng:///${facade.name}.js`;
      return this.compileComponentFromMeta(angularCoreEnv2, jitExpressionSourceMap, meta);
    }
    compileComponentDeclaration(angularCoreEnv2, sourceMapUrl, declaration) {
      const typeSourceSpan = this.createParseSourceSpan("Component", declaration.type.name, sourceMapUrl);
      const meta = convertDeclareComponentFacadeToMetadata(declaration, typeSourceSpan, sourceMapUrl);
      return this.compileComponentFromMeta(angularCoreEnv2, sourceMapUrl, meta);
    }
    compileComponentFromMeta(angularCoreEnv2, sourceMapUrl, meta) {
      const constantPool = new ConstantPool();
      const bindingParser = makeBindingParser(meta.interpolation);
      const res = compileComponentFromMetadata(meta, constantPool, bindingParser);
      return this.jitExpression(res.expression, angularCoreEnv2, sourceMapUrl, constantPool.statements);
    }
    compileFactory(angularCoreEnv2, sourceMapUrl, meta) {
      const factoryRes = compileFactoryFunction({
        name: meta.name,
        type: wrapReference(meta.type),
        internalType: new WrappedNodeExpr(meta.type),
        typeArgumentCount: meta.typeArgumentCount,
        deps: convertR3DependencyMetadataArray(meta.deps),
        target: meta.target
      });
      return this.jitExpression(factoryRes.expression, angularCoreEnv2, sourceMapUrl, factoryRes.statements);
    }
    compileFactoryDeclaration(angularCoreEnv2, sourceMapUrl, meta) {
      const factoryRes = compileFactoryFunction({
        name: meta.type.name,
        type: wrapReference(meta.type),
        internalType: new WrappedNodeExpr(meta.type),
        typeArgumentCount: 0,
        deps: Array.isArray(meta.deps) ? meta.deps.map(convertR3DeclareDependencyMetadata) : meta.deps,
        target: meta.target
      });
      return this.jitExpression(factoryRes.expression, angularCoreEnv2, sourceMapUrl, factoryRes.statements);
    }
    createParseSourceSpan(kind, typeName, sourceUrl) {
      return r3JitTypeSourceSpan(kind, typeName, sourceUrl);
    }
    jitExpression(def, context2, sourceUrl, preStatements) {
      const statements = [
        ...preStatements,
        new DeclareVarStmt("$def", def, void 0, [StmtModifier.Exported])
      ];
      const res = this.jitEvaluator.evaluateStatements(sourceUrl, statements, new R3JitReflector(context2), true);
      return res["$def"];
    }
  };
  var USE_CLASS = Object.keys({ useClass: null })[0];
  var USE_FACTORY = Object.keys({ useFactory: null })[0];
  var USE_VALUE$12 = Object.keys({ useValue: null })[0];
  var USE_EXISTING = Object.keys({ useExisting: null })[0];
  function convertToR3QueryMetadata2(facade) {
    return {
      ...facade,
      predicate: convertQueryPredicate(facade.predicate),
      read: facade.read ? new WrappedNodeExpr(facade.read) : null,
      static: facade.static,
      emitDistinctChangesOnly: facade.emitDistinctChangesOnly
    };
  }
  function convertQueryDeclarationToMetadata(declaration) {
    return {
      propertyName: declaration.propertyName,
      first: declaration.first ?? false,
      predicate: convertQueryPredicate(declaration.predicate),
      descendants: declaration.descendants ?? false,
      read: declaration.read ? new WrappedNodeExpr(declaration.read) : null,
      static: declaration.static ?? false,
      emitDistinctChangesOnly: declaration.emitDistinctChangesOnly ?? true
    };
  }
  function convertQueryPredicate(predicate) {
    return Array.isArray(predicate) ? predicate : createMayBeForwardRefExpression(new WrappedNodeExpr(predicate), 1);
  }
  function convertDirectiveFacadeToMetadata(facade) {
    const inputsFromMetadata = parseInputOutputs(facade.inputs || []);
    const outputsFromMetadata = parseInputOutputs(facade.outputs || []);
    const propMetadata = facade.propMetadata;
    const inputsFromType = {};
    const outputsFromType = {};
    for (const field in propMetadata) {
      if (propMetadata.hasOwnProperty(field)) {
        propMetadata[field].forEach((ann) => {
          if (isInput(ann)) {
            inputsFromType[field] = ann.bindingPropertyName ? [ann.bindingPropertyName, field] : field;
          } else if (isOutput(ann)) {
            outputsFromType[field] = ann.bindingPropertyName || field;
          }
        });
      }
    }
    return {
      ...facade,
      typeArgumentCount: 0,
      typeSourceSpan: facade.typeSourceSpan,
      type: wrapReference(facade.type),
      internalType: new WrappedNodeExpr(facade.type),
      deps: null,
      host: extractHostBindings(facade.propMetadata, facade.typeSourceSpan, facade.host),
      inputs: { ...inputsFromMetadata, ...inputsFromType },
      outputs: { ...outputsFromMetadata, ...outputsFromType },
      queries: facade.queries.map(convertToR3QueryMetadata2),
      providers: facade.providers != null ? new WrappedNodeExpr(facade.providers) : null,
      viewQueries: facade.viewQueries.map(convertToR3QueryMetadata2),
      fullInheritance: false
    };
  }
  function convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan) {
    return {
      name: declaration.type.name,
      type: wrapReference(declaration.type),
      typeSourceSpan,
      internalType: new WrappedNodeExpr(declaration.type),
      selector: declaration.selector ?? null,
      inputs: declaration.inputs ?? {},
      outputs: declaration.outputs ?? {},
      host: convertHostDeclarationToMetadata(declaration.host),
      queries: (declaration.queries ?? []).map(convertQueryDeclarationToMetadata),
      viewQueries: (declaration.viewQueries ?? []).map(convertQueryDeclarationToMetadata),
      providers: declaration.providers !== void 0 ? new WrappedNodeExpr(declaration.providers) : null,
      exportAs: declaration.exportAs ?? null,
      usesInheritance: declaration.usesInheritance ?? false,
      lifecycle: { usesOnChanges: declaration.usesOnChanges ?? false },
      deps: null,
      typeArgumentCount: 0,
      fullInheritance: false
    };
  }
  function convertHostDeclarationToMetadata(host = {}) {
    return {
      attributes: convertOpaqueValuesToExpressions(host.attributes ?? {}),
      listeners: host.listeners ?? {},
      properties: host.properties ?? {},
      specialAttributes: {
        classAttr: host.classAttribute,
        styleAttr: host.styleAttribute
      }
    };
  }
  function convertOpaqueValuesToExpressions(obj) {
    const result = {};
    for (const key of Object.keys(obj)) {
      result[key] = new WrappedNodeExpr(obj[key]);
    }
    return result;
  }
  function convertDeclareComponentFacadeToMetadata(declaration, typeSourceSpan, sourceMapUrl) {
    const { template, interpolation } = parseJitTemplate(declaration.template, declaration.type.name, sourceMapUrl, declaration.preserveWhitespaces ?? false, declaration.interpolation);
    return {
      ...convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan),
      template,
      styles: declaration.styles ?? [],
      directives: (declaration.components ?? []).concat(declaration.directives ?? []).map(convertUsedDirectiveDeclarationToMetadata),
      pipes: convertUsedPipesToMetadata(declaration.pipes),
      viewProviders: declaration.viewProviders !== void 0 ? new WrappedNodeExpr(declaration.viewProviders) : null,
      animations: declaration.animations !== void 0 ? new WrappedNodeExpr(declaration.animations) : null,
      changeDetection: declaration.changeDetection ?? ChangeDetectionStrategy2.Default,
      encapsulation: declaration.encapsulation ?? ViewEncapsulation2.Emulated,
      interpolation,
      declarationListEmitMode: 2,
      relativeContextFilePath: "",
      i18nUseExternalIds: true
    };
  }
  function convertUsedDirectiveDeclarationToMetadata(declaration) {
    return {
      selector: declaration.selector,
      type: new WrappedNodeExpr(declaration.type),
      inputs: declaration.inputs ?? [],
      outputs: declaration.outputs ?? [],
      exportAs: declaration.exportAs ?? null
    };
  }
  function convertUsedPipesToMetadata(declaredPipes) {
    const pipes = /* @__PURE__ */ new Map();
    if (declaredPipes === void 0) {
      return pipes;
    }
    for (const pipeName of Object.keys(declaredPipes)) {
      const pipeType = declaredPipes[pipeName];
      pipes.set(pipeName, new WrappedNodeExpr(pipeType));
    }
    return pipes;
  }
  function parseJitTemplate(template, typeName, sourceMapUrl, preserveWhitespaces, interpolation) {
    const interpolationConfig = interpolation ? InterpolationConfig.fromArray(interpolation) : DEFAULT_INTERPOLATION_CONFIG;
    const parsed = parseTemplate(template, sourceMapUrl, { preserveWhitespaces, interpolationConfig });
    if (parsed.errors !== null) {
      const errors = parsed.errors.map((err) => err.toString()).join(", ");
      throw new Error(`Errors during JIT compilation of template for ${typeName}: ${errors}`);
    }
    return { template: parsed, interpolation: interpolationConfig };
  }
  function convertToProviderExpression(obj, property) {
    if (obj.hasOwnProperty(property)) {
      return createMayBeForwardRefExpression(new WrappedNodeExpr(obj[property]), 0);
    } else {
      return void 0;
    }
  }
  function wrapExpression(obj, property) {
    if (obj.hasOwnProperty(property)) {
      return new WrappedNodeExpr(obj[property]);
    } else {
      return void 0;
    }
  }
  function computeProvidedIn(providedIn) {
    const expression = typeof providedIn === "function" ? new WrappedNodeExpr(providedIn) : new LiteralExpr(providedIn ?? null);
    return createMayBeForwardRefExpression(expression, 0);
  }
  function convertR3DependencyMetadataArray(facades) {
    return facades == null ? null : facades.map(convertR3DependencyMetadata);
  }
  function convertR3DependencyMetadata(facade) {
    const isAttributeDep = facade.attribute != null;
    const rawToken = facade.token === null ? null : new WrappedNodeExpr(facade.token);
    const token = isAttributeDep ? new WrappedNodeExpr(facade.attribute) : rawToken;
    return createR3DependencyMetadata(token, isAttributeDep, facade.host, facade.optional, facade.self, facade.skipSelf);
  }
  function convertR3DeclareDependencyMetadata(facade) {
    const isAttributeDep = facade.attribute ?? false;
    const token = facade.token === null ? null : new WrappedNodeExpr(facade.token);
    return createR3DependencyMetadata(token, isAttributeDep, facade.host ?? false, facade.optional ?? false, facade.self ?? false, facade.skipSelf ?? false);
  }
  function createR3DependencyMetadata(token, isAttributeDep, host, optional, self2, skipSelf) {
    const attributeNameType = isAttributeDep ? literal("unknown") : null;
    return { token, attributeNameType, host, optional, self: self2, skipSelf };
  }
  function extractHostBindings(propMetadata, sourceSpan, host) {
    const bindings = parseHostBindings(host || {});
    const errors = verifyHostBindings(bindings, sourceSpan);
    if (errors.length) {
      throw new Error(errors.map((error3) => error3.msg).join("\n"));
    }
    for (const field in propMetadata) {
      if (propMetadata.hasOwnProperty(field)) {
        propMetadata[field].forEach((ann) => {
          if (isHostBinding(ann)) {
            bindings.properties[ann.hostPropertyName || field] = getSafePropertyAccessString("this", field);
          } else if (isHostListener(ann)) {
            bindings.listeners[ann.eventName || field] = `${field}(${(ann.args || []).join(",")})`;
          }
        });
      }
    }
    return bindings;
  }
  function isHostBinding(value) {
    return value.ngMetadataName === "HostBinding";
  }
  function isHostListener(value) {
    return value.ngMetadataName === "HostListener";
  }
  function isInput(value) {
    return value.ngMetadataName === "Input";
  }
  function isOutput(value) {
    return value.ngMetadataName === "Output";
  }
  function parseInputOutputs(values) {
    return values.reduce((map2, value) => {
      const [field, property] = value.split(",").map((piece) => piece.trim());
      map2[field] = property || field;
      return map2;
    }, {});
  }
  function convertDeclarePipeFacadeToMetadata(declaration) {
    return {
      name: declaration.type.name,
      type: wrapReference(declaration.type),
      internalType: new WrappedNodeExpr(declaration.type),
      typeArgumentCount: 0,
      pipeName: declaration.name,
      deps: null,
      pure: declaration.pure ?? true
    };
  }
  function convertDeclareInjectorFacadeToMetadata(declaration) {
    return {
      name: declaration.type.name,
      type: wrapReference(declaration.type),
      internalType: new WrappedNodeExpr(declaration.type),
      providers: declaration.providers !== void 0 ? new WrappedNodeExpr(declaration.providers) : null,
      imports: declaration.imports !== void 0 ? declaration.imports.map((i) => new WrappedNodeExpr(i)) : []
    };
  }
  function publishFacade(global2) {
    const ng = global2.ng || (global2.ng = {});
    ng.\u0275compilerFacade = new CompilerFacadeImpl();
  }
  var VERSION2 = new Version2("13.0.3");
  var CompilerConfig = class {
    constructor({ defaultEncapsulation = ViewEncapsulation2.Emulated, useJit = true, jitDevMode = false, missingTranslation = null, preserveWhitespaces, strictInjectionParameters } = {}) {
      this.defaultEncapsulation = defaultEncapsulation;
      this.useJit = !!useJit;
      this.jitDevMode = !!jitDevMode;
      this.missingTranslation = missingTranslation;
      this.preserveWhitespaces = preserveWhitespacesDefault(noUndefined(preserveWhitespaces));
      this.strictInjectionParameters = strictInjectionParameters === true;
    }
  };
  function preserveWhitespacesDefault(preserveWhitespacesOption, defaultSetting = false) {
    return preserveWhitespacesOption === null ? defaultSetting : preserveWhitespacesOption;
  }
  var _VisitorMode;
  (function(_VisitorMode2) {
    _VisitorMode2[_VisitorMode2["Extract"] = 0] = "Extract";
    _VisitorMode2[_VisitorMode2["Merge"] = 1] = "Merge";
  })(_VisitorMode || (_VisitorMode = {}));
  var XmlTagDefinition = class {
    constructor() {
      this.closedByParent = false;
      this.isVoid = false;
      this.ignoreFirstLf = false;
      this.canSelfClose = true;
      this.preventNamespaceInheritance = false;
    }
    requireExtraParent(currentParent) {
      return false;
    }
    isClosedByChild(name) {
      return false;
    }
    getContentType() {
      return TagContentType.PARSABLE_DATA;
    }
  };
  var _TAG_DEFINITION = new XmlTagDefinition();
  var LifecycleHooks;
  (function(LifecycleHooks2) {
    LifecycleHooks2[LifecycleHooks2["OnInit"] = 0] = "OnInit";
    LifecycleHooks2[LifecycleHooks2["OnDestroy"] = 1] = "OnDestroy";
    LifecycleHooks2[LifecycleHooks2["DoCheck"] = 2] = "DoCheck";
    LifecycleHooks2[LifecycleHooks2["OnChanges"] = 3] = "OnChanges";
    LifecycleHooks2[LifecycleHooks2["AfterContentInit"] = 4] = "AfterContentInit";
    LifecycleHooks2[LifecycleHooks2["AfterContentChecked"] = 5] = "AfterContentChecked";
    LifecycleHooks2[LifecycleHooks2["AfterViewInit"] = 6] = "AfterViewInit";
    LifecycleHooks2[LifecycleHooks2["AfterViewChecked"] = 7] = "AfterViewChecked";
  })(LifecycleHooks || (LifecycleHooks = {}));
  var LIFECYCLE_HOOKS_VALUES = [
    LifecycleHooks.OnInit,
    LifecycleHooks.OnDestroy,
    LifecycleHooks.DoCheck,
    LifecycleHooks.OnChanges,
    LifecycleHooks.AfterContentInit,
    LifecycleHooks.AfterContentChecked,
    LifecycleHooks.AfterViewInit,
    LifecycleHooks.AfterViewChecked
  ];
  var LOG_VAR$1 = variable("_l");
  var DYNAMIC_VAR_NAME = "_any";
  var TypeCheckLocalResolver = class {
    notifyImplicitReceiverUse() {
    }
    maybeRestoreView() {
    }
    getLocal(name) {
      if (name === EventHandlerVars.event.name) {
        return variable(DYNAMIC_VAR_NAME);
      }
      return null;
    }
  };
  var defaultResolver = new TypeCheckLocalResolver();
  var LOG_VAR = variable("_l");
  var VIEW_VAR = variable("_v");
  var CHECK_VAR = variable("_ck");
  var COMP_VAR = variable("_co");
  var EVENT_NAME_VAR = variable("en");
  var ALLOW_DEFAULT_VAR = variable(`ad`);
  var BindingScope = class {
    static build() {
      const current = /* @__PURE__ */ new Map();
      return {
        define: function(name, value) {
          current.set(name, value);
          return this;
        },
        done: function() {
          return current.size > 0 ? new PopulatedScope(current) : BindingScope.empty;
        }
      };
    }
  };
  BindingScope.missing = {};
  BindingScope.empty = { resolve: (name) => BindingScope.missing };
  var PopulatedScope = class extends BindingScope {
    constructor(bindings) {
      super();
      this.bindings = bindings;
    }
    resolve(name) {
      return this.bindings.has(name) ? this.bindings.get(name) : BindingScope.missing;
    }
  };
  var _splitRe = new RegExp("^(?:([^:/?#.]+):)?(?://(?:([^/?#]*)@)?([\\w\\d\\-\\u0100-\\uffff.%]*)(?::([0-9]+))?)?([^?#]+)?(?:\\?([^#]*))?(?:#(.*))?$");
  var _ComponentIndex;
  (function(_ComponentIndex2) {
    _ComponentIndex2[_ComponentIndex2["Scheme"] = 1] = "Scheme";
    _ComponentIndex2[_ComponentIndex2["UserInfo"] = 2] = "UserInfo";
    _ComponentIndex2[_ComponentIndex2["Domain"] = 3] = "Domain";
    _ComponentIndex2[_ComponentIndex2["Port"] = 4] = "Port";
    _ComponentIndex2[_ComponentIndex2["Path"] = 5] = "Path";
    _ComponentIndex2[_ComponentIndex2["QueryData"] = 6] = "QueryData";
    _ComponentIndex2[_ComponentIndex2["Fragment"] = 7] = "Fragment";
  })(_ComponentIndex || (_ComponentIndex = {}));
  var FactoryTarget2;
  (function(FactoryTarget3) {
    FactoryTarget3[FactoryTarget3["Directive"] = 0] = "Directive";
    FactoryTarget3[FactoryTarget3["Component"] = 1] = "Component";
    FactoryTarget3[FactoryTarget3["Injectable"] = 2] = "Injectable";
    FactoryTarget3[FactoryTarget3["Pipe"] = 3] = "Pipe";
    FactoryTarget3[FactoryTarget3["NgModule"] = 4] = "NgModule";
  })(FactoryTarget2 || (FactoryTarget2 = {}));
  publishFacade(_global3);

  // node_modules/@angular/core/fesm2020/testing.mjs
  var ComponentFixture = class {
    constructor(componentRef, ngZone, _autoDetect) {
      this.componentRef = componentRef;
      this.ngZone = ngZone;
      this._autoDetect = _autoDetect;
      this._isStable = true;
      this._isDestroyed = false;
      this._resolve = null;
      this._promise = null;
      this._onUnstableSubscription = null;
      this._onStableSubscription = null;
      this._onMicrotaskEmptySubscription = null;
      this._onErrorSubscription = null;
      this.changeDetectorRef = componentRef.changeDetectorRef;
      this.elementRef = componentRef.location;
      this.debugElement = getDebugNode(this.elementRef.nativeElement);
      this.componentInstance = componentRef.instance;
      this.nativeElement = this.elementRef.nativeElement;
      this.componentRef = componentRef;
      this.ngZone = ngZone;
      if (ngZone) {
        ngZone.runOutsideAngular(() => {
          this._onUnstableSubscription = ngZone.onUnstable.subscribe({
            next: () => {
              this._isStable = false;
            }
          });
          this._onMicrotaskEmptySubscription = ngZone.onMicrotaskEmpty.subscribe({
            next: () => {
              if (this._autoDetect) {
                this.detectChanges(true);
              }
            }
          });
          this._onStableSubscription = ngZone.onStable.subscribe({
            next: () => {
              this._isStable = true;
              if (this._promise !== null) {
                scheduleMicroTask2(() => {
                  if (!ngZone.hasPendingMacrotasks) {
                    if (this._promise !== null) {
                      this._resolve(true);
                      this._resolve = null;
                      this._promise = null;
                    }
                  }
                });
              }
            }
          });
          this._onErrorSubscription = ngZone.onError.subscribe({
            next: (error3) => {
              throw error3;
            }
          });
        });
      }
    }
    _tick(checkNoChanges) {
      this.changeDetectorRef.detectChanges();
      if (checkNoChanges) {
        this.checkNoChanges();
      }
    }
    detectChanges(checkNoChanges = true) {
      if (this.ngZone != null) {
        this.ngZone.run(() => {
          this._tick(checkNoChanges);
        });
      } else {
        this._tick(checkNoChanges);
      }
    }
    checkNoChanges() {
      this.changeDetectorRef.checkNoChanges();
    }
    autoDetectChanges(autoDetect = true) {
      if (this.ngZone == null) {
        throw new Error("Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set");
      }
      this._autoDetect = autoDetect;
      this.detectChanges();
    }
    isStable() {
      return this._isStable && !this.ngZone.hasPendingMacrotasks;
    }
    whenStable() {
      if (this.isStable()) {
        return Promise.resolve(false);
      } else if (this._promise !== null) {
        return this._promise;
      } else {
        this._promise = new Promise((res) => {
          this._resolve = res;
        });
        return this._promise;
      }
    }
    _getRenderer() {
      if (this._renderer === void 0) {
        this._renderer = this.componentRef.injector.get(RendererFactory2, null);
      }
      return this._renderer;
    }
    whenRenderingDone() {
      const renderer = this._getRenderer();
      if (renderer && renderer.whenRenderingDone) {
        return renderer.whenRenderingDone();
      }
      return this.whenStable();
    }
    destroy() {
      if (!this._isDestroyed) {
        this.componentRef.destroy();
        if (this._onUnstableSubscription != null) {
          this._onUnstableSubscription.unsubscribe();
          this._onUnstableSubscription = null;
        }
        if (this._onStableSubscription != null) {
          this._onStableSubscription.unsubscribe();
          this._onStableSubscription = null;
        }
        if (this._onMicrotaskEmptySubscription != null) {
          this._onMicrotaskEmptySubscription.unsubscribe();
          this._onMicrotaskEmptySubscription = null;
        }
        if (this._onErrorSubscription != null) {
          this._onErrorSubscription.unsubscribe();
          this._onErrorSubscription = null;
        }
        this._isDestroyed = true;
      }
    }
  };
  function scheduleMicroTask2(fn2) {
    Zone.current.scheduleMicroTask("scheduleMicrotask", fn2);
  }
  var _Zone = typeof Zone !== "undefined" ? Zone : null;
  var fakeAsyncTestModule = _Zone && _Zone[_Zone.__symbol__("fakeAsyncTest")];
  var fakeAsyncTestModuleNotLoadedErrorMessage = `zone-testing.js is needed for the fakeAsync() test helper but could not be found.
        Please make sure that your environment includes zone.js/testing`;
  function resetFakeAsyncZone() {
    if (fakeAsyncTestModule) {
      return fakeAsyncTestModule.resetFakeAsyncZone();
    }
    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);
  }
  function resolveComponentResources2(resourceResolver) {
    const componentResolved = [];
    const urlMap = /* @__PURE__ */ new Map();
    function cachedResourceResolve(url) {
      let promise2 = urlMap.get(url);
      if (!promise2) {
        const resp = resourceResolver(url);
        urlMap.set(url, promise2 = resp.then(unwrapResponse2));
      }
      return promise2;
    }
    componentResourceResolutionQueue2.forEach((component, type) => {
      const promises = [];
      if (component.templateUrl) {
        promises.push(cachedResourceResolve(component.templateUrl).then((template) => {
          component.template = template;
        }));
      }
      const styleUrls = component.styleUrls;
      const styles = component.styles || (component.styles = []);
      const styleOffset = component.styles.length;
      styleUrls && styleUrls.forEach((styleUrl, index) => {
        styles.push("");
        promises.push(cachedResourceResolve(styleUrl).then((style) => {
          styles[styleOffset + index] = style;
          styleUrls.splice(styleUrls.indexOf(styleUrl), 1);
          if (styleUrls.length == 0) {
            component.styleUrls = void 0;
          }
        }));
      });
      const fullyResolved = Promise.all(promises).then(() => componentDefResolved2(type));
      componentResolved.push(fullyResolved);
    });
    clearResolutionOfComponentResourcesQueue2();
    return Promise.all(componentResolved).then(() => void 0);
  }
  var componentResourceResolutionQueue2 = /* @__PURE__ */ new Map();
  var componentDefPendingResolution2 = /* @__PURE__ */ new Set();
  function isComponentDefPendingResolution(type) {
    return componentDefPendingResolution2.has(type);
  }
  function clearResolutionOfComponentResourcesQueue2() {
    const old = componentResourceResolutionQueue2;
    componentResourceResolutionQueue2 = /* @__PURE__ */ new Map();
    return old;
  }
  function restoreComponentResolutionQueue(queue) {
    componentDefPendingResolution2.clear();
    queue.forEach((_, type) => componentDefPendingResolution2.add(type));
    componentResourceResolutionQueue2 = queue;
  }
  function unwrapResponse2(response) {
    return typeof response == "string" ? response : response.text();
  }
  function componentDefResolved2(type) {
    componentDefPendingResolution2.delete(type);
  }
  var _nextReferenceId = 0;
  var MetadataOverrider = class {
    constructor() {
      this._references = /* @__PURE__ */ new Map();
    }
    overrideMetadata(metadataClass, oldMetadata, override) {
      const props = {};
      if (oldMetadata) {
        _valueProps(oldMetadata).forEach((prop) => props[prop] = oldMetadata[prop]);
      }
      if (override.set) {
        if (override.remove || override.add) {
          throw new Error(`Cannot set and add/remove ${stringify(metadataClass)} at the same time!`);
        }
        setMetadata(props, override.set);
      }
      if (override.remove) {
        removeMetadata(props, override.remove, this._references);
      }
      if (override.add) {
        addMetadata(props, override.add);
      }
      return new metadataClass(props);
    }
  };
  function removeMetadata(metadata, remove2, references) {
    const removeObjects = /* @__PURE__ */ new Set();
    for (const prop in remove2) {
      const removeValue = remove2[prop];
      if (Array.isArray(removeValue)) {
        removeValue.forEach((value) => {
          removeObjects.add(_propHashKey(prop, value, references));
        });
      } else {
        removeObjects.add(_propHashKey(prop, removeValue, references));
      }
    }
    for (const prop in metadata) {
      const propValue = metadata[prop];
      if (Array.isArray(propValue)) {
        metadata[prop] = propValue.filter((value) => !removeObjects.has(_propHashKey(prop, value, references)));
      } else {
        if (removeObjects.has(_propHashKey(prop, propValue, references))) {
          metadata[prop] = void 0;
        }
      }
    }
  }
  function addMetadata(metadata, add) {
    for (const prop in add) {
      const addValue = add[prop];
      const propValue = metadata[prop];
      if (propValue != null && Array.isArray(propValue)) {
        metadata[prop] = propValue.concat(addValue);
      } else {
        metadata[prop] = addValue;
      }
    }
  }
  function setMetadata(metadata, set) {
    for (const prop in set) {
      metadata[prop] = set[prop];
    }
  }
  function _propHashKey(propName, propValue, references) {
    let nextObjectId = 0;
    const objectIds = /* @__PURE__ */ new Map();
    const replacer = (key, value) => {
      if (value !== null && typeof value === "object") {
        if (objectIds.has(value)) {
          return objectIds.get(value);
        }
        objectIds.set(value, `\u0275obj#${nextObjectId++}`);
        return value;
      } else if (typeof value === "function") {
        value = _serializeReference(value, references);
      }
      return value;
    };
    return `${propName}:${JSON.stringify(propValue, replacer)}`;
  }
  function _serializeReference(ref, references) {
    let id = references.get(ref);
    if (!id) {
      id = `${stringify(ref)}${_nextReferenceId++}`;
      references.set(ref, id);
    }
    return id;
  }
  function _valueProps(obj) {
    const props = [];
    Object.keys(obj).forEach((prop) => {
      if (!prop.startsWith("_")) {
        props.push(prop);
      }
    });
    let proto = obj;
    while (proto = Object.getPrototypeOf(proto)) {
      Object.keys(proto).forEach((protoProp) => {
        const desc = Object.getOwnPropertyDescriptor(proto, protoProp);
        if (!protoProp.startsWith("_") && desc && "get" in desc) {
          props.push(protoProp);
        }
      });
    }
    return props;
  }
  var reflection = new ReflectionCapabilities();
  var OverrideResolver = class {
    constructor() {
      this.overrides = /* @__PURE__ */ new Map();
      this.resolved = /* @__PURE__ */ new Map();
    }
    addOverride(type, override) {
      const overrides = this.overrides.get(type) || [];
      overrides.push(override);
      this.overrides.set(type, overrides);
      this.resolved.delete(type);
    }
    setOverrides(overrides) {
      this.overrides.clear();
      overrides.forEach(([type, override]) => {
        this.addOverride(type, override);
      });
    }
    getAnnotation(type) {
      const annotations = reflection.annotations(type);
      for (let i = annotations.length - 1; i >= 0; i--) {
        const annotation = annotations[i];
        const isKnownType = annotation instanceof Directive || annotation instanceof Component || annotation instanceof Pipe || annotation instanceof NgModule;
        if (isKnownType) {
          return annotation instanceof this.type ? annotation : null;
        }
      }
      return null;
    }
    resolve(type) {
      let resolved = this.resolved.get(type) || null;
      if (!resolved) {
        resolved = this.getAnnotation(type);
        if (resolved) {
          const overrides = this.overrides.get(type);
          if (overrides) {
            const overrider = new MetadataOverrider();
            overrides.forEach((override) => {
              resolved = overrider.overrideMetadata(this.type, resolved, override);
            });
          }
        }
        this.resolved.set(type, resolved);
      }
      return resolved;
    }
  };
  var DirectiveResolver = class extends OverrideResolver {
    get type() {
      return Directive;
    }
  };
  var ComponentResolver = class extends OverrideResolver {
    get type() {
      return Component;
    }
  };
  var PipeResolver = class extends OverrideResolver {
    get type() {
      return Pipe;
    }
  };
  var NgModuleResolver = class extends OverrideResolver {
    get type() {
      return NgModule;
    }
  };
  var TestingModuleOverride;
  (function(TestingModuleOverride2) {
    TestingModuleOverride2[TestingModuleOverride2["DECLARATION"] = 0] = "DECLARATION";
    TestingModuleOverride2[TestingModuleOverride2["OVERRIDE_TEMPLATE"] = 1] = "OVERRIDE_TEMPLATE";
  })(TestingModuleOverride || (TestingModuleOverride = {}));
  function isTestingModuleOverride(value) {
    return value === TestingModuleOverride.DECLARATION || value === TestingModuleOverride.OVERRIDE_TEMPLATE;
  }
  var R3TestBedCompiler = class {
    constructor(platform, additionalModuleTypes) {
      this.platform = platform;
      this.additionalModuleTypes = additionalModuleTypes;
      this.originalComponentResolutionQueue = null;
      this.declarations = [];
      this.imports = [];
      this.providers = [];
      this.schemas = [];
      this.pendingComponents = /* @__PURE__ */ new Set();
      this.pendingDirectives = /* @__PURE__ */ new Set();
      this.pendingPipes = /* @__PURE__ */ new Set();
      this.seenComponents = /* @__PURE__ */ new Set();
      this.seenDirectives = /* @__PURE__ */ new Set();
      this.overriddenModules = /* @__PURE__ */ new Set();
      this.existingComponentStyles = /* @__PURE__ */ new Map();
      this.resolvers = initResolvers();
      this.componentToModuleScope = /* @__PURE__ */ new Map();
      this.initialNgDefs = /* @__PURE__ */ new Map();
      this.defCleanupOps = [];
      this._injector = null;
      this.compilerProviders = null;
      this.providerOverrides = [];
      this.rootProviderOverrides = [];
      this.providerOverridesByModule = /* @__PURE__ */ new Map();
      this.providerOverridesByToken = /* @__PURE__ */ new Map();
      this.moduleProvidersOverridden = /* @__PURE__ */ new Set();
      this.testModuleRef = null;
      class DynamicTestModule {
      }
      this.testModuleType = DynamicTestModule;
    }
    setCompilerProviders(providers) {
      this.compilerProviders = providers;
      this._injector = null;
    }
    configureTestingModule(moduleDef) {
      if (moduleDef.declarations !== void 0) {
        this.queueTypeArray(moduleDef.declarations, TestingModuleOverride.DECLARATION);
        this.declarations.push(...moduleDef.declarations);
      }
      if (moduleDef.imports !== void 0) {
        this.queueTypesFromModulesArray(moduleDef.imports);
        this.imports.push(...moduleDef.imports);
      }
      if (moduleDef.providers !== void 0) {
        this.providers.push(...moduleDef.providers);
      }
      if (moduleDef.schemas !== void 0) {
        this.schemas.push(...moduleDef.schemas);
      }
    }
    overrideModule(ngModule, override) {
      this.overriddenModules.add(ngModule);
      this.resolvers.module.addOverride(ngModule, override);
      const metadata = this.resolvers.module.resolve(ngModule);
      if (metadata === null) {
        throw invalidTypeError(ngModule.name, "NgModule");
      }
      this.recompileNgModule(ngModule, metadata);
      this.queueTypesFromModulesArray([ngModule]);
    }
    overrideComponent(component, override) {
      this.resolvers.component.addOverride(component, override);
      this.pendingComponents.add(component);
    }
    overrideDirective(directive, override) {
      this.resolvers.directive.addOverride(directive, override);
      this.pendingDirectives.add(directive);
    }
    overridePipe(pipe, override) {
      this.resolvers.pipe.addOverride(pipe, override);
      this.pendingPipes.add(pipe);
    }
    overrideProvider(token, provider) {
      let providerDef;
      if (provider.useFactory !== void 0) {
        providerDef = {
          provide: token,
          useFactory: provider.useFactory,
          deps: provider.deps || [],
          multi: provider.multi
        };
      } else if (provider.useValue !== void 0) {
        providerDef = { provide: token, useValue: provider.useValue, multi: provider.multi };
      } else {
        providerDef = { provide: token };
      }
      const injectableDef = typeof token !== "string" ? getInjectableDef(token) : null;
      const providedIn = injectableDef === null ? null : resolveForwardRef(injectableDef.providedIn);
      const overridesBucket = providedIn === "root" ? this.rootProviderOverrides : this.providerOverrides;
      overridesBucket.push(providerDef);
      this.providerOverridesByToken.set(token, providerDef);
      if (injectableDef !== null && providedIn !== null && typeof providedIn !== "string") {
        const existingOverrides = this.providerOverridesByModule.get(providedIn);
        if (existingOverrides !== void 0) {
          existingOverrides.push(providerDef);
        } else {
          this.providerOverridesByModule.set(providedIn, [providerDef]);
        }
      }
    }
    overrideTemplateUsingTestingModule(type, template) {
      const def = type[NG_COMP_DEF];
      const hasStyleUrls = () => {
        const metadata = this.resolvers.component.resolve(type);
        return !!metadata.styleUrls && metadata.styleUrls.length > 0;
      };
      const overrideStyleUrls = !!def && !isComponentDefPendingResolution(type) && hasStyleUrls();
      const override = overrideStyleUrls ? { template, styles: [], styleUrls: [] } : { template };
      this.overrideComponent(type, { set: override });
      if (overrideStyleUrls && def.styles && def.styles.length > 0) {
        this.existingComponentStyles.set(type, def.styles);
      }
      this.componentToModuleScope.set(type, TestingModuleOverride.OVERRIDE_TEMPLATE);
    }
    async compileComponents() {
      this.clearComponentResolutionQueue();
      let needsAsyncResources = this.compileTypesSync();
      if (needsAsyncResources) {
        let resourceLoader;
        let resolver = (url) => {
          if (!resourceLoader) {
            resourceLoader = this.injector.get(ResourceLoader);
          }
          return Promise.resolve(resourceLoader.get(url));
        };
        await resolveComponentResources2(resolver);
      }
    }
    finalize() {
      this.compileTypesSync();
      this.compileTestModule();
      this.applyTransitiveScopes();
      this.applyProviderOverrides();
      this.patchComponentsWithExistingStyles();
      this.componentToModuleScope.clear();
      const parentInjector = this.platform.injector;
      this.testModuleRef = new NgModuleRef(this.testModuleType, parentInjector);
      this.testModuleRef.injector.get(ApplicationInitStatus).runInitializers();
      const localeId = this.testModuleRef.injector.get(LOCALE_ID, DEFAULT_LOCALE_ID);
      setLocaleId(localeId);
      return this.testModuleRef;
    }
    _compileNgModuleSync(moduleType) {
      this.queueTypesFromModulesArray([moduleType]);
      this.compileTypesSync();
      this.applyProviderOverrides();
      this.applyProviderOverridesToModule(moduleType);
      this.applyTransitiveScopes();
    }
    async _compileNgModuleAsync(moduleType) {
      this.queueTypesFromModulesArray([moduleType]);
      await this.compileComponents();
      this.applyProviderOverrides();
      this.applyProviderOverridesToModule(moduleType);
      this.applyTransitiveScopes();
    }
    _getModuleResolver() {
      return this.resolvers.module;
    }
    _getComponentFactories(moduleType) {
      return maybeUnwrapFn2(moduleType.\u0275mod.declarations).reduce((factories, declaration) => {
        const componentDef = declaration.\u0275cmp;
        componentDef && factories.push(new ComponentFactory(componentDef, this.testModuleRef));
        return factories;
      }, []);
    }
    compileTypesSync() {
      let needsAsyncResources = false;
      this.pendingComponents.forEach((declaration) => {
        needsAsyncResources = needsAsyncResources || isComponentDefPendingResolution(declaration);
        const metadata = this.resolvers.component.resolve(declaration);
        if (metadata === null) {
          throw invalidTypeError(declaration.name, "Component");
        }
        this.maybeStoreNgDef(NG_COMP_DEF, declaration);
        compileComponent(declaration, metadata);
      });
      this.pendingComponents.clear();
      this.pendingDirectives.forEach((declaration) => {
        const metadata = this.resolvers.directive.resolve(declaration);
        if (metadata === null) {
          throw invalidTypeError(declaration.name, "Directive");
        }
        this.maybeStoreNgDef(NG_DIR_DEF, declaration);
        compileDirective(declaration, metadata);
      });
      this.pendingDirectives.clear();
      this.pendingPipes.forEach((declaration) => {
        const metadata = this.resolvers.pipe.resolve(declaration);
        if (metadata === null) {
          throw invalidTypeError(declaration.name, "Pipe");
        }
        this.maybeStoreNgDef(NG_PIPE_DEF, declaration);
        compilePipe(declaration, metadata);
      });
      this.pendingPipes.clear();
      return needsAsyncResources;
    }
    applyTransitiveScopes() {
      if (this.overriddenModules.size > 0) {
        const testingModuleDef = this.testModuleType[NG_MOD_DEF];
        const affectedModules = this.collectModulesAffectedByOverrides(testingModuleDef.imports);
        if (affectedModules.size > 0) {
          affectedModules.forEach((moduleType) => {
            this.storeFieldOfDefOnType(moduleType, NG_MOD_DEF, "transitiveCompileScopes");
            moduleType[NG_MOD_DEF].transitiveCompileScopes = null;
          });
        }
      }
      const moduleToScope = /* @__PURE__ */ new Map();
      const getScopeOfModule = (moduleType) => {
        if (!moduleToScope.has(moduleType)) {
          const isTestingModule = isTestingModuleOverride(moduleType);
          const realType = isTestingModule ? this.testModuleType : moduleType;
          moduleToScope.set(moduleType, transitiveScopesFor(realType));
        }
        return moduleToScope.get(moduleType);
      };
      this.componentToModuleScope.forEach((moduleType, componentType) => {
        const moduleScope = getScopeOfModule(moduleType);
        this.storeFieldOfDefOnType(componentType, NG_COMP_DEF, "directiveDefs");
        this.storeFieldOfDefOnType(componentType, NG_COMP_DEF, "pipeDefs");
        this.storeFieldOfDefOnType(componentType, NG_COMP_DEF, "tView");
        patchComponentDefWithScope(componentType.\u0275cmp, moduleScope);
      });
      this.componentToModuleScope.clear();
    }
    applyProviderOverrides() {
      const maybeApplyOverrides = (field) => (type) => {
        const resolver = field === NG_COMP_DEF ? this.resolvers.component : this.resolvers.directive;
        const metadata = resolver.resolve(type);
        if (this.hasProviderOverrides(metadata.providers)) {
          this.patchDefWithProviderOverrides(type, field);
        }
      };
      this.seenComponents.forEach(maybeApplyOverrides(NG_COMP_DEF));
      this.seenDirectives.forEach(maybeApplyOverrides(NG_DIR_DEF));
      this.seenComponents.clear();
      this.seenDirectives.clear();
    }
    applyProviderOverridesToModule(moduleType) {
      if (this.moduleProvidersOverridden.has(moduleType)) {
        return;
      }
      this.moduleProvidersOverridden.add(moduleType);
      const injectorDef = moduleType[NG_INJ_DEF];
      if (this.providerOverridesByToken.size > 0) {
        const providers = [
          ...injectorDef.providers,
          ...this.providerOverridesByModule.get(moduleType) || []
        ];
        if (this.hasProviderOverrides(providers)) {
          this.maybeStoreNgDef(NG_INJ_DEF, moduleType);
          this.storeFieldOfDefOnType(moduleType, NG_INJ_DEF, "providers");
          injectorDef.providers = this.getOverriddenProviders(providers);
        }
        const moduleDef = moduleType[NG_MOD_DEF];
        const imports = maybeUnwrapFn2(moduleDef.imports);
        for (const importedModule of imports) {
          this.applyProviderOverridesToModule(importedModule);
        }
        for (const importedModule of flatten3(injectorDef.imports)) {
          if (isModuleWithProviders2(importedModule)) {
            this.defCleanupOps.push({
              object: importedModule,
              fieldName: "providers",
              originalValue: importedModule.providers
            });
            importedModule.providers = this.getOverriddenProviders(importedModule.providers);
          }
        }
      }
    }
    patchComponentsWithExistingStyles() {
      this.existingComponentStyles.forEach((styles, type) => type[NG_COMP_DEF].styles = styles);
      this.existingComponentStyles.clear();
    }
    queueTypeArray(arr, moduleType) {
      for (const value of arr) {
        if (Array.isArray(value)) {
          this.queueTypeArray(value, moduleType);
        } else {
          this.queueType(value, moduleType);
        }
      }
    }
    recompileNgModule(ngModule, metadata) {
      this.maybeStoreNgDef(NG_MOD_DEF, ngModule);
      this.maybeStoreNgDef(NG_INJ_DEF, ngModule);
      compileNgModuleDefs(ngModule, metadata);
    }
    queueType(type, moduleType) {
      const component = this.resolvers.component.resolve(type);
      if (component) {
        if (isComponentDefPendingResolution(type) || !type.hasOwnProperty(NG_COMP_DEF)) {
          this.pendingComponents.add(type);
        }
        this.seenComponents.add(type);
        if (!this.componentToModuleScope.has(type) || this.componentToModuleScope.get(type) === TestingModuleOverride.DECLARATION) {
          this.componentToModuleScope.set(type, moduleType);
        }
        return;
      }
      const directive = this.resolvers.directive.resolve(type);
      if (directive) {
        if (!type.hasOwnProperty(NG_DIR_DEF)) {
          this.pendingDirectives.add(type);
        }
        this.seenDirectives.add(type);
        return;
      }
      const pipe = this.resolvers.pipe.resolve(type);
      if (pipe && !type.hasOwnProperty(NG_PIPE_DEF)) {
        this.pendingPipes.add(type);
        return;
      }
    }
    queueTypesFromModulesArray(arr) {
      const processedNgModuleDefs = /* @__PURE__ */ new Set();
      const queueTypesFromModulesArrayRecur = (arr2) => {
        for (const value of arr2) {
          if (Array.isArray(value)) {
            queueTypesFromModulesArrayRecur(value);
          } else if (hasNgModuleDef(value)) {
            const def = value.\u0275mod;
            if (processedNgModuleDefs.has(def)) {
              continue;
            }
            processedNgModuleDefs.add(def);
            this.queueTypeArray(maybeUnwrapFn2(def.declarations), value);
            queueTypesFromModulesArrayRecur(maybeUnwrapFn2(def.imports));
            queueTypesFromModulesArrayRecur(maybeUnwrapFn2(def.exports));
          } else if (isModuleWithProviders2(value)) {
            queueTypesFromModulesArrayRecur([value.ngModule]);
          }
        }
      };
      queueTypesFromModulesArrayRecur(arr);
    }
    collectModulesAffectedByOverrides(arr) {
      const seenModules = /* @__PURE__ */ new Set();
      const affectedModules = /* @__PURE__ */ new Set();
      const calcAffectedModulesRecur = (arr2, path) => {
        for (const value of arr2) {
          if (Array.isArray(value)) {
            calcAffectedModulesRecur(value, path);
          } else if (hasNgModuleDef(value)) {
            if (seenModules.has(value)) {
              if (affectedModules.has(value)) {
                path.forEach((item) => affectedModules.add(item));
              }
              continue;
            }
            seenModules.add(value);
            if (this.overriddenModules.has(value)) {
              path.forEach((item) => affectedModules.add(item));
            }
            const moduleDef = value[NG_MOD_DEF];
            calcAffectedModulesRecur(maybeUnwrapFn2(moduleDef.imports), path.concat(value));
          }
        }
      };
      calcAffectedModulesRecur(arr, []);
      return affectedModules;
    }
    maybeStoreNgDef(prop, type) {
      if (!this.initialNgDefs.has(type)) {
        const currentDef = Object.getOwnPropertyDescriptor(type, prop);
        this.initialNgDefs.set(type, [prop, currentDef]);
      }
    }
    storeFieldOfDefOnType(type, defField, fieldName) {
      const def = type[defField];
      const originalValue = def[fieldName];
      this.defCleanupOps.push({ object: def, fieldName, originalValue });
    }
    clearComponentResolutionQueue() {
      if (this.originalComponentResolutionQueue === null) {
        this.originalComponentResolutionQueue = /* @__PURE__ */ new Map();
      }
      clearResolutionOfComponentResourcesQueue2().forEach((value, key) => this.originalComponentResolutionQueue.set(key, value));
    }
    restoreComponentResolutionQueue() {
      if (this.originalComponentResolutionQueue !== null) {
        restoreComponentResolutionQueue(this.originalComponentResolutionQueue);
        this.originalComponentResolutionQueue = null;
      }
    }
    restoreOriginalState() {
      forEachRight(this.defCleanupOps, (op) => {
        op.object[op.fieldName] = op.originalValue;
      });
      this.initialNgDefs.forEach((value, type) => {
        const [prop, descriptor] = value;
        if (!descriptor) {
          delete type[prop];
        } else {
          Object.defineProperty(type, prop, descriptor);
        }
      });
      this.initialNgDefs.clear();
      this.moduleProvidersOverridden.clear();
      this.restoreComponentResolutionQueue();
      setLocaleId(DEFAULT_LOCALE_ID);
    }
    compileTestModule() {
      class RootScopeModule {
      }
      compileNgModuleDefs(RootScopeModule, {
        providers: [...this.rootProviderOverrides]
      });
      const ngZone = new NgZone({ enableLongStackTrace: true });
      const providers = [
        { provide: NgZone, useValue: ngZone },
        { provide: Compiler, useFactory: () => new R3TestCompiler(this) },
        ...this.providers,
        ...this.providerOverrides
      ];
      const imports = [RootScopeModule, this.additionalModuleTypes, this.imports || []];
      compileNgModuleDefs(this.testModuleType, {
        declarations: this.declarations,
        imports,
        schemas: this.schemas,
        providers
      }, true);
      this.applyProviderOverridesToModule(this.testModuleType);
    }
    get injector() {
      if (this._injector !== null) {
        return this._injector;
      }
      const providers = [];
      const compilerOptions = this.platform.injector.get(COMPILER_OPTIONS);
      compilerOptions.forEach((opts) => {
        if (opts.providers) {
          providers.push(opts.providers);
        }
      });
      if (this.compilerProviders !== null) {
        providers.push(...this.compilerProviders);
      }
      class CompilerModule {
      }
      compileNgModuleDefs(CompilerModule, { providers });
      const CompilerModuleFactory = new NgModuleFactory(CompilerModule);
      this._injector = CompilerModuleFactory.create(this.platform.injector).injector;
      return this._injector;
    }
    getSingleProviderOverrides(provider) {
      const token = getProviderToken(provider);
      return this.providerOverridesByToken.get(token) || null;
    }
    getProviderOverrides(providers) {
      if (!providers || !providers.length || this.providerOverridesByToken.size === 0)
        return [];
      return flatten3(flatten3(providers, (provider) => this.getSingleProviderOverrides(provider) || []));
    }
    getOverriddenProviders(providers) {
      if (!providers || !providers.length || this.providerOverridesByToken.size === 0)
        return [];
      const flattenedProviders = flatten3(providers);
      const overrides = this.getProviderOverrides(flattenedProviders);
      const overriddenProviders = [...flattenedProviders, ...overrides];
      const final = [];
      const seenOverriddenProviders = /* @__PURE__ */ new Set();
      forEachRight(overriddenProviders, (provider) => {
        const token = getProviderToken(provider);
        if (this.providerOverridesByToken.has(token)) {
          if (!seenOverriddenProviders.has(token)) {
            seenOverriddenProviders.add(token);
            final.unshift({ ...provider, multi: false });
          }
        } else {
          final.unshift(provider);
        }
      });
      return final;
    }
    hasProviderOverrides(providers) {
      return this.getProviderOverrides(providers).length > 0;
    }
    patchDefWithProviderOverrides(declaration, field) {
      const def = declaration[field];
      if (def && def.providersResolver) {
        this.maybeStoreNgDef(field, declaration);
        const resolver = def.providersResolver;
        const processProvidersFn = (providers) => this.getOverriddenProviders(providers);
        this.storeFieldOfDefOnType(declaration, field, "providersResolver");
        def.providersResolver = (ngDef) => resolver(ngDef, processProvidersFn);
      }
    }
  };
  function initResolvers() {
    return {
      module: new NgModuleResolver(),
      component: new ComponentResolver(),
      directive: new DirectiveResolver(),
      pipe: new PipeResolver()
    };
  }
  function hasNgModuleDef(value) {
    return value.hasOwnProperty("\u0275mod");
  }
  function maybeUnwrapFn2(maybeFn) {
    return maybeFn instanceof Function ? maybeFn() : maybeFn;
  }
  function flatten3(values, mapFn) {
    const out = [];
    values.forEach((value) => {
      if (Array.isArray(value)) {
        out.push(...flatten3(value, mapFn));
      } else {
        out.push(mapFn ? mapFn(value) : value);
      }
    });
    return out;
  }
  function getProviderField(provider, field) {
    return provider && typeof provider === "object" && provider[field];
  }
  function getProviderToken(provider) {
    return getProviderField(provider, "provide") || provider;
  }
  function isModuleWithProviders2(value) {
    return value.hasOwnProperty("ngModule");
  }
  function forEachRight(values, fn2) {
    for (let idx = values.length - 1; idx >= 0; idx--) {
      fn2(values[idx], idx);
    }
  }
  function invalidTypeError(name, expectedType) {
    return new Error(`${name} class doesn't have @${expectedType} decorator or is missing metadata.`);
  }
  var R3TestCompiler = class {
    constructor(testBed2) {
      this.testBed = testBed2;
    }
    compileModuleSync(moduleType) {
      this.testBed._compileNgModuleSync(moduleType);
      return new NgModuleFactory(moduleType);
    }
    async compileModuleAsync(moduleType) {
      await this.testBed._compileNgModuleAsync(moduleType);
      return new NgModuleFactory(moduleType);
    }
    compileModuleAndAllComponentsSync(moduleType) {
      const ngModuleFactory = this.compileModuleSync(moduleType);
      const componentFactories = this.testBed._getComponentFactories(moduleType);
      return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);
    }
    async compileModuleAndAllComponentsAsync(moduleType) {
      const ngModuleFactory = await this.compileModuleAsync(moduleType);
      const componentFactories = this.testBed._getComponentFactories(moduleType);
      return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);
    }
    clearCache() {
    }
    clearCacheFor(type) {
    }
    getModuleId(moduleType) {
      const meta = this.testBed._getModuleResolver().resolve(moduleType);
      return meta && meta.id || void 0;
    }
  };
  var TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT = true;
  var TestComponentRenderer = class {
    insertRootElement(rootElementId) {
    }
    removeAllRootElements() {
    }
  };
  var ComponentFixtureAutoDetect = new InjectionToken("ComponentFixtureAutoDetect");
  var ComponentFixtureNoNgZone = new InjectionToken("ComponentFixtureNoNgZone");
  var _nextRootElementId = 0;
  var TestBedRender3 = class {
    constructor() {
      this.platform = null;
      this.ngModule = null;
      this._compiler = null;
      this._testModuleRef = null;
      this._activeFixtures = [];
      this._globalCompilationChecked = false;
    }
    static initTestEnvironment(ngModule, platform, summariesOrOptions) {
      const testBed2 = _getTestBedRender3();
      testBed2.initTestEnvironment(ngModule, platform, summariesOrOptions);
      return testBed2;
    }
    static resetTestEnvironment() {
      _getTestBedRender3().resetTestEnvironment();
    }
    static configureCompiler(config2) {
      _getTestBedRender3().configureCompiler(config2);
      return TestBedRender3;
    }
    static configureTestingModule(moduleDef) {
      _getTestBedRender3().configureTestingModule(moduleDef);
      return TestBedRender3;
    }
    static compileComponents() {
      return _getTestBedRender3().compileComponents();
    }
    static overrideModule(ngModule, override) {
      _getTestBedRender3().overrideModule(ngModule, override);
      return TestBedRender3;
    }
    static overrideComponent(component, override) {
      _getTestBedRender3().overrideComponent(component, override);
      return TestBedRender3;
    }
    static overrideDirective(directive, override) {
      _getTestBedRender3().overrideDirective(directive, override);
      return TestBedRender3;
    }
    static overridePipe(pipe, override) {
      _getTestBedRender3().overridePipe(pipe, override);
      return TestBedRender3;
    }
    static overrideTemplate(component, template) {
      _getTestBedRender3().overrideComponent(component, { set: { template, templateUrl: null } });
      return TestBedRender3;
    }
    static overrideTemplateUsingTestingModule(component, template) {
      _getTestBedRender3().overrideTemplateUsingTestingModule(component, template);
      return TestBedRender3;
    }
    static overrideProvider(token, provider) {
      _getTestBedRender3().overrideProvider(token, provider);
      return TestBedRender3;
    }
    static inject(token, notFoundValue, flags) {
      return _getTestBedRender3().inject(token, notFoundValue, flags);
    }
    static get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {
      return _getTestBedRender3().inject(token, notFoundValue, flags);
    }
    static createComponent(component) {
      return _getTestBedRender3().createComponent(component);
    }
    static resetTestingModule() {
      _getTestBedRender3().resetTestingModule();
      return TestBedRender3;
    }
    static shouldTearDownTestingModule() {
      return _getTestBedRender3().shouldTearDownTestingModule();
    }
    static tearDownTestingModule() {
      _getTestBedRender3().tearDownTestingModule();
    }
    initTestEnvironment(ngModule, platform, summariesOrOptions) {
      if (this.platform || this.ngModule) {
        throw new Error("Cannot set base providers because it has already been called");
      }
      TestBedRender3._environmentTeardownOptions = typeof summariesOrOptions === "function" ? void 0 : summariesOrOptions?.teardown;
      this.platform = platform;
      this.ngModule = ngModule;
      this._compiler = new R3TestBedCompiler(this.platform, this.ngModule);
    }
    resetTestEnvironment() {
      this.resetTestingModule();
      this._compiler = null;
      this.platform = null;
      this.ngModule = null;
      TestBedRender3._environmentTeardownOptions = void 0;
    }
    resetTestingModule() {
      this.checkGlobalCompilationFinished();
      resetCompiledComponents();
      if (this._compiler !== null) {
        this.compiler.restoreOriginalState();
      }
      this._compiler = new R3TestBedCompiler(this.platform, this.ngModule);
      try {
        this.destroyActiveFixtures();
      } finally {
        try {
          if (this.shouldTearDownTestingModule()) {
            this.tearDownTestingModule();
          }
        } finally {
          this._testModuleRef = null;
          this._instanceTeardownOptions = void 0;
        }
      }
    }
    configureCompiler(config2) {
      if (config2.useJit != null) {
        throw new Error("the Render3 compiler JiT mode is not configurable !");
      }
      if (config2.providers !== void 0) {
        this.compiler.setCompilerProviders(config2.providers);
      }
    }
    configureTestingModule(moduleDef) {
      this.assertNotInstantiated("R3TestBed.configureTestingModule", "configure the test module");
      this._instanceTeardownOptions = moduleDef.teardown;
      this.compiler.configureTestingModule(moduleDef);
    }
    compileComponents() {
      return this.compiler.compileComponents();
    }
    inject(token, notFoundValue, flags) {
      if (token === TestBedRender3) {
        return this;
      }
      const UNDEFINED2 = {};
      const result = this.testModuleRef.injector.get(token, UNDEFINED2, flags);
      return result === UNDEFINED2 ? this.compiler.injector.get(token, notFoundValue, flags) : result;
    }
    get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {
      return this.inject(token, notFoundValue, flags);
    }
    execute(tokens, fn2, context2) {
      const params = tokens.map((t) => this.inject(t));
      return fn2.apply(context2, params);
    }
    overrideModule(ngModule, override) {
      this.assertNotInstantiated("overrideModule", "override module metadata");
      this.compiler.overrideModule(ngModule, override);
    }
    overrideComponent(component, override) {
      this.assertNotInstantiated("overrideComponent", "override component metadata");
      this.compiler.overrideComponent(component, override);
    }
    overrideTemplateUsingTestingModule(component, template) {
      this.assertNotInstantiated("R3TestBed.overrideTemplateUsingTestingModule", "Cannot override template when the test module has already been instantiated");
      this.compiler.overrideTemplateUsingTestingModule(component, template);
    }
    overrideDirective(directive, override) {
      this.assertNotInstantiated("overrideDirective", "override directive metadata");
      this.compiler.overrideDirective(directive, override);
    }
    overridePipe(pipe, override) {
      this.assertNotInstantiated("overridePipe", "override pipe metadata");
      this.compiler.overridePipe(pipe, override);
    }
    overrideProvider(token, provider) {
      this.assertNotInstantiated("overrideProvider", "override provider");
      this.compiler.overrideProvider(token, provider);
    }
    createComponent(type) {
      const testComponentRenderer = this.inject(TestComponentRenderer);
      const rootElId = `root${_nextRootElementId++}`;
      testComponentRenderer.insertRootElement(rootElId);
      const componentDef = type.\u0275cmp;
      if (!componentDef) {
        throw new Error(`It looks like '${stringify(type)}' has not been IVY compiled - it has no '\u0275cmp' field`);
      }
      const noNgZone = this.inject(ComponentFixtureNoNgZone, false);
      const autoDetect = this.inject(ComponentFixtureAutoDetect, false);
      const ngZone = noNgZone ? null : this.inject(NgZone, null);
      const componentFactory = new ComponentFactory(componentDef);
      const initComponent = () => {
        const componentRef = componentFactory.create(Injector.NULL, [], `#${rootElId}`, this.testModuleRef);
        return new ComponentFixture(componentRef, ngZone, autoDetect);
      };
      const fixture = ngZone ? ngZone.run(initComponent) : initComponent();
      this._activeFixtures.push(fixture);
      return fixture;
    }
    get compiler() {
      if (this._compiler === null) {
        throw new Error(`Need to call TestBed.initTestEnvironment() first`);
      }
      return this._compiler;
    }
    get testModuleRef() {
      if (this._testModuleRef === null) {
        this._testModuleRef = this.compiler.finalize();
      }
      return this._testModuleRef;
    }
    assertNotInstantiated(methodName, methodDescription) {
      if (this._testModuleRef !== null) {
        throw new Error(`Cannot ${methodDescription} when the test module has already been instantiated. Make sure you are not using \`inject\` before \`${methodName}\`.`);
      }
    }
    checkGlobalCompilationFinished() {
      if (!this._globalCompilationChecked && this._testModuleRef === null) {
        flushModuleScopingQueueAsMuchAsPossible();
      }
      this._globalCompilationChecked = true;
    }
    destroyActiveFixtures() {
      let errorCount = 0;
      this._activeFixtures.forEach((fixture) => {
        try {
          fixture.destroy();
        } catch (e) {
          errorCount++;
          console.error("Error during cleanup of component", {
            component: fixture.componentInstance,
            stacktrace: e
          });
        }
      });
      this._activeFixtures = [];
      if (errorCount > 0 && this.shouldRethrowTeardownErrors()) {
        throw Error(`${errorCount} ${errorCount === 1 ? "component" : "components"} threw errors during cleanup`);
      }
    }
    shouldRethrowTeardownErrors() {
      const instanceOptions = this._instanceTeardownOptions;
      const environmentOptions = TestBedRender3._environmentTeardownOptions;
      if (!instanceOptions && !environmentOptions) {
        return TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;
      }
      return instanceOptions?.rethrowErrors ?? environmentOptions?.rethrowErrors ?? this.shouldTearDownTestingModule();
    }
    shouldTearDownTestingModule() {
      return this._instanceTeardownOptions?.destroyAfterEach ?? TestBedRender3._environmentTeardownOptions?.destroyAfterEach ?? TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;
    }
    tearDownTestingModule() {
      if (this._testModuleRef === null) {
        return;
      }
      const testRenderer = this.inject(TestComponentRenderer);
      try {
        this._testModuleRef.destroy();
      } catch (e) {
        if (this.shouldRethrowTeardownErrors()) {
          throw e;
        } else {
          console.error("Error during cleanup of a testing module", {
            component: this._testModuleRef.instance,
            stacktrace: e
          });
        }
      } finally {
        testRenderer.removeAllRootElements?.();
      }
    }
  };
  var testBed;
  function _getTestBedRender3() {
    return testBed = testBed || new TestBedRender3();
  }
  var TestBed = TestBedRender3;
  var getTestBed = _getTestBedRender3;
  var _global4 = typeof window === "undefined" ? global : window;
  if (_global4.beforeEach) {
    _global4.beforeEach(getCleanupHook(false));
  }
  if (_global4.afterEach) {
    _global4.afterEach(getCleanupHook(true));
  }
  function getCleanupHook(expectedTeardownValue) {
    return () => {
      if (TestBed.shouldTearDownTestingModule() === expectedTeardownValue) {
        TestBed.resetTestingModule();
        resetFakeAsyncZone();
      }
    };
  }

  // node_modules/@angular/common/fesm2020/common.mjs
  var _DOM = null;
  function getDOM() {
    return _DOM;
  }
  function setRootDomAdapter(adapter) {
    if (!_DOM) {
      _DOM = adapter;
    }
  }
  var DomAdapter = class {
  };
  var DOCUMENT2 = new InjectionToken("DocumentToken");
  var PlatformLocation = class {
    historyGo(relativePosition) {
      throw new Error("Not implemented");
    }
  };
  PlatformLocation.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: PlatformLocation, deps: [], target: FactoryTarget.Injectable });
  PlatformLocation.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: PlatformLocation, providedIn: "platform", useFactory: useBrowserPlatformLocation });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: PlatformLocation, decorators: [{
    type: Injectable,
    args: [{
      providedIn: "platform",
      useFactory: useBrowserPlatformLocation
    }]
  }] });
  function useBrowserPlatformLocation() {
    return \u0275\u0275inject(BrowserPlatformLocation);
  }
  var LOCATION_INITIALIZED = new InjectionToken("Location Initialized");
  var BrowserPlatformLocation = class extends PlatformLocation {
    constructor(_doc) {
      super();
      this._doc = _doc;
      this._init();
    }
    _init() {
      this.location = window.location;
      this._history = window.history;
    }
    getBaseHrefFromDOM() {
      return getDOM().getBaseHref(this._doc);
    }
    onPopState(fn2) {
      const window2 = getDOM().getGlobalEventTarget(this._doc, "window");
      window2.addEventListener("popstate", fn2, false);
      return () => window2.removeEventListener("popstate", fn2);
    }
    onHashChange(fn2) {
      const window2 = getDOM().getGlobalEventTarget(this._doc, "window");
      window2.addEventListener("hashchange", fn2, false);
      return () => window2.removeEventListener("hashchange", fn2);
    }
    get href() {
      return this.location.href;
    }
    get protocol() {
      return this.location.protocol;
    }
    get hostname() {
      return this.location.hostname;
    }
    get port() {
      return this.location.port;
    }
    get pathname() {
      return this.location.pathname;
    }
    get search() {
      return this.location.search;
    }
    get hash() {
      return this.location.hash;
    }
    set pathname(newPath) {
      this.location.pathname = newPath;
    }
    pushState(state, title, url) {
      if (supportsState()) {
        this._history.pushState(state, title, url);
      } else {
        this.location.hash = url;
      }
    }
    replaceState(state, title, url) {
      if (supportsState()) {
        this._history.replaceState(state, title, url);
      } else {
        this.location.hash = url;
      }
    }
    forward() {
      this._history.forward();
    }
    back() {
      this._history.back();
    }
    historyGo(relativePosition = 0) {
      this._history.go(relativePosition);
    }
    getState() {
      return this._history.state;
    }
  };
  BrowserPlatformLocation.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: BrowserPlatformLocation, deps: [{ token: DOCUMENT2 }], target: FactoryTarget.Injectable });
  BrowserPlatformLocation.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: BrowserPlatformLocation, providedIn: "platform", useFactory: createBrowserPlatformLocation });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: BrowserPlatformLocation, decorators: [{
    type: Injectable,
    args: [{
      providedIn: "platform",
      useFactory: createBrowserPlatformLocation
    }]
  }], ctorParameters: function() {
    return [{ type: void 0, decorators: [{
      type: Inject,
      args: [DOCUMENT2]
    }] }];
  } });
  function supportsState() {
    return !!window.history.pushState;
  }
  function createBrowserPlatformLocation() {
    return new BrowserPlatformLocation(\u0275\u0275inject(DOCUMENT2));
  }
  function joinWithSlash(start, end) {
    if (start.length == 0) {
      return end;
    }
    if (end.length == 0) {
      return start;
    }
    let slashes = 0;
    if (start.endsWith("/")) {
      slashes++;
    }
    if (end.startsWith("/")) {
      slashes++;
    }
    if (slashes == 2) {
      return start + end.substring(1);
    }
    if (slashes == 1) {
      return start + end;
    }
    return start + "/" + end;
  }
  function stripTrailingSlash(url) {
    const match2 = url.match(/#|\?|$/);
    const pathEndIdx = match2 && match2.index || url.length;
    const droppedSlashIdx = pathEndIdx - (url[pathEndIdx - 1] === "/" ? 1 : 0);
    return url.slice(0, droppedSlashIdx) + url.slice(pathEndIdx);
  }
  function normalizeQueryParams(params) {
    return params && params[0] !== "?" ? "?" + params : params;
  }
  var LocationStrategy = class {
    historyGo(relativePosition) {
      throw new Error("Not implemented");
    }
  };
  LocationStrategy.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: LocationStrategy, deps: [], target: FactoryTarget.Injectable });
  LocationStrategy.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: LocationStrategy, providedIn: "root", useFactory: provideLocationStrategy });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: LocationStrategy, decorators: [{
    type: Injectable,
    args: [{ providedIn: "root", useFactory: provideLocationStrategy }]
  }] });
  function provideLocationStrategy(platformLocation) {
    const location2 = \u0275\u0275inject(DOCUMENT2).location;
    return new PathLocationStrategy(\u0275\u0275inject(PlatformLocation), location2 && location2.origin || "");
  }
  var APP_BASE_HREF = new InjectionToken("appBaseHref");
  var PathLocationStrategy = class extends LocationStrategy {
    constructor(_platformLocation, href) {
      super();
      this._platformLocation = _platformLocation;
      this._removeListenerFns = [];
      if (href == null) {
        href = this._platformLocation.getBaseHrefFromDOM();
      }
      if (href == null) {
        throw new Error(`No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.`);
      }
      this._baseHref = href;
    }
    ngOnDestroy() {
      while (this._removeListenerFns.length) {
        this._removeListenerFns.pop()();
      }
    }
    onPopState(fn2) {
      this._removeListenerFns.push(this._platformLocation.onPopState(fn2), this._platformLocation.onHashChange(fn2));
    }
    getBaseHref() {
      return this._baseHref;
    }
    prepareExternalUrl(internal) {
      return joinWithSlash(this._baseHref, internal);
    }
    path(includeHash = false) {
      const pathname = this._platformLocation.pathname + normalizeQueryParams(this._platformLocation.search);
      const hash = this._platformLocation.hash;
      return hash && includeHash ? `${pathname}${hash}` : pathname;
    }
    pushState(state, title, url, queryParams) {
      const externalUrl = this.prepareExternalUrl(url + normalizeQueryParams(queryParams));
      this._platformLocation.pushState(state, title, externalUrl);
    }
    replaceState(state, title, url, queryParams) {
      const externalUrl = this.prepareExternalUrl(url + normalizeQueryParams(queryParams));
      this._platformLocation.replaceState(state, title, externalUrl);
    }
    forward() {
      this._platformLocation.forward();
    }
    back() {
      this._platformLocation.back();
    }
    historyGo(relativePosition = 0) {
      this._platformLocation.historyGo?.(relativePosition);
    }
  };
  PathLocationStrategy.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: PathLocationStrategy, deps: [{ token: PlatformLocation }, { token: APP_BASE_HREF, optional: true }], target: FactoryTarget.Injectable });
  PathLocationStrategy.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: PathLocationStrategy });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: PathLocationStrategy, decorators: [{
    type: Injectable
  }], ctorParameters: function() {
    return [{ type: PlatformLocation }, { type: void 0, decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [APP_BASE_HREF]
    }] }];
  } });
  var HashLocationStrategy = class extends LocationStrategy {
    constructor(_platformLocation, _baseHref) {
      super();
      this._platformLocation = _platformLocation;
      this._baseHref = "";
      this._removeListenerFns = [];
      if (_baseHref != null) {
        this._baseHref = _baseHref;
      }
    }
    ngOnDestroy() {
      while (this._removeListenerFns.length) {
        this._removeListenerFns.pop()();
      }
    }
    onPopState(fn2) {
      this._removeListenerFns.push(this._platformLocation.onPopState(fn2), this._platformLocation.onHashChange(fn2));
    }
    getBaseHref() {
      return this._baseHref;
    }
    path(includeHash = false) {
      let path = this._platformLocation.hash;
      if (path == null)
        path = "#";
      return path.length > 0 ? path.substring(1) : path;
    }
    prepareExternalUrl(internal) {
      const url = joinWithSlash(this._baseHref, internal);
      return url.length > 0 ? "#" + url : url;
    }
    pushState(state, title, path, queryParams) {
      let url = this.prepareExternalUrl(path + normalizeQueryParams(queryParams));
      if (url.length == 0) {
        url = this._platformLocation.pathname;
      }
      this._platformLocation.pushState(state, title, url);
    }
    replaceState(state, title, path, queryParams) {
      let url = this.prepareExternalUrl(path + normalizeQueryParams(queryParams));
      if (url.length == 0) {
        url = this._platformLocation.pathname;
      }
      this._platformLocation.replaceState(state, title, url);
    }
    forward() {
      this._platformLocation.forward();
    }
    back() {
      this._platformLocation.back();
    }
    historyGo(relativePosition = 0) {
      this._platformLocation.historyGo?.(relativePosition);
    }
  };
  HashLocationStrategy.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HashLocationStrategy, deps: [{ token: PlatformLocation }, { token: APP_BASE_HREF, optional: true }], target: FactoryTarget.Injectable });
  HashLocationStrategy.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HashLocationStrategy });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HashLocationStrategy, decorators: [{
    type: Injectable
  }], ctorParameters: function() {
    return [{ type: PlatformLocation }, { type: void 0, decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [APP_BASE_HREF]
    }] }];
  } });
  var Location = class {
    constructor(platformStrategy, platformLocation) {
      this._subject = new EventEmitter();
      this._urlChangeListeners = [];
      this._platformStrategy = platformStrategy;
      const browserBaseHref = this._platformStrategy.getBaseHref();
      this._platformLocation = platformLocation;
      this._baseHref = stripTrailingSlash(_stripIndexHtml(browserBaseHref));
      this._platformStrategy.onPopState((ev) => {
        this._subject.emit({
          "url": this.path(true),
          "pop": true,
          "state": ev.state,
          "type": ev.type
        });
      });
    }
    path(includeHash = false) {
      return this.normalize(this._platformStrategy.path(includeHash));
    }
    getState() {
      return this._platformLocation.getState();
    }
    isCurrentPathEqualTo(path, query = "") {
      return this.path() == this.normalize(path + normalizeQueryParams(query));
    }
    normalize(url) {
      return Location.stripTrailingSlash(_stripBaseHref(this._baseHref, _stripIndexHtml(url)));
    }
    prepareExternalUrl(url) {
      if (url && url[0] !== "/") {
        url = "/" + url;
      }
      return this._platformStrategy.prepareExternalUrl(url);
    }
    go(path, query = "", state = null) {
      this._platformStrategy.pushState(state, "", path, query);
      this._notifyUrlChangeListeners(this.prepareExternalUrl(path + normalizeQueryParams(query)), state);
    }
    replaceState(path, query = "", state = null) {
      this._platformStrategy.replaceState(state, "", path, query);
      this._notifyUrlChangeListeners(this.prepareExternalUrl(path + normalizeQueryParams(query)), state);
    }
    forward() {
      this._platformStrategy.forward();
    }
    back() {
      this._platformStrategy.back();
    }
    historyGo(relativePosition = 0) {
      this._platformStrategy.historyGo?.(relativePosition);
    }
    onUrlChange(fn2) {
      this._urlChangeListeners.push(fn2);
      if (!this._urlChangeSubscription) {
        this._urlChangeSubscription = this.subscribe((v) => {
          this._notifyUrlChangeListeners(v.url, v.state);
        });
      }
    }
    _notifyUrlChangeListeners(url = "", state) {
      this._urlChangeListeners.forEach((fn2) => fn2(url, state));
    }
    subscribe(onNext, onThrow, onReturn) {
      return this._subject.subscribe({ next: onNext, error: onThrow, complete: onReturn });
    }
  };
  Location.normalizeQueryParams = normalizeQueryParams;
  Location.joinWithSlash = joinWithSlash;
  Location.stripTrailingSlash = stripTrailingSlash;
  Location.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: Location, deps: [{ token: LocationStrategy }, { token: PlatformLocation }], target: FactoryTarget.Injectable });
  Location.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: Location, providedIn: "root", useFactory: createLocation });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: Location, decorators: [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: createLocation
    }]
  }], ctorParameters: function() {
    return [{ type: LocationStrategy }, { type: PlatformLocation }];
  } });
  function createLocation() {
    return new Location(\u0275\u0275inject(LocationStrategy), \u0275\u0275inject(PlatformLocation));
  }
  function _stripBaseHref(baseHref, url) {
    return baseHref && url.startsWith(baseHref) ? url.substring(baseHref.length) : url;
  }
  function _stripIndexHtml(url) {
    return url.replace(/\/index.html$/, "");
  }
  var CURRENCIES_EN = { "ADP": [void 0, void 0, 0], "AFN": [void 0, "\u060B", 0], "ALL": [void 0, void 0, 0], "AMD": [void 0, "\u058F", 2], "AOA": [void 0, "Kz"], "ARS": [void 0, "$"], "AUD": ["A$", "$"], "AZN": [void 0, "\u20BC"], "BAM": [void 0, "KM"], "BBD": [void 0, "$"], "BDT": [void 0, "\u09F3"], "BHD": [void 0, void 0, 3], "BIF": [void 0, void 0, 0], "BMD": [void 0, "$"], "BND": [void 0, "$"], "BOB": [void 0, "Bs"], "BRL": ["R$"], "BSD": [void 0, "$"], "BWP": [void 0, "P"], "BYN": [void 0, "\u0440.", 2], "BYR": [void 0, void 0, 0], "BZD": [void 0, "$"], "CAD": ["CA$", "$", 2], "CHF": [void 0, void 0, 2], "CLF": [void 0, void 0, 4], "CLP": [void 0, "$", 0], "CNY": ["CN\xA5", "\xA5"], "COP": [void 0, "$", 2], "CRC": [void 0, "\u20A1", 2], "CUC": [void 0, "$"], "CUP": [void 0, "$"], "CZK": [void 0, "K\u010D", 2], "DJF": [void 0, void 0, 0], "DKK": [void 0, "kr", 2], "DOP": [void 0, "$"], "EGP": [void 0, "E\xA3"], "ESP": [void 0, "\u20A7", 0], "EUR": ["\u20AC"], "FJD": [void 0, "$"], "FKP": [void 0, "\xA3"], "GBP": ["\xA3"], "GEL": [void 0, "\u20BE"], "GHS": [void 0, "GH\u20B5"], "GIP": [void 0, "\xA3"], "GNF": [void 0, "FG", 0], "GTQ": [void 0, "Q"], "GYD": [void 0, "$", 2], "HKD": ["HK$", "$"], "HNL": [void 0, "L"], "HRK": [void 0, "kn"], "HUF": [void 0, "Ft", 2], "IDR": [void 0, "Rp", 2], "ILS": ["\u20AA"], "INR": ["\u20B9"], "IQD": [void 0, void 0, 0], "IRR": [void 0, void 0, 0], "ISK": [void 0, "kr", 0], "ITL": [void 0, void 0, 0], "JMD": [void 0, "$"], "JOD": [void 0, void 0, 3], "JPY": ["\xA5", void 0, 0], "KHR": [void 0, "\u17DB"], "KMF": [void 0, "CF", 0], "KPW": [void 0, "\u20A9", 0], "KRW": ["\u20A9", void 0, 0], "KWD": [void 0, void 0, 3], "KYD": [void 0, "$"], "KZT": [void 0, "\u20B8"], "LAK": [void 0, "\u20AD", 0], "LBP": [void 0, "L\xA3", 0], "LKR": [void 0, "Rs"], "LRD": [void 0, "$"], "LTL": [void 0, "Lt"], "LUF": [void 0, void 0, 0], "LVL": [void 0, "Ls"], "LYD": [void 0, void 0, 3], "MGA": [void 0, "Ar", 0], "MGF": [void 0, void 0, 0], "MMK": [void 0, "K", 0], "MNT": [void 0, "\u20AE", 2], "MRO": [void 0, void 0, 0], "MUR": [void 0, "Rs", 2], "MXN": ["MX$", "$"], "MYR": [void 0, "RM"], "NAD": [void 0, "$"], "NGN": [void 0, "\u20A6"], "NIO": [void 0, "C$"], "NOK": [void 0, "kr", 2], "NPR": [void 0, "Rs"], "NZD": ["NZ$", "$"], "OMR": [void 0, void 0, 3], "PHP": ["\u20B1"], "PKR": [void 0, "Rs", 2], "PLN": [void 0, "z\u0142"], "PYG": [void 0, "\u20B2", 0], "RON": [void 0, "lei"], "RSD": [void 0, void 0, 0], "RUB": [void 0, "\u20BD"], "RUR": [void 0, "\u0440."], "RWF": [void 0, "RF", 0], "SBD": [void 0, "$"], "SEK": [void 0, "kr", 2], "SGD": [void 0, "$"], "SHP": [void 0, "\xA3"], "SLL": [void 0, void 0, 0], "SOS": [void 0, void 0, 0], "SRD": [void 0, "$"], "SSP": [void 0, "\xA3"], "STD": [void 0, void 0, 0], "STN": [void 0, "Db"], "SYP": [void 0, "\xA3", 0], "THB": [void 0, "\u0E3F"], "TMM": [void 0, void 0, 0], "TND": [void 0, void 0, 3], "TOP": [void 0, "T$"], "TRL": [void 0, void 0, 0], "TRY": [void 0, "\u20BA"], "TTD": [void 0, "$"], "TWD": ["NT$", "$", 2], "TZS": [void 0, void 0, 2], "UAH": [void 0, "\u20B4"], "UGX": [void 0, void 0, 0], "USD": ["$"], "UYI": [void 0, void 0, 0], "UYU": [void 0, "$"], "UYW": [void 0, void 0, 4], "UZS": [void 0, void 0, 2], "VEF": [void 0, "Bs", 2], "VND": ["\u20AB", void 0, 0], "VUV": [void 0, void 0, 0], "XAF": ["FCFA", void 0, 0], "XCD": ["EC$", "$"], "XOF": ["F\u202FCFA", void 0, 0], "XPF": ["CFPF", void 0, 0], "XXX": ["\xA4"], "YER": [void 0, void 0, 0], "ZAR": [void 0, "R"], "ZMK": [void 0, void 0, 0], "ZMW": [void 0, "ZK"], "ZWD": [void 0, void 0, 0] };
  var NumberFormatStyle;
  (function(NumberFormatStyle2) {
    NumberFormatStyle2[NumberFormatStyle2["Decimal"] = 0] = "Decimal";
    NumberFormatStyle2[NumberFormatStyle2["Percent"] = 1] = "Percent";
    NumberFormatStyle2[NumberFormatStyle2["Currency"] = 2] = "Currency";
    NumberFormatStyle2[NumberFormatStyle2["Scientific"] = 3] = "Scientific";
  })(NumberFormatStyle || (NumberFormatStyle = {}));
  var Plural;
  (function(Plural2) {
    Plural2[Plural2["Zero"] = 0] = "Zero";
    Plural2[Plural2["One"] = 1] = "One";
    Plural2[Plural2["Two"] = 2] = "Two";
    Plural2[Plural2["Few"] = 3] = "Few";
    Plural2[Plural2["Many"] = 4] = "Many";
    Plural2[Plural2["Other"] = 5] = "Other";
  })(Plural || (Plural = {}));
  var FormStyle;
  (function(FormStyle2) {
    FormStyle2[FormStyle2["Format"] = 0] = "Format";
    FormStyle2[FormStyle2["Standalone"] = 1] = "Standalone";
  })(FormStyle || (FormStyle = {}));
  var TranslationWidth;
  (function(TranslationWidth2) {
    TranslationWidth2[TranslationWidth2["Narrow"] = 0] = "Narrow";
    TranslationWidth2[TranslationWidth2["Abbreviated"] = 1] = "Abbreviated";
    TranslationWidth2[TranslationWidth2["Wide"] = 2] = "Wide";
    TranslationWidth2[TranslationWidth2["Short"] = 3] = "Short";
  })(TranslationWidth || (TranslationWidth = {}));
  var FormatWidth;
  (function(FormatWidth2) {
    FormatWidth2[FormatWidth2["Short"] = 0] = "Short";
    FormatWidth2[FormatWidth2["Medium"] = 1] = "Medium";
    FormatWidth2[FormatWidth2["Long"] = 2] = "Long";
    FormatWidth2[FormatWidth2["Full"] = 3] = "Full";
  })(FormatWidth || (FormatWidth = {}));
  var NumberSymbol;
  (function(NumberSymbol2) {
    NumberSymbol2[NumberSymbol2["Decimal"] = 0] = "Decimal";
    NumberSymbol2[NumberSymbol2["Group"] = 1] = "Group";
    NumberSymbol2[NumberSymbol2["List"] = 2] = "List";
    NumberSymbol2[NumberSymbol2["PercentSign"] = 3] = "PercentSign";
    NumberSymbol2[NumberSymbol2["PlusSign"] = 4] = "PlusSign";
    NumberSymbol2[NumberSymbol2["MinusSign"] = 5] = "MinusSign";
    NumberSymbol2[NumberSymbol2["Exponential"] = 6] = "Exponential";
    NumberSymbol2[NumberSymbol2["SuperscriptingExponent"] = 7] = "SuperscriptingExponent";
    NumberSymbol2[NumberSymbol2["PerMille"] = 8] = "PerMille";
    NumberSymbol2[NumberSymbol2["Infinity"] = 9] = "Infinity";
    NumberSymbol2[NumberSymbol2["NaN"] = 10] = "NaN";
    NumberSymbol2[NumberSymbol2["TimeSeparator"] = 11] = "TimeSeparator";
    NumberSymbol2[NumberSymbol2["CurrencyDecimal"] = 12] = "CurrencyDecimal";
    NumberSymbol2[NumberSymbol2["CurrencyGroup"] = 13] = "CurrencyGroup";
  })(NumberSymbol || (NumberSymbol = {}));
  var WeekDay;
  (function(WeekDay2) {
    WeekDay2[WeekDay2["Sunday"] = 0] = "Sunday";
    WeekDay2[WeekDay2["Monday"] = 1] = "Monday";
    WeekDay2[WeekDay2["Tuesday"] = 2] = "Tuesday";
    WeekDay2[WeekDay2["Wednesday"] = 3] = "Wednesday";
    WeekDay2[WeekDay2["Thursday"] = 4] = "Thursday";
    WeekDay2[WeekDay2["Friday"] = 5] = "Friday";
    WeekDay2[WeekDay2["Saturday"] = 6] = "Saturday";
  })(WeekDay || (WeekDay = {}));
  function getLocaleId2(locale) {
    return findLocaleData(locale)[LocaleDataIndex.LocaleId];
  }
  function getLocaleDayPeriods(locale, formStyle, width) {
    const data = findLocaleData(locale);
    const amPmData = [
      data[LocaleDataIndex.DayPeriodsFormat],
      data[LocaleDataIndex.DayPeriodsStandalone]
    ];
    const amPm = getLastDefinedValue(amPmData, formStyle);
    return getLastDefinedValue(amPm, width);
  }
  function getLocaleDayNames(locale, formStyle, width) {
    const data = findLocaleData(locale);
    const daysData = [data[LocaleDataIndex.DaysFormat], data[LocaleDataIndex.DaysStandalone]];
    const days = getLastDefinedValue(daysData, formStyle);
    return getLastDefinedValue(days, width);
  }
  function getLocaleMonthNames(locale, formStyle, width) {
    const data = findLocaleData(locale);
    const monthsData = [data[LocaleDataIndex.MonthsFormat], data[LocaleDataIndex.MonthsStandalone]];
    const months = getLastDefinedValue(monthsData, formStyle);
    return getLastDefinedValue(months, width);
  }
  function getLocaleEraNames(locale, width) {
    const data = findLocaleData(locale);
    const erasData = data[LocaleDataIndex.Eras];
    return getLastDefinedValue(erasData, width);
  }
  function getLocaleDateFormat(locale, width) {
    const data = findLocaleData(locale);
    return getLastDefinedValue(data[LocaleDataIndex.DateFormat], width);
  }
  function getLocaleTimeFormat(locale, width) {
    const data = findLocaleData(locale);
    return getLastDefinedValue(data[LocaleDataIndex.TimeFormat], width);
  }
  function getLocaleDateTimeFormat(locale, width) {
    const data = findLocaleData(locale);
    const dateTimeFormatData = data[LocaleDataIndex.DateTimeFormat];
    return getLastDefinedValue(dateTimeFormatData, width);
  }
  function getLocaleNumberSymbol(locale, symbol) {
    const data = findLocaleData(locale);
    const res = data[LocaleDataIndex.NumberSymbols][symbol];
    if (typeof res === "undefined") {
      if (symbol === NumberSymbol.CurrencyDecimal) {
        return data[LocaleDataIndex.NumberSymbols][NumberSymbol.Decimal];
      } else if (symbol === NumberSymbol.CurrencyGroup) {
        return data[LocaleDataIndex.NumberSymbols][NumberSymbol.Group];
      }
    }
    return res;
  }
  function getLocaleNumberFormat(locale, type) {
    const data = findLocaleData(locale);
    return data[LocaleDataIndex.NumberFormats][type];
  }
  function getLocaleCurrencies(locale) {
    const data = findLocaleData(locale);
    return data[LocaleDataIndex.Currencies];
  }
  var getLocalePluralCase2 = getLocalePluralCase;
  function checkFullData(data) {
    if (!data[LocaleDataIndex.ExtraData]) {
      throw new Error(`Missing extra locale data for the locale "${data[LocaleDataIndex.LocaleId]}". Use "registerLocaleData" to load new data. See the "I18n guide" on angular.io to know more.`);
    }
  }
  function getLocaleExtraDayPeriodRules(locale) {
    const data = findLocaleData(locale);
    checkFullData(data);
    const rules = data[LocaleDataIndex.ExtraData][2] || [];
    return rules.map((rule) => {
      if (typeof rule === "string") {
        return extractTime(rule);
      }
      return [extractTime(rule[0]), extractTime(rule[1])];
    });
  }
  function getLocaleExtraDayPeriods(locale, formStyle, width) {
    const data = findLocaleData(locale);
    checkFullData(data);
    const dayPeriodsData = [
      data[LocaleDataIndex.ExtraData][0],
      data[LocaleDataIndex.ExtraData][1]
    ];
    const dayPeriods = getLastDefinedValue(dayPeriodsData, formStyle) || [];
    return getLastDefinedValue(dayPeriods, width) || [];
  }
  function getLastDefinedValue(data, index) {
    for (let i = index; i > -1; i--) {
      if (typeof data[i] !== "undefined") {
        return data[i];
      }
    }
    throw new Error("Locale data API: locale data undefined");
  }
  function extractTime(time) {
    const [h, m] = time.split(":");
    return { hours: +h, minutes: +m };
  }
  function getCurrencySymbol(code, format, locale = "en") {
    const currency = getLocaleCurrencies(locale)[code] || CURRENCIES_EN[code] || [];
    const symbolNarrow = currency[1];
    if (format === "narrow" && typeof symbolNarrow === "string") {
      return symbolNarrow;
    }
    return currency[0] || code;
  }
  var DEFAULT_NB_OF_CURRENCY_DIGITS = 2;
  function getNumberOfCurrencyDigits(code) {
    let digits;
    const currency = CURRENCIES_EN[code];
    if (currency) {
      digits = currency[2];
    }
    return typeof digits === "number" ? digits : DEFAULT_NB_OF_CURRENCY_DIGITS;
  }
  var ISO8601_DATE_REGEX = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
  var NAMED_FORMATS = {};
  var DATE_FORMATS_SPLIT = /((?:[^BEGHLMOSWYZabcdhmswyz']+)|(?:'(?:[^']|'')*')|(?:G{1,5}|y{1,4}|Y{1,4}|M{1,5}|L{1,5}|w{1,2}|W{1}|d{1,2}|E{1,6}|c{1,6}|a{1,5}|b{1,5}|B{1,5}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|O{1,4}))([\s\S]*)/;
  var ZoneWidth;
  (function(ZoneWidth2) {
    ZoneWidth2[ZoneWidth2["Short"] = 0] = "Short";
    ZoneWidth2[ZoneWidth2["ShortGMT"] = 1] = "ShortGMT";
    ZoneWidth2[ZoneWidth2["Long"] = 2] = "Long";
    ZoneWidth2[ZoneWidth2["Extended"] = 3] = "Extended";
  })(ZoneWidth || (ZoneWidth = {}));
  var DateType;
  (function(DateType2) {
    DateType2[DateType2["FullYear"] = 0] = "FullYear";
    DateType2[DateType2["Month"] = 1] = "Month";
    DateType2[DateType2["Date"] = 2] = "Date";
    DateType2[DateType2["Hours"] = 3] = "Hours";
    DateType2[DateType2["Minutes"] = 4] = "Minutes";
    DateType2[DateType2["Seconds"] = 5] = "Seconds";
    DateType2[DateType2["FractionalSeconds"] = 6] = "FractionalSeconds";
    DateType2[DateType2["Day"] = 7] = "Day";
  })(DateType || (DateType = {}));
  var TranslationType;
  (function(TranslationType2) {
    TranslationType2[TranslationType2["DayPeriods"] = 0] = "DayPeriods";
    TranslationType2[TranslationType2["Days"] = 1] = "Days";
    TranslationType2[TranslationType2["Months"] = 2] = "Months";
    TranslationType2[TranslationType2["Eras"] = 3] = "Eras";
  })(TranslationType || (TranslationType = {}));
  function formatDate(value, format, locale, timezone) {
    let date = toDate(value);
    const namedFormat = getNamedFormat(locale, format);
    format = namedFormat || format;
    let parts = [];
    let match2;
    while (format) {
      match2 = DATE_FORMATS_SPLIT.exec(format);
      if (match2) {
        parts = parts.concat(match2.slice(1));
        const part = parts.pop();
        if (!part) {
          break;
        }
        format = part;
      } else {
        parts.push(format);
        break;
      }
    }
    let dateTimezoneOffset = date.getTimezoneOffset();
    if (timezone) {
      dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
      date = convertTimezoneToLocal(date, timezone, true);
    }
    let text = "";
    parts.forEach((value2) => {
      const dateFormatter = getDateFormatter(value2);
      text += dateFormatter ? dateFormatter(date, locale, dateTimezoneOffset) : value2 === "''" ? "'" : value2.replace(/(^'|'$)/g, "").replace(/''/g, "'");
    });
    return text;
  }
  function createDate(year, month, date) {
    const newDate = new Date(0);
    newDate.setFullYear(year, month, date);
    newDate.setHours(0, 0, 0);
    return newDate;
  }
  function getNamedFormat(locale, format) {
    const localeId = getLocaleId2(locale);
    NAMED_FORMATS[localeId] = NAMED_FORMATS[localeId] || {};
    if (NAMED_FORMATS[localeId][format]) {
      return NAMED_FORMATS[localeId][format];
    }
    let formatValue = "";
    switch (format) {
      case "shortDate":
        formatValue = getLocaleDateFormat(locale, FormatWidth.Short);
        break;
      case "mediumDate":
        formatValue = getLocaleDateFormat(locale, FormatWidth.Medium);
        break;
      case "longDate":
        formatValue = getLocaleDateFormat(locale, FormatWidth.Long);
        break;
      case "fullDate":
        formatValue = getLocaleDateFormat(locale, FormatWidth.Full);
        break;
      case "shortTime":
        formatValue = getLocaleTimeFormat(locale, FormatWidth.Short);
        break;
      case "mediumTime":
        formatValue = getLocaleTimeFormat(locale, FormatWidth.Medium);
        break;
      case "longTime":
        formatValue = getLocaleTimeFormat(locale, FormatWidth.Long);
        break;
      case "fullTime":
        formatValue = getLocaleTimeFormat(locale, FormatWidth.Full);
        break;
      case "short":
        const shortTime = getNamedFormat(locale, "shortTime");
        const shortDate = getNamedFormat(locale, "shortDate");
        formatValue = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Short), [shortTime, shortDate]);
        break;
      case "medium":
        const mediumTime = getNamedFormat(locale, "mediumTime");
        const mediumDate = getNamedFormat(locale, "mediumDate");
        formatValue = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Medium), [mediumTime, mediumDate]);
        break;
      case "long":
        const longTime = getNamedFormat(locale, "longTime");
        const longDate = getNamedFormat(locale, "longDate");
        formatValue = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Long), [longTime, longDate]);
        break;
      case "full":
        const fullTime = getNamedFormat(locale, "fullTime");
        const fullDate = getNamedFormat(locale, "fullDate");
        formatValue = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Full), [fullTime, fullDate]);
        break;
    }
    if (formatValue) {
      NAMED_FORMATS[localeId][format] = formatValue;
    }
    return formatValue;
  }
  function formatDateTime(str, opt_values) {
    if (opt_values) {
      str = str.replace(/\{([^}]+)}/g, function(match2, key) {
        return opt_values != null && key in opt_values ? opt_values[key] : match2;
      });
    }
    return str;
  }
  function padNumber(num, digits, minusSign = "-", trim, negWrap) {
    let neg = "";
    if (num < 0 || negWrap && num <= 0) {
      if (negWrap) {
        num = -num + 1;
      } else {
        num = -num;
        neg = minusSign;
      }
    }
    let strNum = String(num);
    while (strNum.length < digits) {
      strNum = "0" + strNum;
    }
    if (trim) {
      strNum = strNum.substr(strNum.length - digits);
    }
    return neg + strNum;
  }
  function formatFractionalSeconds(milliseconds, digits) {
    const strMs = padNumber(milliseconds, 3);
    return strMs.substr(0, digits);
  }
  function dateGetter(name, size, offset = 0, trim = false, negWrap = false) {
    return function(date, locale) {
      let part = getDatePart(name, date);
      if (offset > 0 || part > -offset) {
        part += offset;
      }
      if (name === DateType.Hours) {
        if (part === 0 && offset === -12) {
          part = 12;
        }
      } else if (name === DateType.FractionalSeconds) {
        return formatFractionalSeconds(part, size);
      }
      const localeMinus = getLocaleNumberSymbol(locale, NumberSymbol.MinusSign);
      return padNumber(part, size, localeMinus, trim, negWrap);
    };
  }
  function getDatePart(part, date) {
    switch (part) {
      case DateType.FullYear:
        return date.getFullYear();
      case DateType.Month:
        return date.getMonth();
      case DateType.Date:
        return date.getDate();
      case DateType.Hours:
        return date.getHours();
      case DateType.Minutes:
        return date.getMinutes();
      case DateType.Seconds:
        return date.getSeconds();
      case DateType.FractionalSeconds:
        return date.getMilliseconds();
      case DateType.Day:
        return date.getDay();
      default:
        throw new Error(`Unknown DateType value "${part}".`);
    }
  }
  function dateStrGetter(name, width, form = FormStyle.Format, extended = false) {
    return function(date, locale) {
      return getDateTranslation(date, locale, name, width, form, extended);
    };
  }
  function getDateTranslation(date, locale, name, width, form, extended) {
    switch (name) {
      case TranslationType.Months:
        return getLocaleMonthNames(locale, form, width)[date.getMonth()];
      case TranslationType.Days:
        return getLocaleDayNames(locale, form, width)[date.getDay()];
      case TranslationType.DayPeriods:
        const currentHours = date.getHours();
        const currentMinutes = date.getMinutes();
        if (extended) {
          const rules = getLocaleExtraDayPeriodRules(locale);
          const dayPeriods = getLocaleExtraDayPeriods(locale, form, width);
          const index = rules.findIndex((rule) => {
            if (Array.isArray(rule)) {
              const [from2, to] = rule;
              const afterFrom = currentHours >= from2.hours && currentMinutes >= from2.minutes;
              const beforeTo = currentHours < to.hours || currentHours === to.hours && currentMinutes < to.minutes;
              if (from2.hours < to.hours) {
                if (afterFrom && beforeTo) {
                  return true;
                }
              } else if (afterFrom || beforeTo) {
                return true;
              }
            } else {
              if (rule.hours === currentHours && rule.minutes === currentMinutes) {
                return true;
              }
            }
            return false;
          });
          if (index !== -1) {
            return dayPeriods[index];
          }
        }
        return getLocaleDayPeriods(locale, form, width)[currentHours < 12 ? 0 : 1];
      case TranslationType.Eras:
        return getLocaleEraNames(locale, width)[date.getFullYear() <= 0 ? 0 : 1];
      default:
        const unexpected = name;
        throw new Error(`unexpected translation type ${unexpected}`);
    }
  }
  function timeZoneGetter(width) {
    return function(date, locale, offset) {
      const zone = -1 * offset;
      const minusSign = getLocaleNumberSymbol(locale, NumberSymbol.MinusSign);
      const hours = zone > 0 ? Math.floor(zone / 60) : Math.ceil(zone / 60);
      switch (width) {
        case ZoneWidth.Short:
          return (zone >= 0 ? "+" : "") + padNumber(hours, 2, minusSign) + padNumber(Math.abs(zone % 60), 2, minusSign);
        case ZoneWidth.ShortGMT:
          return "GMT" + (zone >= 0 ? "+" : "") + padNumber(hours, 1, minusSign);
        case ZoneWidth.Long:
          return "GMT" + (zone >= 0 ? "+" : "") + padNumber(hours, 2, minusSign) + ":" + padNumber(Math.abs(zone % 60), 2, minusSign);
        case ZoneWidth.Extended:
          if (offset === 0) {
            return "Z";
          } else {
            return (zone >= 0 ? "+" : "") + padNumber(hours, 2, minusSign) + ":" + padNumber(Math.abs(zone % 60), 2, minusSign);
          }
        default:
          throw new Error(`Unknown zone width "${width}"`);
      }
    };
  }
  var JANUARY = 0;
  var THURSDAY = 4;
  function getFirstThursdayOfYear(year) {
    const firstDayOfYear = createDate(year, JANUARY, 1).getDay();
    return createDate(year, 0, 1 + (firstDayOfYear <= THURSDAY ? THURSDAY : THURSDAY + 7) - firstDayOfYear);
  }
  function getThursdayThisWeek(datetime) {
    return createDate(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (THURSDAY - datetime.getDay()));
  }
  function weekGetter(size, monthBased = false) {
    return function(date, locale) {
      let result;
      if (monthBased) {
        const nbDaysBefore1stDayOfMonth = new Date(date.getFullYear(), date.getMonth(), 1).getDay() - 1;
        const today = date.getDate();
        result = 1 + Math.floor((today + nbDaysBefore1stDayOfMonth) / 7);
      } else {
        const thisThurs = getThursdayThisWeek(date);
        const firstThurs = getFirstThursdayOfYear(thisThurs.getFullYear());
        const diff = thisThurs.getTime() - firstThurs.getTime();
        result = 1 + Math.round(diff / 6048e5);
      }
      return padNumber(result, size, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
    };
  }
  function weekNumberingYearGetter(size, trim = false) {
    return function(date, locale) {
      const thisThurs = getThursdayThisWeek(date);
      const weekNumberingYear = thisThurs.getFullYear();
      return padNumber(weekNumberingYear, size, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign), trim);
    };
  }
  var DATE_FORMATS = {};
  function getDateFormatter(format) {
    if (DATE_FORMATS[format]) {
      return DATE_FORMATS[format];
    }
    let formatter;
    switch (format) {
      case "G":
      case "GG":
      case "GGG":
        formatter = dateStrGetter(TranslationType.Eras, TranslationWidth.Abbreviated);
        break;
      case "GGGG":
        formatter = dateStrGetter(TranslationType.Eras, TranslationWidth.Wide);
        break;
      case "GGGGG":
        formatter = dateStrGetter(TranslationType.Eras, TranslationWidth.Narrow);
        break;
      case "y":
        formatter = dateGetter(DateType.FullYear, 1, 0, false, true);
        break;
      case "yy":
        formatter = dateGetter(DateType.FullYear, 2, 0, true, true);
        break;
      case "yyy":
        formatter = dateGetter(DateType.FullYear, 3, 0, false, true);
        break;
      case "yyyy":
        formatter = dateGetter(DateType.FullYear, 4, 0, false, true);
        break;
      case "Y":
        formatter = weekNumberingYearGetter(1);
        break;
      case "YY":
        formatter = weekNumberingYearGetter(2, true);
        break;
      case "YYY":
        formatter = weekNumberingYearGetter(3);
        break;
      case "YYYY":
        formatter = weekNumberingYearGetter(4);
        break;
      case "M":
      case "L":
        formatter = dateGetter(DateType.Month, 1, 1);
        break;
      case "MM":
      case "LL":
        formatter = dateGetter(DateType.Month, 2, 1);
        break;
      case "MMM":
        formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Abbreviated);
        break;
      case "MMMM":
        formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Wide);
        break;
      case "MMMMM":
        formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Narrow);
        break;
      case "LLL":
        formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Abbreviated, FormStyle.Standalone);
        break;
      case "LLLL":
        formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Wide, FormStyle.Standalone);
        break;
      case "LLLLL":
        formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Narrow, FormStyle.Standalone);
        break;
      case "w":
        formatter = weekGetter(1);
        break;
      case "ww":
        formatter = weekGetter(2);
        break;
      case "W":
        formatter = weekGetter(1, true);
        break;
      case "d":
        formatter = dateGetter(DateType.Date, 1);
        break;
      case "dd":
        formatter = dateGetter(DateType.Date, 2);
        break;
      case "c":
      case "cc":
        formatter = dateGetter(DateType.Day, 1);
        break;
      case "ccc":
        formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Abbreviated, FormStyle.Standalone);
        break;
      case "cccc":
        formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Wide, FormStyle.Standalone);
        break;
      case "ccccc":
        formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Narrow, FormStyle.Standalone);
        break;
      case "cccccc":
        formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Short, FormStyle.Standalone);
        break;
      case "E":
      case "EE":
      case "EEE":
        formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Abbreviated);
        break;
      case "EEEE":
        formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Wide);
        break;
      case "EEEEE":
        formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Narrow);
        break;
      case "EEEEEE":
        formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Short);
        break;
      case "a":
      case "aa":
      case "aaa":
        formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Abbreviated);
        break;
      case "aaaa":
        formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Wide);
        break;
      case "aaaaa":
        formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Narrow);
        break;
      case "b":
      case "bb":
      case "bbb":
        formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Abbreviated, FormStyle.Standalone, true);
        break;
      case "bbbb":
        formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Wide, FormStyle.Standalone, true);
        break;
      case "bbbbb":
        formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Narrow, FormStyle.Standalone, true);
        break;
      case "B":
      case "BB":
      case "BBB":
        formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Abbreviated, FormStyle.Format, true);
        break;
      case "BBBB":
        formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Wide, FormStyle.Format, true);
        break;
      case "BBBBB":
        formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Narrow, FormStyle.Format, true);
        break;
      case "h":
        formatter = dateGetter(DateType.Hours, 1, -12);
        break;
      case "hh":
        formatter = dateGetter(DateType.Hours, 2, -12);
        break;
      case "H":
        formatter = dateGetter(DateType.Hours, 1);
        break;
      case "HH":
        formatter = dateGetter(DateType.Hours, 2);
        break;
      case "m":
        formatter = dateGetter(DateType.Minutes, 1);
        break;
      case "mm":
        formatter = dateGetter(DateType.Minutes, 2);
        break;
      case "s":
        formatter = dateGetter(DateType.Seconds, 1);
        break;
      case "ss":
        formatter = dateGetter(DateType.Seconds, 2);
        break;
      case "S":
        formatter = dateGetter(DateType.FractionalSeconds, 1);
        break;
      case "SS":
        formatter = dateGetter(DateType.FractionalSeconds, 2);
        break;
      case "SSS":
        formatter = dateGetter(DateType.FractionalSeconds, 3);
        break;
      case "Z":
      case "ZZ":
      case "ZZZ":
        formatter = timeZoneGetter(ZoneWidth.Short);
        break;
      case "ZZZZZ":
        formatter = timeZoneGetter(ZoneWidth.Extended);
        break;
      case "O":
      case "OO":
      case "OOO":
      case "z":
      case "zz":
      case "zzz":
        formatter = timeZoneGetter(ZoneWidth.ShortGMT);
        break;
      case "OOOO":
      case "ZZZZ":
      case "zzzz":
        formatter = timeZoneGetter(ZoneWidth.Long);
        break;
      default:
        return null;
    }
    DATE_FORMATS[format] = formatter;
    return formatter;
  }
  function timezoneToOffset(timezone, fallback) {
    timezone = timezone.replace(/:/g, "");
    const requestedTimezoneOffset = Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 6e4;
    return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
  }
  function addDateMinutes(date, minutes) {
    date = new Date(date.getTime());
    date.setMinutes(date.getMinutes() + minutes);
    return date;
  }
  function convertTimezoneToLocal(date, timezone, reverse) {
    const reverseValue = reverse ? -1 : 1;
    const dateTimezoneOffset = date.getTimezoneOffset();
    const timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
    return addDateMinutes(date, reverseValue * (timezoneOffset - dateTimezoneOffset));
  }
  function toDate(value) {
    if (isDate(value)) {
      return value;
    }
    if (typeof value === "number" && !isNaN(value)) {
      return new Date(value);
    }
    if (typeof value === "string") {
      value = value.trim();
      if (/^(\d{4}(-\d{1,2}(-\d{1,2})?)?)$/.test(value)) {
        const [y, m = 1, d = 1] = value.split("-").map((val) => +val);
        return createDate(y, m - 1, d);
      }
      const parsedNb = parseFloat(value);
      if (!isNaN(value - parsedNb)) {
        return new Date(parsedNb);
      }
      let match2;
      if (match2 = value.match(ISO8601_DATE_REGEX)) {
        return isoStringToDate(match2);
      }
    }
    const date = new Date(value);
    if (!isDate(date)) {
      throw new Error(`Unable to convert "${value}" into a date`);
    }
    return date;
  }
  function isoStringToDate(match2) {
    const date = new Date(0);
    let tzHour = 0;
    let tzMin = 0;
    const dateSetter = match2[8] ? date.setUTCFullYear : date.setFullYear;
    const timeSetter = match2[8] ? date.setUTCHours : date.setHours;
    if (match2[9]) {
      tzHour = Number(match2[9] + match2[10]);
      tzMin = Number(match2[9] + match2[11]);
    }
    dateSetter.call(date, Number(match2[1]), Number(match2[2]) - 1, Number(match2[3]));
    const h = Number(match2[4] || 0) - tzHour;
    const m = Number(match2[5] || 0) - tzMin;
    const s = Number(match2[6] || 0);
    const ms = Math.floor(parseFloat("0." + (match2[7] || 0)) * 1e3);
    timeSetter.call(date, h, m, s, ms);
    return date;
  }
  function isDate(value) {
    return value instanceof Date && !isNaN(value.valueOf());
  }
  var NUMBER_FORMAT_REGEXP = /^(\d+)?\.((\d+)(-(\d+))?)?$/;
  var MAX_DIGITS = 22;
  var DECIMAL_SEP = ".";
  var ZERO_CHAR = "0";
  var PATTERN_SEP = ";";
  var GROUP_SEP = ",";
  var DIGIT_CHAR = "#";
  var CURRENCY_CHAR = "\xA4";
  var PERCENT_CHAR = "%";
  function formatNumberToLocaleString(value, pattern, locale, groupSymbol, decimalSymbol, digitsInfo, isPercent = false) {
    let formattedText = "";
    let isZero = false;
    if (!isFinite(value)) {
      formattedText = getLocaleNumberSymbol(locale, NumberSymbol.Infinity);
    } else {
      let parsedNumber = parseNumber(value);
      if (isPercent) {
        parsedNumber = toPercent(parsedNumber);
      }
      let minInt = pattern.minInt;
      let minFraction = pattern.minFrac;
      let maxFraction = pattern.maxFrac;
      if (digitsInfo) {
        const parts = digitsInfo.match(NUMBER_FORMAT_REGEXP);
        if (parts === null) {
          throw new Error(`${digitsInfo} is not a valid digit info`);
        }
        const minIntPart = parts[1];
        const minFractionPart = parts[3];
        const maxFractionPart = parts[5];
        if (minIntPart != null) {
          minInt = parseIntAutoRadix2(minIntPart);
        }
        if (minFractionPart != null) {
          minFraction = parseIntAutoRadix2(minFractionPart);
        }
        if (maxFractionPart != null) {
          maxFraction = parseIntAutoRadix2(maxFractionPart);
        } else if (minFractionPart != null && minFraction > maxFraction) {
          maxFraction = minFraction;
        }
      }
      roundNumber(parsedNumber, minFraction, maxFraction);
      let digits = parsedNumber.digits;
      let integerLen = parsedNumber.integerLen;
      const exponent = parsedNumber.exponent;
      let decimals = [];
      isZero = digits.every((d) => !d);
      for (; integerLen < minInt; integerLen++) {
        digits.unshift(0);
      }
      for (; integerLen < 0; integerLen++) {
        digits.unshift(0);
      }
      if (integerLen > 0) {
        decimals = digits.splice(integerLen, digits.length);
      } else {
        decimals = digits;
        digits = [0];
      }
      const groups = [];
      if (digits.length >= pattern.lgSize) {
        groups.unshift(digits.splice(-pattern.lgSize, digits.length).join(""));
      }
      while (digits.length > pattern.gSize) {
        groups.unshift(digits.splice(-pattern.gSize, digits.length).join(""));
      }
      if (digits.length) {
        groups.unshift(digits.join(""));
      }
      formattedText = groups.join(getLocaleNumberSymbol(locale, groupSymbol));
      if (decimals.length) {
        formattedText += getLocaleNumberSymbol(locale, decimalSymbol) + decimals.join("");
      }
      if (exponent) {
        formattedText += getLocaleNumberSymbol(locale, NumberSymbol.Exponential) + "+" + exponent;
      }
    }
    if (value < 0 && !isZero) {
      formattedText = pattern.negPre + formattedText + pattern.negSuf;
    } else {
      formattedText = pattern.posPre + formattedText + pattern.posSuf;
    }
    return formattedText;
  }
  function formatCurrency(value, locale, currency, currencyCode, digitsInfo) {
    const format = getLocaleNumberFormat(locale, NumberFormatStyle.Currency);
    const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
    pattern.minFrac = getNumberOfCurrencyDigits(currencyCode);
    pattern.maxFrac = pattern.minFrac;
    const res = formatNumberToLocaleString(value, pattern, locale, NumberSymbol.CurrencyGroup, NumberSymbol.CurrencyDecimal, digitsInfo);
    return res.replace(CURRENCY_CHAR, currency).replace(CURRENCY_CHAR, "").trim();
  }
  function formatPercent(value, locale, digitsInfo) {
    const format = getLocaleNumberFormat(locale, NumberFormatStyle.Percent);
    const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
    const res = formatNumberToLocaleString(value, pattern, locale, NumberSymbol.Group, NumberSymbol.Decimal, digitsInfo, true);
    return res.replace(new RegExp(PERCENT_CHAR, "g"), getLocaleNumberSymbol(locale, NumberSymbol.PercentSign));
  }
  function formatNumber(value, locale, digitsInfo) {
    const format = getLocaleNumberFormat(locale, NumberFormatStyle.Decimal);
    const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
    return formatNumberToLocaleString(value, pattern, locale, NumberSymbol.Group, NumberSymbol.Decimal, digitsInfo);
  }
  function parseNumberFormat(format, minusSign = "-") {
    const p = {
      minInt: 1,
      minFrac: 0,
      maxFrac: 0,
      posPre: "",
      posSuf: "",
      negPre: "",
      negSuf: "",
      gSize: 0,
      lgSize: 0
    };
    const patternParts = format.split(PATTERN_SEP);
    const positive = patternParts[0];
    const negative = patternParts[1];
    const positiveParts = positive.indexOf(DECIMAL_SEP) !== -1 ? positive.split(DECIMAL_SEP) : [
      positive.substring(0, positive.lastIndexOf(ZERO_CHAR) + 1),
      positive.substring(positive.lastIndexOf(ZERO_CHAR) + 1)
    ], integer = positiveParts[0], fraction = positiveParts[1] || "";
    p.posPre = integer.substr(0, integer.indexOf(DIGIT_CHAR));
    for (let i = 0; i < fraction.length; i++) {
      const ch = fraction.charAt(i);
      if (ch === ZERO_CHAR) {
        p.minFrac = p.maxFrac = i + 1;
      } else if (ch === DIGIT_CHAR) {
        p.maxFrac = i + 1;
      } else {
        p.posSuf += ch;
      }
    }
    const groups = integer.split(GROUP_SEP);
    p.gSize = groups[1] ? groups[1].length : 0;
    p.lgSize = groups[2] || groups[1] ? (groups[2] || groups[1]).length : 0;
    if (negative) {
      const trunkLen = positive.length - p.posPre.length - p.posSuf.length, pos = negative.indexOf(DIGIT_CHAR);
      p.negPre = negative.substr(0, pos).replace(/'/g, "");
      p.negSuf = negative.substr(pos + trunkLen).replace(/'/g, "");
    } else {
      p.negPre = minusSign + p.posPre;
      p.negSuf = p.posSuf;
    }
    return p;
  }
  function toPercent(parsedNumber) {
    if (parsedNumber.digits[0] === 0) {
      return parsedNumber;
    }
    const fractionLen = parsedNumber.digits.length - parsedNumber.integerLen;
    if (parsedNumber.exponent) {
      parsedNumber.exponent += 2;
    } else {
      if (fractionLen === 0) {
        parsedNumber.digits.push(0, 0);
      } else if (fractionLen === 1) {
        parsedNumber.digits.push(0);
      }
      parsedNumber.integerLen += 2;
    }
    return parsedNumber;
  }
  function parseNumber(num) {
    let numStr = Math.abs(num) + "";
    let exponent = 0, digits, integerLen;
    let i, j, zeros;
    if ((integerLen = numStr.indexOf(DECIMAL_SEP)) > -1) {
      numStr = numStr.replace(DECIMAL_SEP, "");
    }
    if ((i = numStr.search(/e/i)) > 0) {
      if (integerLen < 0)
        integerLen = i;
      integerLen += +numStr.slice(i + 1);
      numStr = numStr.substring(0, i);
    } else if (integerLen < 0) {
      integerLen = numStr.length;
    }
    for (i = 0; numStr.charAt(i) === ZERO_CHAR; i++) {
    }
    if (i === (zeros = numStr.length)) {
      digits = [0];
      integerLen = 1;
    } else {
      zeros--;
      while (numStr.charAt(zeros) === ZERO_CHAR)
        zeros--;
      integerLen -= i;
      digits = [];
      for (j = 0; i <= zeros; i++, j++) {
        digits[j] = Number(numStr.charAt(i));
      }
    }
    if (integerLen > MAX_DIGITS) {
      digits = digits.splice(0, MAX_DIGITS - 1);
      exponent = integerLen - 1;
      integerLen = 1;
    }
    return { digits, exponent, integerLen };
  }
  function roundNumber(parsedNumber, minFrac, maxFrac) {
    if (minFrac > maxFrac) {
      throw new Error(`The minimum number of digits after fraction (${minFrac}) is higher than the maximum (${maxFrac}).`);
    }
    let digits = parsedNumber.digits;
    let fractionLen = digits.length - parsedNumber.integerLen;
    const fractionSize = Math.min(Math.max(minFrac, fractionLen), maxFrac);
    let roundAt = fractionSize + parsedNumber.integerLen;
    let digit = digits[roundAt];
    if (roundAt > 0) {
      digits.splice(Math.max(parsedNumber.integerLen, roundAt));
      for (let j = roundAt; j < digits.length; j++) {
        digits[j] = 0;
      }
    } else {
      fractionLen = Math.max(0, fractionLen);
      parsedNumber.integerLen = 1;
      digits.length = Math.max(1, roundAt = fractionSize + 1);
      digits[0] = 0;
      for (let i = 1; i < roundAt; i++)
        digits[i] = 0;
    }
    if (digit >= 5) {
      if (roundAt - 1 < 0) {
        for (let k = 0; k > roundAt; k--) {
          digits.unshift(0);
          parsedNumber.integerLen++;
        }
        digits.unshift(1);
        parsedNumber.integerLen++;
      } else {
        digits[roundAt - 1]++;
      }
    }
    for (; fractionLen < Math.max(0, fractionSize); fractionLen++)
      digits.push(0);
    let dropTrailingZeros = fractionSize !== 0;
    const minLen = minFrac + parsedNumber.integerLen;
    const carry = digits.reduceRight(function(carry2, d, i, digits2) {
      d = d + carry2;
      digits2[i] = d < 10 ? d : d - 10;
      if (dropTrailingZeros) {
        if (digits2[i] === 0 && i >= minLen) {
          digits2.pop();
        } else {
          dropTrailingZeros = false;
        }
      }
      return d >= 10 ? 1 : 0;
    }, 0);
    if (carry) {
      digits.unshift(carry);
      parsedNumber.integerLen++;
    }
  }
  function parseIntAutoRadix2(text) {
    const result = parseInt(text);
    if (isNaN(result)) {
      throw new Error("Invalid integer literal when parsing " + text);
    }
    return result;
  }
  var NgLocalization = class {
  };
  function getPluralCategory(value, cases, ngLocalization, locale) {
    let key = `=${value}`;
    if (cases.indexOf(key) > -1) {
      return key;
    }
    key = ngLocalization.getPluralCategory(value, locale);
    if (cases.indexOf(key) > -1) {
      return key;
    }
    if (cases.indexOf("other") > -1) {
      return "other";
    }
    throw new Error(`No plural message found for value "${value}"`);
  }
  var NgLocaleLocalization = class extends NgLocalization {
    constructor(locale) {
      super();
      this.locale = locale;
    }
    getPluralCategory(value, locale) {
      const plural2 = getLocalePluralCase2(locale || this.locale)(value);
      switch (plural2) {
        case Plural.Zero:
          return "zero";
        case Plural.One:
          return "one";
        case Plural.Two:
          return "two";
        case Plural.Few:
          return "few";
        case Plural.Many:
          return "many";
        default:
          return "other";
      }
    }
  };
  NgLocaleLocalization.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: NgLocaleLocalization, deps: [{ token: LOCALE_ID }], target: FactoryTarget.Injectable });
  NgLocaleLocalization.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: NgLocaleLocalization });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: NgLocaleLocalization, decorators: [{
    type: Injectable
  }], ctorParameters: function() {
    return [{ type: void 0, decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }] }];
  } });
  function parseCookieValue(cookieStr, name) {
    name = encodeURIComponent(name);
    for (const cookie of cookieStr.split(";")) {
      const eqIndex = cookie.indexOf("=");
      const [cookieName, cookieValue] = eqIndex == -1 ? [cookie, ""] : [cookie.slice(0, eqIndex), cookie.slice(eqIndex + 1)];
      if (cookieName.trim() === name) {
        return decodeURIComponent(cookieValue);
      }
    }
    return null;
  }
  var NgClass = class {
    constructor(_iterableDiffers, _keyValueDiffers, _ngEl, _renderer) {
      this._iterableDiffers = _iterableDiffers;
      this._keyValueDiffers = _keyValueDiffers;
      this._ngEl = _ngEl;
      this._renderer = _renderer;
      this._iterableDiffer = null;
      this._keyValueDiffer = null;
      this._initialClasses = [];
      this._rawClass = null;
    }
    set klass(value) {
      this._removeClasses(this._initialClasses);
      this._initialClasses = typeof value === "string" ? value.split(/\s+/) : [];
      this._applyClasses(this._initialClasses);
      this._applyClasses(this._rawClass);
    }
    set ngClass(value) {
      this._removeClasses(this._rawClass);
      this._applyClasses(this._initialClasses);
      this._iterableDiffer = null;
      this._keyValueDiffer = null;
      this._rawClass = typeof value === "string" ? value.split(/\s+/) : value;
      if (this._rawClass) {
        if (isListLikeIterable(this._rawClass)) {
          this._iterableDiffer = this._iterableDiffers.find(this._rawClass).create();
        } else {
          this._keyValueDiffer = this._keyValueDiffers.find(this._rawClass).create();
        }
      }
    }
    ngDoCheck() {
      if (this._iterableDiffer) {
        const iterableChanges = this._iterableDiffer.diff(this._rawClass);
        if (iterableChanges) {
          this._applyIterableChanges(iterableChanges);
        }
      } else if (this._keyValueDiffer) {
        const keyValueChanges = this._keyValueDiffer.diff(this._rawClass);
        if (keyValueChanges) {
          this._applyKeyValueChanges(keyValueChanges);
        }
      }
    }
    _applyKeyValueChanges(changes) {
      changes.forEachAddedItem((record) => this._toggleClass(record.key, record.currentValue));
      changes.forEachChangedItem((record) => this._toggleClass(record.key, record.currentValue));
      changes.forEachRemovedItem((record) => {
        if (record.previousValue) {
          this._toggleClass(record.key, false);
        }
      });
    }
    _applyIterableChanges(changes) {
      changes.forEachAddedItem((record) => {
        if (typeof record.item === "string") {
          this._toggleClass(record.item, true);
        } else {
          throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${stringify(record.item)}`);
        }
      });
      changes.forEachRemovedItem((record) => this._toggleClass(record.item, false));
    }
    _applyClasses(rawClassVal) {
      if (rawClassVal) {
        if (Array.isArray(rawClassVal) || rawClassVal instanceof Set) {
          rawClassVal.forEach((klass) => this._toggleClass(klass, true));
        } else {
          Object.keys(rawClassVal).forEach((klass) => this._toggleClass(klass, !!rawClassVal[klass]));
        }
      }
    }
    _removeClasses(rawClassVal) {
      if (rawClassVal) {
        if (Array.isArray(rawClassVal) || rawClassVal instanceof Set) {
          rawClassVal.forEach((klass) => this._toggleClass(klass, false));
        } else {
          Object.keys(rawClassVal).forEach((klass) => this._toggleClass(klass, false));
        }
      }
    }
    _toggleClass(klass, enabled) {
      klass = klass.trim();
      if (klass) {
        klass.split(/\s+/g).forEach((klass2) => {
          if (enabled) {
            this._renderer.addClass(this._ngEl.nativeElement, klass2);
          } else {
            this._renderer.removeClass(this._ngEl.nativeElement, klass2);
          }
        });
      }
    }
  };
  NgClass.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: NgClass, deps: [{ token: IterableDiffers }, { token: KeyValueDiffers }, { token: ElementRef }, { token: Renderer2 }], target: FactoryTarget.Directive });
  NgClass.\u0275dir = \u0275\u0275ngDeclareDirective({ minVersion: "12.0.0", version: "13.0.3", type: NgClass, selector: "[ngClass]", inputs: { klass: ["class", "klass"], ngClass: "ngClass" }, ngImport: core_exports });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: NgClass, decorators: [{
    type: Directive,
    args: [{ selector: "[ngClass]" }]
  }], ctorParameters: function() {
    return [{ type: IterableDiffers }, { type: KeyValueDiffers }, { type: ElementRef }, { type: Renderer2 }];
  }, propDecorators: { klass: [{
    type: Input,
    args: ["class"]
  }], ngClass: [{
    type: Input,
    args: ["ngClass"]
  }] } });
  var NgComponentOutlet = class {
    constructor(_viewContainerRef) {
      this._viewContainerRef = _viewContainerRef;
      this._componentRef = null;
      this._moduleRef = null;
    }
    ngOnChanges(changes) {
      this._viewContainerRef.clear();
      this._componentRef = null;
      if (this.ngComponentOutlet) {
        const elInjector = this.ngComponentOutletInjector || this._viewContainerRef.parentInjector;
        if (changes["ngComponentOutletNgModuleFactory"]) {
          if (this._moduleRef)
            this._moduleRef.destroy();
          if (this.ngComponentOutletNgModuleFactory) {
            const parentModule = elInjector.get(NgModuleRef$1);
            this._moduleRef = this.ngComponentOutletNgModuleFactory.create(parentModule.injector);
          } else {
            this._moduleRef = null;
          }
        }
        const componentFactoryResolver2 = this._moduleRef ? this._moduleRef.componentFactoryResolver : elInjector.get(ComponentFactoryResolver$1);
        const componentFactory = componentFactoryResolver2.resolveComponentFactory(this.ngComponentOutlet);
        this._componentRef = this._viewContainerRef.createComponent(componentFactory, this._viewContainerRef.length, elInjector, this.ngComponentOutletContent);
      }
    }
    ngOnDestroy() {
      if (this._moduleRef)
        this._moduleRef.destroy();
    }
  };
  NgComponentOutlet.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: NgComponentOutlet, deps: [{ token: ViewContainerRef }], target: FactoryTarget.Directive });
  NgComponentOutlet.\u0275dir = \u0275\u0275ngDeclareDirective({ minVersion: "12.0.0", version: "13.0.3", type: NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: { ngComponentOutlet: "ngComponentOutlet", ngComponentOutletInjector: "ngComponentOutletInjector", ngComponentOutletContent: "ngComponentOutletContent", ngComponentOutletNgModuleFactory: "ngComponentOutletNgModuleFactory" }, usesOnChanges: true, ngImport: core_exports });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: NgComponentOutlet, decorators: [{
    type: Directive,
    args: [{ selector: "[ngComponentOutlet]" }]
  }], ctorParameters: function() {
    return [{ type: ViewContainerRef }];
  }, propDecorators: { ngComponentOutlet: [{
    type: Input
  }], ngComponentOutletInjector: [{
    type: Input
  }], ngComponentOutletContent: [{
    type: Input
  }], ngComponentOutletNgModuleFactory: [{
    type: Input
  }] } });
  var NgForOfContext = class {
    constructor($implicit, ngForOf, index, count) {
      this.$implicit = $implicit;
      this.ngForOf = ngForOf;
      this.index = index;
      this.count = count;
    }
    get first() {
      return this.index === 0;
    }
    get last() {
      return this.index === this.count - 1;
    }
    get even() {
      return this.index % 2 === 0;
    }
    get odd() {
      return !this.even;
    }
  };
  var NgForOf = class {
    constructor(_viewContainer, _template, _differs) {
      this._viewContainer = _viewContainer;
      this._template = _template;
      this._differs = _differs;
      this._ngForOf = null;
      this._ngForOfDirty = true;
      this._differ = null;
    }
    set ngForOf(ngForOf) {
      this._ngForOf = ngForOf;
      this._ngForOfDirty = true;
    }
    set ngForTrackBy(fn2) {
      if ((typeof ngDevMode === "undefined" || ngDevMode) && fn2 != null && typeof fn2 !== "function") {
        if (console && console.warn) {
          console.warn(`trackBy must be a function, but received ${JSON.stringify(fn2)}. See https://angular.io/api/common/NgForOf#change-propagation for more information.`);
        }
      }
      this._trackByFn = fn2;
    }
    get ngForTrackBy() {
      return this._trackByFn;
    }
    set ngForTemplate(value) {
      if (value) {
        this._template = value;
      }
    }
    ngDoCheck() {
      if (this._ngForOfDirty) {
        this._ngForOfDirty = false;
        const value = this._ngForOf;
        if (!this._differ && value) {
          try {
            this._differ = this._differs.find(value).create(this.ngForTrackBy);
          } catch {
            throw new Error(`Cannot find a differ supporting object '${value}' of type '${getTypeName2(value)}'. NgFor only supports binding to Iterables such as Arrays.`);
          }
        }
      }
      if (this._differ) {
        const changes = this._differ.diff(this._ngForOf);
        if (changes)
          this._applyChanges(changes);
      }
    }
    _applyChanges(changes) {
      const insertTuples = [];
      changes.forEachOperation((item, adjustedPreviousIndex, currentIndex) => {
        if (item.previousIndex == null) {
          const view = this._viewContainer.createEmbeddedView(this._template, new NgForOfContext(null, this._ngForOf, -1, -1), currentIndex === null ? void 0 : currentIndex);
          const tuple = new RecordViewTuple(item, view);
          insertTuples.push(tuple);
        } else if (currentIndex == null) {
          this._viewContainer.remove(adjustedPreviousIndex === null ? void 0 : adjustedPreviousIndex);
        } else if (adjustedPreviousIndex !== null) {
          const view = this._viewContainer.get(adjustedPreviousIndex);
          this._viewContainer.move(view, currentIndex);
          const tuple = new RecordViewTuple(item, view);
          insertTuples.push(tuple);
        }
      });
      for (let i = 0; i < insertTuples.length; i++) {
        this._perViewChange(insertTuples[i].view, insertTuples[i].record);
      }
      for (let i = 0, ilen = this._viewContainer.length; i < ilen; i++) {
        const viewRef = this._viewContainer.get(i);
        viewRef.context.index = i;
        viewRef.context.count = ilen;
        viewRef.context.ngForOf = this._ngForOf;
      }
      changes.forEachIdentityChange((record) => {
        const viewRef = this._viewContainer.get(record.currentIndex);
        viewRef.context.$implicit = record.item;
      });
    }
    _perViewChange(view, record) {
      view.context.$implicit = record.item;
    }
    static ngTemplateContextGuard(dir, ctx) {
      return true;
    }
  };
  NgForOf.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: NgForOf, deps: [{ token: ViewContainerRef }, { token: TemplateRef }, { token: IterableDiffers }], target: FactoryTarget.Directive });
  NgForOf.\u0275dir = \u0275\u0275ngDeclareDirective({ minVersion: "12.0.0", version: "13.0.3", type: NgForOf, selector: "[ngFor][ngForOf]", inputs: { ngForOf: "ngForOf", ngForTrackBy: "ngForTrackBy", ngForTemplate: "ngForTemplate" }, ngImport: core_exports });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: NgForOf, decorators: [{
    type: Directive,
    args: [{ selector: "[ngFor][ngForOf]" }]
  }], ctorParameters: function() {
    return [{ type: ViewContainerRef }, { type: TemplateRef }, { type: IterableDiffers }];
  }, propDecorators: { ngForOf: [{
    type: Input
  }], ngForTrackBy: [{
    type: Input
  }], ngForTemplate: [{
    type: Input
  }] } });
  var RecordViewTuple = class {
    constructor(record, view) {
      this.record = record;
      this.view = view;
    }
  };
  function getTypeName2(type) {
    return type["name"] || typeof type;
  }
  var NgIf = class {
    constructor(_viewContainer, templateRef) {
      this._viewContainer = _viewContainer;
      this._context = new NgIfContext();
      this._thenTemplateRef = null;
      this._elseTemplateRef = null;
      this._thenViewRef = null;
      this._elseViewRef = null;
      this._thenTemplateRef = templateRef;
    }
    set ngIf(condition) {
      this._context.$implicit = this._context.ngIf = condition;
      this._updateView();
    }
    set ngIfThen(templateRef) {
      assertTemplate("ngIfThen", templateRef);
      this._thenTemplateRef = templateRef;
      this._thenViewRef = null;
      this._updateView();
    }
    set ngIfElse(templateRef) {
      assertTemplate("ngIfElse", templateRef);
      this._elseTemplateRef = templateRef;
      this._elseViewRef = null;
      this._updateView();
    }
    _updateView() {
      if (this._context.$implicit) {
        if (!this._thenViewRef) {
          this._viewContainer.clear();
          this._elseViewRef = null;
          if (this._thenTemplateRef) {
            this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context);
          }
        }
      } else {
        if (!this._elseViewRef) {
          this._viewContainer.clear();
          this._thenViewRef = null;
          if (this._elseTemplateRef) {
            this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context);
          }
        }
      }
    }
    static ngTemplateContextGuard(dir, ctx) {
      return true;
    }
  };
  NgIf.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: NgIf, deps: [{ token: ViewContainerRef }, { token: TemplateRef }], target: FactoryTarget.Directive });
  NgIf.\u0275dir = \u0275\u0275ngDeclareDirective({ minVersion: "12.0.0", version: "13.0.3", type: NgIf, selector: "[ngIf]", inputs: { ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse" }, ngImport: core_exports });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: NgIf, decorators: [{
    type: Directive,
    args: [{ selector: "[ngIf]" }]
  }], ctorParameters: function() {
    return [{ type: ViewContainerRef }, { type: TemplateRef }];
  }, propDecorators: { ngIf: [{
    type: Input
  }], ngIfThen: [{
    type: Input
  }], ngIfElse: [{
    type: Input
  }] } });
  var NgIfContext = class {
    constructor() {
      this.$implicit = null;
      this.ngIf = null;
    }
  };
  function assertTemplate(property, templateRef) {
    const isTemplateRefOrNull = !!(!templateRef || templateRef.createEmbeddedView);
    if (!isTemplateRefOrNull) {
      throw new Error(`${property} must be a TemplateRef, but received '${stringify(templateRef)}'.`);
    }
  }
  var SwitchView = class {
    constructor(_viewContainerRef, _templateRef) {
      this._viewContainerRef = _viewContainerRef;
      this._templateRef = _templateRef;
      this._created = false;
    }
    create() {
      this._created = true;
      this._viewContainerRef.createEmbeddedView(this._templateRef);
    }
    destroy() {
      this._created = false;
      this._viewContainerRef.clear();
    }
    enforceState(created) {
      if (created && !this._created) {
        this.create();
      } else if (!created && this._created) {
        this.destroy();
      }
    }
  };
  var NgSwitch = class {
    constructor() {
      this._defaultUsed = false;
      this._caseCount = 0;
      this._lastCaseCheckIndex = 0;
      this._lastCasesMatched = false;
    }
    set ngSwitch(newValue) {
      this._ngSwitch = newValue;
      if (this._caseCount === 0) {
        this._updateDefaultCases(true);
      }
    }
    _addCase() {
      return this._caseCount++;
    }
    _addDefault(view) {
      if (!this._defaultViews) {
        this._defaultViews = [];
      }
      this._defaultViews.push(view);
    }
    _matchCase(value) {
      const matched = value == this._ngSwitch;
      this._lastCasesMatched = this._lastCasesMatched || matched;
      this._lastCaseCheckIndex++;
      if (this._lastCaseCheckIndex === this._caseCount) {
        this._updateDefaultCases(!this._lastCasesMatched);
        this._lastCaseCheckIndex = 0;
        this._lastCasesMatched = false;
      }
      return matched;
    }
    _updateDefaultCases(useDefault) {
      if (this._defaultViews && useDefault !== this._defaultUsed) {
        this._defaultUsed = useDefault;
        for (let i = 0; i < this._defaultViews.length; i++) {
          const defaultView = this._defaultViews[i];
          defaultView.enforceState(useDefault);
        }
      }
    }
  };
  NgSwitch.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: NgSwitch, deps: [], target: FactoryTarget.Directive });
  NgSwitch.\u0275dir = \u0275\u0275ngDeclareDirective({ minVersion: "12.0.0", version: "13.0.3", type: NgSwitch, selector: "[ngSwitch]", inputs: { ngSwitch: "ngSwitch" }, ngImport: core_exports });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: NgSwitch, decorators: [{
    type: Directive,
    args: [{ selector: "[ngSwitch]" }]
  }], propDecorators: { ngSwitch: [{
    type: Input
  }] } });
  var NgSwitchCase = class {
    constructor(viewContainer, templateRef, ngSwitch) {
      this.ngSwitch = ngSwitch;
      if ((typeof ngDevMode === "undefined" || ngDevMode) && !ngSwitch) {
        throwNgSwitchProviderNotFoundError("ngSwitchCase", "NgSwitchCase");
      }
      ngSwitch._addCase();
      this._view = new SwitchView(viewContainer, templateRef);
    }
    ngDoCheck() {
      this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase));
    }
  };
  NgSwitchCase.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: NgSwitchCase, deps: [{ token: ViewContainerRef }, { token: TemplateRef }, { token: NgSwitch, host: true, optional: true }], target: FactoryTarget.Directive });
  NgSwitchCase.\u0275dir = \u0275\u0275ngDeclareDirective({ minVersion: "12.0.0", version: "13.0.3", type: NgSwitchCase, selector: "[ngSwitchCase]", inputs: { ngSwitchCase: "ngSwitchCase" }, ngImport: core_exports });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: NgSwitchCase, decorators: [{
    type: Directive,
    args: [{ selector: "[ngSwitchCase]" }]
  }], ctorParameters: function() {
    return [{ type: ViewContainerRef }, { type: TemplateRef }, { type: NgSwitch, decorators: [{
      type: Optional
    }, {
      type: Host
    }] }];
  }, propDecorators: { ngSwitchCase: [{
    type: Input
  }] } });
  var NgSwitchDefault = class {
    constructor(viewContainer, templateRef, ngSwitch) {
      if ((typeof ngDevMode === "undefined" || ngDevMode) && !ngSwitch) {
        throwNgSwitchProviderNotFoundError("ngSwitchDefault", "NgSwitchDefault");
      }
      ngSwitch._addDefault(new SwitchView(viewContainer, templateRef));
    }
  };
  NgSwitchDefault.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: NgSwitchDefault, deps: [{ token: ViewContainerRef }, { token: TemplateRef }, { token: NgSwitch, host: true, optional: true }], target: FactoryTarget.Directive });
  NgSwitchDefault.\u0275dir = \u0275\u0275ngDeclareDirective({ minVersion: "12.0.0", version: "13.0.3", type: NgSwitchDefault, selector: "[ngSwitchDefault]", ngImport: core_exports });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: NgSwitchDefault, decorators: [{
    type: Directive,
    args: [{ selector: "[ngSwitchDefault]" }]
  }], ctorParameters: function() {
    return [{ type: ViewContainerRef }, { type: TemplateRef }, { type: NgSwitch, decorators: [{
      type: Optional
    }, {
      type: Host
    }] }];
  } });
  function throwNgSwitchProviderNotFoundError(attrName, directiveName) {
    throw new RuntimeError("305", `An element with the "${attrName}" attribute (matching the "${directiveName}" directive) must be located inside an element with the "ngSwitch" attribute (matching "NgSwitch" directive)`);
  }
  var NgPlural = class {
    constructor(_localization) {
      this._localization = _localization;
      this._caseViews = {};
    }
    set ngPlural(value) {
      this._switchValue = value;
      this._updateView();
    }
    addCase(value, switchView) {
      this._caseViews[value] = switchView;
    }
    _updateView() {
      this._clearViews();
      const cases = Object.keys(this._caseViews);
      const key = getPluralCategory(this._switchValue, cases, this._localization);
      this._activateView(this._caseViews[key]);
    }
    _clearViews() {
      if (this._activeView)
        this._activeView.destroy();
    }
    _activateView(view) {
      if (view) {
        this._activeView = view;
        this._activeView.create();
      }
    }
  };
  NgPlural.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: NgPlural, deps: [{ token: NgLocalization }], target: FactoryTarget.Directive });
  NgPlural.\u0275dir = \u0275\u0275ngDeclareDirective({ minVersion: "12.0.0", version: "13.0.3", type: NgPlural, selector: "[ngPlural]", inputs: { ngPlural: "ngPlural" }, ngImport: core_exports });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: NgPlural, decorators: [{
    type: Directive,
    args: [{ selector: "[ngPlural]" }]
  }], ctorParameters: function() {
    return [{ type: NgLocalization }];
  }, propDecorators: { ngPlural: [{
    type: Input
  }] } });
  var NgPluralCase = class {
    constructor(value, template, viewContainer, ngPlural) {
      this.value = value;
      const isANumber = !isNaN(Number(value));
      ngPlural.addCase(isANumber ? `=${value}` : value, new SwitchView(viewContainer, template));
    }
  };
  NgPluralCase.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: NgPluralCase, deps: [{ token: "ngPluralCase", attribute: true }, { token: TemplateRef }, { token: ViewContainerRef }, { token: NgPlural, host: true }], target: FactoryTarget.Directive });
  NgPluralCase.\u0275dir = \u0275\u0275ngDeclareDirective({ minVersion: "12.0.0", version: "13.0.3", type: NgPluralCase, selector: "[ngPluralCase]", ngImport: core_exports });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: NgPluralCase, decorators: [{
    type: Directive,
    args: [{ selector: "[ngPluralCase]" }]
  }], ctorParameters: function() {
    return [{ type: void 0, decorators: [{
      type: Attribute,
      args: ["ngPluralCase"]
    }] }, { type: TemplateRef }, { type: ViewContainerRef }, { type: NgPlural, decorators: [{
      type: Host
    }] }];
  } });
  var NgStyle = class {
    constructor(_ngEl, _differs, _renderer) {
      this._ngEl = _ngEl;
      this._differs = _differs;
      this._renderer = _renderer;
      this._ngStyle = null;
      this._differ = null;
    }
    set ngStyle(values) {
      this._ngStyle = values;
      if (!this._differ && values) {
        this._differ = this._differs.find(values).create();
      }
    }
    ngDoCheck() {
      if (this._differ) {
        const changes = this._differ.diff(this._ngStyle);
        if (changes) {
          this._applyChanges(changes);
        }
      }
    }
    _setStyle(nameAndUnit, value) {
      const [name, unit] = nameAndUnit.split(".");
      value = value != null && unit ? `${value}${unit}` : value;
      if (value != null) {
        this._renderer.setStyle(this._ngEl.nativeElement, name, value);
      } else {
        this._renderer.removeStyle(this._ngEl.nativeElement, name);
      }
    }
    _applyChanges(changes) {
      changes.forEachRemovedItem((record) => this._setStyle(record.key, null));
      changes.forEachAddedItem((record) => this._setStyle(record.key, record.currentValue));
      changes.forEachChangedItem((record) => this._setStyle(record.key, record.currentValue));
    }
  };
  NgStyle.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: NgStyle, deps: [{ token: ElementRef }, { token: KeyValueDiffers }, { token: Renderer2 }], target: FactoryTarget.Directive });
  NgStyle.\u0275dir = \u0275\u0275ngDeclareDirective({ minVersion: "12.0.0", version: "13.0.3", type: NgStyle, selector: "[ngStyle]", inputs: { ngStyle: "ngStyle" }, ngImport: core_exports });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: NgStyle, decorators: [{
    type: Directive,
    args: [{ selector: "[ngStyle]" }]
  }], ctorParameters: function() {
    return [{ type: ElementRef }, { type: KeyValueDiffers }, { type: Renderer2 }];
  }, propDecorators: { ngStyle: [{
    type: Input,
    args: ["ngStyle"]
  }] } });
  var NgTemplateOutlet = class {
    constructor(_viewContainerRef) {
      this._viewContainerRef = _viewContainerRef;
      this._viewRef = null;
      this.ngTemplateOutletContext = null;
      this.ngTemplateOutlet = null;
    }
    ngOnChanges(changes) {
      if (changes["ngTemplateOutlet"]) {
        const viewContainerRef = this._viewContainerRef;
        if (this._viewRef) {
          viewContainerRef.remove(viewContainerRef.indexOf(this._viewRef));
        }
        this._viewRef = this.ngTemplateOutlet ? viewContainerRef.createEmbeddedView(this.ngTemplateOutlet, this.ngTemplateOutletContext) : null;
      } else if (this._viewRef && changes["ngTemplateOutletContext"] && this.ngTemplateOutletContext) {
        this._viewRef.context = this.ngTemplateOutletContext;
      }
    }
  };
  NgTemplateOutlet.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: NgTemplateOutlet, deps: [{ token: ViewContainerRef }], target: FactoryTarget.Directive });
  NgTemplateOutlet.\u0275dir = \u0275\u0275ngDeclareDirective({ minVersion: "12.0.0", version: "13.0.3", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: { ngTemplateOutletContext: "ngTemplateOutletContext", ngTemplateOutlet: "ngTemplateOutlet" }, usesOnChanges: true, ngImport: core_exports });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: NgTemplateOutlet, decorators: [{
    type: Directive,
    args: [{ selector: "[ngTemplateOutlet]" }]
  }], ctorParameters: function() {
    return [{ type: ViewContainerRef }];
  }, propDecorators: { ngTemplateOutletContext: [{
    type: Input
  }], ngTemplateOutlet: [{
    type: Input
  }] } });
  var COMMON_DIRECTIVES = [
    NgClass,
    NgComponentOutlet,
    NgForOf,
    NgIf,
    NgTemplateOutlet,
    NgStyle,
    NgSwitch,
    NgSwitchCase,
    NgSwitchDefault,
    NgPlural,
    NgPluralCase
  ];
  function invalidPipeArgumentError(type, value) {
    return Error(`InvalidPipeArgument: '${value}' for pipe '${stringify(type)}'`);
  }
  var SubscribableStrategy = class {
    createSubscription(async, updateLatestValue) {
      return async.subscribe({
        next: updateLatestValue,
        error: (e) => {
          throw e;
        }
      });
    }
    dispose(subscription) {
      subscription.unsubscribe();
    }
    onDestroy(subscription) {
      subscription.unsubscribe();
    }
  };
  var PromiseStrategy = class {
    createSubscription(async, updateLatestValue) {
      return async.then(updateLatestValue, (e) => {
        throw e;
      });
    }
    dispose(subscription) {
    }
    onDestroy(subscription) {
    }
  };
  var _promiseStrategy = new PromiseStrategy();
  var _subscribableStrategy = new SubscribableStrategy();
  var AsyncPipe = class {
    constructor(_ref) {
      this._ref = _ref;
      this._latestValue = null;
      this._subscription = null;
      this._obj = null;
      this._strategy = null;
    }
    ngOnDestroy() {
      if (this._subscription) {
        this._dispose();
      }
    }
    transform(obj) {
      if (!this._obj) {
        if (obj) {
          this._subscribe(obj);
        }
        return this._latestValue;
      }
      if (obj !== this._obj) {
        this._dispose();
        return this.transform(obj);
      }
      return this._latestValue;
    }
    _subscribe(obj) {
      this._obj = obj;
      this._strategy = this._selectStrategy(obj);
      this._subscription = this._strategy.createSubscription(obj, (value) => this._updateLatestValue(obj, value));
    }
    _selectStrategy(obj) {
      if (isPromise2(obj)) {
        return _promiseStrategy;
      }
      if (isSubscribable(obj)) {
        return _subscribableStrategy;
      }
      throw invalidPipeArgumentError(AsyncPipe, obj);
    }
    _dispose() {
      this._strategy.dispose(this._subscription);
      this._latestValue = null;
      this._subscription = null;
      this._obj = null;
    }
    _updateLatestValue(async, value) {
      if (async === this._obj) {
        this._latestValue = value;
        this._ref.markForCheck();
      }
    }
  };
  AsyncPipe.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: AsyncPipe, deps: [{ token: ChangeDetectorRef }], target: FactoryTarget.Pipe });
  AsyncPipe.\u0275pipe = \u0275\u0275ngDeclarePipe({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: AsyncPipe, name: "async", pure: false });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: AsyncPipe, decorators: [{
    type: Pipe,
    args: [{ name: "async", pure: false }]
  }], ctorParameters: function() {
    return [{ type: ChangeDetectorRef }];
  } });
  var LowerCasePipe = class {
    transform(value) {
      if (value == null)
        return null;
      if (typeof value !== "string") {
        throw invalidPipeArgumentError(LowerCasePipe, value);
      }
      return value.toLowerCase();
    }
  };
  LowerCasePipe.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: LowerCasePipe, deps: [], target: FactoryTarget.Pipe });
  LowerCasePipe.\u0275pipe = \u0275\u0275ngDeclarePipe({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: LowerCasePipe, name: "lowercase" });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: LowerCasePipe, decorators: [{
    type: Pipe,
    args: [{ name: "lowercase" }]
  }] });
  var unicodeWordMatch = /(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])\S*/g;
  var TitleCasePipe = class {
    transform(value) {
      if (value == null)
        return null;
      if (typeof value !== "string") {
        throw invalidPipeArgumentError(TitleCasePipe, value);
      }
      return value.replace(unicodeWordMatch, (txt) => txt[0].toUpperCase() + txt.substr(1).toLowerCase());
    }
  };
  TitleCasePipe.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: TitleCasePipe, deps: [], target: FactoryTarget.Pipe });
  TitleCasePipe.\u0275pipe = \u0275\u0275ngDeclarePipe({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: TitleCasePipe, name: "titlecase" });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: TitleCasePipe, decorators: [{
    type: Pipe,
    args: [{ name: "titlecase" }]
  }] });
  var UpperCasePipe = class {
    transform(value) {
      if (value == null)
        return null;
      if (typeof value !== "string") {
        throw invalidPipeArgumentError(UpperCasePipe, value);
      }
      return value.toUpperCase();
    }
  };
  UpperCasePipe.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: UpperCasePipe, deps: [], target: FactoryTarget.Pipe });
  UpperCasePipe.\u0275pipe = \u0275\u0275ngDeclarePipe({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: UpperCasePipe, name: "uppercase" });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: UpperCasePipe, decorators: [{
    type: Pipe,
    args: [{ name: "uppercase" }]
  }] });
  var DATE_PIPE_DEFAULT_TIMEZONE = new InjectionToken("DATE_PIPE_DEFAULT_TIMEZONE");
  var DatePipe = class {
    constructor(locale, defaultTimezone) {
      this.locale = locale;
      this.defaultTimezone = defaultTimezone;
    }
    transform(value, format = "mediumDate", timezone, locale) {
      if (value == null || value === "" || value !== value)
        return null;
      try {
        return formatDate(value, format, locale || this.locale, timezone ?? this.defaultTimezone ?? void 0);
      } catch (error3) {
        throw invalidPipeArgumentError(DatePipe, error3.message);
      }
    }
  };
  DatePipe.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: DatePipe, deps: [{ token: LOCALE_ID }, { token: DATE_PIPE_DEFAULT_TIMEZONE, optional: true }], target: FactoryTarget.Pipe });
  DatePipe.\u0275pipe = \u0275\u0275ngDeclarePipe({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: DatePipe, name: "date" });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: DatePipe, decorators: [{
    type: Pipe,
    args: [{ name: "date", pure: true }]
  }], ctorParameters: function() {
    return [{ type: void 0, decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }] }, { type: void 0, decorators: [{
      type: Inject,
      args: [DATE_PIPE_DEFAULT_TIMEZONE]
    }, {
      type: Optional
    }] }];
  } });
  var _INTERPOLATION_REGEXP = /#/g;
  var I18nPluralPipe = class {
    constructor(_localization) {
      this._localization = _localization;
    }
    transform(value, pluralMap, locale) {
      if (value == null)
        return "";
      if (typeof pluralMap !== "object" || pluralMap === null) {
        throw invalidPipeArgumentError(I18nPluralPipe, pluralMap);
      }
      const key = getPluralCategory(value, Object.keys(pluralMap), this._localization, locale);
      return pluralMap[key].replace(_INTERPOLATION_REGEXP, value.toString());
    }
  };
  I18nPluralPipe.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: I18nPluralPipe, deps: [{ token: NgLocalization }], target: FactoryTarget.Pipe });
  I18nPluralPipe.\u0275pipe = \u0275\u0275ngDeclarePipe({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: I18nPluralPipe, name: "i18nPlural" });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: I18nPluralPipe, decorators: [{
    type: Pipe,
    args: [{ name: "i18nPlural", pure: true }]
  }], ctorParameters: function() {
    return [{ type: NgLocalization }];
  } });
  var I18nSelectPipe = class {
    transform(value, mapping) {
      if (value == null)
        return "";
      if (typeof mapping !== "object" || typeof value !== "string") {
        throw invalidPipeArgumentError(I18nSelectPipe, mapping);
      }
      if (mapping.hasOwnProperty(value)) {
        return mapping[value];
      }
      if (mapping.hasOwnProperty("other")) {
        return mapping["other"];
      }
      return "";
    }
  };
  I18nSelectPipe.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: I18nSelectPipe, deps: [], target: FactoryTarget.Pipe });
  I18nSelectPipe.\u0275pipe = \u0275\u0275ngDeclarePipe({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: I18nSelectPipe, name: "i18nSelect" });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: I18nSelectPipe, decorators: [{
    type: Pipe,
    args: [{ name: "i18nSelect", pure: true }]
  }] });
  var JsonPipe = class {
    transform(value) {
      return JSON.stringify(value, null, 2);
    }
  };
  JsonPipe.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: JsonPipe, deps: [], target: FactoryTarget.Pipe });
  JsonPipe.\u0275pipe = \u0275\u0275ngDeclarePipe({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: JsonPipe, name: "json", pure: false });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: JsonPipe, decorators: [{
    type: Pipe,
    args: [{ name: "json", pure: false }]
  }] });
  function makeKeyValuePair(key, value) {
    return { key, value };
  }
  var KeyValuePipe = class {
    constructor(differs) {
      this.differs = differs;
      this.keyValues = [];
      this.compareFn = defaultComparator;
    }
    transform(input, compareFn = defaultComparator) {
      if (!input || !(input instanceof Map) && typeof input !== "object") {
        return null;
      }
      if (!this.differ) {
        this.differ = this.differs.find(input).create();
      }
      const differChanges = this.differ.diff(input);
      const compareFnChanged = compareFn !== this.compareFn;
      if (differChanges) {
        this.keyValues = [];
        differChanges.forEachItem((r) => {
          this.keyValues.push(makeKeyValuePair(r.key, r.currentValue));
        });
      }
      if (differChanges || compareFnChanged) {
        this.keyValues.sort(compareFn);
        this.compareFn = compareFn;
      }
      return this.keyValues;
    }
  };
  KeyValuePipe.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: KeyValuePipe, deps: [{ token: KeyValueDiffers }], target: FactoryTarget.Pipe });
  KeyValuePipe.\u0275pipe = \u0275\u0275ngDeclarePipe({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: KeyValuePipe, name: "keyvalue", pure: false });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: KeyValuePipe, decorators: [{
    type: Pipe,
    args: [{ name: "keyvalue", pure: false }]
  }], ctorParameters: function() {
    return [{ type: KeyValueDiffers }];
  } });
  function defaultComparator(keyValueA, keyValueB) {
    const a = keyValueA.key;
    const b = keyValueB.key;
    if (a === b)
      return 0;
    if (a === void 0)
      return 1;
    if (b === void 0)
      return -1;
    if (a === null)
      return 1;
    if (b === null)
      return -1;
    if (typeof a == "string" && typeof b == "string") {
      return a < b ? -1 : 1;
    }
    if (typeof a == "number" && typeof b == "number") {
      return a - b;
    }
    if (typeof a == "boolean" && typeof b == "boolean") {
      return a < b ? -1 : 1;
    }
    const aString = String(a);
    const bString = String(b);
    return aString == bString ? 0 : aString < bString ? -1 : 1;
  }
  var DecimalPipe = class {
    constructor(_locale) {
      this._locale = _locale;
    }
    transform(value, digitsInfo, locale) {
      if (!isValue(value))
        return null;
      locale = locale || this._locale;
      try {
        const num = strToNumber(value);
        return formatNumber(num, locale, digitsInfo);
      } catch (error3) {
        throw invalidPipeArgumentError(DecimalPipe, error3.message);
      }
    }
  };
  DecimalPipe.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: DecimalPipe, deps: [{ token: LOCALE_ID }], target: FactoryTarget.Pipe });
  DecimalPipe.\u0275pipe = \u0275\u0275ngDeclarePipe({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: DecimalPipe, name: "number" });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: DecimalPipe, decorators: [{
    type: Pipe,
    args: [{ name: "number" }]
  }], ctorParameters: function() {
    return [{ type: void 0, decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }] }];
  } });
  var PercentPipe = class {
    constructor(_locale) {
      this._locale = _locale;
    }
    transform(value, digitsInfo, locale) {
      if (!isValue(value))
        return null;
      locale = locale || this._locale;
      try {
        const num = strToNumber(value);
        return formatPercent(num, locale, digitsInfo);
      } catch (error3) {
        throw invalidPipeArgumentError(PercentPipe, error3.message);
      }
    }
  };
  PercentPipe.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: PercentPipe, deps: [{ token: LOCALE_ID }], target: FactoryTarget.Pipe });
  PercentPipe.\u0275pipe = \u0275\u0275ngDeclarePipe({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: PercentPipe, name: "percent" });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: PercentPipe, decorators: [{
    type: Pipe,
    args: [{ name: "percent" }]
  }], ctorParameters: function() {
    return [{ type: void 0, decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }] }];
  } });
  var CurrencyPipe = class {
    constructor(_locale, _defaultCurrencyCode = "USD") {
      this._locale = _locale;
      this._defaultCurrencyCode = _defaultCurrencyCode;
    }
    transform(value, currencyCode = this._defaultCurrencyCode, display = "symbol", digitsInfo, locale) {
      if (!isValue(value))
        return null;
      locale = locale || this._locale;
      if (typeof display === "boolean") {
        if ((typeof ngDevMode === "undefined" || ngDevMode) && console && console.warn) {
          console.warn(`Warning: the currency pipe has been changed in Angular v5. The symbolDisplay option (third parameter) is now a string instead of a boolean. The accepted values are "code", "symbol" or "symbol-narrow".`);
        }
        display = display ? "symbol" : "code";
      }
      let currency = currencyCode || this._defaultCurrencyCode;
      if (display !== "code") {
        if (display === "symbol" || display === "symbol-narrow") {
          currency = getCurrencySymbol(currency, display === "symbol" ? "wide" : "narrow", locale);
        } else {
          currency = display;
        }
      }
      try {
        const num = strToNumber(value);
        return formatCurrency(num, locale, currency, currencyCode, digitsInfo);
      } catch (error3) {
        throw invalidPipeArgumentError(CurrencyPipe, error3.message);
      }
    }
  };
  CurrencyPipe.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: CurrencyPipe, deps: [{ token: LOCALE_ID }, { token: DEFAULT_CURRENCY_CODE }], target: FactoryTarget.Pipe });
  CurrencyPipe.\u0275pipe = \u0275\u0275ngDeclarePipe({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: CurrencyPipe, name: "currency" });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: CurrencyPipe, decorators: [{
    type: Pipe,
    args: [{ name: "currency" }]
  }], ctorParameters: function() {
    return [{ type: void 0, decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }] }, { type: void 0, decorators: [{
      type: Inject,
      args: [DEFAULT_CURRENCY_CODE]
    }] }];
  } });
  function isValue(value) {
    return !(value == null || value === "" || value !== value);
  }
  function strToNumber(value) {
    if (typeof value === "string" && !isNaN(Number(value) - parseFloat(value))) {
      return Number(value);
    }
    if (typeof value !== "number") {
      throw new Error(`${value} is not a number`);
    }
    return value;
  }
  var SlicePipe = class {
    transform(value, start, end) {
      if (value == null)
        return null;
      if (!this.supports(value)) {
        throw invalidPipeArgumentError(SlicePipe, value);
      }
      return value.slice(start, end);
    }
    supports(obj) {
      return typeof obj === "string" || Array.isArray(obj);
    }
  };
  SlicePipe.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: SlicePipe, deps: [], target: FactoryTarget.Pipe });
  SlicePipe.\u0275pipe = \u0275\u0275ngDeclarePipe({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: SlicePipe, name: "slice", pure: false });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: SlicePipe, decorators: [{
    type: Pipe,
    args: [{ name: "slice", pure: false }]
  }] });
  var COMMON_PIPES = [
    AsyncPipe,
    UpperCasePipe,
    LowerCasePipe,
    JsonPipe,
    SlicePipe,
    DecimalPipe,
    PercentPipe,
    TitleCasePipe,
    CurrencyPipe,
    DatePipe,
    I18nPluralPipe,
    I18nSelectPipe,
    KeyValuePipe
  ];
  var CommonModule = class {
  };
  CommonModule.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: CommonModule, deps: [], target: FactoryTarget.NgModule });
  CommonModule.\u0275mod = \u0275\u0275ngDeclareNgModule({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: CommonModule, declarations: [NgClass, NgComponentOutlet, NgForOf, NgIf, NgTemplateOutlet, NgStyle, NgSwitch, NgSwitchCase, NgSwitchDefault, NgPlural, NgPluralCase, AsyncPipe, UpperCasePipe, LowerCasePipe, JsonPipe, SlicePipe, DecimalPipe, PercentPipe, TitleCasePipe, CurrencyPipe, DatePipe, I18nPluralPipe, I18nSelectPipe, KeyValuePipe], exports: [NgClass, NgComponentOutlet, NgForOf, NgIf, NgTemplateOutlet, NgStyle, NgSwitch, NgSwitchCase, NgSwitchDefault, NgPlural, NgPluralCase, AsyncPipe, UpperCasePipe, LowerCasePipe, JsonPipe, SlicePipe, DecimalPipe, PercentPipe, TitleCasePipe, CurrencyPipe, DatePipe, I18nPluralPipe, I18nSelectPipe, KeyValuePipe] });
  CommonModule.\u0275inj = \u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: CommonModule, providers: [
    { provide: NgLocalization, useClass: NgLocaleLocalization }
  ] });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: CommonModule, decorators: [{
    type: NgModule,
    args: [{
      declarations: [COMMON_DIRECTIVES, COMMON_PIPES],
      exports: [COMMON_DIRECTIVES, COMMON_PIPES],
      providers: [
        { provide: NgLocalization, useClass: NgLocaleLocalization }
      ]
    }]
  }] });
  var PLATFORM_BROWSER_ID = "browser";
  var VERSION3 = new Version("13.0.3");
  var ViewportScroller = class {
  };
  ViewportScroller.\u0275prov = \u0275\u0275defineInjectable({
    token: ViewportScroller,
    providedIn: "root",
    factory: () => new BrowserViewportScroller(\u0275\u0275inject(DOCUMENT2), window)
  });
  var BrowserViewportScroller = class {
    constructor(document2, window2) {
      this.document = document2;
      this.window = window2;
      this.offset = () => [0, 0];
    }
    setOffset(offset) {
      if (Array.isArray(offset)) {
        this.offset = () => offset;
      } else {
        this.offset = offset;
      }
    }
    getScrollPosition() {
      if (this.supportsScrolling()) {
        return [this.window.pageXOffset, this.window.pageYOffset];
      } else {
        return [0, 0];
      }
    }
    scrollToPosition(position) {
      if (this.supportsScrolling()) {
        this.window.scrollTo(position[0], position[1]);
      }
    }
    scrollToAnchor(target) {
      if (!this.supportsScrolling()) {
        return;
      }
      const elSelected = findAnchorFromDocument(this.document, target);
      if (elSelected) {
        this.scrollToElement(elSelected);
        this.attemptFocus(elSelected);
      }
    }
    setHistoryScrollRestoration(scrollRestoration) {
      if (this.supportScrollRestoration()) {
        const history = this.window.history;
        if (history && history.scrollRestoration) {
          history.scrollRestoration = scrollRestoration;
        }
      }
    }
    scrollToElement(el) {
      const rect = el.getBoundingClientRect();
      const left = rect.left + this.window.pageXOffset;
      const top = rect.top + this.window.pageYOffset;
      const offset = this.offset();
      this.window.scrollTo(left - offset[0], top - offset[1]);
    }
    attemptFocus(focusTarget) {
      focusTarget.focus();
      return this.document.activeElement === focusTarget;
    }
    supportScrollRestoration() {
      try {
        if (!this.supportsScrolling()) {
          return false;
        }
        const scrollRestorationDescriptor = getScrollRestorationProperty(this.window.history) || getScrollRestorationProperty(Object.getPrototypeOf(this.window.history));
        return !!scrollRestorationDescriptor && !!(scrollRestorationDescriptor.writable || scrollRestorationDescriptor.set);
      } catch {
        return false;
      }
    }
    supportsScrolling() {
      try {
        return !!this.window && !!this.window.scrollTo && "pageXOffset" in this.window;
      } catch {
        return false;
      }
    }
  };
  function getScrollRestorationProperty(obj) {
    return Object.getOwnPropertyDescriptor(obj, "scrollRestoration");
  }
  function findAnchorFromDocument(document2, target) {
    const documentResult = document2.getElementById(target) || document2.getElementsByName(target)[0];
    if (documentResult) {
      return documentResult;
    }
    if (typeof document2.createTreeWalker === "function" && document2.body && (document2.body.createShadowRoot || document2.body.attachShadow)) {
      const treeWalker = document2.createTreeWalker(document2.body, NodeFilter.SHOW_ELEMENT);
      let currentNode = treeWalker.currentNode;
      while (currentNode) {
        const shadowRoot = currentNode.shadowRoot;
        if (shadowRoot) {
          const result = shadowRoot.getElementById(target) || shadowRoot.querySelector(`[name="${target}"]`);
          if (result) {
            return result;
          }
        }
        currentNode = treeWalker.nextNode();
      }
    }
    return null;
  }
  var XhrFactory = class {
  };

  // node_modules/@angular/platform-browser/fesm2020/platform-browser.mjs
  var GenericBrowserDomAdapter = class extends DomAdapter {
    constructor() {
      super(...arguments);
      this.supportsDOMEvents = true;
    }
  };
  var BrowserDomAdapter = class extends GenericBrowserDomAdapter {
    static makeCurrent() {
      setRootDomAdapter(new BrowserDomAdapter());
    }
    onAndCancel(el, evt, listener) {
      el.addEventListener(evt, listener, false);
      return () => {
        el.removeEventListener(evt, listener, false);
      };
    }
    dispatchEvent(el, evt) {
      el.dispatchEvent(evt);
    }
    remove(node) {
      if (node.parentNode) {
        node.parentNode.removeChild(node);
      }
    }
    createElement(tagName, doc) {
      doc = doc || this.getDefaultDocument();
      return doc.createElement(tagName);
    }
    createHtmlDocument() {
      return document.implementation.createHTMLDocument("fakeTitle");
    }
    getDefaultDocument() {
      return document;
    }
    isElementNode(node) {
      return node.nodeType === Node.ELEMENT_NODE;
    }
    isShadowRoot(node) {
      return node instanceof DocumentFragment;
    }
    getGlobalEventTarget(doc, target) {
      if (target === "window") {
        return window;
      }
      if (target === "document") {
        return doc;
      }
      if (target === "body") {
        return doc.body;
      }
      return null;
    }
    getBaseHref(doc) {
      const href = getBaseElementHref();
      return href == null ? null : relativePath(href);
    }
    resetBaseElement() {
      baseElement = null;
    }
    getUserAgent() {
      return window.navigator.userAgent;
    }
    getCookie(name) {
      return parseCookieValue(document.cookie, name);
    }
  };
  var baseElement = null;
  function getBaseElementHref() {
    baseElement = baseElement || document.querySelector("base");
    return baseElement ? baseElement.getAttribute("href") : null;
  }
  var urlParsingNode;
  function relativePath(url) {
    urlParsingNode = urlParsingNode || document.createElement("a");
    urlParsingNode.setAttribute("href", url);
    const pathName = urlParsingNode.pathname;
    return pathName.charAt(0) === "/" ? pathName : `/${pathName}`;
  }
  var TRANSITION_ID = new InjectionToken("TRANSITION_ID");
  function appInitializerFactory(transitionId, document2, injector) {
    return () => {
      injector.get(ApplicationInitStatus).donePromise.then(() => {
        const dom = getDOM();
        const styles = document2.querySelectorAll(`style[ng-transition="${transitionId}"]`);
        for (let i = 0; i < styles.length; i++) {
          dom.remove(styles[i]);
        }
      });
    };
  }
  var SERVER_TRANSITION_PROVIDERS = [
    {
      provide: APP_INITIALIZER,
      useFactory: appInitializerFactory,
      deps: [TRANSITION_ID, DOCUMENT2, Injector],
      multi: true
    }
  ];
  var BrowserGetTestability = class {
    static init() {
      setTestabilityGetter(new BrowserGetTestability());
    }
    addToWindow(registry) {
      _global2["getAngularTestability"] = (elem, findInAncestors = true) => {
        const testability = registry.findTestabilityInTree(elem, findInAncestors);
        if (testability == null) {
          throw new Error("Could not find testability for element.");
        }
        return testability;
      };
      _global2["getAllAngularTestabilities"] = () => registry.getAllTestabilities();
      _global2["getAllAngularRootElements"] = () => registry.getAllRootElements();
      const whenAllStable = (callback) => {
        const testabilities = _global2["getAllAngularTestabilities"]();
        let count = testabilities.length;
        let didWork = false;
        const decrement = function(didWork_) {
          didWork = didWork || didWork_;
          count--;
          if (count == 0) {
            callback(didWork);
          }
        };
        testabilities.forEach(function(testability) {
          testability.whenStable(decrement);
        });
      };
      if (!_global2["frameworkStabilizers"]) {
        _global2["frameworkStabilizers"] = [];
      }
      _global2["frameworkStabilizers"].push(whenAllStable);
    }
    findTestabilityInTree(registry, elem, findInAncestors) {
      if (elem == null) {
        return null;
      }
      const t = registry.getTestability(elem);
      if (t != null) {
        return t;
      } else if (!findInAncestors) {
        return null;
      }
      if (getDOM().isShadowRoot(elem)) {
        return this.findTestabilityInTree(registry, elem.host, true);
      }
      return this.findTestabilityInTree(registry, elem.parentElement, true);
    }
  };
  var BrowserXhr = class {
    build() {
      return new XMLHttpRequest();
    }
  };
  BrowserXhr.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: BrowserXhr, deps: [], target: FactoryTarget.Injectable });
  BrowserXhr.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: BrowserXhr });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: BrowserXhr, decorators: [{
    type: Injectable
  }] });
  var EVENT_MANAGER_PLUGINS = new InjectionToken("EventManagerPlugins");
  var EventManager = class {
    constructor(plugins, _zone) {
      this._zone = _zone;
      this._eventNameToPlugin = /* @__PURE__ */ new Map();
      plugins.forEach((p) => p.manager = this);
      this._plugins = plugins.slice().reverse();
    }
    addEventListener(element, eventName, handler) {
      const plugin = this._findPluginFor(eventName);
      return plugin.addEventListener(element, eventName, handler);
    }
    addGlobalEventListener(target, eventName, handler) {
      const plugin = this._findPluginFor(eventName);
      return plugin.addGlobalEventListener(target, eventName, handler);
    }
    getZone() {
      return this._zone;
    }
    _findPluginFor(eventName) {
      const plugin = this._eventNameToPlugin.get(eventName);
      if (plugin) {
        return plugin;
      }
      const plugins = this._plugins;
      for (let i = 0; i < plugins.length; i++) {
        const plugin2 = plugins[i];
        if (plugin2.supports(eventName)) {
          this._eventNameToPlugin.set(eventName, plugin2);
          return plugin2;
        }
      }
      throw new Error(`No event manager plugin found for event ${eventName}`);
    }
  };
  EventManager.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: EventManager, deps: [{ token: EVENT_MANAGER_PLUGINS }, { token: NgZone }], target: FactoryTarget.Injectable });
  EventManager.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: EventManager });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: EventManager, decorators: [{
    type: Injectable
  }], ctorParameters: function() {
    return [{ type: void 0, decorators: [{
      type: Inject,
      args: [EVENT_MANAGER_PLUGINS]
    }] }, { type: NgZone }];
  } });
  var EventManagerPlugin = class {
    constructor(_doc) {
      this._doc = _doc;
    }
    addGlobalEventListener(element, eventName, handler) {
      const target = getDOM().getGlobalEventTarget(this._doc, element);
      if (!target) {
        throw new Error(`Unsupported event target ${target} for event ${eventName}`);
      }
      return this.addEventListener(target, eventName, handler);
    }
  };
  var SharedStylesHost = class {
    constructor() {
      this._stylesSet = /* @__PURE__ */ new Set();
    }
    addStyles(styles) {
      const additions = /* @__PURE__ */ new Set();
      styles.forEach((style) => {
        if (!this._stylesSet.has(style)) {
          this._stylesSet.add(style);
          additions.add(style);
        }
      });
      this.onStylesAdded(additions);
    }
    onStylesAdded(additions) {
    }
    getAllStyles() {
      return Array.from(this._stylesSet);
    }
  };
  SharedStylesHost.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: SharedStylesHost, deps: [], target: FactoryTarget.Injectable });
  SharedStylesHost.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: SharedStylesHost });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: SharedStylesHost, decorators: [{
    type: Injectable
  }] });
  var DomSharedStylesHost = class extends SharedStylesHost {
    constructor(_doc) {
      super();
      this._doc = _doc;
      this._hostNodes = /* @__PURE__ */ new Map();
      this._hostNodes.set(_doc.head, []);
    }
    _addStylesToHost(styles, host, styleNodes) {
      styles.forEach((style) => {
        const styleEl = this._doc.createElement("style");
        styleEl.textContent = style;
        styleNodes.push(host.appendChild(styleEl));
      });
    }
    addHost(hostNode) {
      const styleNodes = [];
      this._addStylesToHost(this._stylesSet, hostNode, styleNodes);
      this._hostNodes.set(hostNode, styleNodes);
    }
    removeHost(hostNode) {
      const styleNodes = this._hostNodes.get(hostNode);
      if (styleNodes) {
        styleNodes.forEach(removeStyle);
      }
      this._hostNodes.delete(hostNode);
    }
    onStylesAdded(additions) {
      this._hostNodes.forEach((styleNodes, hostNode) => {
        this._addStylesToHost(additions, hostNode, styleNodes);
      });
    }
    ngOnDestroy() {
      this._hostNodes.forEach((styleNodes) => styleNodes.forEach(removeStyle));
    }
  };
  DomSharedStylesHost.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: DomSharedStylesHost, deps: [{ token: DOCUMENT2 }], target: FactoryTarget.Injectable });
  DomSharedStylesHost.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: DomSharedStylesHost });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: DomSharedStylesHost, decorators: [{
    type: Injectable
  }], ctorParameters: function() {
    return [{ type: void 0, decorators: [{
      type: Inject,
      args: [DOCUMENT2]
    }] }];
  } });
  function removeStyle(styleNode) {
    getDOM().remove(styleNode);
  }
  var NAMESPACE_URIS = {
    "svg": "http://www.w3.org/2000/svg",
    "xhtml": "http://www.w3.org/1999/xhtml",
    "xlink": "http://www.w3.org/1999/xlink",
    "xml": "http://www.w3.org/XML/1998/namespace",
    "xmlns": "http://www.w3.org/2000/xmlns/"
  };
  var COMPONENT_REGEX = /%COMP%/g;
  var NG_DEV_MODE = typeof ngDevMode === "undefined" || !!ngDevMode;
  var COMPONENT_VARIABLE2 = "%COMP%";
  var HOST_ATTR2 = `_nghost-${COMPONENT_VARIABLE2}`;
  var CONTENT_ATTR2 = `_ngcontent-${COMPONENT_VARIABLE2}`;
  function shimContentAttribute(componentShortId) {
    return CONTENT_ATTR2.replace(COMPONENT_REGEX, componentShortId);
  }
  function shimHostAttribute(componentShortId) {
    return HOST_ATTR2.replace(COMPONENT_REGEX, componentShortId);
  }
  function flattenStyles(compId, styles, target) {
    for (let i = 0; i < styles.length; i++) {
      let style = styles[i];
      if (Array.isArray(style)) {
        flattenStyles(compId, style, target);
      } else {
        style = style.replace(COMPONENT_REGEX, compId);
        target.push(style);
      }
    }
    return target;
  }
  function decoratePreventDefault(eventHandler) {
    return (event) => {
      if (event === "__ngUnwrap__") {
        return eventHandler;
      }
      const allowDefaultBehavior = eventHandler(event);
      if (allowDefaultBehavior === false) {
        event.preventDefault();
        event.returnValue = false;
      }
      return void 0;
    };
  }
  var hasLoggedNativeEncapsulationWarning = false;
  var DomRendererFactory2 = class {
    constructor(eventManager, sharedStylesHost, appId) {
      this.eventManager = eventManager;
      this.sharedStylesHost = sharedStylesHost;
      this.appId = appId;
      this.rendererByCompId = /* @__PURE__ */ new Map();
      this.defaultRenderer = new DefaultDomRenderer2(eventManager);
    }
    createRenderer(element, type) {
      if (!element || !type) {
        return this.defaultRenderer;
      }
      switch (type.encapsulation) {
        case ViewEncapsulation$1.Emulated: {
          let renderer = this.rendererByCompId.get(type.id);
          if (!renderer) {
            renderer = new EmulatedEncapsulationDomRenderer2(this.eventManager, this.sharedStylesHost, type, this.appId);
            this.rendererByCompId.set(type.id, renderer);
          }
          renderer.applyToHost(element);
          return renderer;
        }
        case 1:
        case ViewEncapsulation$1.ShadowDom:
          if ((typeof ngDevMode === "undefined" || ngDevMode) && !hasLoggedNativeEncapsulationWarning && type.encapsulation === 1) {
            hasLoggedNativeEncapsulationWarning = true;
            console.warn("ViewEncapsulation.Native is no longer supported. Falling back to ViewEncapsulation.ShadowDom. The fallback will be removed in v12.");
          }
          return new ShadowDomRenderer(this.eventManager, this.sharedStylesHost, element, type);
        default: {
          if (!this.rendererByCompId.has(type.id)) {
            const styles = flattenStyles(type.id, type.styles, []);
            this.sharedStylesHost.addStyles(styles);
            this.rendererByCompId.set(type.id, this.defaultRenderer);
          }
          return this.defaultRenderer;
        }
      }
    }
    begin() {
    }
    end() {
    }
  };
  DomRendererFactory2.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: DomRendererFactory2, deps: [{ token: EventManager }, { token: DomSharedStylesHost }, { token: APP_ID }], target: FactoryTarget.Injectable });
  DomRendererFactory2.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: DomRendererFactory2 });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: DomRendererFactory2, decorators: [{
    type: Injectable
  }], ctorParameters: function() {
    return [{ type: EventManager }, { type: DomSharedStylesHost }, { type: void 0, decorators: [{
      type: Inject,
      args: [APP_ID]
    }] }];
  } });
  var DefaultDomRenderer2 = class {
    constructor(eventManager) {
      this.eventManager = eventManager;
      this.data = /* @__PURE__ */ Object.create(null);
      this.destroyNode = null;
    }
    destroy() {
    }
    createElement(name, namespace) {
      if (namespace) {
        return document.createElementNS(NAMESPACE_URIS[namespace] || namespace, name);
      }
      return document.createElement(name);
    }
    createComment(value) {
      return document.createComment(value);
    }
    createText(value) {
      return document.createTextNode(value);
    }
    appendChild(parent, newChild) {
      parent.appendChild(newChild);
    }
    insertBefore(parent, newChild, refChild) {
      if (parent) {
        parent.insertBefore(newChild, refChild);
      }
    }
    removeChild(parent, oldChild) {
      if (parent) {
        parent.removeChild(oldChild);
      }
    }
    selectRootElement(selectorOrNode, preserveContent) {
      let el = typeof selectorOrNode === "string" ? document.querySelector(selectorOrNode) : selectorOrNode;
      if (!el) {
        throw new Error(`The selector "${selectorOrNode}" did not match any elements`);
      }
      if (!preserveContent) {
        el.textContent = "";
      }
      return el;
    }
    parentNode(node) {
      return node.parentNode;
    }
    nextSibling(node) {
      return node.nextSibling;
    }
    setAttribute(el, name, value, namespace) {
      if (namespace) {
        name = namespace + ":" + name;
        const namespaceUri = NAMESPACE_URIS[namespace];
        if (namespaceUri) {
          el.setAttributeNS(namespaceUri, name, value);
        } else {
          el.setAttribute(name, value);
        }
      } else {
        el.setAttribute(name, value);
      }
    }
    removeAttribute(el, name, namespace) {
      if (namespace) {
        const namespaceUri = NAMESPACE_URIS[namespace];
        if (namespaceUri) {
          el.removeAttributeNS(namespaceUri, name);
        } else {
          el.removeAttribute(`${namespace}:${name}`);
        }
      } else {
        el.removeAttribute(name);
      }
    }
    addClass(el, name) {
      el.classList.add(name);
    }
    removeClass(el, name) {
      el.classList.remove(name);
    }
    setStyle(el, style, value, flags) {
      if (flags & (RendererStyleFlags2.DashCase | RendererStyleFlags2.Important)) {
        el.style.setProperty(style, value, flags & RendererStyleFlags2.Important ? "important" : "");
      } else {
        el.style[style] = value;
      }
    }
    removeStyle(el, style, flags) {
      if (flags & RendererStyleFlags2.DashCase) {
        el.style.removeProperty(style);
      } else {
        el.style[style] = "";
      }
    }
    setProperty(el, name, value) {
      NG_DEV_MODE && checkNoSyntheticProp(name, "property");
      el[name] = value;
    }
    setValue(node, value) {
      node.nodeValue = value;
    }
    listen(target, event, callback) {
      NG_DEV_MODE && checkNoSyntheticProp(event, "listener");
      if (typeof target === "string") {
        return this.eventManager.addGlobalEventListener(target, event, decoratePreventDefault(callback));
      }
      return this.eventManager.addEventListener(target, event, decoratePreventDefault(callback));
    }
  };
  var AT_CHARCODE = (() => "@".charCodeAt(0))();
  function checkNoSyntheticProp(name, nameKind) {
    if (name.charCodeAt(0) === AT_CHARCODE) {
      throw new Error(`Unexpected synthetic ${nameKind} ${name} found. Please make sure that:
  - Either \`BrowserAnimationsModule\` or \`NoopAnimationsModule\` are imported in your application.
  - There is corresponding configuration for the animation named \`${name}\` defined in the \`animations\` field of the \`@Component\` decorator (see https://angular.io/api/core/Component#animations).`);
    }
  }
  var EmulatedEncapsulationDomRenderer2 = class extends DefaultDomRenderer2 {
    constructor(eventManager, sharedStylesHost, component, appId) {
      super(eventManager);
      this.component = component;
      const styles = flattenStyles(appId + "-" + component.id, component.styles, []);
      sharedStylesHost.addStyles(styles);
      this.contentAttr = shimContentAttribute(appId + "-" + component.id);
      this.hostAttr = shimHostAttribute(appId + "-" + component.id);
    }
    applyToHost(element) {
      super.setAttribute(element, this.hostAttr, "");
    }
    createElement(parent, name) {
      const el = super.createElement(parent, name);
      super.setAttribute(el, this.contentAttr, "");
      return el;
    }
  };
  var ShadowDomRenderer = class extends DefaultDomRenderer2 {
    constructor(eventManager, sharedStylesHost, hostEl, component) {
      super(eventManager);
      this.sharedStylesHost = sharedStylesHost;
      this.hostEl = hostEl;
      this.shadowRoot = hostEl.attachShadow({ mode: "open" });
      this.sharedStylesHost.addHost(this.shadowRoot);
      const styles = flattenStyles(component.id, component.styles, []);
      for (let i = 0; i < styles.length; i++) {
        const styleEl = document.createElement("style");
        styleEl.textContent = styles[i];
        this.shadowRoot.appendChild(styleEl);
      }
    }
    nodeOrShadowRoot(node) {
      return node === this.hostEl ? this.shadowRoot : node;
    }
    destroy() {
      this.sharedStylesHost.removeHost(this.shadowRoot);
    }
    appendChild(parent, newChild) {
      return super.appendChild(this.nodeOrShadowRoot(parent), newChild);
    }
    insertBefore(parent, newChild, refChild) {
      return super.insertBefore(this.nodeOrShadowRoot(parent), newChild, refChild);
    }
    removeChild(parent, oldChild) {
      return super.removeChild(this.nodeOrShadowRoot(parent), oldChild);
    }
    parentNode(node) {
      return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(node)));
    }
  };
  var DomEventsPlugin = class extends EventManagerPlugin {
    constructor(doc) {
      super(doc);
    }
    supports(eventName) {
      return true;
    }
    addEventListener(element, eventName, handler) {
      element.addEventListener(eventName, handler, false);
      return () => this.removeEventListener(element, eventName, handler);
    }
    removeEventListener(target, eventName, callback) {
      return target.removeEventListener(eventName, callback);
    }
  };
  DomEventsPlugin.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: DomEventsPlugin, deps: [{ token: DOCUMENT2 }], target: FactoryTarget.Injectable });
  DomEventsPlugin.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: DomEventsPlugin });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: DomEventsPlugin, decorators: [{
    type: Injectable
  }], ctorParameters: function() {
    return [{ type: void 0, decorators: [{
      type: Inject,
      args: [DOCUMENT2]
    }] }];
  } });
  var MODIFIER_KEYS = ["alt", "control", "meta", "shift"];
  var DOM_KEY_LOCATION_NUMPAD = 3;
  var _keyMap = {
    "\b": "Backspace",
    "	": "Tab",
    "\x7F": "Delete",
    "\x1B": "Escape",
    "Del": "Delete",
    "Esc": "Escape",
    "Left": "ArrowLeft",
    "Right": "ArrowRight",
    "Up": "ArrowUp",
    "Down": "ArrowDown",
    "Menu": "ContextMenu",
    "Scroll": "ScrollLock",
    "Win": "OS"
  };
  var _chromeNumKeyPadMap = {
    "A": "1",
    "B": "2",
    "C": "3",
    "D": "4",
    "E": "5",
    "F": "6",
    "G": "7",
    "H": "8",
    "I": "9",
    "J": "*",
    "K": "+",
    "M": "-",
    "N": ".",
    "O": "/",
    "`": "0",
    "\x90": "NumLock"
  };
  var MODIFIER_KEY_GETTERS = {
    "alt": (event) => event.altKey,
    "control": (event) => event.ctrlKey,
    "meta": (event) => event.metaKey,
    "shift": (event) => event.shiftKey
  };
  var KeyEventsPlugin = class extends EventManagerPlugin {
    constructor(doc) {
      super(doc);
    }
    supports(eventName) {
      return KeyEventsPlugin.parseEventName(eventName) != null;
    }
    addEventListener(element, eventName, handler) {
      const parsedEvent = KeyEventsPlugin.parseEventName(eventName);
      const outsideHandler = KeyEventsPlugin.eventCallback(parsedEvent["fullKey"], handler, this.manager.getZone());
      return this.manager.getZone().runOutsideAngular(() => {
        return getDOM().onAndCancel(element, parsedEvent["domEventName"], outsideHandler);
      });
    }
    static parseEventName(eventName) {
      const parts = eventName.toLowerCase().split(".");
      const domEventName = parts.shift();
      if (parts.length === 0 || !(domEventName === "keydown" || domEventName === "keyup")) {
        return null;
      }
      const key = KeyEventsPlugin._normalizeKey(parts.pop());
      let fullKey = "";
      MODIFIER_KEYS.forEach((modifierName) => {
        const index = parts.indexOf(modifierName);
        if (index > -1) {
          parts.splice(index, 1);
          fullKey += modifierName + ".";
        }
      });
      fullKey += key;
      if (parts.length != 0 || key.length === 0) {
        return null;
      }
      const result = {};
      result["domEventName"] = domEventName;
      result["fullKey"] = fullKey;
      return result;
    }
    static getEventFullKey(event) {
      let fullKey = "";
      let key = getEventKey(event);
      key = key.toLowerCase();
      if (key === " ") {
        key = "space";
      } else if (key === ".") {
        key = "dot";
      }
      MODIFIER_KEYS.forEach((modifierName) => {
        if (modifierName != key) {
          const modifierGetter = MODIFIER_KEY_GETTERS[modifierName];
          if (modifierGetter(event)) {
            fullKey += modifierName + ".";
          }
        }
      });
      fullKey += key;
      return fullKey;
    }
    static eventCallback(fullKey, handler, zone) {
      return (event) => {
        if (KeyEventsPlugin.getEventFullKey(event) === fullKey) {
          zone.runGuarded(() => handler(event));
        }
      };
    }
    static _normalizeKey(keyName) {
      switch (keyName) {
        case "esc":
          return "escape";
        default:
          return keyName;
      }
    }
  };
  KeyEventsPlugin.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: KeyEventsPlugin, deps: [{ token: DOCUMENT2 }], target: FactoryTarget.Injectable });
  KeyEventsPlugin.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: KeyEventsPlugin });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: KeyEventsPlugin, decorators: [{
    type: Injectable
  }], ctorParameters: function() {
    return [{ type: void 0, decorators: [{
      type: Inject,
      args: [DOCUMENT2]
    }] }];
  } });
  function getEventKey(event) {
    let key = event.key;
    if (key == null) {
      key = event.keyIdentifier;
      if (key == null) {
        return "Unidentified";
      }
      if (key.startsWith("U+")) {
        key = String.fromCharCode(parseInt(key.substring(2), 16));
        if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {
          key = _chromeNumKeyPadMap[key];
        }
      }
    }
    return _keyMap[key] || key;
  }
  function initDomAdapter() {
    BrowserDomAdapter.makeCurrent();
    BrowserGetTestability.init();
  }
  function errorHandler() {
    return new ErrorHandler();
  }
  function _document() {
    setDocument(document);
    return document;
  }
  var INTERNAL_BROWSER_PLATFORM_PROVIDERS = [
    { provide: PLATFORM_ID, useValue: PLATFORM_BROWSER_ID },
    { provide: PLATFORM_INITIALIZER, useValue: initDomAdapter, multi: true },
    { provide: DOCUMENT2, useFactory: _document, deps: [] }
  ];
  var platformBrowser = createPlatformFactory(platformCore, "browser", INTERNAL_BROWSER_PLATFORM_PROVIDERS);
  var BROWSER_MODULE_PROVIDERS = [
    { provide: INJECTOR_SCOPE, useValue: "root" },
    { provide: ErrorHandler, useFactory: errorHandler, deps: [] },
    {
      provide: EVENT_MANAGER_PLUGINS,
      useClass: DomEventsPlugin,
      multi: true,
      deps: [DOCUMENT2, NgZone, PLATFORM_ID]
    },
    { provide: EVENT_MANAGER_PLUGINS, useClass: KeyEventsPlugin, multi: true, deps: [DOCUMENT2] },
    {
      provide: DomRendererFactory2,
      useClass: DomRendererFactory2,
      deps: [EventManager, DomSharedStylesHost, APP_ID]
    },
    { provide: RendererFactory2, useExisting: DomRendererFactory2 },
    { provide: SharedStylesHost, useExisting: DomSharedStylesHost },
    { provide: DomSharedStylesHost, useClass: DomSharedStylesHost, deps: [DOCUMENT2] },
    { provide: Testability, useClass: Testability, deps: [NgZone] },
    { provide: EventManager, useClass: EventManager, deps: [EVENT_MANAGER_PLUGINS, NgZone] },
    { provide: XhrFactory, useClass: BrowserXhr, deps: [] }
  ];
  var BrowserModule = class {
    constructor(parentModule) {
      if (parentModule) {
        throw new Error(`BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.`);
      }
    }
    static withServerTransition(params) {
      return {
        ngModule: BrowserModule,
        providers: [
          { provide: APP_ID, useValue: params.appId },
          { provide: TRANSITION_ID, useExisting: APP_ID },
          SERVER_TRANSITION_PROVIDERS
        ]
      };
    }
  };
  BrowserModule.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: BrowserModule, deps: [{ token: BrowserModule, optional: true, skipSelf: true }], target: FactoryTarget.NgModule });
  BrowserModule.\u0275mod = \u0275\u0275ngDeclareNgModule({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: BrowserModule, exports: [CommonModule, ApplicationModule] });
  BrowserModule.\u0275inj = \u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: BrowserModule, providers: BROWSER_MODULE_PROVIDERS, imports: [CommonModule, ApplicationModule] });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: BrowserModule, decorators: [{
    type: NgModule,
    args: [{ providers: BROWSER_MODULE_PROVIDERS, exports: [CommonModule, ApplicationModule] }]
  }], ctorParameters: function() {
    return [{ type: BrowserModule, decorators: [{
      type: Optional
    }, {
      type: SkipSelf
    }, {
      type: Inject,
      args: [BrowserModule]
    }] }];
  } });
  function createMeta() {
    return new Meta(\u0275\u0275inject(DOCUMENT2));
  }
  var Meta = class {
    constructor(_doc) {
      this._doc = _doc;
      this._dom = getDOM();
    }
    addTag(tag, forceCreation = false) {
      if (!tag)
        return null;
      return this._getOrCreateElement(tag, forceCreation);
    }
    addTags(tags, forceCreation = false) {
      if (!tags)
        return [];
      return tags.reduce((result, tag) => {
        if (tag) {
          result.push(this._getOrCreateElement(tag, forceCreation));
        }
        return result;
      }, []);
    }
    getTag(attrSelector) {
      if (!attrSelector)
        return null;
      return this._doc.querySelector(`meta[${attrSelector}]`) || null;
    }
    getTags(attrSelector) {
      if (!attrSelector)
        return [];
      const list = this._doc.querySelectorAll(`meta[${attrSelector}]`);
      return list ? [].slice.call(list) : [];
    }
    updateTag(tag, selector) {
      if (!tag)
        return null;
      selector = selector || this._parseSelector(tag);
      const meta = this.getTag(selector);
      if (meta) {
        return this._setMetaElementAttributes(tag, meta);
      }
      return this._getOrCreateElement(tag, true);
    }
    removeTag(attrSelector) {
      this.removeTagElement(this.getTag(attrSelector));
    }
    removeTagElement(meta) {
      if (meta) {
        this._dom.remove(meta);
      }
    }
    _getOrCreateElement(meta, forceCreation = false) {
      if (!forceCreation) {
        const selector = this._parseSelector(meta);
        const elem = this.getTags(selector).filter((elem2) => this._containsAttributes(meta, elem2))[0];
        if (elem !== void 0)
          return elem;
      }
      const element = this._dom.createElement("meta");
      this._setMetaElementAttributes(meta, element);
      const head = this._doc.getElementsByTagName("head")[0];
      head.appendChild(element);
      return element;
    }
    _setMetaElementAttributes(tag, el) {
      Object.keys(tag).forEach((prop) => el.setAttribute(this._getMetaKeyMap(prop), tag[prop]));
      return el;
    }
    _parseSelector(tag) {
      const attr = tag.name ? "name" : "property";
      return `${attr}="${tag[attr]}"`;
    }
    _containsAttributes(tag, elem) {
      return Object.keys(tag).every((key) => elem.getAttribute(this._getMetaKeyMap(key)) === tag[key]);
    }
    _getMetaKeyMap(prop) {
      return META_KEYS_MAP[prop] || prop;
    }
  };
  Meta.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: Meta, deps: [{ token: DOCUMENT2 }], target: FactoryTarget.Injectable });
  Meta.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: Meta, providedIn: "root", useFactory: createMeta, deps: [] });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: Meta, decorators: [{
    type: Injectable,
    args: [{ providedIn: "root", useFactory: createMeta, deps: [] }]
  }], ctorParameters: function() {
    return [{ type: void 0, decorators: [{
      type: Inject,
      args: [DOCUMENT2]
    }] }];
  } });
  var META_KEYS_MAP = {
    httpEquiv: "http-equiv"
  };
  function createTitle() {
    return new Title(\u0275\u0275inject(DOCUMENT2));
  }
  var Title = class {
    constructor(_doc) {
      this._doc = _doc;
    }
    getTitle() {
      return this._doc.title;
    }
    setTitle(newTitle) {
      this._doc.title = newTitle || "";
    }
  };
  Title.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: Title, deps: [{ token: DOCUMENT2 }], target: FactoryTarget.Injectable });
  Title.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: Title, providedIn: "root", useFactory: createTitle, deps: [] });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: Title, decorators: [{
    type: Injectable,
    args: [{ providedIn: "root", useFactory: createTitle, deps: [] }]
  }], ctorParameters: function() {
    return [{ type: void 0, decorators: [{
      type: Inject,
      args: [DOCUMENT2]
    }] }];
  } });
  function unescapeHtml(text) {
    const unescapedText = {
      "&a;": "&",
      "&q;": '"',
      "&s;": "'",
      "&l;": "<",
      "&g;": ">"
    };
    return text.replace(/&[^;]+;/g, (s) => unescapedText[s]);
  }
  var TransferState = class {
    constructor() {
      this.store = {};
      this.onSerializeCallbacks = {};
    }
    static init(initState) {
      const transferState = new TransferState();
      transferState.store = initState;
      return transferState;
    }
    get(key, defaultValue) {
      return this.store[key] !== void 0 ? this.store[key] : defaultValue;
    }
    set(key, value) {
      this.store[key] = value;
    }
    remove(key) {
      delete this.store[key];
    }
    hasKey(key) {
      return this.store.hasOwnProperty(key);
    }
    onSerialize(key, callback) {
      this.onSerializeCallbacks[key] = callback;
    }
    toJson() {
      for (const key in this.onSerializeCallbacks) {
        if (this.onSerializeCallbacks.hasOwnProperty(key)) {
          try {
            this.store[key] = this.onSerializeCallbacks[key]();
          } catch (e) {
            console.warn("Exception in onSerialize callback: ", e);
          }
        }
      }
      return JSON.stringify(this.store);
    }
  };
  TransferState.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: TransferState, deps: [], target: FactoryTarget.Injectable });
  TransferState.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: TransferState });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: TransferState, decorators: [{
    type: Injectable
  }] });
  function initTransferState(doc, appId) {
    const script = doc.getElementById(appId + "-state");
    let initialState = {};
    if (script && script.textContent) {
      try {
        initialState = JSON.parse(unescapeHtml(script.textContent));
      } catch (e) {
        console.warn("Exception while restoring TransferState for app " + appId, e);
      }
    }
    return TransferState.init(initialState);
  }
  var BrowserTransferStateModule = class {
  };
  BrowserTransferStateModule.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: BrowserTransferStateModule, deps: [], target: FactoryTarget.NgModule });
  BrowserTransferStateModule.\u0275mod = \u0275\u0275ngDeclareNgModule({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: BrowserTransferStateModule });
  BrowserTransferStateModule.\u0275inj = \u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: BrowserTransferStateModule, providers: [{ provide: TransferState, useFactory: initTransferState, deps: [DOCUMENT2, APP_ID] }] });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: BrowserTransferStateModule, decorators: [{
    type: NgModule,
    args: [{
      providers: [{ provide: TransferState, useFactory: initTransferState, deps: [DOCUMENT2, APP_ID] }]
    }]
  }] });
  var EVENT_NAMES = {
    "pan": true,
    "panstart": true,
    "panmove": true,
    "panend": true,
    "pancancel": true,
    "panleft": true,
    "panright": true,
    "panup": true,
    "pandown": true,
    "pinch": true,
    "pinchstart": true,
    "pinchmove": true,
    "pinchend": true,
    "pinchcancel": true,
    "pinchin": true,
    "pinchout": true,
    "press": true,
    "pressup": true,
    "rotate": true,
    "rotatestart": true,
    "rotatemove": true,
    "rotateend": true,
    "rotatecancel": true,
    "swipe": true,
    "swipeleft": true,
    "swiperight": true,
    "swipeup": true,
    "swipedown": true,
    "tap": true,
    "doubletap": true
  };
  var HAMMER_GESTURE_CONFIG = new InjectionToken("HammerGestureConfig");
  var HAMMER_LOADER = new InjectionToken("HammerLoader");
  var HammerGestureConfig = class {
    constructor() {
      this.events = [];
      this.overrides = {};
    }
    buildHammer(element) {
      const mc = new Hammer(element, this.options);
      mc.get("pinch").set({ enable: true });
      mc.get("rotate").set({ enable: true });
      for (const eventName in this.overrides) {
        mc.get(eventName).set(this.overrides[eventName]);
      }
      return mc;
    }
  };
  HammerGestureConfig.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HammerGestureConfig, deps: [], target: FactoryTarget.Injectable });
  HammerGestureConfig.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HammerGestureConfig });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HammerGestureConfig, decorators: [{
    type: Injectable
  }] });
  var HammerGesturesPlugin = class extends EventManagerPlugin {
    constructor(doc, _config, console2, loader) {
      super(doc);
      this._config = _config;
      this.console = console2;
      this.loader = loader;
      this._loaderPromise = null;
    }
    supports(eventName) {
      if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {
        return false;
      }
      if (!window.Hammer && !this.loader) {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          this.console.warn(`The "${eventName}" event cannot be bound because Hammer.JS is not loaded and no custom loader has been specified.`);
        }
        return false;
      }
      return true;
    }
    addEventListener(element, eventName, handler) {
      const zone = this.manager.getZone();
      eventName = eventName.toLowerCase();
      if (!window.Hammer && this.loader) {
        this._loaderPromise = this._loaderPromise || this.loader();
        let cancelRegistration = false;
        let deregister = () => {
          cancelRegistration = true;
        };
        this._loaderPromise.then(() => {
          if (!window.Hammer) {
            if (typeof ngDevMode === "undefined" || ngDevMode) {
              this.console.warn(`The custom HAMMER_LOADER completed, but Hammer.JS is not present.`);
            }
            deregister = () => {
            };
            return;
          }
          if (!cancelRegistration) {
            deregister = this.addEventListener(element, eventName, handler);
          }
        }).catch(() => {
          if (typeof ngDevMode === "undefined" || ngDevMode) {
            this.console.warn(`The "${eventName}" event cannot be bound because the custom Hammer.JS loader failed.`);
          }
          deregister = () => {
          };
        });
        return () => {
          deregister();
        };
      }
      return zone.runOutsideAngular(() => {
        const mc = this._config.buildHammer(element);
        const callback = function(eventObj) {
          zone.runGuarded(function() {
            handler(eventObj);
          });
        };
        mc.on(eventName, callback);
        return () => {
          mc.off(eventName, callback);
          if (typeof mc.destroy === "function") {
            mc.destroy();
          }
        };
      });
    }
    isCustomEvent(eventName) {
      return this._config.events.indexOf(eventName) > -1;
    }
  };
  HammerGesturesPlugin.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HammerGesturesPlugin, deps: [{ token: DOCUMENT2 }, { token: HAMMER_GESTURE_CONFIG }, { token: Console }, { token: HAMMER_LOADER, optional: true }], target: FactoryTarget.Injectable });
  HammerGesturesPlugin.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HammerGesturesPlugin });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HammerGesturesPlugin, decorators: [{
    type: Injectable
  }], ctorParameters: function() {
    return [{ type: void 0, decorators: [{
      type: Inject,
      args: [DOCUMENT2]
    }] }, { type: HammerGestureConfig, decorators: [{
      type: Inject,
      args: [HAMMER_GESTURE_CONFIG]
    }] }, { type: Console }, { type: void 0, decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [HAMMER_LOADER]
    }] }];
  } });
  var HammerModule = class {
  };
  HammerModule.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HammerModule, deps: [], target: FactoryTarget.NgModule });
  HammerModule.\u0275mod = \u0275\u0275ngDeclareNgModule({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HammerModule });
  HammerModule.\u0275inj = \u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HammerModule, providers: [
    {
      provide: EVENT_MANAGER_PLUGINS,
      useClass: HammerGesturesPlugin,
      multi: true,
      deps: [DOCUMENT2, HAMMER_GESTURE_CONFIG, Console, [new Optional(), HAMMER_LOADER]]
    },
    { provide: HAMMER_GESTURE_CONFIG, useClass: HammerGestureConfig, deps: [] }
  ] });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HammerModule, decorators: [{
    type: NgModule,
    args: [{
      providers: [
        {
          provide: EVENT_MANAGER_PLUGINS,
          useClass: HammerGesturesPlugin,
          multi: true,
          deps: [DOCUMENT2, HAMMER_GESTURE_CONFIG, Console, [new Optional(), HAMMER_LOADER]]
        },
        { provide: HAMMER_GESTURE_CONFIG, useClass: HammerGestureConfig, deps: [] }
      ]
    }]
  }] });
  var DomSanitizer = class {
  };
  DomSanitizer.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: DomSanitizer, deps: [], target: FactoryTarget.Injectable });
  DomSanitizer.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: DomSanitizer, providedIn: "root", useExisting: forwardRef(function() {
    return DomSanitizerImpl;
  }) });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: DomSanitizer, decorators: [{
    type: Injectable,
    args: [{ providedIn: "root", useExisting: forwardRef(() => DomSanitizerImpl) }]
  }] });
  function domSanitizerImplFactory(injector) {
    return new DomSanitizerImpl(injector.get(DOCUMENT2));
  }
  var DomSanitizerImpl = class extends DomSanitizer {
    constructor(_doc) {
      super();
      this._doc = _doc;
    }
    sanitize(ctx, value) {
      if (value == null)
        return null;
      switch (ctx) {
        case SecurityContext.NONE:
          return value;
        case SecurityContext.HTML:
          if (allowSanitizationBypassAndThrow(value, "HTML")) {
            return unwrapSafeValue(value);
          }
          return _sanitizeHtml(this._doc, String(value)).toString();
        case SecurityContext.STYLE:
          if (allowSanitizationBypassAndThrow(value, "Style")) {
            return unwrapSafeValue(value);
          }
          return value;
        case SecurityContext.SCRIPT:
          if (allowSanitizationBypassAndThrow(value, "Script")) {
            return unwrapSafeValue(value);
          }
          throw new Error("unsafe value used in a script context");
        case SecurityContext.URL:
          const type = getSanitizationBypassType(value);
          if (allowSanitizationBypassAndThrow(value, "URL")) {
            return unwrapSafeValue(value);
          }
          return _sanitizeUrl(String(value));
        case SecurityContext.RESOURCE_URL:
          if (allowSanitizationBypassAndThrow(value, "ResourceURL")) {
            return unwrapSafeValue(value);
          }
          throw new Error("unsafe value used in a resource URL context (see https://g.co/ng/security#xss)");
        default:
          throw new Error(`Unexpected SecurityContext ${ctx} (see https://g.co/ng/security#xss)`);
      }
    }
    bypassSecurityTrustHtml(value) {
      return bypassSanitizationTrustHtml(value);
    }
    bypassSecurityTrustStyle(value) {
      return bypassSanitizationTrustStyle(value);
    }
    bypassSecurityTrustScript(value) {
      return bypassSanitizationTrustScript(value);
    }
    bypassSecurityTrustUrl(value) {
      return bypassSanitizationTrustUrl(value);
    }
    bypassSecurityTrustResourceUrl(value) {
      return bypassSanitizationTrustResourceUrl(value);
    }
  };
  DomSanitizerImpl.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: DomSanitizerImpl, deps: [{ token: DOCUMENT2 }], target: FactoryTarget.Injectable });
  DomSanitizerImpl.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: DomSanitizerImpl, providedIn: "root", useFactory: domSanitizerImplFactory, deps: [{ token: Injector }] });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: DomSanitizerImpl, decorators: [{
    type: Injectable,
    args: [{ providedIn: "root", useFactory: domSanitizerImplFactory, deps: [Injector] }]
  }], ctorParameters: function() {
    return [{ type: void 0, decorators: [{
      type: Inject,
      args: [DOCUMENT2]
    }] }];
  } });
  var VERSION4 = new Version("13.0.3");

  // node_modules/@angular/platform-browser-dynamic/fesm2020/platform-browser-dynamic.mjs
  var ERROR_COLLECTOR_TOKEN = new InjectionToken("ErrorCollector");
  var COMPILER_PROVIDERS = [{ provide: Compiler, useFactory: () => new Compiler() }];
  var JitCompilerFactory = class {
    constructor(defaultOptions) {
      const compilerOptions = {
        useJit: true,
        defaultEncapsulation: ViewEncapsulation$1.Emulated,
        missingTranslation: MissingTranslationStrategy.Warning
      };
      this._defaultOptions = [compilerOptions, ...defaultOptions];
    }
    createCompiler(options = []) {
      const opts = _mergeOptions(this._defaultOptions.concat(options));
      const injector = Injector.create([
        COMPILER_PROVIDERS,
        {
          provide: CompilerConfig,
          useFactory: () => {
            return new CompilerConfig({
              useJit: opts.useJit,
              jitDevMode: isDevMode(),
              defaultEncapsulation: opts.defaultEncapsulation,
              missingTranslation: opts.missingTranslation,
              preserveWhitespaces: opts.preserveWhitespaces
            });
          },
          deps: []
        },
        opts.providers
      ]);
      return injector.get(Compiler);
    }
  };
  function _mergeOptions(optionsArr) {
    return {
      useJit: _lastDefined2(optionsArr.map((options) => options.useJit)),
      defaultEncapsulation: _lastDefined2(optionsArr.map((options) => options.defaultEncapsulation)),
      providers: _mergeArrays2(optionsArr.map((options) => options.providers)),
      missingTranslation: _lastDefined2(optionsArr.map((options) => options.missingTranslation)),
      preserveWhitespaces: _lastDefined2(optionsArr.map((options) => options.preserveWhitespaces))
    };
  }
  function _lastDefined2(args) {
    for (let i = args.length - 1; i >= 0; i--) {
      if (args[i] !== void 0) {
        return args[i];
      }
    }
    return void 0;
  }
  function _mergeArrays2(parts) {
    const result = [];
    parts.forEach((part) => part && result.push(...part));
    return result;
  }
  var platformCoreDynamic = createPlatformFactory(platformCore, "coreDynamic", [
    { provide: COMPILER_OPTIONS, useValue: {}, multi: true },
    { provide: CompilerFactory, useClass: JitCompilerFactory, deps: [COMPILER_OPTIONS] }
  ]);
  var ResourceLoaderImpl = class extends ResourceLoader {
    get(url) {
      let resolve;
      let reject;
      const promise2 = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
      const xhr = new XMLHttpRequest();
      xhr.open("GET", url, true);
      xhr.responseType = "text";
      xhr.onload = function() {
        const response = xhr.response || xhr.responseText;
        let status = xhr.status === 1223 ? 204 : xhr.status;
        if (status === 0) {
          status = response ? 200 : 0;
        }
        if (200 <= status && status <= 300) {
          resolve(response);
        } else {
          reject(`Failed to load ${url}`);
        }
      };
      xhr.onerror = function() {
        reject(`Failed to load ${url}`);
      };
      xhr.send();
      return promise2;
    }
  };
  ResourceLoaderImpl.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: ResourceLoaderImpl, deps: null, target: FactoryTarget.Injectable });
  ResourceLoaderImpl.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: ResourceLoaderImpl });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: ResourceLoaderImpl, decorators: [{
    type: Injectable
  }] });
  var INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS = [
    INTERNAL_BROWSER_PLATFORM_PROVIDERS,
    {
      provide: COMPILER_OPTIONS,
      useValue: { providers: [{ provide: ResourceLoader, useClass: ResourceLoaderImpl, deps: [] }] },
      multi: true
    },
    { provide: PLATFORM_ID, useValue: PLATFORM_BROWSER_ID }
  ];
  var VERSION5 = new Version("13.0.3");
  var platformBrowserDynamic = createPlatformFactory(platformCoreDynamic, "browserDynamic", INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS);

  // node_modules/@angular/platform-browser/fesm2020/testing.mjs
  var BrowserDetection = class {
    constructor(ua) {
      this._overrideUa = ua;
    }
    get _ua() {
      if (typeof this._overrideUa === "string") {
        return this._overrideUa;
      }
      return getDOM() ? getDOM().getUserAgent() : "";
    }
    static setup() {
      return new BrowserDetection(null);
    }
    get isFirefox() {
      return this._ua.indexOf("Firefox") > -1;
    }
    get isAndroid() {
      return this._ua.indexOf("Mozilla/5.0") > -1 && this._ua.indexOf("Android") > -1 && this._ua.indexOf("AppleWebKit") > -1 && this._ua.indexOf("Chrome") == -1 && this._ua.indexOf("IEMobile") == -1;
    }
    get isEdge() {
      return this._ua.indexOf("Edge") > -1;
    }
    get isIE() {
      return this._ua.indexOf("Trident") > -1;
    }
    get isWebkit() {
      return this._ua.indexOf("AppleWebKit") > -1 && this._ua.indexOf("Edge") == -1 && this._ua.indexOf("IEMobile") == -1;
    }
    get isIOS7() {
      return (this._ua.indexOf("iPhone OS 7") > -1 || this._ua.indexOf("iPad OS 7") > -1) && this._ua.indexOf("IEMobile") == -1;
    }
    get isSlow() {
      return this.isAndroid || this.isIE || this.isIOS7;
    }
    get isChromeDesktop() {
      return this._ua.indexOf("Chrome") > -1 && this._ua.indexOf("Mobile Safari") == -1 && this._ua.indexOf("Edge") == -1;
    }
    get isOldChrome() {
      return this._ua.indexOf("Chrome") > -1 && this._ua.indexOf("Chrome/3") > -1 && this._ua.indexOf("Edge") == -1;
    }
    get supportsCustomElements() {
      return typeof _global2.customElements !== "undefined";
    }
    get supportsDeprecatedCustomCustomElementsV0() {
      return typeof document.registerElement !== "undefined";
    }
    get supportsRegExUnicodeFlag() {
      return RegExp.prototype.hasOwnProperty("unicode");
    }
    get supportsShadowDom() {
      const testEl = document.createElement("div");
      return typeof testEl.attachShadow !== "undefined";
    }
    get supportsDeprecatedShadowDomV0() {
      const testEl = document.createElement("div");
      return typeof testEl.createShadowRoot !== "undefined";
    }
  };
  var browserDetection = BrowserDetection.setup();
  function createNgZone() {
    return new NgZone({ enableLongStackTrace: true, shouldCoalesceEventChangeDetection: false });
  }
  function initBrowserTests() {
    BrowserDomAdapter.makeCurrent();
    BrowserDetection.setup();
  }
  var _TEST_BROWSER_PLATFORM_PROVIDERS = [{ provide: PLATFORM_INITIALIZER, useValue: initBrowserTests, multi: true }];
  var platformBrowserTesting = createPlatformFactory(platformCore, "browserTesting", _TEST_BROWSER_PLATFORM_PROVIDERS);
  var BrowserTestingModule = class {
  };
  BrowserTestingModule.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: BrowserTestingModule, deps: [], target: FactoryTarget.NgModule });
  BrowserTestingModule.\u0275mod = \u0275\u0275ngDeclareNgModule({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: BrowserTestingModule, exports: [BrowserModule] });
  BrowserTestingModule.\u0275inj = \u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: BrowserTestingModule, providers: [
    { provide: APP_ID, useValue: "a" },
    { provide: NgZone, useFactory: createNgZone }
  ], imports: [BrowserModule] });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: BrowserTestingModule, decorators: [{
    type: NgModule,
    args: [{
      exports: [BrowserModule],
      providers: [
        { provide: APP_ID, useValue: "a" },
        { provide: NgZone, useFactory: createNgZone }
      ]
    }]
  }] });

  // node_modules/@angular/platform-browser-dynamic/fesm2020/testing.mjs
  var DOMTestComponentRenderer = class extends TestComponentRenderer {
    constructor(_doc) {
      super();
      this._doc = _doc;
    }
    insertRootElement(rootElId) {
      this.removeAllRootElements();
      const rootElement = getDOM().getDefaultDocument().createElement("div");
      rootElement.setAttribute("id", rootElId);
      this._doc.body.appendChild(rootElement);
    }
    removeAllRootElements() {
      const oldRoots = this._doc.querySelectorAll("[id^=root]");
      for (let i = 0; i < oldRoots.length; i++) {
        getDOM().remove(oldRoots[i]);
      }
    }
  };
  DOMTestComponentRenderer.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: DOMTestComponentRenderer, deps: [{ token: DOCUMENT2 }], target: FactoryTarget.Injectable });
  DOMTestComponentRenderer.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: DOMTestComponentRenderer });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: DOMTestComponentRenderer, decorators: [{
    type: Injectable
  }], ctorParameters: function() {
    return [{ type: void 0, decorators: [{
      type: Inject,
      args: [DOCUMENT2]
    }] }];
  } });
  var platformCoreDynamicTesting = createPlatformFactory(platformCoreDynamic, "coreDynamicTesting", []);
  var platformBrowserDynamicTesting = createPlatformFactory(platformCoreDynamicTesting, "browserDynamicTesting", INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS);
  var BrowserDynamicTestingModule = class {
  };
  BrowserDynamicTestingModule.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: BrowserDynamicTestingModule, deps: [], target: FactoryTarget.NgModule });
  BrowserDynamicTestingModule.\u0275mod = \u0275\u0275ngDeclareNgModule({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: BrowserDynamicTestingModule, exports: [BrowserTestingModule] });
  BrowserDynamicTestingModule.\u0275inj = \u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: BrowserDynamicTestingModule, providers: [
    { provide: TestComponentRenderer, useClass: DOMTestComponentRenderer }
  ], imports: [BrowserTestingModule] });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: BrowserDynamicTestingModule, decorators: [{
    type: NgModule,
    args: [{
      exports: [BrowserTestingModule],
      providers: [
        { provide: TestComponentRenderer, useClass: DOMTestComponentRenderer }
      ]
    }]
  }] });

  // node_modules/@angular/common/fesm2020/testing.mjs
  function normalizeQueryParams2(params) {
    return params && params[0] !== "?" ? "?" + params : params;
  }
  var SpyLocation = class {
    constructor() {
      this.urlChanges = [];
      this._history = [new LocationState("", "", null)];
      this._historyIndex = 0;
      this._subject = new EventEmitter();
      this._baseHref = "";
      this._platformStrategy = null;
      this._platformLocation = null;
      this._urlChangeListeners = [];
    }
    setInitialPath(url) {
      this._history[this._historyIndex].path = url;
    }
    setBaseHref(url) {
      this._baseHref = url;
    }
    path() {
      return this._history[this._historyIndex].path;
    }
    getState() {
      return this._history[this._historyIndex].state;
    }
    isCurrentPathEqualTo(path, query = "") {
      const givenPath = path.endsWith("/") ? path.substring(0, path.length - 1) : path;
      const currPath = this.path().endsWith("/") ? this.path().substring(0, this.path().length - 1) : this.path();
      return currPath == givenPath + (query.length > 0 ? "?" + query : "");
    }
    simulateUrlPop(pathname) {
      this._subject.emit({ "url": pathname, "pop": true, "type": "popstate" });
    }
    simulateHashChange(pathname) {
      const path = this.prepareExternalUrl(pathname);
      this.pushHistory(path, "", null);
      this.urlChanges.push("hash: " + pathname);
      this._subject.emit({ "url": pathname, "pop": true, "type": "popstate" });
      this._subject.emit({ "url": pathname, "pop": true, "type": "hashchange" });
    }
    prepareExternalUrl(url) {
      if (url.length > 0 && !url.startsWith("/")) {
        url = "/" + url;
      }
      return this._baseHref + url;
    }
    go(path, query = "", state = null) {
      path = this.prepareExternalUrl(path);
      this.pushHistory(path, query, state);
      const locationState = this._history[this._historyIndex - 1];
      if (locationState.path == path && locationState.query == query) {
        return;
      }
      const url = path + (query.length > 0 ? "?" + query : "");
      this.urlChanges.push(url);
      this._notifyUrlChangeListeners(path + normalizeQueryParams2(query), state);
    }
    replaceState(path, query = "", state = null) {
      path = this.prepareExternalUrl(path);
      const history = this._history[this._historyIndex];
      if (history.path == path && history.query == query) {
        return;
      }
      history.path = path;
      history.query = query;
      history.state = state;
      const url = path + (query.length > 0 ? "?" + query : "");
      this.urlChanges.push("replace: " + url);
      this._notifyUrlChangeListeners(path + normalizeQueryParams2(query), state);
    }
    forward() {
      if (this._historyIndex < this._history.length - 1) {
        this._historyIndex++;
        this._subject.emit({ "url": this.path(), "state": this.getState(), "pop": true, "type": "popstate" });
      }
    }
    back() {
      if (this._historyIndex > 0) {
        this._historyIndex--;
        this._subject.emit({ "url": this.path(), "state": this.getState(), "pop": true, "type": "popstate" });
      }
    }
    historyGo(relativePosition = 0) {
      const nextPageIndex = this._historyIndex + relativePosition;
      if (nextPageIndex >= 0 && nextPageIndex < this._history.length) {
        this._historyIndex = nextPageIndex;
        this._subject.emit({ "url": this.path(), "state": this.getState(), "pop": true, "type": "popstate" });
      }
    }
    onUrlChange(fn2) {
      this._urlChangeListeners.push(fn2);
      if (!this._urlChangeSubscription) {
        this._urlChangeSubscription = this.subscribe((v) => {
          this._notifyUrlChangeListeners(v.url, v.state);
        });
      }
    }
    _notifyUrlChangeListeners(url = "", state) {
      this._urlChangeListeners.forEach((fn2) => fn2(url, state));
    }
    subscribe(onNext, onThrow, onReturn) {
      return this._subject.subscribe({ next: onNext, error: onThrow, complete: onReturn });
    }
    normalize(url) {
      return null;
    }
    pushHistory(path, query, state) {
      if (this._historyIndex > 0) {
        this._history.splice(this._historyIndex + 1);
      }
      this._history.push(new LocationState(path, query, state));
      this._historyIndex = this._history.length - 1;
    }
  };
  SpyLocation.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: SpyLocation, deps: [], target: FactoryTarget.Injectable });
  SpyLocation.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: SpyLocation });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: SpyLocation, decorators: [{
    type: Injectable
  }] });
  var LocationState = class {
    constructor(path, query, state) {
      this.path = path;
      this.query = query;
      this.state = state;
    }
  };
  var MockLocationStrategy = class extends LocationStrategy {
    constructor() {
      super();
      this.internalBaseHref = "/";
      this.internalPath = "/";
      this.internalTitle = "";
      this.urlChanges = [];
      this._subject = new EventEmitter();
      this.stateChanges = [];
    }
    simulatePopState(url) {
      this.internalPath = url;
      this._subject.emit(new _MockPopStateEvent(this.path()));
    }
    path(includeHash = false) {
      return this.internalPath;
    }
    prepareExternalUrl(internal) {
      if (internal.startsWith("/") && this.internalBaseHref.endsWith("/")) {
        return this.internalBaseHref + internal.substring(1);
      }
      return this.internalBaseHref + internal;
    }
    pushState(ctx, title, path, query) {
      this.stateChanges.push(ctx);
      this.internalTitle = title;
      const url = path + (query.length > 0 ? "?" + query : "");
      this.internalPath = url;
      const externalUrl = this.prepareExternalUrl(url);
      this.urlChanges.push(externalUrl);
    }
    replaceState(ctx, title, path, query) {
      this.stateChanges[(this.stateChanges.length || 1) - 1] = ctx;
      this.internalTitle = title;
      const url = path + (query.length > 0 ? "?" + query : "");
      this.internalPath = url;
      const externalUrl = this.prepareExternalUrl(url);
      this.urlChanges.push("replace: " + externalUrl);
    }
    onPopState(fn2) {
      this._subject.subscribe({ next: fn2 });
    }
    getBaseHref() {
      return this.internalBaseHref;
    }
    back() {
      if (this.urlChanges.length > 0) {
        this.urlChanges.pop();
        this.stateChanges.pop();
        const nextUrl = this.urlChanges.length > 0 ? this.urlChanges[this.urlChanges.length - 1] : "";
        this.simulatePopState(nextUrl);
      }
    }
    forward() {
      throw "not implemented";
    }
    getState() {
      return this.stateChanges[(this.stateChanges.length || 1) - 1];
    }
  };
  MockLocationStrategy.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: MockLocationStrategy, deps: [], target: FactoryTarget.Injectable });
  MockLocationStrategy.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: MockLocationStrategy });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: MockLocationStrategy, decorators: [{
    type: Injectable
  }], ctorParameters: function() {
    return [];
  } });
  var _MockPopStateEvent = class {
    constructor(newUrl) {
      this.newUrl = newUrl;
      this.pop = true;
      this.type = "popstate";
    }
  };
  var urlParse = /^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
  function parseUrl(urlStr, baseHref) {
    const verifyProtocol = /^((http[s]?|ftp):\/\/)/;
    let serverBase;
    if (!verifyProtocol.test(urlStr)) {
      serverBase = "http://empty.com/";
    }
    let parsedUrl;
    try {
      parsedUrl = new URL(urlStr, serverBase);
    } catch (e) {
      const result = urlParse.exec(serverBase || "" + urlStr);
      if (!result) {
        throw new Error(`Invalid URL: ${urlStr} with base: ${baseHref}`);
      }
      const hostSplit = result[4].split(":");
      parsedUrl = {
        protocol: result[1],
        hostname: hostSplit[0],
        port: hostSplit[1] || "",
        pathname: result[5],
        search: result[6],
        hash: result[8]
      };
    }
    if (parsedUrl.pathname && parsedUrl.pathname.indexOf(baseHref) === 0) {
      parsedUrl.pathname = parsedUrl.pathname.substring(baseHref.length);
    }
    return {
      hostname: !serverBase && parsedUrl.hostname || "",
      protocol: !serverBase && parsedUrl.protocol || "",
      port: !serverBase && parsedUrl.port || "",
      pathname: parsedUrl.pathname || "/",
      search: parsedUrl.search || "",
      hash: parsedUrl.hash || ""
    };
  }
  var MOCK_PLATFORM_LOCATION_CONFIG = new InjectionToken("MOCK_PLATFORM_LOCATION_CONFIG");
  var MockPlatformLocation = class {
    constructor(config2) {
      this.baseHref = "";
      this.hashUpdate = new Subject();
      this.urlChangeIndex = 0;
      this.urlChanges = [{ hostname: "", protocol: "", port: "", pathname: "/", search: "", hash: "", state: null }];
      if (config2) {
        this.baseHref = config2.appBaseHref || "";
        const parsedChanges = this.parseChanges(null, config2.startUrl || "http://_empty_/", this.baseHref);
        this.urlChanges[0] = { ...parsedChanges };
      }
    }
    get hostname() {
      return this.urlChanges[this.urlChangeIndex].hostname;
    }
    get protocol() {
      return this.urlChanges[this.urlChangeIndex].protocol;
    }
    get port() {
      return this.urlChanges[this.urlChangeIndex].port;
    }
    get pathname() {
      return this.urlChanges[this.urlChangeIndex].pathname;
    }
    get search() {
      return this.urlChanges[this.urlChangeIndex].search;
    }
    get hash() {
      return this.urlChanges[this.urlChangeIndex].hash;
    }
    get state() {
      return this.urlChanges[this.urlChangeIndex].state;
    }
    getBaseHrefFromDOM() {
      return this.baseHref;
    }
    onPopState(fn2) {
      return () => {
      };
    }
    onHashChange(fn2) {
      const subscription = this.hashUpdate.subscribe(fn2);
      return () => subscription.unsubscribe();
    }
    get href() {
      let url = `${this.protocol}//${this.hostname}${this.port ? ":" + this.port : ""}`;
      url += `${this.pathname === "/" ? "" : this.pathname}${this.search}${this.hash}`;
      return url;
    }
    get url() {
      return `${this.pathname}${this.search}${this.hash}`;
    }
    parseChanges(state, url, baseHref = "") {
      state = JSON.parse(JSON.stringify(state));
      return { ...parseUrl(url, baseHref), state };
    }
    replaceState(state, title, newUrl) {
      const { pathname, search, state: parsedState, hash } = this.parseChanges(state, newUrl);
      this.urlChanges[this.urlChangeIndex] = { ...this.urlChanges[this.urlChangeIndex], pathname, search, hash, state: parsedState };
    }
    pushState(state, title, newUrl) {
      const { pathname, search, state: parsedState, hash } = this.parseChanges(state, newUrl);
      if (this.urlChangeIndex > 0) {
        this.urlChanges.splice(this.urlChangeIndex + 1);
      }
      this.urlChanges.push({ ...this.urlChanges[this.urlChangeIndex], pathname, search, hash, state: parsedState });
      this.urlChangeIndex = this.urlChanges.length - 1;
    }
    forward() {
      const oldUrl = this.url;
      const oldHash = this.hash;
      if (this.urlChangeIndex < this.urlChanges.length) {
        this.urlChangeIndex++;
      }
      this.scheduleHashUpdate(oldHash, oldUrl);
    }
    back() {
      const oldUrl = this.url;
      const oldHash = this.hash;
      if (this.urlChangeIndex > 0) {
        this.urlChangeIndex--;
      }
      this.scheduleHashUpdate(oldHash, oldUrl);
    }
    historyGo(relativePosition = 0) {
      const oldUrl = this.url;
      const oldHash = this.hash;
      const nextPageIndex = this.urlChangeIndex + relativePosition;
      if (nextPageIndex >= 0 && nextPageIndex < this.urlChanges.length) {
        this.urlChangeIndex = nextPageIndex;
      }
      this.scheduleHashUpdate(oldHash, oldUrl);
    }
    getState() {
      return this.state;
    }
    scheduleHashUpdate(oldHash, oldUrl) {
      if (oldHash !== this.hash) {
        scheduleMicroTask3(() => this.hashUpdate.next({ type: "hashchange", state: null, oldUrl, newUrl: this.url }));
      }
    }
  };
  MockPlatformLocation.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: MockPlatformLocation, deps: [{ token: MOCK_PLATFORM_LOCATION_CONFIG, optional: true }], target: FactoryTarget.Injectable });
  MockPlatformLocation.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: MockPlatformLocation });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: MockPlatformLocation, decorators: [{
    type: Injectable
  }], ctorParameters: function() {
    return [{ type: void 0, decorators: [{
      type: Inject,
      args: [MOCK_PLATFORM_LOCATION_CONFIG]
    }, {
      type: Optional
    }] }];
  } });
  function scheduleMicroTask3(cb) {
    Promise.resolve(null).then(cb);
  }

  // node_modules/@angular/router/fesm2020/router.mjs
  var RouterEvent = class {
    constructor(id, url) {
      this.id = id;
      this.url = url;
    }
  };
  var NavigationStart = class extends RouterEvent {
    constructor(id, url, navigationTrigger = "imperative", restoredState = null) {
      super(id, url);
      this.navigationTrigger = navigationTrigger;
      this.restoredState = restoredState;
    }
    toString() {
      return `NavigationStart(id: ${this.id}, url: '${this.url}')`;
    }
  };
  var NavigationEnd = class extends RouterEvent {
    constructor(id, url, urlAfterRedirects) {
      super(id, url);
      this.urlAfterRedirects = urlAfterRedirects;
    }
    toString() {
      return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`;
    }
  };
  var NavigationCancel = class extends RouterEvent {
    constructor(id, url, reason) {
      super(id, url);
      this.reason = reason;
    }
    toString() {
      return `NavigationCancel(id: ${this.id}, url: '${this.url}')`;
    }
  };
  var NavigationError = class extends RouterEvent {
    constructor(id, url, error3) {
      super(id, url);
      this.error = error3;
    }
    toString() {
      return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`;
    }
  };
  var RoutesRecognized = class extends RouterEvent {
    constructor(id, url, urlAfterRedirects, state) {
      super(id, url);
      this.urlAfterRedirects = urlAfterRedirects;
      this.state = state;
    }
    toString() {
      return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
    }
  };
  var GuardsCheckStart = class extends RouterEvent {
    constructor(id, url, urlAfterRedirects, state) {
      super(id, url);
      this.urlAfterRedirects = urlAfterRedirects;
      this.state = state;
    }
    toString() {
      return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
    }
  };
  var GuardsCheckEnd = class extends RouterEvent {
    constructor(id, url, urlAfterRedirects, state, shouldActivate) {
      super(id, url);
      this.urlAfterRedirects = urlAfterRedirects;
      this.state = state;
      this.shouldActivate = shouldActivate;
    }
    toString() {
      return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`;
    }
  };
  var ResolveStart = class extends RouterEvent {
    constructor(id, url, urlAfterRedirects, state) {
      super(id, url);
      this.urlAfterRedirects = urlAfterRedirects;
      this.state = state;
    }
    toString() {
      return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
    }
  };
  var ResolveEnd = class extends RouterEvent {
    constructor(id, url, urlAfterRedirects, state) {
      super(id, url);
      this.urlAfterRedirects = urlAfterRedirects;
      this.state = state;
    }
    toString() {
      return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
    }
  };
  var RouteConfigLoadStart = class {
    constructor(route) {
      this.route = route;
    }
    toString() {
      return `RouteConfigLoadStart(path: ${this.route.path})`;
    }
  };
  var RouteConfigLoadEnd = class {
    constructor(route) {
      this.route = route;
    }
    toString() {
      return `RouteConfigLoadEnd(path: ${this.route.path})`;
    }
  };
  var ChildActivationStart = class {
    constructor(snapshot) {
      this.snapshot = snapshot;
    }
    toString() {
      const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
      return `ChildActivationStart(path: '${path}')`;
    }
  };
  var ChildActivationEnd = class {
    constructor(snapshot) {
      this.snapshot = snapshot;
    }
    toString() {
      const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
      return `ChildActivationEnd(path: '${path}')`;
    }
  };
  var ActivationStart = class {
    constructor(snapshot) {
      this.snapshot = snapshot;
    }
    toString() {
      const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
      return `ActivationStart(path: '${path}')`;
    }
  };
  var ActivationEnd = class {
    constructor(snapshot) {
      this.snapshot = snapshot;
    }
    toString() {
      const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
      return `ActivationEnd(path: '${path}')`;
    }
  };
  var Scroll = class {
    constructor(routerEvent, position, anchor) {
      this.routerEvent = routerEvent;
      this.position = position;
      this.anchor = anchor;
    }
    toString() {
      const pos = this.position ? `${this.position[0]}, ${this.position[1]}` : null;
      return `Scroll(anchor: '${this.anchor}', position: '${pos}')`;
    }
  };
  var PRIMARY_OUTLET = "primary";
  var ParamsAsMap = class {
    constructor(params) {
      this.params = params || {};
    }
    has(name) {
      return Object.prototype.hasOwnProperty.call(this.params, name);
    }
    get(name) {
      if (this.has(name)) {
        const v = this.params[name];
        return Array.isArray(v) ? v[0] : v;
      }
      return null;
    }
    getAll(name) {
      if (this.has(name)) {
        const v = this.params[name];
        return Array.isArray(v) ? v : [v];
      }
      return [];
    }
    get keys() {
      return Object.keys(this.params);
    }
  };
  function convertToParamMap(params) {
    return new ParamsAsMap(params);
  }
  var NAVIGATION_CANCELING_ERROR = "ngNavigationCancelingError";
  function navigationCancelingError(message) {
    const error3 = Error("NavigationCancelingError: " + message);
    error3[NAVIGATION_CANCELING_ERROR] = true;
    return error3;
  }
  function isNavigationCancelingError(error3) {
    return error3 && error3[NAVIGATION_CANCELING_ERROR];
  }
  function defaultUrlMatcher(segments, segmentGroup, route) {
    const parts = route.path.split("/");
    if (parts.length > segments.length) {
      return null;
    }
    if (route.pathMatch === "full" && (segmentGroup.hasChildren() || parts.length < segments.length)) {
      return null;
    }
    const posParams = {};
    for (let index = 0; index < parts.length; index++) {
      const part = parts[index];
      const segment = segments[index];
      const isParameter = part.startsWith(":");
      if (isParameter) {
        posParams[part.substring(1)] = segment;
      } else if (part !== segment.path) {
        return null;
      }
    }
    return { consumed: segments.slice(0, parts.length), posParams };
  }
  function shallowEqualArrays(a, b) {
    if (a.length !== b.length)
      return false;
    for (let i = 0; i < a.length; ++i) {
      if (!shallowEqual(a[i], b[i]))
        return false;
    }
    return true;
  }
  function shallowEqual(a, b) {
    const k1 = a ? Object.keys(a) : void 0;
    const k2 = b ? Object.keys(b) : void 0;
    if (!k1 || !k2 || k1.length != k2.length) {
      return false;
    }
    let key;
    for (let i = 0; i < k1.length; i++) {
      key = k1[i];
      if (!equalArraysOrString(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  function equalArraysOrString(a, b) {
    if (Array.isArray(a) && Array.isArray(b)) {
      if (a.length !== b.length)
        return false;
      const aSorted = [...a].sort();
      const bSorted = [...b].sort();
      return aSorted.every((val, index) => bSorted[index] === val);
    } else {
      return a === b;
    }
  }
  function flatten4(arr) {
    return Array.prototype.concat.apply([], arr);
  }
  function last3(a) {
    return a.length > 0 ? a[a.length - 1] : null;
  }
  function forEach(map2, callback) {
    for (const prop in map2) {
      if (map2.hasOwnProperty(prop)) {
        callback(map2[prop], prop);
      }
    }
  }
  function wrapIntoObservable(value) {
    if (isObservable(value)) {
      return value;
    }
    if (isPromise2(value)) {
      return from(Promise.resolve(value));
    }
    return of(value);
  }
  function createEmptyUrlTree() {
    return new UrlTree(new UrlSegmentGroup([], {}), {}, null);
  }
  var pathCompareMap = {
    "exact": equalSegmentGroups,
    "subset": containsSegmentGroup
  };
  var paramCompareMap = {
    "exact": equalParams,
    "subset": containsParams,
    "ignored": () => true
  };
  function containsTree(container, containee, options) {
    return pathCompareMap[options.paths](container.root, containee.root, options.matrixParams) && paramCompareMap[options.queryParams](container.queryParams, containee.queryParams) && !(options.fragment === "exact" && container.fragment !== containee.fragment);
  }
  function equalParams(container, containee) {
    return shallowEqual(container, containee);
  }
  function equalSegmentGroups(container, containee, matrixParams) {
    if (!equalPath(container.segments, containee.segments))
      return false;
    if (!matrixParamsMatch(container.segments, containee.segments, matrixParams)) {
      return false;
    }
    if (container.numberOfChildren !== containee.numberOfChildren)
      return false;
    for (const c in containee.children) {
      if (!container.children[c])
        return false;
      if (!equalSegmentGroups(container.children[c], containee.children[c], matrixParams))
        return false;
    }
    return true;
  }
  function containsParams(container, containee) {
    return Object.keys(containee).length <= Object.keys(container).length && Object.keys(containee).every((key) => equalArraysOrString(container[key], containee[key]));
  }
  function containsSegmentGroup(container, containee, matrixParams) {
    return containsSegmentGroupHelper(container, containee, containee.segments, matrixParams);
  }
  function containsSegmentGroupHelper(container, containee, containeePaths, matrixParams) {
    if (container.segments.length > containeePaths.length) {
      const current = container.segments.slice(0, containeePaths.length);
      if (!equalPath(current, containeePaths))
        return false;
      if (containee.hasChildren())
        return false;
      if (!matrixParamsMatch(current, containeePaths, matrixParams))
        return false;
      return true;
    } else if (container.segments.length === containeePaths.length) {
      if (!equalPath(container.segments, containeePaths))
        return false;
      if (!matrixParamsMatch(container.segments, containeePaths, matrixParams))
        return false;
      for (const c in containee.children) {
        if (!container.children[c])
          return false;
        if (!containsSegmentGroup(container.children[c], containee.children[c], matrixParams)) {
          return false;
        }
      }
      return true;
    } else {
      const current = containeePaths.slice(0, container.segments.length);
      const next = containeePaths.slice(container.segments.length);
      if (!equalPath(container.segments, current))
        return false;
      if (!matrixParamsMatch(container.segments, current, matrixParams))
        return false;
      if (!container.children[PRIMARY_OUTLET])
        return false;
      return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next, matrixParams);
    }
  }
  function matrixParamsMatch(containerPaths, containeePaths, options) {
    return containeePaths.every((containeeSegment, i) => {
      return paramCompareMap[options](containerPaths[i].parameters, containeeSegment.parameters);
    });
  }
  var UrlTree = class {
    constructor(root, queryParams, fragment) {
      this.root = root;
      this.queryParams = queryParams;
      this.fragment = fragment;
    }
    get queryParamMap() {
      if (!this._queryParamMap) {
        this._queryParamMap = convertToParamMap(this.queryParams);
      }
      return this._queryParamMap;
    }
    toString() {
      return DEFAULT_SERIALIZER.serialize(this);
    }
  };
  var UrlSegmentGroup = class {
    constructor(segments, children) {
      this.segments = segments;
      this.children = children;
      this.parent = null;
      forEach(children, (v, k) => v.parent = this);
    }
    hasChildren() {
      return this.numberOfChildren > 0;
    }
    get numberOfChildren() {
      return Object.keys(this.children).length;
    }
    toString() {
      return serializePaths(this);
    }
  };
  var UrlSegment = class {
    constructor(path, parameters) {
      this.path = path;
      this.parameters = parameters;
    }
    get parameterMap() {
      if (!this._parameterMap) {
        this._parameterMap = convertToParamMap(this.parameters);
      }
      return this._parameterMap;
    }
    toString() {
      return serializePath(this);
    }
  };
  function equalSegments(as, bs) {
    return equalPath(as, bs) && as.every((a, i) => shallowEqual(a.parameters, bs[i].parameters));
  }
  function equalPath(as, bs) {
    if (as.length !== bs.length)
      return false;
    return as.every((a, i) => a.path === bs[i].path);
  }
  function mapChildrenIntoArray(segment, fn2) {
    let res = [];
    forEach(segment.children, (child, childOutlet) => {
      if (childOutlet === PRIMARY_OUTLET) {
        res = res.concat(fn2(child, childOutlet));
      }
    });
    forEach(segment.children, (child, childOutlet) => {
      if (childOutlet !== PRIMARY_OUTLET) {
        res = res.concat(fn2(child, childOutlet));
      }
    });
    return res;
  }
  var UrlSerializer = class {
  };
  var DefaultUrlSerializer = class {
    parse(url) {
      const p = new UrlParser(url);
      return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());
    }
    serialize(tree2) {
      const segment = `/${serializeSegment(tree2.root, true)}`;
      const query = serializeQueryParams(tree2.queryParams);
      const fragment = typeof tree2.fragment === `string` ? `#${encodeUriFragment(tree2.fragment)}` : "";
      return `${segment}${query}${fragment}`;
    }
  };
  var DEFAULT_SERIALIZER = new DefaultUrlSerializer();
  function serializePaths(segment) {
    return segment.segments.map((p) => serializePath(p)).join("/");
  }
  function serializeSegment(segment, root) {
    if (!segment.hasChildren()) {
      return serializePaths(segment);
    }
    if (root) {
      const primary = segment.children[PRIMARY_OUTLET] ? serializeSegment(segment.children[PRIMARY_OUTLET], false) : "";
      const children = [];
      forEach(segment.children, (v, k) => {
        if (k !== PRIMARY_OUTLET) {
          children.push(`${k}:${serializeSegment(v, false)}`);
        }
      });
      return children.length > 0 ? `${primary}(${children.join("//")})` : primary;
    } else {
      const children = mapChildrenIntoArray(segment, (v, k) => {
        if (k === PRIMARY_OUTLET) {
          return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];
        }
        return [`${k}:${serializeSegment(v, false)}`];
      });
      if (Object.keys(segment.children).length === 1 && segment.children[PRIMARY_OUTLET] != null) {
        return `${serializePaths(segment)}/${children[0]}`;
      }
      return `${serializePaths(segment)}/(${children.join("//")})`;
    }
  }
  function encodeUriString(s) {
    return encodeURIComponent(s).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",");
  }
  function encodeUriQuery(s) {
    return encodeUriString(s).replace(/%3B/gi, ";");
  }
  function encodeUriFragment(s) {
    return encodeURI(s);
  }
  function encodeUriSegment(s) {
    return encodeUriString(s).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&");
  }
  function decode(s) {
    return decodeURIComponent(s);
  }
  function decodeQuery(s) {
    return decode(s.replace(/\+/g, "%20"));
  }
  function serializePath(path) {
    return `${encodeUriSegment(path.path)}${serializeMatrixParams(path.parameters)}`;
  }
  function serializeMatrixParams(params) {
    return Object.keys(params).map((key) => `;${encodeUriSegment(key)}=${encodeUriSegment(params[key])}`).join("");
  }
  function serializeQueryParams(params) {
    const strParams = Object.keys(params).map((name) => {
      const value = params[name];
      return Array.isArray(value) ? value.map((v) => `${encodeUriQuery(name)}=${encodeUriQuery(v)}`).join("&") : `${encodeUriQuery(name)}=${encodeUriQuery(value)}`;
    }).filter((s) => !!s);
    return strParams.length ? `?${strParams.join("&")}` : "";
  }
  var SEGMENT_RE = /^[^\/()?;=#]+/;
  function matchSegments(str) {
    const match2 = str.match(SEGMENT_RE);
    return match2 ? match2[0] : "";
  }
  var QUERY_PARAM_RE = /^[^=?&#]+/;
  function matchQueryParams(str) {
    const match2 = str.match(QUERY_PARAM_RE);
    return match2 ? match2[0] : "";
  }
  var QUERY_PARAM_VALUE_RE = /^[^&#]+/;
  function matchUrlQueryParamValue(str) {
    const match2 = str.match(QUERY_PARAM_VALUE_RE);
    return match2 ? match2[0] : "";
  }
  var UrlParser = class {
    constructor(url) {
      this.url = url;
      this.remaining = url;
    }
    parseRootSegment() {
      this.consumeOptional("/");
      if (this.remaining === "" || this.peekStartsWith("?") || this.peekStartsWith("#")) {
        return new UrlSegmentGroup([], {});
      }
      return new UrlSegmentGroup([], this.parseChildren());
    }
    parseQueryParams() {
      const params = {};
      if (this.consumeOptional("?")) {
        do {
          this.parseQueryParam(params);
        } while (this.consumeOptional("&"));
      }
      return params;
    }
    parseFragment() {
      return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null;
    }
    parseChildren() {
      if (this.remaining === "") {
        return {};
      }
      this.consumeOptional("/");
      const segments = [];
      if (!this.peekStartsWith("(")) {
        segments.push(this.parseSegment());
      }
      while (this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(")) {
        this.capture("/");
        segments.push(this.parseSegment());
      }
      let children = {};
      if (this.peekStartsWith("/(")) {
        this.capture("/");
        children = this.parseParens(true);
      }
      let res = {};
      if (this.peekStartsWith("(")) {
        res = this.parseParens(false);
      }
      if (segments.length > 0 || Object.keys(children).length > 0) {
        res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);
      }
      return res;
    }
    parseSegment() {
      const path = matchSegments(this.remaining);
      if (path === "" && this.peekStartsWith(";")) {
        throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`);
      }
      this.capture(path);
      return new UrlSegment(decode(path), this.parseMatrixParams());
    }
    parseMatrixParams() {
      const params = {};
      while (this.consumeOptional(";")) {
        this.parseParam(params);
      }
      return params;
    }
    parseParam(params) {
      const key = matchSegments(this.remaining);
      if (!key) {
        return;
      }
      this.capture(key);
      let value = "";
      if (this.consumeOptional("=")) {
        const valueMatch = matchSegments(this.remaining);
        if (valueMatch) {
          value = valueMatch;
          this.capture(value);
        }
      }
      params[decode(key)] = decode(value);
    }
    parseQueryParam(params) {
      const key = matchQueryParams(this.remaining);
      if (!key) {
        return;
      }
      this.capture(key);
      let value = "";
      if (this.consumeOptional("=")) {
        const valueMatch = matchUrlQueryParamValue(this.remaining);
        if (valueMatch) {
          value = valueMatch;
          this.capture(value);
        }
      }
      const decodedKey = decodeQuery(key);
      const decodedVal = decodeQuery(value);
      if (params.hasOwnProperty(decodedKey)) {
        let currentVal = params[decodedKey];
        if (!Array.isArray(currentVal)) {
          currentVal = [currentVal];
          params[decodedKey] = currentVal;
        }
        currentVal.push(decodedVal);
      } else {
        params[decodedKey] = decodedVal;
      }
    }
    parseParens(allowPrimary) {
      const segments = {};
      this.capture("(");
      while (!this.consumeOptional(")") && this.remaining.length > 0) {
        const path = matchSegments(this.remaining);
        const next = this.remaining[path.length];
        if (next !== "/" && next !== ")" && next !== ";") {
          throw new Error(`Cannot parse url '${this.url}'`);
        }
        let outletName = void 0;
        if (path.indexOf(":") > -1) {
          outletName = path.substr(0, path.indexOf(":"));
          this.capture(outletName);
          this.capture(":");
        } else if (allowPrimary) {
          outletName = PRIMARY_OUTLET;
        }
        const children = this.parseChildren();
        segments[outletName] = Object.keys(children).length === 1 ? children[PRIMARY_OUTLET] : new UrlSegmentGroup([], children);
        this.consumeOptional("//");
      }
      return segments;
    }
    peekStartsWith(str) {
      return this.remaining.startsWith(str);
    }
    consumeOptional(str) {
      if (this.peekStartsWith(str)) {
        this.remaining = this.remaining.substring(str.length);
        return true;
      }
      return false;
    }
    capture(str) {
      if (!this.consumeOptional(str)) {
        throw new Error(`Expected "${str}".`);
      }
    }
  };
  var Tree = class {
    constructor(root) {
      this._root = root;
    }
    get root() {
      return this._root.value;
    }
    parent(t) {
      const p = this.pathFromRoot(t);
      return p.length > 1 ? p[p.length - 2] : null;
    }
    children(t) {
      const n = findNode(t, this._root);
      return n ? n.children.map((t2) => t2.value) : [];
    }
    firstChild(t) {
      const n = findNode(t, this._root);
      return n && n.children.length > 0 ? n.children[0].value : null;
    }
    siblings(t) {
      const p = findPath(t, this._root);
      if (p.length < 2)
        return [];
      const c = p[p.length - 2].children.map((c2) => c2.value);
      return c.filter((cc) => cc !== t);
    }
    pathFromRoot(t) {
      return findPath(t, this._root).map((s) => s.value);
    }
  };
  function findNode(value, node) {
    if (value === node.value)
      return node;
    for (const child of node.children) {
      const node2 = findNode(value, child);
      if (node2)
        return node2;
    }
    return null;
  }
  function findPath(value, node) {
    if (value === node.value)
      return [node];
    for (const child of node.children) {
      const path = findPath(value, child);
      if (path.length) {
        path.unshift(node);
        return path;
      }
    }
    return [];
  }
  var TreeNode = class {
    constructor(value, children) {
      this.value = value;
      this.children = children;
    }
    toString() {
      return `TreeNode(${this.value})`;
    }
  };
  function nodeChildrenAsMap(node) {
    const map2 = {};
    if (node) {
      node.children.forEach((child) => map2[child.value.outlet] = child);
    }
    return map2;
  }
  var RouterState = class extends Tree {
    constructor(root, snapshot) {
      super(root);
      this.snapshot = snapshot;
      setRouterState(this, root);
    }
    toString() {
      return this.snapshot.toString();
    }
  };
  function createEmptyState(urlTree, rootComponent) {
    const snapshot = createEmptyStateSnapshot(urlTree, rootComponent);
    const emptyUrl = new BehaviorSubject([new UrlSegment("", {})]);
    const emptyParams = new BehaviorSubject({});
    const emptyData = new BehaviorSubject({});
    const emptyQueryParams = new BehaviorSubject({});
    const fragment = new BehaviorSubject("");
    const activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);
    activated.snapshot = snapshot.root;
    return new RouterState(new TreeNode(activated, []), snapshot);
  }
  function createEmptyStateSnapshot(urlTree, rootComponent) {
    const emptyParams = {};
    const emptyData = {};
    const emptyQueryParams = {};
    const fragment = "";
    const activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, urlTree.root, -1, {});
    return new RouterStateSnapshot("", new TreeNode(activated, []));
  }
  var ActivatedRoute = class {
    constructor(url, params, queryParams, fragment, data, outlet, component, futureSnapshot) {
      this.url = url;
      this.params = params;
      this.queryParams = queryParams;
      this.fragment = fragment;
      this.data = data;
      this.outlet = outlet;
      this.component = component;
      this._futureSnapshot = futureSnapshot;
    }
    get routeConfig() {
      return this._futureSnapshot.routeConfig;
    }
    get root() {
      return this._routerState.root;
    }
    get parent() {
      return this._routerState.parent(this);
    }
    get firstChild() {
      return this._routerState.firstChild(this);
    }
    get children() {
      return this._routerState.children(this);
    }
    get pathFromRoot() {
      return this._routerState.pathFromRoot(this);
    }
    get paramMap() {
      if (!this._paramMap) {
        this._paramMap = this.params.pipe(map((p) => convertToParamMap(p)));
      }
      return this._paramMap;
    }
    get queryParamMap() {
      if (!this._queryParamMap) {
        this._queryParamMap = this.queryParams.pipe(map((p) => convertToParamMap(p)));
      }
      return this._queryParamMap;
    }
    toString() {
      return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})`;
    }
  };
  function inheritedParamsDataResolve(route, paramsInheritanceStrategy = "emptyOnly") {
    const pathFromRoot = route.pathFromRoot;
    let inheritingStartingFrom = 0;
    if (paramsInheritanceStrategy !== "always") {
      inheritingStartingFrom = pathFromRoot.length - 1;
      while (inheritingStartingFrom >= 1) {
        const current = pathFromRoot[inheritingStartingFrom];
        const parent = pathFromRoot[inheritingStartingFrom - 1];
        if (current.routeConfig && current.routeConfig.path === "") {
          inheritingStartingFrom--;
        } else if (!parent.component) {
          inheritingStartingFrom--;
        } else {
          break;
        }
      }
    }
    return flattenInherited(pathFromRoot.slice(inheritingStartingFrom));
  }
  function flattenInherited(pathFromRoot) {
    return pathFromRoot.reduce((res, curr) => {
      const params = { ...res.params, ...curr.params };
      const data = { ...res.data, ...curr.data };
      const resolve = { ...res.resolve, ...curr._resolvedData };
      return { params, data, resolve };
    }, { params: {}, data: {}, resolve: {} });
  }
  var ActivatedRouteSnapshot = class {
    constructor(url, params, queryParams, fragment, data, outlet, component, routeConfig, urlSegment, lastPathIndex, resolve) {
      this.url = url;
      this.params = params;
      this.queryParams = queryParams;
      this.fragment = fragment;
      this.data = data;
      this.outlet = outlet;
      this.component = component;
      this.routeConfig = routeConfig;
      this._urlSegment = urlSegment;
      this._lastPathIndex = lastPathIndex;
      this._resolve = resolve;
    }
    get root() {
      return this._routerState.root;
    }
    get parent() {
      return this._routerState.parent(this);
    }
    get firstChild() {
      return this._routerState.firstChild(this);
    }
    get children() {
      return this._routerState.children(this);
    }
    get pathFromRoot() {
      return this._routerState.pathFromRoot(this);
    }
    get paramMap() {
      if (!this._paramMap) {
        this._paramMap = convertToParamMap(this.params);
      }
      return this._paramMap;
    }
    get queryParamMap() {
      if (!this._queryParamMap) {
        this._queryParamMap = convertToParamMap(this.queryParams);
      }
      return this._queryParamMap;
    }
    toString() {
      const url = this.url.map((segment) => segment.toString()).join("/");
      const matched = this.routeConfig ? this.routeConfig.path : "";
      return `Route(url:'${url}', path:'${matched}')`;
    }
  };
  var RouterStateSnapshot = class extends Tree {
    constructor(url, root) {
      super(root);
      this.url = url;
      setRouterState(this, root);
    }
    toString() {
      return serializeNode(this._root);
    }
  };
  function setRouterState(state, node) {
    node.value._routerState = state;
    node.children.forEach((c) => setRouterState(state, c));
  }
  function serializeNode(node) {
    const c = node.children.length > 0 ? ` { ${node.children.map(serializeNode).join(", ")} } ` : "";
    return `${node.value}${c}`;
  }
  function advanceActivatedRoute(route) {
    if (route.snapshot) {
      const currentSnapshot = route.snapshot;
      const nextSnapshot = route._futureSnapshot;
      route.snapshot = nextSnapshot;
      if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {
        route.queryParams.next(nextSnapshot.queryParams);
      }
      if (currentSnapshot.fragment !== nextSnapshot.fragment) {
        route.fragment.next(nextSnapshot.fragment);
      }
      if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {
        route.params.next(nextSnapshot.params);
      }
      if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {
        route.url.next(nextSnapshot.url);
      }
      if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {
        route.data.next(nextSnapshot.data);
      }
    } else {
      route.snapshot = route._futureSnapshot;
      route.data.next(route._futureSnapshot.data);
    }
  }
  function equalParamsAndUrlSegments(a, b) {
    const equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);
    const parentsMismatch = !a.parent !== !b.parent;
    return equalUrlParams && !parentsMismatch && (!a.parent || equalParamsAndUrlSegments(a.parent, b.parent));
  }
  function createRouterState(routeReuseStrategy, curr, prevState) {
    const root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : void 0);
    return new RouterState(root, curr);
  }
  function createNode(routeReuseStrategy, curr, prevState) {
    if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {
      const value = prevState.value;
      value._futureSnapshot = curr.value;
      const children = createOrReuseChildren(routeReuseStrategy, curr, prevState);
      return new TreeNode(value, children);
    } else {
      if (routeReuseStrategy.shouldAttach(curr.value)) {
        const detachedRouteHandle = routeReuseStrategy.retrieve(curr.value);
        if (detachedRouteHandle !== null) {
          const tree2 = detachedRouteHandle.route;
          tree2.value._futureSnapshot = curr.value;
          tree2.children = curr.children.map((c) => createNode(routeReuseStrategy, c));
          return tree2;
        }
      }
      const value = createActivatedRoute(curr.value);
      const children = curr.children.map((c) => createNode(routeReuseStrategy, c));
      return new TreeNode(value, children);
    }
  }
  function createOrReuseChildren(routeReuseStrategy, curr, prevState) {
    return curr.children.map((child) => {
      for (const p of prevState.children) {
        if (routeReuseStrategy.shouldReuseRoute(child.value, p.value.snapshot)) {
          return createNode(routeReuseStrategy, child, p);
        }
      }
      return createNode(routeReuseStrategy, child);
    });
  }
  function createActivatedRoute(c) {
    return new ActivatedRoute(new BehaviorSubject(c.url), new BehaviorSubject(c.params), new BehaviorSubject(c.queryParams), new BehaviorSubject(c.fragment), new BehaviorSubject(c.data), c.outlet, c.component, c);
  }
  function createUrlTree(route, urlTree, commands, queryParams, fragment) {
    if (commands.length === 0) {
      return tree(urlTree.root, urlTree.root, urlTree, queryParams, fragment);
    }
    const nav = computeNavigation(commands);
    if (nav.toRoot()) {
      return tree(urlTree.root, new UrlSegmentGroup([], {}), urlTree, queryParams, fragment);
    }
    const startingPosition = findStartingPosition(nav, urlTree, route);
    const segmentGroup = startingPosition.processChildren ? updateSegmentGroupChildren(startingPosition.segmentGroup, startingPosition.index, nav.commands) : updateSegmentGroup(startingPosition.segmentGroup, startingPosition.index, nav.commands);
    return tree(startingPosition.segmentGroup, segmentGroup, urlTree, queryParams, fragment);
  }
  function isMatrixParams(command) {
    return typeof command === "object" && command != null && !command.outlets && !command.segmentPath;
  }
  function isCommandWithOutlets(command) {
    return typeof command === "object" && command != null && command.outlets;
  }
  function tree(oldSegmentGroup, newSegmentGroup, urlTree, queryParams, fragment) {
    let qp = {};
    if (queryParams) {
      forEach(queryParams, (value, name) => {
        qp[name] = Array.isArray(value) ? value.map((v) => `${v}`) : `${value}`;
      });
    }
    if (urlTree.root === oldSegmentGroup) {
      return new UrlTree(newSegmentGroup, qp, fragment);
    }
    return new UrlTree(replaceSegment(urlTree.root, oldSegmentGroup, newSegmentGroup), qp, fragment);
  }
  function replaceSegment(current, oldSegment, newSegment) {
    const children = {};
    forEach(current.children, (c, outletName) => {
      if (c === oldSegment) {
        children[outletName] = newSegment;
      } else {
        children[outletName] = replaceSegment(c, oldSegment, newSegment);
      }
    });
    return new UrlSegmentGroup(current.segments, children);
  }
  var Navigation = class {
    constructor(isAbsolute, numberOfDoubleDots, commands) {
      this.isAbsolute = isAbsolute;
      this.numberOfDoubleDots = numberOfDoubleDots;
      this.commands = commands;
      if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {
        throw new Error("Root segment cannot have matrix parameters");
      }
      const cmdWithOutlet = commands.find(isCommandWithOutlets);
      if (cmdWithOutlet && cmdWithOutlet !== last3(commands)) {
        throw new Error("{outlets:{}} has to be the last command");
      }
    }
    toRoot() {
      return this.isAbsolute && this.commands.length === 1 && this.commands[0] == "/";
    }
  };
  function computeNavigation(commands) {
    if (typeof commands[0] === "string" && commands.length === 1 && commands[0] === "/") {
      return new Navigation(true, 0, commands);
    }
    let numberOfDoubleDots = 0;
    let isAbsolute = false;
    const res = commands.reduce((res2, cmd, cmdIdx) => {
      if (typeof cmd === "object" && cmd != null) {
        if (cmd.outlets) {
          const outlets = {};
          forEach(cmd.outlets, (commands2, name) => {
            outlets[name] = typeof commands2 === "string" ? commands2.split("/") : commands2;
          });
          return [...res2, { outlets }];
        }
        if (cmd.segmentPath) {
          return [...res2, cmd.segmentPath];
        }
      }
      if (!(typeof cmd === "string")) {
        return [...res2, cmd];
      }
      if (cmdIdx === 0) {
        cmd.split("/").forEach((urlPart, partIndex) => {
          if (partIndex == 0 && urlPart === ".") {
          } else if (partIndex == 0 && urlPart === "") {
            isAbsolute = true;
          } else if (urlPart === "..") {
            numberOfDoubleDots++;
          } else if (urlPart != "") {
            res2.push(urlPart);
          }
        });
        return res2;
      }
      return [...res2, cmd];
    }, []);
    return new Navigation(isAbsolute, numberOfDoubleDots, res);
  }
  var Position = class {
    constructor(segmentGroup, processChildren, index) {
      this.segmentGroup = segmentGroup;
      this.processChildren = processChildren;
      this.index = index;
    }
  };
  function findStartingPosition(nav, tree2, route) {
    if (nav.isAbsolute) {
      return new Position(tree2.root, true, 0);
    }
    if (route.snapshot._lastPathIndex === -1) {
      const segmentGroup = route.snapshot._urlSegment;
      const processChildren = segmentGroup === tree2.root;
      return new Position(segmentGroup, processChildren, 0);
    }
    const modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;
    const index = route.snapshot._lastPathIndex + modifier;
    return createPositionApplyingDoubleDots(route.snapshot._urlSegment, index, nav.numberOfDoubleDots);
  }
  function createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {
    let g = group;
    let ci = index;
    let dd = numberOfDoubleDots;
    while (dd > ci) {
      dd -= ci;
      g = g.parent;
      if (!g) {
        throw new Error("Invalid number of '../'");
      }
      ci = g.segments.length;
    }
    return new Position(g, false, ci - dd);
  }
  function getOutlets(commands) {
    if (isCommandWithOutlets(commands[0])) {
      return commands[0].outlets;
    }
    return { [PRIMARY_OUTLET]: commands };
  }
  function updateSegmentGroup(segmentGroup, startIndex, commands) {
    if (!segmentGroup) {
      segmentGroup = new UrlSegmentGroup([], {});
    }
    if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
      return updateSegmentGroupChildren(segmentGroup, startIndex, commands);
    }
    const m = prefixedWith(segmentGroup, startIndex, commands);
    const slicedCommands = commands.slice(m.commandIndex);
    if (m.match && m.pathIndex < segmentGroup.segments.length) {
      const g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});
      g.children[PRIMARY_OUTLET] = new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);
      return updateSegmentGroupChildren(g, 0, slicedCommands);
    } else if (m.match && slicedCommands.length === 0) {
      return new UrlSegmentGroup(segmentGroup.segments, {});
    } else if (m.match && !segmentGroup.hasChildren()) {
      return createNewSegmentGroup(segmentGroup, startIndex, commands);
    } else if (m.match) {
      return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);
    } else {
      return createNewSegmentGroup(segmentGroup, startIndex, commands);
    }
  }
  function updateSegmentGroupChildren(segmentGroup, startIndex, commands) {
    if (commands.length === 0) {
      return new UrlSegmentGroup(segmentGroup.segments, {});
    } else {
      const outlets = getOutlets(commands);
      const children = {};
      forEach(outlets, (commands2, outlet) => {
        if (typeof commands2 === "string") {
          commands2 = [commands2];
        }
        if (commands2 !== null) {
          children[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands2);
        }
      });
      forEach(segmentGroup.children, (child, childOutlet) => {
        if (outlets[childOutlet] === void 0) {
          children[childOutlet] = child;
        }
      });
      return new UrlSegmentGroup(segmentGroup.segments, children);
    }
  }
  function prefixedWith(segmentGroup, startIndex, commands) {
    let currentCommandIndex = 0;
    let currentPathIndex = startIndex;
    const noMatch2 = { match: false, pathIndex: 0, commandIndex: 0 };
    while (currentPathIndex < segmentGroup.segments.length) {
      if (currentCommandIndex >= commands.length)
        return noMatch2;
      const path = segmentGroup.segments[currentPathIndex];
      const command = commands[currentCommandIndex];
      if (isCommandWithOutlets(command)) {
        break;
      }
      const curr = `${command}`;
      const next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;
      if (currentPathIndex > 0 && curr === void 0)
        break;
      if (curr && next && typeof next === "object" && next.outlets === void 0) {
        if (!compare(curr, next, path))
          return noMatch2;
        currentCommandIndex += 2;
      } else {
        if (!compare(curr, {}, path))
          return noMatch2;
        currentCommandIndex++;
      }
      currentPathIndex++;
    }
    return { match: true, pathIndex: currentPathIndex, commandIndex: currentCommandIndex };
  }
  function createNewSegmentGroup(segmentGroup, startIndex, commands) {
    const paths = segmentGroup.segments.slice(0, startIndex);
    let i = 0;
    while (i < commands.length) {
      const command = commands[i];
      if (isCommandWithOutlets(command)) {
        const children = createNewSegmentChildren(command.outlets);
        return new UrlSegmentGroup(paths, children);
      }
      if (i === 0 && isMatrixParams(commands[0])) {
        const p = segmentGroup.segments[startIndex];
        paths.push(new UrlSegment(p.path, stringify3(commands[0])));
        i++;
        continue;
      }
      const curr = isCommandWithOutlets(command) ? command.outlets[PRIMARY_OUTLET] : `${command}`;
      const next = i < commands.length - 1 ? commands[i + 1] : null;
      if (curr && next && isMatrixParams(next)) {
        paths.push(new UrlSegment(curr, stringify3(next)));
        i += 2;
      } else {
        paths.push(new UrlSegment(curr, {}));
        i++;
      }
    }
    return new UrlSegmentGroup(paths, {});
  }
  function createNewSegmentChildren(outlets) {
    const children = {};
    forEach(outlets, (commands, outlet) => {
      if (typeof commands === "string") {
        commands = [commands];
      }
      if (commands !== null) {
        children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);
      }
    });
    return children;
  }
  function stringify3(params) {
    const res = {};
    forEach(params, (v, k) => res[k] = `${v}`);
    return res;
  }
  function compare(path, params, segment) {
    return path == segment.path && shallowEqual(params, segment.parameters);
  }
  var activateRoutes = (rootContexts, routeReuseStrategy, forwardEvent) => map((t) => {
    new ActivateRoutes(routeReuseStrategy, t.targetRouterState, t.currentRouterState, forwardEvent).activate(rootContexts);
    return t;
  });
  var ActivateRoutes = class {
    constructor(routeReuseStrategy, futureState, currState, forwardEvent) {
      this.routeReuseStrategy = routeReuseStrategy;
      this.futureState = futureState;
      this.currState = currState;
      this.forwardEvent = forwardEvent;
    }
    activate(parentContexts) {
      const futureRoot = this.futureState._root;
      const currRoot = this.currState ? this.currState._root : null;
      this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);
      advanceActivatedRoute(this.futureState.root);
      this.activateChildRoutes(futureRoot, currRoot, parentContexts);
    }
    deactivateChildRoutes(futureNode, currNode, contexts) {
      const children = nodeChildrenAsMap(currNode);
      futureNode.children.forEach((futureChild) => {
        const childOutletName = futureChild.value.outlet;
        this.deactivateRoutes(futureChild, children[childOutletName], contexts);
        delete children[childOutletName];
      });
      forEach(children, (v, childName) => {
        this.deactivateRouteAndItsChildren(v, contexts);
      });
    }
    deactivateRoutes(futureNode, currNode, parentContext) {
      const future = futureNode.value;
      const curr = currNode ? currNode.value : null;
      if (future === curr) {
        if (future.component) {
          const context2 = parentContext.getContext(future.outlet);
          if (context2) {
            this.deactivateChildRoutes(futureNode, currNode, context2.children);
          }
        } else {
          this.deactivateChildRoutes(futureNode, currNode, parentContext);
        }
      } else {
        if (curr) {
          this.deactivateRouteAndItsChildren(currNode, parentContext);
        }
      }
    }
    deactivateRouteAndItsChildren(route, parentContexts) {
      if (route.value.component && this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {
        this.detachAndStoreRouteSubtree(route, parentContexts);
      } else {
        this.deactivateRouteAndOutlet(route, parentContexts);
      }
    }
    detachAndStoreRouteSubtree(route, parentContexts) {
      const context2 = parentContexts.getContext(route.value.outlet);
      const contexts = context2 && route.value.component ? context2.children : parentContexts;
      const children = nodeChildrenAsMap(route);
      for (const childOutlet of Object.keys(children)) {
        this.deactivateRouteAndItsChildren(children[childOutlet], contexts);
      }
      if (context2 && context2.outlet) {
        const componentRef = context2.outlet.detach();
        const contexts2 = context2.children.onOutletDeactivated();
        this.routeReuseStrategy.store(route.value.snapshot, { componentRef, route, contexts: contexts2 });
      }
    }
    deactivateRouteAndOutlet(route, parentContexts) {
      const context2 = parentContexts.getContext(route.value.outlet);
      const contexts = context2 && route.value.component ? context2.children : parentContexts;
      const children = nodeChildrenAsMap(route);
      for (const childOutlet of Object.keys(children)) {
        this.deactivateRouteAndItsChildren(children[childOutlet], contexts);
      }
      if (context2 && context2.outlet) {
        context2.outlet.deactivate();
        context2.children.onOutletDeactivated();
        context2.attachRef = null;
        context2.resolver = null;
        context2.route = null;
      }
    }
    activateChildRoutes(futureNode, currNode, contexts) {
      const children = nodeChildrenAsMap(currNode);
      futureNode.children.forEach((c) => {
        this.activateRoutes(c, children[c.value.outlet], contexts);
        this.forwardEvent(new ActivationEnd(c.value.snapshot));
      });
      if (futureNode.children.length) {
        this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));
      }
    }
    activateRoutes(futureNode, currNode, parentContexts) {
      const future = futureNode.value;
      const curr = currNode ? currNode.value : null;
      advanceActivatedRoute(future);
      if (future === curr) {
        if (future.component) {
          const context2 = parentContexts.getOrCreateContext(future.outlet);
          this.activateChildRoutes(futureNode, currNode, context2.children);
        } else {
          this.activateChildRoutes(futureNode, currNode, parentContexts);
        }
      } else {
        if (future.component) {
          const context2 = parentContexts.getOrCreateContext(future.outlet);
          if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {
            const stored = this.routeReuseStrategy.retrieve(future.snapshot);
            this.routeReuseStrategy.store(future.snapshot, null);
            context2.children.onOutletReAttached(stored.contexts);
            context2.attachRef = stored.componentRef;
            context2.route = stored.route.value;
            if (context2.outlet) {
              context2.outlet.attach(stored.componentRef, stored.route.value);
            }
            advanceActivatedRoute(stored.route.value);
            this.activateChildRoutes(futureNode, null, context2.children);
          } else {
            const config2 = parentLoadedConfig(future.snapshot);
            const cmpFactoryResolver = config2 ? config2.module.componentFactoryResolver : null;
            context2.attachRef = null;
            context2.route = future;
            context2.resolver = cmpFactoryResolver;
            if (context2.outlet) {
              context2.outlet.activateWith(future, cmpFactoryResolver);
            }
            this.activateChildRoutes(futureNode, null, context2.children);
          }
        } else {
          this.activateChildRoutes(futureNode, null, parentContexts);
        }
      }
    }
  };
  function parentLoadedConfig(snapshot) {
    for (let s = snapshot.parent; s; s = s.parent) {
      const route = s.routeConfig;
      if (route && route._loadedConfig)
        return route._loadedConfig;
      if (route && route.component)
        return null;
    }
    return null;
  }
  var LoadedRouterConfig = class {
    constructor(routes, module) {
      this.routes = routes;
      this.module = module;
    }
  };
  function isFunction2(v) {
    return typeof v === "function";
  }
  function isBoolean(v) {
    return typeof v === "boolean";
  }
  function isUrlTree(v) {
    return v instanceof UrlTree;
  }
  function isCanLoad(guard) {
    return guard && isFunction2(guard.canLoad);
  }
  function isCanActivate(guard) {
    return guard && isFunction2(guard.canActivate);
  }
  function isCanActivateChild(guard) {
    return guard && isFunction2(guard.canActivateChild);
  }
  function isCanDeactivate(guard) {
    return guard && isFunction2(guard.canDeactivate);
  }
  var INITIAL_VALUE = Symbol("INITIAL_VALUE");
  function prioritizedGuardValue() {
    return switchMap((obs) => {
      return combineLatest(obs.map((o) => o.pipe(take(1), startWith(INITIAL_VALUE)))).pipe(scan((acc, list) => {
        let isPending = false;
        return list.reduce((innerAcc, val, i) => {
          if (innerAcc !== INITIAL_VALUE)
            return innerAcc;
          if (val === INITIAL_VALUE)
            isPending = true;
          if (!isPending) {
            if (val === false)
              return val;
            if (i === list.length - 1 || isUrlTree(val)) {
              return val;
            }
          }
          return innerAcc;
        }, acc);
      }, INITIAL_VALUE), filter((item) => item !== INITIAL_VALUE), map((item) => isUrlTree(item) ? item : item === true), take(1));
    });
  }
  var OutletContext = class {
    constructor() {
      this.outlet = null;
      this.route = null;
      this.resolver = null;
      this.children = new ChildrenOutletContexts();
      this.attachRef = null;
    }
  };
  var ChildrenOutletContexts = class {
    constructor() {
      this.contexts = /* @__PURE__ */ new Map();
    }
    onChildOutletCreated(childName, outlet) {
      const context2 = this.getOrCreateContext(childName);
      context2.outlet = outlet;
      this.contexts.set(childName, context2);
    }
    onChildOutletDestroyed(childName) {
      const context2 = this.getContext(childName);
      if (context2) {
        context2.outlet = null;
        context2.attachRef = null;
      }
    }
    onOutletDeactivated() {
      const contexts = this.contexts;
      this.contexts = /* @__PURE__ */ new Map();
      return contexts;
    }
    onOutletReAttached(contexts) {
      this.contexts = contexts;
    }
    getOrCreateContext(childName) {
      let context2 = this.getContext(childName);
      if (!context2) {
        context2 = new OutletContext();
        this.contexts.set(childName, context2);
      }
      return context2;
    }
    getContext(childName) {
      return this.contexts.get(childName) || null;
    }
  };
  var RouterOutlet = class {
    constructor(parentContexts, location2, resolver, name, changeDetector) {
      this.parentContexts = parentContexts;
      this.location = location2;
      this.resolver = resolver;
      this.changeDetector = changeDetector;
      this.activated = null;
      this._activatedRoute = null;
      this.activateEvents = new EventEmitter();
      this.deactivateEvents = new EventEmitter();
      this.attachEvents = new EventEmitter();
      this.detachEvents = new EventEmitter();
      this.name = name || PRIMARY_OUTLET;
      parentContexts.onChildOutletCreated(this.name, this);
    }
    ngOnDestroy() {
      this.parentContexts.onChildOutletDestroyed(this.name);
    }
    ngOnInit() {
      if (!this.activated) {
        const context2 = this.parentContexts.getContext(this.name);
        if (context2 && context2.route) {
          if (context2.attachRef) {
            this.attach(context2.attachRef, context2.route);
          } else {
            this.activateWith(context2.route, context2.resolver || null);
          }
        }
      }
    }
    get isActivated() {
      return !!this.activated;
    }
    get component() {
      if (!this.activated)
        throw new Error("Outlet is not activated");
      return this.activated.instance;
    }
    get activatedRoute() {
      if (!this.activated)
        throw new Error("Outlet is not activated");
      return this._activatedRoute;
    }
    get activatedRouteData() {
      if (this._activatedRoute) {
        return this._activatedRoute.snapshot.data;
      }
      return {};
    }
    detach() {
      if (!this.activated)
        throw new Error("Outlet is not activated");
      this.location.detach();
      const cmp = this.activated;
      this.activated = null;
      this._activatedRoute = null;
      this.detachEvents.emit(cmp.instance);
      return cmp;
    }
    attach(ref, activatedRoute) {
      this.activated = ref;
      this._activatedRoute = activatedRoute;
      this.location.insert(ref.hostView);
      this.attachEvents.emit(ref.instance);
    }
    deactivate() {
      if (this.activated) {
        const c = this.component;
        this.activated.destroy();
        this.activated = null;
        this._activatedRoute = null;
        this.deactivateEvents.emit(c);
      }
    }
    activateWith(activatedRoute, resolver) {
      if (this.isActivated) {
        throw new Error("Cannot activate an already activated outlet");
      }
      this._activatedRoute = activatedRoute;
      const snapshot = activatedRoute._futureSnapshot;
      const component = snapshot.routeConfig.component;
      resolver = resolver || this.resolver;
      const factory = resolver.resolveComponentFactory(component);
      const childContexts = this.parentContexts.getOrCreateContext(this.name).children;
      const injector = new OutletInjector(activatedRoute, childContexts, this.location.injector);
      this.activated = this.location.createComponent(factory, this.location.length, injector);
      this.changeDetector.markForCheck();
      this.activateEvents.emit(this.activated.instance);
    }
  };
  RouterOutlet.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: RouterOutlet, deps: [{ token: ChildrenOutletContexts }, { token: ViewContainerRef }, { token: ComponentFactoryResolver$1 }, { token: "name", attribute: true }, { token: ChangeDetectorRef }], target: FactoryTarget.Directive });
  RouterOutlet.\u0275dir = \u0275\u0275ngDeclareDirective({ minVersion: "12.0.0", version: "13.0.3", type: RouterOutlet, selector: "router-outlet", outputs: { activateEvents: "activate", deactivateEvents: "deactivate", attachEvents: "attach", detachEvents: "detach" }, exportAs: ["outlet"], ngImport: core_exports });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: RouterOutlet, decorators: [{
    type: Directive,
    args: [{ selector: "router-outlet", exportAs: "outlet" }]
  }], ctorParameters: function() {
    return [{ type: ChildrenOutletContexts }, { type: ViewContainerRef }, { type: ComponentFactoryResolver$1 }, { type: void 0, decorators: [{
      type: Attribute,
      args: ["name"]
    }] }, { type: ChangeDetectorRef }];
  }, propDecorators: { activateEvents: [{
    type: Output,
    args: ["activate"]
  }], deactivateEvents: [{
    type: Output,
    args: ["deactivate"]
  }], attachEvents: [{
    type: Output,
    args: ["attach"]
  }], detachEvents: [{
    type: Output,
    args: ["detach"]
  }] } });
  var OutletInjector = class {
    constructor(route, childContexts, parent) {
      this.route = route;
      this.childContexts = childContexts;
      this.parent = parent;
    }
    get(token, notFoundValue) {
      if (token === ActivatedRoute) {
        return this.route;
      }
      if (token === ChildrenOutletContexts) {
        return this.childContexts;
      }
      return this.parent.get(token, notFoundValue);
    }
  };
  var \u0275EmptyOutletComponent = class {
  };
  \u0275EmptyOutletComponent.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: \u0275EmptyOutletComponent, deps: [], target: FactoryTarget.Component });
  \u0275EmptyOutletComponent.\u0275cmp = \u0275\u0275ngDeclareComponent({ minVersion: "12.0.0", version: "13.0.3", type: \u0275EmptyOutletComponent, selector: "ng-component", ngImport: core_exports, template: `<router-outlet></router-outlet>`, isInline: true, directives: [{ type: RouterOutlet, selector: "router-outlet", outputs: ["activate", "deactivate", "attach", "detach"], exportAs: ["outlet"] }] });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: \u0275EmptyOutletComponent, decorators: [{
    type: Component,
    args: [{ template: `<router-outlet></router-outlet>` }]
  }] });
  function validateConfig(config2, parentPath = "") {
    for (let i = 0; i < config2.length; i++) {
      const route = config2[i];
      const fullPath = getFullPath(parentPath, route);
      validateNode(route, fullPath);
    }
  }
  function validateNode(route, fullPath) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (!route) {
        throw new Error(`
      Invalid configuration of route '${fullPath}': Encountered undefined route.
      The reason might be an extra comma.

      Example:
      const routes: Routes = [
        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },
        { path: 'dashboard',  component: DashboardComponent },, << two commas
        { path: 'detail/:id', component: HeroDetailComponent }
      ];
    `);
      }
      if (Array.isArray(route)) {
        throw new Error(`Invalid configuration of route '${fullPath}': Array cannot be specified`);
      }
      if (!route.component && !route.children && !route.loadChildren && (route.outlet && route.outlet !== PRIMARY_OUTLET)) {
        throw new Error(`Invalid configuration of route '${fullPath}': a componentless route without children or loadChildren cannot have a named outlet set`);
      }
      if (route.redirectTo && route.children) {
        throw new Error(`Invalid configuration of route '${fullPath}': redirectTo and children cannot be used together`);
      }
      if (route.redirectTo && route.loadChildren) {
        throw new Error(`Invalid configuration of route '${fullPath}': redirectTo and loadChildren cannot be used together`);
      }
      if (route.children && route.loadChildren) {
        throw new Error(`Invalid configuration of route '${fullPath}': children and loadChildren cannot be used together`);
      }
      if (route.redirectTo && route.component) {
        throw new Error(`Invalid configuration of route '${fullPath}': redirectTo and component cannot be used together`);
      }
      if (route.redirectTo && route.canActivate) {
        throw new Error(`Invalid configuration of route '${fullPath}': redirectTo and canActivate cannot be used together. Redirects happen before activation so canActivate will never be executed.`);
      }
      if (route.path && route.matcher) {
        throw new Error(`Invalid configuration of route '${fullPath}': path and matcher cannot be used together`);
      }
      if (route.redirectTo === void 0 && !route.component && !route.children && !route.loadChildren) {
        throw new Error(`Invalid configuration of route '${fullPath}'. One of the following must be provided: component, redirectTo, children or loadChildren`);
      }
      if (route.path === void 0 && route.matcher === void 0) {
        throw new Error(`Invalid configuration of route '${fullPath}': routes must have either a path or a matcher specified`);
      }
      if (typeof route.path === "string" && route.path.charAt(0) === "/") {
        throw new Error(`Invalid configuration of route '${fullPath}': path cannot start with a slash`);
      }
      if (route.path === "" && route.redirectTo !== void 0 && route.pathMatch === void 0) {
        const exp = `The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`;
        throw new Error(`Invalid configuration of route '{path: "${fullPath}", redirectTo: "${route.redirectTo}"}': please provide 'pathMatch'. ${exp}`);
      }
      if (route.pathMatch !== void 0 && route.pathMatch !== "full" && route.pathMatch !== "prefix") {
        throw new Error(`Invalid configuration of route '${fullPath}': pathMatch can only be set to 'prefix' or 'full'`);
      }
    }
    if (route.children) {
      validateConfig(route.children, fullPath);
    }
  }
  function getFullPath(parentPath, currentRoute) {
    if (!currentRoute) {
      return parentPath;
    }
    if (!parentPath && !currentRoute.path) {
      return "";
    } else if (parentPath && !currentRoute.path) {
      return `${parentPath}/`;
    } else if (!parentPath && currentRoute.path) {
      return currentRoute.path;
    } else {
      return `${parentPath}/${currentRoute.path}`;
    }
  }
  function standardizeConfig(r) {
    const children = r.children && r.children.map(standardizeConfig);
    const c = children ? { ...r, children } : { ...r };
    if (!c.component && (children || c.loadChildren) && (c.outlet && c.outlet !== PRIMARY_OUTLET)) {
      c.component = \u0275EmptyOutletComponent;
    }
    return c;
  }
  function getOutlet(route) {
    return route.outlet || PRIMARY_OUTLET;
  }
  function sortByMatchingOutlets(routes, outletName) {
    const sortedConfig = routes.filter((r) => getOutlet(r) === outletName);
    sortedConfig.push(...routes.filter((r) => getOutlet(r) !== outletName));
    return sortedConfig;
  }
  var noMatch$1 = {
    matched: false,
    consumedSegments: [],
    lastChild: 0,
    parameters: {},
    positionalParamSegments: {}
  };
  function match(segmentGroup, route, segments) {
    if (route.path === "") {
      if (route.pathMatch === "full" && (segmentGroup.hasChildren() || segments.length > 0)) {
        return { ...noMatch$1 };
      }
      return {
        matched: true,
        consumedSegments: [],
        lastChild: 0,
        parameters: {},
        positionalParamSegments: {}
      };
    }
    const matcher = route.matcher || defaultUrlMatcher;
    const res = matcher(segments, segmentGroup, route);
    if (!res)
      return { ...noMatch$1 };
    const posParams = {};
    forEach(res.posParams, (v, k) => {
      posParams[k] = v.path;
    });
    const parameters = res.consumed.length > 0 ? { ...posParams, ...res.consumed[res.consumed.length - 1].parameters } : posParams;
    return {
      matched: true,
      consumedSegments: res.consumed,
      lastChild: res.consumed.length,
      parameters,
      positionalParamSegments: res.posParams ?? {}
    };
  }
  function split(segmentGroup, consumedSegments, slicedSegments, config2, relativeLinkResolution = "corrected") {
    if (slicedSegments.length > 0 && containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config2)) {
      const s2 = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(segmentGroup, consumedSegments, config2, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));
      s2._sourceSegment = segmentGroup;
      s2._segmentIndexShift = consumedSegments.length;
      return { segmentGroup: s2, slicedSegments: [] };
    }
    if (slicedSegments.length === 0 && containsEmptyPathMatches(segmentGroup, slicedSegments, config2)) {
      const s2 = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, consumedSegments, slicedSegments, config2, segmentGroup.children, relativeLinkResolution));
      s2._sourceSegment = segmentGroup;
      s2._segmentIndexShift = consumedSegments.length;
      return { segmentGroup: s2, slicedSegments };
    }
    const s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);
    s._sourceSegment = segmentGroup;
    s._segmentIndexShift = consumedSegments.length;
    return { segmentGroup: s, slicedSegments };
  }
  function addEmptyPathsToChildrenIfNeeded(segmentGroup, consumedSegments, slicedSegments, routes, children, relativeLinkResolution) {
    const res = {};
    for (const r of routes) {
      if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {
        const s = new UrlSegmentGroup([], {});
        s._sourceSegment = segmentGroup;
        if (relativeLinkResolution === "legacy") {
          s._segmentIndexShift = segmentGroup.segments.length;
        } else {
          s._segmentIndexShift = consumedSegments.length;
        }
        res[getOutlet(r)] = s;
      }
    }
    return { ...children, ...res };
  }
  function createChildrenForEmptyPaths(segmentGroup, consumedSegments, routes, primarySegment) {
    const res = {};
    res[PRIMARY_OUTLET] = primarySegment;
    primarySegment._sourceSegment = segmentGroup;
    primarySegment._segmentIndexShift = consumedSegments.length;
    for (const r of routes) {
      if (r.path === "" && getOutlet(r) !== PRIMARY_OUTLET) {
        const s = new UrlSegmentGroup([], {});
        s._sourceSegment = segmentGroup;
        s._segmentIndexShift = consumedSegments.length;
        res[getOutlet(r)] = s;
      }
    }
    return res;
  }
  function containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes) {
    return routes.some((r) => emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet(r) !== PRIMARY_OUTLET);
  }
  function containsEmptyPathMatches(segmentGroup, slicedSegments, routes) {
    return routes.some((r) => emptyPathMatch(segmentGroup, slicedSegments, r));
  }
  function emptyPathMatch(segmentGroup, slicedSegments, r) {
    if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === "full") {
      return false;
    }
    return r.path === "";
  }
  function isImmediateMatch(route, rawSegment, segments, outlet) {
    if (getOutlet(route) !== outlet && (outlet === PRIMARY_OUTLET || !emptyPathMatch(rawSegment, segments, route))) {
      return false;
    }
    if (route.path === "**") {
      return true;
    }
    return match(rawSegment, route, segments).matched;
  }
  function noLeftoversInUrl(segmentGroup, segments, outlet) {
    return segments.length === 0 && !segmentGroup.children[outlet];
  }
  var NoMatch$1 = class {
    constructor(segmentGroup) {
      this.segmentGroup = segmentGroup || null;
    }
  };
  var AbsoluteRedirect = class {
    constructor(urlTree) {
      this.urlTree = urlTree;
    }
  };
  function noMatch(segmentGroup) {
    return new Observable((obs) => obs.error(new NoMatch$1(segmentGroup)));
  }
  function absoluteRedirect(newTree) {
    return new Observable((obs) => obs.error(new AbsoluteRedirect(newTree)));
  }
  function namedOutletsRedirect(redirectTo) {
    return new Observable((obs) => obs.error(new Error(`Only absolute redirects can have named outlets. redirectTo: '${redirectTo}'`)));
  }
  function canLoadFails(route) {
    return new Observable((obs) => obs.error(navigationCancelingError(`Cannot load children because the guard of the route "path: '${route.path}'" returned false`)));
  }
  function applyRedirects$1(moduleInjector, configLoader, urlSerializer, urlTree, config2) {
    return new ApplyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config2).apply();
  }
  var ApplyRedirects = class {
    constructor(moduleInjector, configLoader, urlSerializer, urlTree, config2) {
      this.configLoader = configLoader;
      this.urlSerializer = urlSerializer;
      this.urlTree = urlTree;
      this.config = config2;
      this.allowRedirects = true;
      this.ngModule = moduleInjector.get(NgModuleRef$1);
    }
    apply() {
      const splitGroup = split(this.urlTree.root, [], [], this.config).segmentGroup;
      const rootSegmentGroup = new UrlSegmentGroup(splitGroup.segments, splitGroup.children);
      const expanded$ = this.expandSegmentGroup(this.ngModule, this.config, rootSegmentGroup, PRIMARY_OUTLET);
      const urlTrees$ = expanded$.pipe(map((rootSegmentGroup2) => {
        return this.createUrlTree(squashSegmentGroup(rootSegmentGroup2), this.urlTree.queryParams, this.urlTree.fragment);
      }));
      return urlTrees$.pipe(catchError((e) => {
        if (e instanceof AbsoluteRedirect) {
          this.allowRedirects = false;
          return this.match(e.urlTree);
        }
        if (e instanceof NoMatch$1) {
          throw this.noMatchError(e);
        }
        throw e;
      }));
    }
    match(tree2) {
      const expanded$ = this.expandSegmentGroup(this.ngModule, this.config, tree2.root, PRIMARY_OUTLET);
      const mapped$ = expanded$.pipe(map((rootSegmentGroup) => {
        return this.createUrlTree(squashSegmentGroup(rootSegmentGroup), tree2.queryParams, tree2.fragment);
      }));
      return mapped$.pipe(catchError((e) => {
        if (e instanceof NoMatch$1) {
          throw this.noMatchError(e);
        }
        throw e;
      }));
    }
    noMatchError(e) {
      return new Error(`Cannot match any routes. URL Segment: '${e.segmentGroup}'`);
    }
    createUrlTree(rootCandidate, queryParams, fragment) {
      const root = rootCandidate.segments.length > 0 ? new UrlSegmentGroup([], { [PRIMARY_OUTLET]: rootCandidate }) : rootCandidate;
      return new UrlTree(root, queryParams, fragment);
    }
    expandSegmentGroup(ngModule, routes, segmentGroup, outlet) {
      if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
        return this.expandChildren(ngModule, routes, segmentGroup).pipe(map((children) => new UrlSegmentGroup([], children)));
      }
      return this.expandSegment(ngModule, segmentGroup, routes, segmentGroup.segments, outlet, true);
    }
    expandChildren(ngModule, routes, segmentGroup) {
      const childOutlets = [];
      for (const child of Object.keys(segmentGroup.children)) {
        if (child === "primary") {
          childOutlets.unshift(child);
        } else {
          childOutlets.push(child);
        }
      }
      return from(childOutlets).pipe(concatMap((childOutlet) => {
        const child = segmentGroup.children[childOutlet];
        const sortedRoutes = sortByMatchingOutlets(routes, childOutlet);
        return this.expandSegmentGroup(ngModule, sortedRoutes, child, childOutlet).pipe(map((s) => ({ segment: s, outlet: childOutlet })));
      }), scan((children, expandedChild) => {
        children[expandedChild.outlet] = expandedChild.segment;
        return children;
      }, {}), last2());
    }
    expandSegment(ngModule, segmentGroup, routes, segments, outlet, allowRedirects) {
      return from(routes).pipe(concatMap((r) => {
        const expanded$ = this.expandSegmentAgainstRoute(ngModule, segmentGroup, routes, r, segments, outlet, allowRedirects);
        return expanded$.pipe(catchError((e) => {
          if (e instanceof NoMatch$1) {
            return of(null);
          }
          throw e;
        }));
      }), first((s) => !!s), catchError((e, _) => {
        if (e instanceof EmptyError || e.name === "EmptyError") {
          if (noLeftoversInUrl(segmentGroup, segments, outlet)) {
            return of(new UrlSegmentGroup([], {}));
          }
          throw new NoMatch$1(segmentGroup);
        }
        throw e;
      }));
    }
    expandSegmentAgainstRoute(ngModule, segmentGroup, routes, route, paths, outlet, allowRedirects) {
      if (!isImmediateMatch(route, segmentGroup, paths, outlet)) {
        return noMatch(segmentGroup);
      }
      if (route.redirectTo === void 0) {
        return this.matchSegmentAgainstRoute(ngModule, segmentGroup, route, paths, outlet);
      }
      if (allowRedirects && this.allowRedirects) {
        return this.expandSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, paths, outlet);
      }
      return noMatch(segmentGroup);
    }
    expandSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, segments, outlet) {
      if (route.path === "**") {
        return this.expandWildCardWithParamsAgainstRouteUsingRedirect(ngModule, routes, route, outlet);
      }
      return this.expandRegularSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, segments, outlet);
    }
    expandWildCardWithParamsAgainstRouteUsingRedirect(ngModule, routes, route, outlet) {
      const newTree = this.applyRedirectCommands([], route.redirectTo, {});
      if (route.redirectTo.startsWith("/")) {
        return absoluteRedirect(newTree);
      }
      return this.lineralizeSegments(route, newTree).pipe(mergeMap((newSegments) => {
        const group = new UrlSegmentGroup(newSegments, {});
        return this.expandSegment(ngModule, group, routes, newSegments, outlet, false);
      }));
    }
    expandRegularSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, segments, outlet) {
      const { matched, consumedSegments, lastChild, positionalParamSegments } = match(segmentGroup, route, segments);
      if (!matched)
        return noMatch(segmentGroup);
      const newTree = this.applyRedirectCommands(consumedSegments, route.redirectTo, positionalParamSegments);
      if (route.redirectTo.startsWith("/")) {
        return absoluteRedirect(newTree);
      }
      return this.lineralizeSegments(route, newTree).pipe(mergeMap((newSegments) => {
        return this.expandSegment(ngModule, segmentGroup, routes, newSegments.concat(segments.slice(lastChild)), outlet, false);
      }));
    }
    matchSegmentAgainstRoute(ngModule, rawSegmentGroup, route, segments, outlet) {
      if (route.path === "**") {
        if (route.loadChildren) {
          const loaded$ = route._loadedConfig ? of(route._loadedConfig) : this.configLoader.load(ngModule.injector, route);
          return loaded$.pipe(map((cfg) => {
            route._loadedConfig = cfg;
            return new UrlSegmentGroup(segments, {});
          }));
        }
        return of(new UrlSegmentGroup(segments, {}));
      }
      const { matched, consumedSegments, lastChild } = match(rawSegmentGroup, route, segments);
      if (!matched)
        return noMatch(rawSegmentGroup);
      const rawSlicedSegments = segments.slice(lastChild);
      const childConfig$ = this.getChildConfig(ngModule, route, segments);
      return childConfig$.pipe(mergeMap((routerConfig) => {
        const childModule = routerConfig.module;
        const childConfig = routerConfig.routes;
        const { segmentGroup: splitSegmentGroup, slicedSegments } = split(rawSegmentGroup, consumedSegments, rawSlicedSegments, childConfig);
        const segmentGroup = new UrlSegmentGroup(splitSegmentGroup.segments, splitSegmentGroup.children);
        if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {
          const expanded$2 = this.expandChildren(childModule, childConfig, segmentGroup);
          return expanded$2.pipe(map((children) => new UrlSegmentGroup(consumedSegments, children)));
        }
        if (childConfig.length === 0 && slicedSegments.length === 0) {
          return of(new UrlSegmentGroup(consumedSegments, {}));
        }
        const matchedOnOutlet = getOutlet(route) === outlet;
        const expanded$ = this.expandSegment(childModule, segmentGroup, childConfig, slicedSegments, matchedOnOutlet ? PRIMARY_OUTLET : outlet, true);
        return expanded$.pipe(map((cs) => new UrlSegmentGroup(consumedSegments.concat(cs.segments), cs.children)));
      }));
    }
    getChildConfig(ngModule, route, segments) {
      if (route.children) {
        return of(new LoadedRouterConfig(route.children, ngModule));
      }
      if (route.loadChildren) {
        if (route._loadedConfig !== void 0) {
          return of(route._loadedConfig);
        }
        return this.runCanLoadGuards(ngModule.injector, route, segments).pipe(mergeMap((shouldLoadResult) => {
          if (shouldLoadResult) {
            return this.configLoader.load(ngModule.injector, route).pipe(map((cfg) => {
              route._loadedConfig = cfg;
              return cfg;
            }));
          }
          return canLoadFails(route);
        }));
      }
      return of(new LoadedRouterConfig([], ngModule));
    }
    runCanLoadGuards(moduleInjector, route, segments) {
      const canLoad = route.canLoad;
      if (!canLoad || canLoad.length === 0)
        return of(true);
      const canLoadObservables = canLoad.map((injectionToken) => {
        const guard = moduleInjector.get(injectionToken);
        let guardVal;
        if (isCanLoad(guard)) {
          guardVal = guard.canLoad(route, segments);
        } else if (isFunction2(guard)) {
          guardVal = guard(route, segments);
        } else {
          throw new Error("Invalid CanLoad guard");
        }
        return wrapIntoObservable(guardVal);
      });
      return of(canLoadObservables).pipe(prioritizedGuardValue(), tap((result) => {
        if (!isUrlTree(result))
          return;
        const error3 = navigationCancelingError(`Redirecting to "${this.urlSerializer.serialize(result)}"`);
        error3.url = result;
        throw error3;
      }), map((result) => result === true));
    }
    lineralizeSegments(route, urlTree) {
      let res = [];
      let c = urlTree.root;
      while (true) {
        res = res.concat(c.segments);
        if (c.numberOfChildren === 0) {
          return of(res);
        }
        if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {
          return namedOutletsRedirect(route.redirectTo);
        }
        c = c.children[PRIMARY_OUTLET];
      }
    }
    applyRedirectCommands(segments, redirectTo, posParams) {
      return this.applyRedirectCreatreUrlTree(redirectTo, this.urlSerializer.parse(redirectTo), segments, posParams);
    }
    applyRedirectCreatreUrlTree(redirectTo, urlTree, segments, posParams) {
      const newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);
      return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);
    }
    createQueryParams(redirectToParams, actualParams) {
      const res = {};
      forEach(redirectToParams, (v, k) => {
        const copySourceValue = typeof v === "string" && v.startsWith(":");
        if (copySourceValue) {
          const sourceName = v.substring(1);
          res[k] = actualParams[sourceName];
        } else {
          res[k] = v;
        }
      });
      return res;
    }
    createSegmentGroup(redirectTo, group, segments, posParams) {
      const updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);
      let children = {};
      forEach(group.children, (child, name) => {
        children[name] = this.createSegmentGroup(redirectTo, child, segments, posParams);
      });
      return new UrlSegmentGroup(updatedSegments, children);
    }
    createSegments(redirectTo, redirectToSegments, actualSegments, posParams) {
      return redirectToSegments.map((s) => s.path.startsWith(":") ? this.findPosParam(redirectTo, s, posParams) : this.findOrReturn(s, actualSegments));
    }
    findPosParam(redirectTo, redirectToUrlSegment, posParams) {
      const pos = posParams[redirectToUrlSegment.path.substring(1)];
      if (!pos)
        throw new Error(`Cannot redirect to '${redirectTo}'. Cannot find '${redirectToUrlSegment.path}'.`);
      return pos;
    }
    findOrReturn(redirectToUrlSegment, actualSegments) {
      let idx = 0;
      for (const s of actualSegments) {
        if (s.path === redirectToUrlSegment.path) {
          actualSegments.splice(idx);
          return s;
        }
        idx++;
      }
      return redirectToUrlSegment;
    }
  };
  function mergeTrivialChildren(s) {
    if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {
      const c = s.children[PRIMARY_OUTLET];
      return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);
    }
    return s;
  }
  function squashSegmentGroup(segmentGroup) {
    const newChildren = {};
    for (const childOutlet of Object.keys(segmentGroup.children)) {
      const child = segmentGroup.children[childOutlet];
      const childCandidate = squashSegmentGroup(child);
      if (childCandidate.segments.length > 0 || childCandidate.hasChildren()) {
        newChildren[childOutlet] = childCandidate;
      }
    }
    const s = new UrlSegmentGroup(segmentGroup.segments, newChildren);
    return mergeTrivialChildren(s);
  }
  function applyRedirects(moduleInjector, configLoader, urlSerializer, config2) {
    return switchMap((t) => applyRedirects$1(moduleInjector, configLoader, urlSerializer, t.extractedUrl, config2).pipe(map((urlAfterRedirects) => ({ ...t, urlAfterRedirects }))));
  }
  var CanActivate = class {
    constructor(path) {
      this.path = path;
      this.route = this.path[this.path.length - 1];
    }
  };
  var CanDeactivate = class {
    constructor(component, route) {
      this.component = component;
      this.route = route;
    }
  };
  function getAllRouteGuards(future, curr, parentContexts) {
    const futureRoot = future._root;
    const currRoot = curr ? curr._root : null;
    return getChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);
  }
  function getCanActivateChild(p) {
    const canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;
    if (!canActivateChild || canActivateChild.length === 0)
      return null;
    return { node: p, guards: canActivateChild };
  }
  function getToken(token, snapshot, moduleInjector) {
    const config2 = getClosestLoadedConfig(snapshot);
    const injector = config2 ? config2.module.injector : moduleInjector;
    return injector.get(token);
  }
  function getClosestLoadedConfig(snapshot) {
    if (!snapshot)
      return null;
    for (let s = snapshot.parent; s; s = s.parent) {
      const route = s.routeConfig;
      if (route && route._loadedConfig)
        return route._loadedConfig;
    }
    return null;
  }
  function getChildRouteGuards(futureNode, currNode, contexts, futurePath, checks = {
    canDeactivateChecks: [],
    canActivateChecks: []
  }) {
    const prevChildren = nodeChildrenAsMap(currNode);
    futureNode.children.forEach((c) => {
      getRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]), checks);
      delete prevChildren[c.value.outlet];
    });
    forEach(prevChildren, (v, k) => deactivateRouteAndItsChildren(v, contexts.getContext(k), checks));
    return checks;
  }
  function getRouteGuards(futureNode, currNode, parentContexts, futurePath, checks = {
    canDeactivateChecks: [],
    canActivateChecks: []
  }) {
    const future = futureNode.value;
    const curr = currNode ? currNode.value : null;
    const context2 = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;
    if (curr && future.routeConfig === curr.routeConfig) {
      const shouldRun = shouldRunGuardsAndResolvers(curr, future, future.routeConfig.runGuardsAndResolvers);
      if (shouldRun) {
        checks.canActivateChecks.push(new CanActivate(futurePath));
      } else {
        future.data = curr.data;
        future._resolvedData = curr._resolvedData;
      }
      if (future.component) {
        getChildRouteGuards(futureNode, currNode, context2 ? context2.children : null, futurePath, checks);
      } else {
        getChildRouteGuards(futureNode, currNode, parentContexts, futurePath, checks);
      }
      if (shouldRun && context2 && context2.outlet && context2.outlet.isActivated) {
        checks.canDeactivateChecks.push(new CanDeactivate(context2.outlet.component, curr));
      }
    } else {
      if (curr) {
        deactivateRouteAndItsChildren(currNode, context2, checks);
      }
      checks.canActivateChecks.push(new CanActivate(futurePath));
      if (future.component) {
        getChildRouteGuards(futureNode, null, context2 ? context2.children : null, futurePath, checks);
      } else {
        getChildRouteGuards(futureNode, null, parentContexts, futurePath, checks);
      }
    }
    return checks;
  }
  function shouldRunGuardsAndResolvers(curr, future, mode) {
    if (typeof mode === "function") {
      return mode(curr, future);
    }
    switch (mode) {
      case "pathParamsChange":
        return !equalPath(curr.url, future.url);
      case "pathParamsOrQueryParamsChange":
        return !equalPath(curr.url, future.url) || !shallowEqual(curr.queryParams, future.queryParams);
      case "always":
        return true;
      case "paramsOrQueryParamsChange":
        return !equalParamsAndUrlSegments(curr, future) || !shallowEqual(curr.queryParams, future.queryParams);
      case "paramsChange":
      default:
        return !equalParamsAndUrlSegments(curr, future);
    }
  }
  function deactivateRouteAndItsChildren(route, context2, checks) {
    const children = nodeChildrenAsMap(route);
    const r = route.value;
    forEach(children, (node, childName) => {
      if (!r.component) {
        deactivateRouteAndItsChildren(node, context2, checks);
      } else if (context2) {
        deactivateRouteAndItsChildren(node, context2.children.getContext(childName), checks);
      } else {
        deactivateRouteAndItsChildren(node, null, checks);
      }
    });
    if (!r.component) {
      checks.canDeactivateChecks.push(new CanDeactivate(null, r));
    } else if (context2 && context2.outlet && context2.outlet.isActivated) {
      checks.canDeactivateChecks.push(new CanDeactivate(context2.outlet.component, r));
    } else {
      checks.canDeactivateChecks.push(new CanDeactivate(null, r));
    }
  }
  function checkGuards(moduleInjector, forwardEvent) {
    return mergeMap((t) => {
      const { targetSnapshot, currentSnapshot, guards: { canActivateChecks, canDeactivateChecks } } = t;
      if (canDeactivateChecks.length === 0 && canActivateChecks.length === 0) {
        return of({ ...t, guardsResult: true });
      }
      return runCanDeactivateChecks(canDeactivateChecks, targetSnapshot, currentSnapshot, moduleInjector).pipe(mergeMap((canDeactivate) => {
        return canDeactivate && isBoolean(canDeactivate) ? runCanActivateChecks(targetSnapshot, canActivateChecks, moduleInjector, forwardEvent) : of(canDeactivate);
      }), map((guardsResult) => ({ ...t, guardsResult })));
    });
  }
  function runCanDeactivateChecks(checks, futureRSS, currRSS, moduleInjector) {
    return from(checks).pipe(mergeMap((check) => runCanDeactivate(check.component, check.route, currRSS, futureRSS, moduleInjector)), first((result) => {
      return result !== true;
    }, true));
  }
  function runCanActivateChecks(futureSnapshot, checks, moduleInjector, forwardEvent) {
    return from(checks).pipe(concatMap((check) => {
      return concat(fireChildActivationStart(check.route.parent, forwardEvent), fireActivationStart(check.route, forwardEvent), runCanActivateChild(futureSnapshot, check.path, moduleInjector), runCanActivate(futureSnapshot, check.route, moduleInjector));
    }), first((result) => {
      return result !== true;
    }, true));
  }
  function fireActivationStart(snapshot, forwardEvent) {
    if (snapshot !== null && forwardEvent) {
      forwardEvent(new ActivationStart(snapshot));
    }
    return of(true);
  }
  function fireChildActivationStart(snapshot, forwardEvent) {
    if (snapshot !== null && forwardEvent) {
      forwardEvent(new ChildActivationStart(snapshot));
    }
    return of(true);
  }
  function runCanActivate(futureRSS, futureARS, moduleInjector) {
    const canActivate = futureARS.routeConfig ? futureARS.routeConfig.canActivate : null;
    if (!canActivate || canActivate.length === 0)
      return of(true);
    const canActivateObservables = canActivate.map((c) => {
      return defer(() => {
        const guard = getToken(c, futureARS, moduleInjector);
        let observable2;
        if (isCanActivate(guard)) {
          observable2 = wrapIntoObservable(guard.canActivate(futureARS, futureRSS));
        } else if (isFunction2(guard)) {
          observable2 = wrapIntoObservable(guard(futureARS, futureRSS));
        } else {
          throw new Error("Invalid CanActivate guard");
        }
        return observable2.pipe(first());
      });
    });
    return of(canActivateObservables).pipe(prioritizedGuardValue());
  }
  function runCanActivateChild(futureRSS, path, moduleInjector) {
    const futureARS = path[path.length - 1];
    const canActivateChildGuards = path.slice(0, path.length - 1).reverse().map((p) => getCanActivateChild(p)).filter((_) => _ !== null);
    const canActivateChildGuardsMapped = canActivateChildGuards.map((d) => {
      return defer(() => {
        const guardsMapped = d.guards.map((c) => {
          const guard = getToken(c, d.node, moduleInjector);
          let observable2;
          if (isCanActivateChild(guard)) {
            observable2 = wrapIntoObservable(guard.canActivateChild(futureARS, futureRSS));
          } else if (isFunction2(guard)) {
            observable2 = wrapIntoObservable(guard(futureARS, futureRSS));
          } else {
            throw new Error("Invalid CanActivateChild guard");
          }
          return observable2.pipe(first());
        });
        return of(guardsMapped).pipe(prioritizedGuardValue());
      });
    });
    return of(canActivateChildGuardsMapped).pipe(prioritizedGuardValue());
  }
  function runCanDeactivate(component, currARS, currRSS, futureRSS, moduleInjector) {
    const canDeactivate = currARS && currARS.routeConfig ? currARS.routeConfig.canDeactivate : null;
    if (!canDeactivate || canDeactivate.length === 0)
      return of(true);
    const canDeactivateObservables = canDeactivate.map((c) => {
      const guard = getToken(c, currARS, moduleInjector);
      let observable2;
      if (isCanDeactivate(guard)) {
        observable2 = wrapIntoObservable(guard.canDeactivate(component, currARS, currRSS, futureRSS));
      } else if (isFunction2(guard)) {
        observable2 = wrapIntoObservable(guard(component, currARS, currRSS, futureRSS));
      } else {
        throw new Error("Invalid CanDeactivate guard");
      }
      return observable2.pipe(first());
    });
    return of(canDeactivateObservables).pipe(prioritizedGuardValue());
  }
  var NoMatch = class {
  };
  function newObservableError(e) {
    return new Observable((obs) => obs.error(e));
  }
  function recognize$1(rootComponentType, config2, urlTree, url, paramsInheritanceStrategy = "emptyOnly", relativeLinkResolution = "legacy") {
    try {
      const result = new Recognizer(rootComponentType, config2, urlTree, url, paramsInheritanceStrategy, relativeLinkResolution).recognize();
      if (result === null) {
        return newObservableError(new NoMatch());
      } else {
        return of(result);
      }
    } catch (e) {
      return newObservableError(e);
    }
  }
  var Recognizer = class {
    constructor(rootComponentType, config2, urlTree, url, paramsInheritanceStrategy, relativeLinkResolution) {
      this.rootComponentType = rootComponentType;
      this.config = config2;
      this.urlTree = urlTree;
      this.url = url;
      this.paramsInheritanceStrategy = paramsInheritanceStrategy;
      this.relativeLinkResolution = relativeLinkResolution;
    }
    recognize() {
      const rootSegmentGroup = split(this.urlTree.root, [], [], this.config.filter((c) => c.redirectTo === void 0), this.relativeLinkResolution).segmentGroup;
      const children = this.processSegmentGroup(this.config, rootSegmentGroup, PRIMARY_OUTLET);
      if (children === null) {
        return null;
      }
      const root = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, {}, PRIMARY_OUTLET, this.rootComponentType, null, this.urlTree.root, -1, {});
      const rootNode = new TreeNode(root, children);
      const routeState = new RouterStateSnapshot(this.url, rootNode);
      this.inheritParamsAndData(routeState._root);
      return routeState;
    }
    inheritParamsAndData(routeNode) {
      const route = routeNode.value;
      const i = inheritedParamsDataResolve(route, this.paramsInheritanceStrategy);
      route.params = Object.freeze(i.params);
      route.data = Object.freeze(i.data);
      routeNode.children.forEach((n) => this.inheritParamsAndData(n));
    }
    processSegmentGroup(config2, segmentGroup, outlet) {
      if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
        return this.processChildren(config2, segmentGroup);
      }
      return this.processSegment(config2, segmentGroup, segmentGroup.segments, outlet);
    }
    processChildren(config2, segmentGroup) {
      const children = [];
      for (const childOutlet of Object.keys(segmentGroup.children)) {
        const child = segmentGroup.children[childOutlet];
        const sortedConfig = sortByMatchingOutlets(config2, childOutlet);
        const outletChildren = this.processSegmentGroup(sortedConfig, child, childOutlet);
        if (outletChildren === null) {
          return null;
        }
        children.push(...outletChildren);
      }
      const mergedChildren = mergeEmptyPathMatches(children);
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        checkOutletNameUniqueness(mergedChildren);
      }
      sortActivatedRouteSnapshots(mergedChildren);
      return mergedChildren;
    }
    processSegment(config2, segmentGroup, segments, outlet) {
      for (const r of config2) {
        const children = this.processSegmentAgainstRoute(r, segmentGroup, segments, outlet);
        if (children !== null) {
          return children;
        }
      }
      if (noLeftoversInUrl(segmentGroup, segments, outlet)) {
        return [];
      }
      return null;
    }
    processSegmentAgainstRoute(route, rawSegment, segments, outlet) {
      if (route.redirectTo || !isImmediateMatch(route, rawSegment, segments, outlet))
        return null;
      let snapshot;
      let consumedSegments = [];
      let rawSlicedSegments = [];
      if (route.path === "**") {
        const params = segments.length > 0 ? last3(segments).parameters : {};
        snapshot = new ActivatedRouteSnapshot(segments, params, Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, getData(route), getOutlet(route), route.component, route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + segments.length, getResolve(route));
      } else {
        const result = match(rawSegment, route, segments);
        if (!result.matched) {
          return null;
        }
        consumedSegments = result.consumedSegments;
        rawSlicedSegments = segments.slice(result.lastChild);
        snapshot = new ActivatedRouteSnapshot(consumedSegments, result.parameters, Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, getData(route), getOutlet(route), route.component, route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + consumedSegments.length, getResolve(route));
      }
      const childConfig = getChildConfig(route);
      const { segmentGroup, slicedSegments } = split(rawSegment, consumedSegments, rawSlicedSegments, childConfig.filter((c) => c.redirectTo === void 0), this.relativeLinkResolution);
      if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {
        const children2 = this.processChildren(childConfig, segmentGroup);
        if (children2 === null) {
          return null;
        }
        return [new TreeNode(snapshot, children2)];
      }
      if (childConfig.length === 0 && slicedSegments.length === 0) {
        return [new TreeNode(snapshot, [])];
      }
      const matchedOnOutlet = getOutlet(route) === outlet;
      const children = this.processSegment(childConfig, segmentGroup, slicedSegments, matchedOnOutlet ? PRIMARY_OUTLET : outlet);
      if (children === null) {
        return null;
      }
      return [new TreeNode(snapshot, children)];
    }
  };
  function sortActivatedRouteSnapshots(nodes) {
    nodes.sort((a, b) => {
      if (a.value.outlet === PRIMARY_OUTLET)
        return -1;
      if (b.value.outlet === PRIMARY_OUTLET)
        return 1;
      return a.value.outlet.localeCompare(b.value.outlet);
    });
  }
  function getChildConfig(route) {
    if (route.children) {
      return route.children;
    }
    if (route.loadChildren) {
      return route._loadedConfig.routes;
    }
    return [];
  }
  function hasEmptyPathConfig(node) {
    const config2 = node.value.routeConfig;
    return config2 && config2.path === "" && config2.redirectTo === void 0;
  }
  function mergeEmptyPathMatches(nodes) {
    const result = [];
    const mergedNodes = /* @__PURE__ */ new Set();
    for (const node of nodes) {
      if (!hasEmptyPathConfig(node)) {
        result.push(node);
        continue;
      }
      const duplicateEmptyPathNode = result.find((resultNode) => node.value.routeConfig === resultNode.value.routeConfig);
      if (duplicateEmptyPathNode !== void 0) {
        duplicateEmptyPathNode.children.push(...node.children);
        mergedNodes.add(duplicateEmptyPathNode);
      } else {
        result.push(node);
      }
    }
    for (const mergedNode of mergedNodes) {
      const mergedChildren = mergeEmptyPathMatches(mergedNode.children);
      result.push(new TreeNode(mergedNode.value, mergedChildren));
    }
    return result.filter((n) => !mergedNodes.has(n));
  }
  function checkOutletNameUniqueness(nodes) {
    const names = {};
    nodes.forEach((n) => {
      const routeWithSameOutletName = names[n.value.outlet];
      if (routeWithSameOutletName) {
        const p = routeWithSameOutletName.url.map((s) => s.toString()).join("/");
        const c = n.value.url.map((s) => s.toString()).join("/");
        throw new Error(`Two segments cannot have the same outlet name: '${p}' and '${c}'.`);
      }
      names[n.value.outlet] = n.value;
    });
  }
  function getSourceSegmentGroup(segmentGroup) {
    let s = segmentGroup;
    while (s._sourceSegment) {
      s = s._sourceSegment;
    }
    return s;
  }
  function getPathIndexShift(segmentGroup) {
    let s = segmentGroup;
    let res = s._segmentIndexShift ? s._segmentIndexShift : 0;
    while (s._sourceSegment) {
      s = s._sourceSegment;
      res += s._segmentIndexShift ? s._segmentIndexShift : 0;
    }
    return res - 1;
  }
  function getData(route) {
    return route.data || {};
  }
  function getResolve(route) {
    return route.resolve || {};
  }
  function recognize(rootComponentType, config2, serializer2, paramsInheritanceStrategy, relativeLinkResolution) {
    return mergeMap((t) => recognize$1(rootComponentType, config2, t.urlAfterRedirects, serializer2(t.urlAfterRedirects), paramsInheritanceStrategy, relativeLinkResolution).pipe(map((targetSnapshot) => ({ ...t, targetSnapshot }))));
  }
  function resolveData(paramsInheritanceStrategy, moduleInjector) {
    return mergeMap((t) => {
      const { targetSnapshot, guards: { canActivateChecks } } = t;
      if (!canActivateChecks.length) {
        return of(t);
      }
      let canActivateChecksResolved = 0;
      return from(canActivateChecks).pipe(concatMap((check) => runResolve(check.route, targetSnapshot, paramsInheritanceStrategy, moduleInjector)), tap(() => canActivateChecksResolved++), takeLast(1), mergeMap((_) => canActivateChecksResolved === canActivateChecks.length ? of(t) : EMPTY));
    });
  }
  function runResolve(futureARS, futureRSS, paramsInheritanceStrategy, moduleInjector) {
    const resolve = futureARS._resolve;
    return resolveNode(resolve, futureARS, futureRSS, moduleInjector).pipe(map((resolvedData) => {
      futureARS._resolvedData = resolvedData;
      futureARS.data = {
        ...futureARS.data,
        ...inheritedParamsDataResolve(futureARS, paramsInheritanceStrategy).resolve
      };
      return null;
    }));
  }
  function resolveNode(resolve, futureARS, futureRSS, moduleInjector) {
    const keys = Object.keys(resolve);
    if (keys.length === 0) {
      return of({});
    }
    const data = {};
    return from(keys).pipe(mergeMap((key) => getResolver(resolve[key], futureARS, futureRSS, moduleInjector).pipe(tap((value) => {
      data[key] = value;
    }))), takeLast(1), mergeMap(() => {
      if (Object.keys(data).length === keys.length) {
        return of(data);
      }
      return EMPTY;
    }));
  }
  function getResolver(injectionToken, futureARS, futureRSS, moduleInjector) {
    const resolver = getToken(injectionToken, futureARS, moduleInjector);
    return resolver.resolve ? wrapIntoObservable(resolver.resolve(futureARS, futureRSS)) : wrapIntoObservable(resolver(futureARS, futureRSS));
  }
  function switchTap(next) {
    return switchMap((v) => {
      const nextResult = next(v);
      if (nextResult) {
        return from(nextResult).pipe(map(() => v));
      }
      return of(v);
    });
  }
  var RouteReuseStrategy = class {
  };
  var BaseRouteReuseStrategy = class {
    shouldDetach(route) {
      return false;
    }
    store(route, detachedTree) {
    }
    shouldAttach(route) {
      return false;
    }
    retrieve(route) {
      return null;
    }
    shouldReuseRoute(future, curr) {
      return future.routeConfig === curr.routeConfig;
    }
  };
  var DefaultRouteReuseStrategy = class extends BaseRouteReuseStrategy {
  };
  var ROUTES = new InjectionToken("ROUTES");
  var RouterConfigLoader = class {
    constructor(injector, compiler, onLoadStartListener, onLoadEndListener) {
      this.injector = injector;
      this.compiler = compiler;
      this.onLoadStartListener = onLoadStartListener;
      this.onLoadEndListener = onLoadEndListener;
    }
    load(parentInjector, route) {
      if (route._loader$) {
        return route._loader$;
      }
      if (this.onLoadStartListener) {
        this.onLoadStartListener(route);
      }
      const moduleFactory$ = this.loadModuleFactory(route.loadChildren);
      const loadRunner = moduleFactory$.pipe(map((factory) => {
        if (this.onLoadEndListener) {
          this.onLoadEndListener(route);
        }
        const module = factory.create(parentInjector);
        return new LoadedRouterConfig(flatten4(module.injector.get(ROUTES, void 0, InjectFlags.Self | InjectFlags.Optional)).map(standardizeConfig), module);
      }), catchError((err) => {
        route._loader$ = void 0;
        throw err;
      }));
      route._loader$ = new ConnectableObservable(loadRunner, () => new Subject()).pipe(refCount());
      return route._loader$;
    }
    loadModuleFactory(loadChildren) {
      return wrapIntoObservable(loadChildren()).pipe(mergeMap((t) => {
        if (t instanceof NgModuleFactory$1) {
          return of(t);
        } else {
          return from(this.compiler.compileModuleAsync(t));
        }
      }));
    }
  };
  var UrlHandlingStrategy = class {
  };
  var DefaultUrlHandlingStrategy = class {
    shouldProcessUrl(url) {
      return true;
    }
    extract(url) {
      return url;
    }
    merge(newUrlPart, wholeUrl) {
      return newUrlPart;
    }
  };
  function defaultErrorHandler2(error3) {
    throw error3;
  }
  function defaultMalformedUriErrorHandler(error3, urlSerializer, url) {
    return urlSerializer.parse("/");
  }
  function defaultRouterHook(snapshot, runExtras) {
    return of(null);
  }
  var exactMatchOptions = {
    paths: "exact",
    fragment: "ignored",
    matrixParams: "ignored",
    queryParams: "exact"
  };
  var subsetMatchOptions = {
    paths: "subset",
    fragment: "ignored",
    matrixParams: "ignored",
    queryParams: "subset"
  };
  var Router = class {
    constructor(rootComponentType, urlSerializer, rootContexts, location2, injector, compiler, config2) {
      this.rootComponentType = rootComponentType;
      this.urlSerializer = urlSerializer;
      this.rootContexts = rootContexts;
      this.location = location2;
      this.config = config2;
      this.lastSuccessfulNavigation = null;
      this.currentNavigation = null;
      this.disposed = false;
      this.navigationId = 0;
      this.currentPageId = 0;
      this.isNgZoneEnabled = false;
      this.events = new Subject();
      this.errorHandler = defaultErrorHandler2;
      this.malformedUriErrorHandler = defaultMalformedUriErrorHandler;
      this.navigated = false;
      this.lastSuccessfulId = -1;
      this.hooks = { beforePreactivation: defaultRouterHook, afterPreactivation: defaultRouterHook };
      this.urlHandlingStrategy = new DefaultUrlHandlingStrategy();
      this.routeReuseStrategy = new DefaultRouteReuseStrategy();
      this.onSameUrlNavigation = "ignore";
      this.paramsInheritanceStrategy = "emptyOnly";
      this.urlUpdateStrategy = "deferred";
      this.relativeLinkResolution = "corrected";
      this.canceledNavigationResolution = "replace";
      const onLoadStart = (r) => this.triggerEvent(new RouteConfigLoadStart(r));
      const onLoadEnd = (r) => this.triggerEvent(new RouteConfigLoadEnd(r));
      this.ngModule = injector.get(NgModuleRef$1);
      this.console = injector.get(Console);
      const ngZone = injector.get(NgZone);
      this.isNgZoneEnabled = ngZone instanceof NgZone && NgZone.isInAngularZone();
      this.resetConfig(config2);
      this.currentUrlTree = createEmptyUrlTree();
      this.rawUrlTree = this.currentUrlTree;
      this.browserUrlTree = this.currentUrlTree;
      this.configLoader = new RouterConfigLoader(injector, compiler, onLoadStart, onLoadEnd);
      this.routerState = createEmptyState(this.currentUrlTree, this.rootComponentType);
      this.transitions = new BehaviorSubject({
        id: 0,
        targetPageId: 0,
        currentUrlTree: this.currentUrlTree,
        currentRawUrl: this.currentUrlTree,
        extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree),
        urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree),
        rawUrl: this.currentUrlTree,
        extras: {},
        resolve: null,
        reject: null,
        promise: Promise.resolve(true),
        source: "imperative",
        restoredState: null,
        currentSnapshot: this.routerState.snapshot,
        targetSnapshot: null,
        currentRouterState: this.routerState,
        targetRouterState: null,
        guards: { canActivateChecks: [], canDeactivateChecks: [] },
        guardsResult: null
      });
      this.navigations = this.setupNavigations(this.transitions);
      this.processNavigations();
    }
    get browserPageId() {
      return this.location.getState()?.\u0275routerPageId;
    }
    setupNavigations(transitions) {
      const eventsSubject = this.events;
      return transitions.pipe(filter((t) => t.id !== 0), map((t) => ({ ...t, extractedUrl: this.urlHandlingStrategy.extract(t.rawUrl) })), switchMap((t) => {
        let completed = false;
        let errored = false;
        return of(t).pipe(tap((t2) => {
          this.currentNavigation = {
            id: t2.id,
            initialUrl: t2.currentRawUrl,
            extractedUrl: t2.extractedUrl,
            trigger: t2.source,
            extras: t2.extras,
            previousNavigation: this.lastSuccessfulNavigation ? { ...this.lastSuccessfulNavigation, previousNavigation: null } : null
          };
        }), switchMap((t2) => {
          const browserUrlTree = this.browserUrlTree.toString();
          const urlTransition = !this.navigated || t2.extractedUrl.toString() !== browserUrlTree || browserUrlTree !== this.currentUrlTree.toString();
          const processCurrentUrl = (this.onSameUrlNavigation === "reload" ? true : urlTransition) && this.urlHandlingStrategy.shouldProcessUrl(t2.rawUrl);
          if (processCurrentUrl) {
            if (isBrowserTriggeredNavigation(t2.source)) {
              this.browserUrlTree = t2.extractedUrl;
            }
            return of(t2).pipe(switchMap((t3) => {
              const transition = this.transitions.getValue();
              eventsSubject.next(new NavigationStart(t3.id, this.serializeUrl(t3.extractedUrl), t3.source, t3.restoredState));
              if (transition !== this.transitions.getValue()) {
                return EMPTY;
              }
              return Promise.resolve(t3);
            }), applyRedirects(this.ngModule.injector, this.configLoader, this.urlSerializer, this.config), tap((t3) => {
              this.currentNavigation = {
                ...this.currentNavigation,
                finalUrl: t3.urlAfterRedirects
              };
            }), recognize(this.rootComponentType, this.config, (url) => this.serializeUrl(url), this.paramsInheritanceStrategy, this.relativeLinkResolution), tap((t3) => {
              if (this.urlUpdateStrategy === "eager") {
                if (!t3.extras.skipLocationChange) {
                  const rawUrl = this.urlHandlingStrategy.merge(t3.urlAfterRedirects, t3.rawUrl);
                  this.setBrowserUrl(rawUrl, t3);
                }
                this.browserUrlTree = t3.urlAfterRedirects;
              }
              const routesRecognized = new RoutesRecognized(t3.id, this.serializeUrl(t3.extractedUrl), this.serializeUrl(t3.urlAfterRedirects), t3.targetSnapshot);
              eventsSubject.next(routesRecognized);
            }));
          } else {
            const processPreviousUrl = urlTransition && this.rawUrlTree && this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree);
            if (processPreviousUrl) {
              const { id, extractedUrl, source, restoredState, extras } = t2;
              const navStart = new NavigationStart(id, this.serializeUrl(extractedUrl), source, restoredState);
              eventsSubject.next(navStart);
              const targetSnapshot = createEmptyState(extractedUrl, this.rootComponentType).snapshot;
              return of({
                ...t2,
                targetSnapshot,
                urlAfterRedirects: extractedUrl,
                extras: { ...extras, skipLocationChange: false, replaceUrl: false }
              });
            } else {
              this.rawUrlTree = t2.rawUrl;
              t2.resolve(null);
              return EMPTY;
            }
          }
        }), switchTap((t2) => {
          const { targetSnapshot, id: navigationId, extractedUrl: appliedUrlTree, rawUrl: rawUrlTree, extras: { skipLocationChange, replaceUrl } } = t2;
          return this.hooks.beforePreactivation(targetSnapshot, {
            navigationId,
            appliedUrlTree,
            rawUrlTree,
            skipLocationChange: !!skipLocationChange,
            replaceUrl: !!replaceUrl
          });
        }), tap((t2) => {
          const guardsStart = new GuardsCheckStart(t2.id, this.serializeUrl(t2.extractedUrl), this.serializeUrl(t2.urlAfterRedirects), t2.targetSnapshot);
          this.triggerEvent(guardsStart);
        }), map((t2) => ({
          ...t2,
          guards: getAllRouteGuards(t2.targetSnapshot, t2.currentSnapshot, this.rootContexts)
        })), checkGuards(this.ngModule.injector, (evt) => this.triggerEvent(evt)), tap((t2) => {
          if (isUrlTree(t2.guardsResult)) {
            const error3 = navigationCancelingError(`Redirecting to "${this.serializeUrl(t2.guardsResult)}"`);
            error3.url = t2.guardsResult;
            throw error3;
          }
          const guardsEnd = new GuardsCheckEnd(t2.id, this.serializeUrl(t2.extractedUrl), this.serializeUrl(t2.urlAfterRedirects), t2.targetSnapshot, !!t2.guardsResult);
          this.triggerEvent(guardsEnd);
        }), filter((t2) => {
          if (!t2.guardsResult) {
            this.restoreHistory(t2);
            this.cancelNavigationTransition(t2, "");
            return false;
          }
          return true;
        }), switchTap((t2) => {
          if (t2.guards.canActivateChecks.length) {
            return of(t2).pipe(tap((t3) => {
              const resolveStart = new ResolveStart(t3.id, this.serializeUrl(t3.extractedUrl), this.serializeUrl(t3.urlAfterRedirects), t3.targetSnapshot);
              this.triggerEvent(resolveStart);
            }), switchMap((t3) => {
              let dataResolved = false;
              return of(t3).pipe(resolveData(this.paramsInheritanceStrategy, this.ngModule.injector), tap({
                next: () => dataResolved = true,
                complete: () => {
                  if (!dataResolved) {
                    this.restoreHistory(t3);
                    this.cancelNavigationTransition(t3, `At least one route resolver didn't emit any value.`);
                  }
                }
              }));
            }), tap((t3) => {
              const resolveEnd = new ResolveEnd(t3.id, this.serializeUrl(t3.extractedUrl), this.serializeUrl(t3.urlAfterRedirects), t3.targetSnapshot);
              this.triggerEvent(resolveEnd);
            }));
          }
          return void 0;
        }), switchTap((t2) => {
          const { targetSnapshot, id: navigationId, extractedUrl: appliedUrlTree, rawUrl: rawUrlTree, extras: { skipLocationChange, replaceUrl } } = t2;
          return this.hooks.afterPreactivation(targetSnapshot, {
            navigationId,
            appliedUrlTree,
            rawUrlTree,
            skipLocationChange: !!skipLocationChange,
            replaceUrl: !!replaceUrl
          });
        }), map((t2) => {
          const targetRouterState = createRouterState(this.routeReuseStrategy, t2.targetSnapshot, t2.currentRouterState);
          return { ...t2, targetRouterState };
        }), tap((t2) => {
          this.currentUrlTree = t2.urlAfterRedirects;
          this.rawUrlTree = this.urlHandlingStrategy.merge(t2.urlAfterRedirects, t2.rawUrl);
          this.routerState = t2.targetRouterState;
          if (this.urlUpdateStrategy === "deferred") {
            if (!t2.extras.skipLocationChange) {
              this.setBrowserUrl(this.rawUrlTree, t2);
            }
            this.browserUrlTree = t2.urlAfterRedirects;
          }
        }), activateRoutes(this.rootContexts, this.routeReuseStrategy, (evt) => this.triggerEvent(evt)), tap({
          next() {
            completed = true;
          },
          complete() {
            completed = true;
          }
        }), finalize(() => {
          if (!completed && !errored) {
            const cancelationReason = `Navigation ID ${t.id} is not equal to the current navigation id ${this.navigationId}`;
            this.cancelNavigationTransition(t, cancelationReason);
          }
          if (this.currentNavigation?.id === t.id) {
            this.currentNavigation = null;
          }
        }), catchError((e) => {
          errored = true;
          if (isNavigationCancelingError(e)) {
            const redirecting = isUrlTree(e.url);
            if (!redirecting) {
              this.navigated = true;
              this.restoreHistory(t, true);
            }
            const navCancel = new NavigationCancel(t.id, this.serializeUrl(t.extractedUrl), e.message);
            eventsSubject.next(navCancel);
            if (!redirecting) {
              t.resolve(false);
            } else {
              setTimeout(() => {
                const mergedTree = this.urlHandlingStrategy.merge(e.url, this.rawUrlTree);
                const extras = {
                  skipLocationChange: t.extras.skipLocationChange,
                  replaceUrl: this.urlUpdateStrategy === "eager" || isBrowserTriggeredNavigation(t.source)
                };
                this.scheduleNavigation(mergedTree, "imperative", null, extras, { resolve: t.resolve, reject: t.reject, promise: t.promise });
              }, 0);
            }
          } else {
            this.restoreHistory(t, true);
            const navError = new NavigationError(t.id, this.serializeUrl(t.extractedUrl), e);
            eventsSubject.next(navError);
            try {
              t.resolve(this.errorHandler(e));
            } catch (ee) {
              t.reject(ee);
            }
          }
          return EMPTY;
        }));
      }));
    }
    resetRootComponentType(rootComponentType) {
      this.rootComponentType = rootComponentType;
      this.routerState.root.component = this.rootComponentType;
    }
    setTransition(t) {
      this.transitions.next({ ...this.transitions.value, ...t });
    }
    initialNavigation() {
      this.setUpLocationChangeListener();
      if (this.navigationId === 0) {
        this.navigateByUrl(this.location.path(true), { replaceUrl: true });
      }
    }
    setUpLocationChangeListener() {
      if (!this.locationSubscription) {
        this.locationSubscription = this.location.subscribe((event) => {
          const source = event["type"] === "popstate" ? "popstate" : "hashchange";
          if (source === "popstate") {
            setTimeout(() => {
              const extras = { replaceUrl: true };
              const state = event.state?.navigationId ? event.state : null;
              if (state) {
                const stateCopy = { ...state };
                delete stateCopy.navigationId;
                delete stateCopy.\u0275routerPageId;
                if (Object.keys(stateCopy).length !== 0) {
                  extras.state = stateCopy;
                }
              }
              const urlTree = this.parseUrl(event["url"]);
              this.scheduleNavigation(urlTree, source, state, extras);
            }, 0);
          }
        });
      }
    }
    get url() {
      return this.serializeUrl(this.currentUrlTree);
    }
    getCurrentNavigation() {
      return this.currentNavigation;
    }
    triggerEvent(event) {
      this.events.next(event);
    }
    resetConfig(config2) {
      validateConfig(config2);
      this.config = config2.map(standardizeConfig);
      this.navigated = false;
      this.lastSuccessfulId = -1;
    }
    ngOnDestroy() {
      this.dispose();
    }
    dispose() {
      this.transitions.complete();
      if (this.locationSubscription) {
        this.locationSubscription.unsubscribe();
        this.locationSubscription = void 0;
      }
      this.disposed = true;
    }
    createUrlTree(commands, navigationExtras = {}) {
      const { relativeTo, queryParams, fragment, queryParamsHandling, preserveFragment } = navigationExtras;
      const a = relativeTo || this.routerState.root;
      const f = preserveFragment ? this.currentUrlTree.fragment : fragment;
      let q = null;
      switch (queryParamsHandling) {
        case "merge":
          q = { ...this.currentUrlTree.queryParams, ...queryParams };
          break;
        case "preserve":
          q = this.currentUrlTree.queryParams;
          break;
        default:
          q = queryParams || null;
      }
      if (q !== null) {
        q = this.removeEmptyProps(q);
      }
      return createUrlTree(a, this.currentUrlTree, commands, q, f ?? null);
    }
    navigateByUrl(url, extras = {
      skipLocationChange: false
    }) {
      if (typeof ngDevMode === "undefined" || ngDevMode && this.isNgZoneEnabled && !NgZone.isInAngularZone()) {
        this.console.warn(`Navigation triggered outside Angular zone, did you forget to call 'ngZone.run()'?`);
      }
      const urlTree = isUrlTree(url) ? url : this.parseUrl(url);
      const mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);
      return this.scheduleNavigation(mergedTree, "imperative", null, extras);
    }
    navigate(commands, extras = { skipLocationChange: false }) {
      validateCommands(commands);
      return this.navigateByUrl(this.createUrlTree(commands, extras), extras);
    }
    serializeUrl(url) {
      return this.urlSerializer.serialize(url);
    }
    parseUrl(url) {
      let urlTree;
      try {
        urlTree = this.urlSerializer.parse(url);
      } catch (e) {
        urlTree = this.malformedUriErrorHandler(e, this.urlSerializer, url);
      }
      return urlTree;
    }
    isActive(url, matchOptions) {
      let options;
      if (matchOptions === true) {
        options = { ...exactMatchOptions };
      } else if (matchOptions === false) {
        options = { ...subsetMatchOptions };
      } else {
        options = matchOptions;
      }
      if (isUrlTree(url)) {
        return containsTree(this.currentUrlTree, url, options);
      }
      const urlTree = this.parseUrl(url);
      return containsTree(this.currentUrlTree, urlTree, options);
    }
    removeEmptyProps(params) {
      return Object.keys(params).reduce((result, key) => {
        const value = params[key];
        if (value !== null && value !== void 0) {
          result[key] = value;
        }
        return result;
      }, {});
    }
    processNavigations() {
      this.navigations.subscribe((t) => {
        this.navigated = true;
        this.lastSuccessfulId = t.id;
        this.currentPageId = t.targetPageId;
        this.events.next(new NavigationEnd(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(this.currentUrlTree)));
        this.lastSuccessfulNavigation = this.currentNavigation;
        t.resolve(true);
      }, (e) => {
        this.console.warn(`Unhandled Navigation Error: ${e}`);
      });
    }
    scheduleNavigation(rawUrl, source, restoredState, extras, priorPromise) {
      if (this.disposed) {
        return Promise.resolve(false);
      }
      const lastNavigation = this.transitions.value;
      const browserNavPrecededByRouterNav = isBrowserTriggeredNavigation(source) && lastNavigation && !isBrowserTriggeredNavigation(lastNavigation.source);
      const navToSameUrl = lastNavigation.rawUrl.toString() === rawUrl.toString();
      const lastNavigationInProgress = lastNavigation.id === this.currentNavigation?.id;
      const isDuplicateNav = navToSameUrl && lastNavigationInProgress;
      if (browserNavPrecededByRouterNav && isDuplicateNav) {
        return Promise.resolve(true);
      }
      let resolve;
      let reject;
      let promise2;
      if (priorPromise) {
        resolve = priorPromise.resolve;
        reject = priorPromise.reject;
        promise2 = priorPromise.promise;
      } else {
        promise2 = new Promise((res, rej) => {
          resolve = res;
          reject = rej;
        });
      }
      const id = ++this.navigationId;
      let targetPageId;
      if (this.canceledNavigationResolution === "computed") {
        const isInitialPage = this.currentPageId === 0;
        if (isInitialPage) {
          restoredState = this.location.getState();
        }
        if (restoredState && restoredState.\u0275routerPageId) {
          targetPageId = restoredState.\u0275routerPageId;
        } else {
          if (extras.replaceUrl || extras.skipLocationChange) {
            targetPageId = this.browserPageId ?? 0;
          } else {
            targetPageId = (this.browserPageId ?? 0) + 1;
          }
        }
      } else {
        targetPageId = 0;
      }
      this.setTransition({
        id,
        targetPageId,
        source,
        restoredState,
        currentUrlTree: this.currentUrlTree,
        currentRawUrl: this.rawUrlTree,
        rawUrl,
        extras,
        resolve,
        reject,
        promise: promise2,
        currentSnapshot: this.routerState.snapshot,
        currentRouterState: this.routerState
      });
      return promise2.catch((e) => {
        return Promise.reject(e);
      });
    }
    setBrowserUrl(url, t) {
      const path = this.urlSerializer.serialize(url);
      const state = { ...t.extras.state, ...this.generateNgRouterState(t.id, t.targetPageId) };
      if (this.location.isCurrentPathEqualTo(path) || !!t.extras.replaceUrl) {
        this.location.replaceState(path, "", state);
      } else {
        this.location.go(path, "", state);
      }
    }
    restoreHistory(t, restoringFromCaughtError = false) {
      if (this.canceledNavigationResolution === "computed") {
        const targetPagePosition = this.currentPageId - t.targetPageId;
        const browserUrlUpdateOccurred = t.source === "popstate" || this.urlUpdateStrategy === "eager" || this.currentUrlTree === this.currentNavigation?.finalUrl;
        if (browserUrlUpdateOccurred && targetPagePosition !== 0) {
          this.location.historyGo(targetPagePosition);
        } else if (this.currentUrlTree === this.currentNavigation?.finalUrl && targetPagePosition === 0) {
          this.resetState(t);
          this.browserUrlTree = t.currentUrlTree;
          this.resetUrlToCurrentUrlTree();
        } else {
        }
      } else if (this.canceledNavigationResolution === "replace") {
        if (restoringFromCaughtError) {
          this.resetState(t);
        }
        this.resetUrlToCurrentUrlTree();
      }
    }
    resetState(t) {
      this.routerState = t.currentRouterState;
      this.currentUrlTree = t.currentUrlTree;
      this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, t.rawUrl);
    }
    resetUrlToCurrentUrlTree() {
      this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId));
    }
    cancelNavigationTransition(t, reason) {
      const navCancel = new NavigationCancel(t.id, this.serializeUrl(t.extractedUrl), reason);
      this.triggerEvent(navCancel);
      t.resolve(false);
    }
    generateNgRouterState(navigationId, routerPageId) {
      if (this.canceledNavigationResolution === "computed") {
        return { navigationId, \u0275routerPageId: routerPageId };
      }
      return { navigationId };
    }
  };
  Router.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: Router, deps: "invalid", target: FactoryTarget.Injectable });
  Router.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: Router });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: Router, decorators: [{
    type: Injectable
  }], ctorParameters: function() {
    return [{ type: Type }, { type: UrlSerializer }, { type: ChildrenOutletContexts }, { type: Location }, { type: Injector }, { type: Compiler }, { type: void 0 }];
  } });
  function validateCommands(commands) {
    for (let i = 0; i < commands.length; i++) {
      const cmd = commands[i];
      if (cmd == null) {
        throw new Error(`The requested path contains ${cmd} segment at index ${i}`);
      }
    }
  }
  function isBrowserTriggeredNavigation(source) {
    return source !== "imperative";
  }
  var RouterLink = class {
    constructor(router, route, tabIndexAttribute, renderer, el) {
      this.router = router;
      this.route = route;
      this.tabIndexAttribute = tabIndexAttribute;
      this.renderer = renderer;
      this.el = el;
      this.commands = null;
      this.onChanges = new Subject();
      this.setTabIndexIfNotOnNativeEl("0");
    }
    setTabIndexIfNotOnNativeEl(newTabIndex) {
      if (this.tabIndexAttribute != null) {
        return;
      }
      const renderer = this.renderer;
      const nativeElement = this.el.nativeElement;
      if (newTabIndex !== null) {
        renderer.setAttribute(nativeElement, "tabindex", newTabIndex);
      } else {
        renderer.removeAttribute(nativeElement, "tabindex");
      }
    }
    ngOnChanges(changes) {
      this.onChanges.next(this);
    }
    set routerLink(commands) {
      if (commands != null) {
        this.commands = Array.isArray(commands) ? commands : [commands];
        this.setTabIndexIfNotOnNativeEl("0");
      } else {
        this.commands = null;
        this.setTabIndexIfNotOnNativeEl(null);
      }
    }
    onClick() {
      if (this.urlTree === null) {
        return true;
      }
      const extras = {
        skipLocationChange: attrBoolValue(this.skipLocationChange),
        replaceUrl: attrBoolValue(this.replaceUrl),
        state: this.state
      };
      this.router.navigateByUrl(this.urlTree, extras);
      return true;
    }
    get urlTree() {
      if (this.commands === null) {
        return null;
      }
      return this.router.createUrlTree(this.commands, {
        relativeTo: this.relativeTo !== void 0 ? this.relativeTo : this.route,
        queryParams: this.queryParams,
        fragment: this.fragment,
        queryParamsHandling: this.queryParamsHandling,
        preserveFragment: attrBoolValue(this.preserveFragment)
      });
    }
  };
  RouterLink.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: RouterLink, deps: [{ token: Router }, { token: ActivatedRoute }, { token: "tabindex", attribute: true }, { token: Renderer2 }, { token: ElementRef }], target: FactoryTarget.Directive });
  RouterLink.\u0275dir = \u0275\u0275ngDeclareDirective({ minVersion: "12.0.0", version: "13.0.3", type: RouterLink, selector: ":not(a):not(area)[routerLink]", inputs: { queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", preserveFragment: "preserveFragment", skipLocationChange: "skipLocationChange", replaceUrl: "replaceUrl", state: "state", relativeTo: "relativeTo", routerLink: "routerLink" }, host: { listeners: { "click": "onClick()" } }, usesOnChanges: true, ngImport: core_exports });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: RouterLink, decorators: [{
    type: Directive,
    args: [{ selector: ":not(a):not(area)[routerLink]" }]
  }], ctorParameters: function() {
    return [{ type: Router }, { type: ActivatedRoute }, { type: void 0, decorators: [{
      type: Attribute,
      args: ["tabindex"]
    }] }, { type: Renderer2 }, { type: ElementRef }];
  }, propDecorators: { queryParams: [{
    type: Input
  }], fragment: [{
    type: Input
  }], queryParamsHandling: [{
    type: Input
  }], preserveFragment: [{
    type: Input
  }], skipLocationChange: [{
    type: Input
  }], replaceUrl: [{
    type: Input
  }], state: [{
    type: Input
  }], relativeTo: [{
    type: Input
  }], routerLink: [{
    type: Input
  }], onClick: [{
    type: HostListener,
    args: ["click"]
  }] } });
  var RouterLinkWithHref = class {
    constructor(router, route, locationStrategy) {
      this.router = router;
      this.route = route;
      this.locationStrategy = locationStrategy;
      this.commands = null;
      this.href = null;
      this.onChanges = new Subject();
      this.subscription = router.events.subscribe((s) => {
        if (s instanceof NavigationEnd) {
          this.updateTargetUrlAndHref();
        }
      });
    }
    set routerLink(commands) {
      if (commands != null) {
        this.commands = Array.isArray(commands) ? commands : [commands];
      } else {
        this.commands = null;
      }
    }
    ngOnChanges(changes) {
      this.updateTargetUrlAndHref();
      this.onChanges.next(this);
    }
    ngOnDestroy() {
      this.subscription.unsubscribe();
    }
    onClick(button, ctrlKey, shiftKey, altKey, metaKey) {
      if (button !== 0 || ctrlKey || shiftKey || altKey || metaKey) {
        return true;
      }
      if (typeof this.target === "string" && this.target != "_self" || this.urlTree === null) {
        return true;
      }
      const extras = {
        skipLocationChange: attrBoolValue(this.skipLocationChange),
        replaceUrl: attrBoolValue(this.replaceUrl),
        state: this.state
      };
      this.router.navigateByUrl(this.urlTree, extras);
      return false;
    }
    updateTargetUrlAndHref() {
      this.href = this.urlTree !== null ? this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree)) : null;
    }
    get urlTree() {
      if (this.commands === null) {
        return null;
      }
      return this.router.createUrlTree(this.commands, {
        relativeTo: this.relativeTo !== void 0 ? this.relativeTo : this.route,
        queryParams: this.queryParams,
        fragment: this.fragment,
        queryParamsHandling: this.queryParamsHandling,
        preserveFragment: attrBoolValue(this.preserveFragment)
      });
    }
  };
  RouterLinkWithHref.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: RouterLinkWithHref, deps: [{ token: Router }, { token: ActivatedRoute }, { token: LocationStrategy }], target: FactoryTarget.Directive });
  RouterLinkWithHref.\u0275dir = \u0275\u0275ngDeclareDirective({ minVersion: "12.0.0", version: "13.0.3", type: RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: { target: "target", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", preserveFragment: "preserveFragment", skipLocationChange: "skipLocationChange", replaceUrl: "replaceUrl", state: "state", relativeTo: "relativeTo", routerLink: "routerLink" }, host: { listeners: { "click": "onClick($event.button,$event.ctrlKey,$event.shiftKey,$event.altKey,$event.metaKey)" }, properties: { "attr.target": "this.target", "attr.href": "this.href" } }, usesOnChanges: true, ngImport: core_exports });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: RouterLinkWithHref, decorators: [{
    type: Directive,
    args: [{ selector: "a[routerLink],area[routerLink]" }]
  }], ctorParameters: function() {
    return [{ type: Router }, { type: ActivatedRoute }, { type: LocationStrategy }];
  }, propDecorators: { target: [{
    type: HostBinding,
    args: ["attr.target"]
  }, {
    type: Input
  }], queryParams: [{
    type: Input
  }], fragment: [{
    type: Input
  }], queryParamsHandling: [{
    type: Input
  }], preserveFragment: [{
    type: Input
  }], skipLocationChange: [{
    type: Input
  }], replaceUrl: [{
    type: Input
  }], state: [{
    type: Input
  }], relativeTo: [{
    type: Input
  }], href: [{
    type: HostBinding,
    args: ["attr.href"]
  }], routerLink: [{
    type: Input
  }], onClick: [{
    type: HostListener,
    args: [
      "click",
      ["$event.button", "$event.ctrlKey", "$event.shiftKey", "$event.altKey", "$event.metaKey"]
    ]
  }] } });
  function attrBoolValue(s) {
    return s === "" || !!s;
  }
  var RouterLinkActive = class {
    constructor(router, element, renderer, cdr, link, linkWithHref) {
      this.router = router;
      this.element = element;
      this.renderer = renderer;
      this.cdr = cdr;
      this.link = link;
      this.linkWithHref = linkWithHref;
      this.classes = [];
      this.isActive = false;
      this.routerLinkActiveOptions = { exact: false };
      this.isActiveChange = new EventEmitter();
      this.routerEventsSubscription = router.events.subscribe((s) => {
        if (s instanceof NavigationEnd) {
          this.update();
        }
      });
    }
    ngAfterContentInit() {
      of(this.links.changes, this.linksWithHrefs.changes, of(null)).pipe(mergeAll()).subscribe((_) => {
        this.update();
        this.subscribeToEachLinkOnChanges();
      });
    }
    subscribeToEachLinkOnChanges() {
      this.linkInputChangesSubscription?.unsubscribe();
      const allLinkChanges = [...this.links.toArray(), ...this.linksWithHrefs.toArray(), this.link, this.linkWithHref].filter((link) => !!link).map((link) => link.onChanges);
      this.linkInputChangesSubscription = from(allLinkChanges).pipe(mergeAll()).subscribe((link) => {
        if (this.isActive !== this.isLinkActive(this.router)(link)) {
          this.update();
        }
      });
    }
    set routerLinkActive(data) {
      const classes = Array.isArray(data) ? data : data.split(" ");
      this.classes = classes.filter((c) => !!c);
    }
    ngOnChanges(changes) {
      this.update();
    }
    ngOnDestroy() {
      this.routerEventsSubscription.unsubscribe();
      this.linkInputChangesSubscription?.unsubscribe();
    }
    update() {
      if (!this.links || !this.linksWithHrefs || !this.router.navigated)
        return;
      Promise.resolve().then(() => {
        const hasActiveLinks = this.hasActiveLinks();
        if (this.isActive !== hasActiveLinks) {
          this.isActive = hasActiveLinks;
          this.cdr.markForCheck();
          this.classes.forEach((c) => {
            if (hasActiveLinks) {
              this.renderer.addClass(this.element.nativeElement, c);
            } else {
              this.renderer.removeClass(this.element.nativeElement, c);
            }
          });
          this.isActiveChange.emit(hasActiveLinks);
        }
      });
    }
    isLinkActive(router) {
      const options = isActiveMatchOptions(this.routerLinkActiveOptions) ? this.routerLinkActiveOptions : this.routerLinkActiveOptions.exact || false;
      return (link) => link.urlTree ? router.isActive(link.urlTree, options) : false;
    }
    hasActiveLinks() {
      const isActiveCheckFn = this.isLinkActive(this.router);
      return this.link && isActiveCheckFn(this.link) || this.linkWithHref && isActiveCheckFn(this.linkWithHref) || this.links.some(isActiveCheckFn) || this.linksWithHrefs.some(isActiveCheckFn);
    }
  };
  RouterLinkActive.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: RouterLinkActive, deps: [{ token: Router }, { token: ElementRef }, { token: Renderer2 }, { token: ChangeDetectorRef }, { token: RouterLink, optional: true }, { token: RouterLinkWithHref, optional: true }], target: FactoryTarget.Directive });
  RouterLinkActive.\u0275dir = \u0275\u0275ngDeclareDirective({ minVersion: "12.0.0", version: "13.0.3", type: RouterLinkActive, selector: "[routerLinkActive]", inputs: { routerLinkActiveOptions: "routerLinkActiveOptions", routerLinkActive: "routerLinkActive" }, outputs: { isActiveChange: "isActiveChange" }, queries: [{ propertyName: "links", predicate: RouterLink, descendants: true }, { propertyName: "linksWithHrefs", predicate: RouterLinkWithHref, descendants: true }], exportAs: ["routerLinkActive"], usesOnChanges: true, ngImport: core_exports });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: RouterLinkActive, decorators: [{
    type: Directive,
    args: [{
      selector: "[routerLinkActive]",
      exportAs: "routerLinkActive"
    }]
  }], ctorParameters: function() {
    return [{ type: Router }, { type: ElementRef }, { type: Renderer2 }, { type: ChangeDetectorRef }, { type: RouterLink, decorators: [{
      type: Optional
    }] }, { type: RouterLinkWithHref, decorators: [{
      type: Optional
    }] }];
  }, propDecorators: { links: [{
    type: ContentChildren,
    args: [RouterLink, { descendants: true }]
  }], linksWithHrefs: [{
    type: ContentChildren,
    args: [RouterLinkWithHref, { descendants: true }]
  }], routerLinkActiveOptions: [{
    type: Input
  }], isActiveChange: [{
    type: Output
  }], routerLinkActive: [{
    type: Input
  }] } });
  function isActiveMatchOptions(options) {
    return !!options.paths;
  }
  var PreloadingStrategy = class {
  };
  var PreloadAllModules = class {
    preload(route, fn2) {
      return fn2().pipe(catchError(() => of(null)));
    }
  };
  var NoPreloading = class {
    preload(route, fn2) {
      return of(null);
    }
  };
  var RouterPreloader = class {
    constructor(router, compiler, injector, preloadingStrategy) {
      this.router = router;
      this.injector = injector;
      this.preloadingStrategy = preloadingStrategy;
      const onStartLoad = (r) => router.triggerEvent(new RouteConfigLoadStart(r));
      const onEndLoad = (r) => router.triggerEvent(new RouteConfigLoadEnd(r));
      this.loader = new RouterConfigLoader(injector, compiler, onStartLoad, onEndLoad);
    }
    setUpPreloading() {
      this.subscription = this.router.events.pipe(filter((e) => e instanceof NavigationEnd), concatMap(() => this.preload())).subscribe(() => {
      });
    }
    preload() {
      const ngModule = this.injector.get(NgModuleRef$1);
      return this.processRoutes(ngModule, this.router.config);
    }
    ngOnDestroy() {
      if (this.subscription) {
        this.subscription.unsubscribe();
      }
    }
    processRoutes(ngModule, routes) {
      const res = [];
      for (const route of routes) {
        if (route.loadChildren && !route.canLoad && route._loadedConfig) {
          const childConfig = route._loadedConfig;
          res.push(this.processRoutes(childConfig.module, childConfig.routes));
        } else if (route.loadChildren && !route.canLoad) {
          res.push(this.preloadConfig(ngModule, route));
        } else if (route.children) {
          res.push(this.processRoutes(ngModule, route.children));
        }
      }
      return from(res).pipe(mergeAll(), map((_) => void 0));
    }
    preloadConfig(ngModule, route) {
      return this.preloadingStrategy.preload(route, () => {
        const loaded$ = route._loadedConfig ? of(route._loadedConfig) : this.loader.load(ngModule.injector, route);
        return loaded$.pipe(mergeMap((config2) => {
          route._loadedConfig = config2;
          return this.processRoutes(config2.module, config2.routes);
        }));
      });
    }
  };
  RouterPreloader.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: RouterPreloader, deps: [{ token: Router }, { token: Compiler }, { token: Injector }, { token: PreloadingStrategy }], target: FactoryTarget.Injectable });
  RouterPreloader.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: RouterPreloader });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: RouterPreloader, decorators: [{
    type: Injectable
  }], ctorParameters: function() {
    return [{ type: Router }, { type: Compiler }, { type: Injector }, { type: PreloadingStrategy }];
  } });
  var RouterScroller = class {
    constructor(router, viewportScroller, options = {}) {
      this.router = router;
      this.viewportScroller = viewportScroller;
      this.options = options;
      this.lastId = 0;
      this.lastSource = "imperative";
      this.restoredId = 0;
      this.store = {};
      options.scrollPositionRestoration = options.scrollPositionRestoration || "disabled";
      options.anchorScrolling = options.anchorScrolling || "disabled";
    }
    init() {
      if (this.options.scrollPositionRestoration !== "disabled") {
        this.viewportScroller.setHistoryScrollRestoration("manual");
      }
      this.routerEventsSubscription = this.createScrollEvents();
      this.scrollEventsSubscription = this.consumeScrollEvents();
    }
    createScrollEvents() {
      return this.router.events.subscribe((e) => {
        if (e instanceof NavigationStart) {
          this.store[this.lastId] = this.viewportScroller.getScrollPosition();
          this.lastSource = e.navigationTrigger;
          this.restoredId = e.restoredState ? e.restoredState.navigationId : 0;
        } else if (e instanceof NavigationEnd) {
          this.lastId = e.id;
          this.scheduleScrollEvent(e, this.router.parseUrl(e.urlAfterRedirects).fragment);
        }
      });
    }
    consumeScrollEvents() {
      return this.router.events.subscribe((e) => {
        if (!(e instanceof Scroll))
          return;
        if (e.position) {
          if (this.options.scrollPositionRestoration === "top") {
            this.viewportScroller.scrollToPosition([0, 0]);
          } else if (this.options.scrollPositionRestoration === "enabled") {
            this.viewportScroller.scrollToPosition(e.position);
          }
        } else {
          if (e.anchor && this.options.anchorScrolling === "enabled") {
            this.viewportScroller.scrollToAnchor(e.anchor);
          } else if (this.options.scrollPositionRestoration !== "disabled") {
            this.viewportScroller.scrollToPosition([0, 0]);
          }
        }
      });
    }
    scheduleScrollEvent(routerEvent, anchor) {
      this.router.triggerEvent(new Scroll(routerEvent, this.lastSource === "popstate" ? this.store[this.restoredId] : null, anchor));
    }
    ngOnDestroy() {
      if (this.routerEventsSubscription) {
        this.routerEventsSubscription.unsubscribe();
      }
      if (this.scrollEventsSubscription) {
        this.scrollEventsSubscription.unsubscribe();
      }
    }
  };
  RouterScroller.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: RouterScroller, deps: "invalid", target: FactoryTarget.Injectable });
  RouterScroller.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: RouterScroller });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: RouterScroller, decorators: [{
    type: Injectable
  }], ctorParameters: function() {
    return [{ type: Router }, { type: ViewportScroller }, { type: void 0 }];
  } });
  var ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive, \u0275EmptyOutletComponent];
  var ROUTER_CONFIGURATION = new InjectionToken("ROUTER_CONFIGURATION");
  var ROUTER_FORROOT_GUARD = new InjectionToken("ROUTER_FORROOT_GUARD");
  var ROUTER_PROVIDERS = [
    Location,
    { provide: UrlSerializer, useClass: DefaultUrlSerializer },
    {
      provide: Router,
      useFactory: setupRouter,
      deps: [
        UrlSerializer,
        ChildrenOutletContexts,
        Location,
        Injector,
        Compiler,
        ROUTES,
        ROUTER_CONFIGURATION,
        [UrlHandlingStrategy, new Optional()],
        [RouteReuseStrategy, new Optional()]
      ]
    },
    ChildrenOutletContexts,
    { provide: ActivatedRoute, useFactory: rootRoute, deps: [Router] },
    RouterPreloader,
    NoPreloading,
    PreloadAllModules,
    { provide: ROUTER_CONFIGURATION, useValue: { enableTracing: false } }
  ];
  function routerNgProbeToken() {
    return new NgProbeToken("Router", Router);
  }
  var RouterModule = class {
    constructor(guard, router) {
    }
    static forRoot(routes, config2) {
      return {
        ngModule: RouterModule,
        providers: [
          ROUTER_PROVIDERS,
          provideRoutes(routes),
          {
            provide: ROUTER_FORROOT_GUARD,
            useFactory: provideForRootGuard,
            deps: [[Router, new Optional(), new SkipSelf()]]
          },
          { provide: ROUTER_CONFIGURATION, useValue: config2 ? config2 : {} },
          {
            provide: LocationStrategy,
            useFactory: provideLocationStrategy2,
            deps: [PlatformLocation, [new Inject(APP_BASE_HREF), new Optional()], ROUTER_CONFIGURATION]
          },
          {
            provide: RouterScroller,
            useFactory: createRouterScroller,
            deps: [Router, ViewportScroller, ROUTER_CONFIGURATION]
          },
          {
            provide: PreloadingStrategy,
            useExisting: config2 && config2.preloadingStrategy ? config2.preloadingStrategy : NoPreloading
          },
          { provide: NgProbeToken, multi: true, useFactory: routerNgProbeToken },
          provideRouterInitializer()
        ]
      };
    }
    static forChild(routes) {
      return { ngModule: RouterModule, providers: [provideRoutes(routes)] };
    }
  };
  RouterModule.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: RouterModule, deps: [{ token: ROUTER_FORROOT_GUARD, optional: true }, { token: Router, optional: true }], target: FactoryTarget.NgModule });
  RouterModule.\u0275mod = \u0275\u0275ngDeclareNgModule({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: RouterModule, declarations: [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive, \u0275EmptyOutletComponent], exports: [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive, \u0275EmptyOutletComponent] });
  RouterModule.\u0275inj = \u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: RouterModule });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: RouterModule, decorators: [{
    type: NgModule,
    args: [{
      declarations: ROUTER_DIRECTIVES,
      exports: ROUTER_DIRECTIVES,
      entryComponents: [\u0275EmptyOutletComponent]
    }]
  }], ctorParameters: function() {
    return [{ type: void 0, decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [ROUTER_FORROOT_GUARD]
    }] }, { type: Router, decorators: [{
      type: Optional
    }] }];
  } });
  function createRouterScroller(router, viewportScroller, config2) {
    if (config2.scrollOffset) {
      viewportScroller.setOffset(config2.scrollOffset);
    }
    return new RouterScroller(router, viewportScroller, config2);
  }
  function provideLocationStrategy2(platformLocationStrategy, baseHref, options = {}) {
    return options.useHash ? new HashLocationStrategy(platformLocationStrategy, baseHref) : new PathLocationStrategy(platformLocationStrategy, baseHref);
  }
  function provideForRootGuard(router) {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && router) {
      throw new Error(`RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead.`);
    }
    return "guarded";
  }
  function provideRoutes(routes) {
    return [
      { provide: ANALYZE_FOR_ENTRY_COMPONENTS, multi: true, useValue: routes },
      { provide: ROUTES, multi: true, useValue: routes }
    ];
  }
  function setupRouter(urlSerializer, contexts, location2, injector, compiler, config2, opts = {}, urlHandlingStrategy, routeReuseStrategy) {
    const router = new Router(null, urlSerializer, contexts, location2, injector, compiler, flatten4(config2));
    if (urlHandlingStrategy) {
      router.urlHandlingStrategy = urlHandlingStrategy;
    }
    if (routeReuseStrategy) {
      router.routeReuseStrategy = routeReuseStrategy;
    }
    assignExtraOptionsToRouter(opts, router);
    if (opts.enableTracing) {
      router.events.subscribe((e) => {
        console.group?.(`Router Event: ${e.constructor.name}`);
        console.log(e.toString());
        console.log(e);
        console.groupEnd?.();
      });
    }
    return router;
  }
  function assignExtraOptionsToRouter(opts, router) {
    if (opts.errorHandler) {
      router.errorHandler = opts.errorHandler;
    }
    if (opts.malformedUriErrorHandler) {
      router.malformedUriErrorHandler = opts.malformedUriErrorHandler;
    }
    if (opts.onSameUrlNavigation) {
      router.onSameUrlNavigation = opts.onSameUrlNavigation;
    }
    if (opts.paramsInheritanceStrategy) {
      router.paramsInheritanceStrategy = opts.paramsInheritanceStrategy;
    }
    if (opts.relativeLinkResolution) {
      router.relativeLinkResolution = opts.relativeLinkResolution;
    }
    if (opts.urlUpdateStrategy) {
      router.urlUpdateStrategy = opts.urlUpdateStrategy;
    }
    if (opts.canceledNavigationResolution) {
      router.canceledNavigationResolution = opts.canceledNavigationResolution;
    }
  }
  function rootRoute(router) {
    return router.routerState.root;
  }
  var RouterInitializer = class {
    constructor(injector) {
      this.injector = injector;
      this.initNavigation = false;
      this.destroyed = false;
      this.resultOfPreactivationDone = new Subject();
    }
    appInitializer() {
      const p = this.injector.get(LOCATION_INITIALIZED, Promise.resolve(null));
      return p.then(() => {
        if (this.destroyed) {
          return Promise.resolve(true);
        }
        let resolve = null;
        const res = new Promise((r) => resolve = r);
        const router = this.injector.get(Router);
        const opts = this.injector.get(ROUTER_CONFIGURATION);
        if (opts.initialNavigation === "disabled") {
          router.setUpLocationChangeListener();
          resolve(true);
        } else if (opts.initialNavigation === "enabled" || opts.initialNavigation === "enabledBlocking") {
          router.hooks.afterPreactivation = () => {
            if (!this.initNavigation) {
              this.initNavigation = true;
              resolve(true);
              return this.resultOfPreactivationDone;
            } else {
              return of(null);
            }
          };
          router.initialNavigation();
        } else {
          resolve(true);
        }
        return res;
      });
    }
    bootstrapListener(bootstrappedComponentRef) {
      const opts = this.injector.get(ROUTER_CONFIGURATION);
      const preloader = this.injector.get(RouterPreloader);
      const routerScroller = this.injector.get(RouterScroller);
      const router = this.injector.get(Router);
      const ref = this.injector.get(ApplicationRef);
      if (bootstrappedComponentRef !== ref.components[0]) {
        return;
      }
      if (opts.initialNavigation === "enabledNonBlocking" || opts.initialNavigation === void 0) {
        router.initialNavigation();
      }
      preloader.setUpPreloading();
      routerScroller.init();
      router.resetRootComponentType(ref.componentTypes[0]);
      this.resultOfPreactivationDone.next(null);
      this.resultOfPreactivationDone.complete();
    }
    ngOnDestroy() {
      this.destroyed = true;
    }
  };
  RouterInitializer.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: RouterInitializer, deps: [{ token: Injector }], target: FactoryTarget.Injectable });
  RouterInitializer.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: RouterInitializer });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: RouterInitializer, decorators: [{
    type: Injectable
  }], ctorParameters: function() {
    return [{ type: Injector }];
  } });
  function getAppInitializer(r) {
    return r.appInitializer.bind(r);
  }
  function getBootstrapListener(r) {
    return r.bootstrapListener.bind(r);
  }
  var ROUTER_INITIALIZER = new InjectionToken("Router Initializer");
  function provideRouterInitializer() {
    return [
      RouterInitializer,
      {
        provide: APP_INITIALIZER,
        multi: true,
        useFactory: getAppInitializer,
        deps: [RouterInitializer]
      },
      { provide: ROUTER_INITIALIZER, useFactory: getBootstrapListener, deps: [RouterInitializer] },
      { provide: APP_BOOTSTRAP_LISTENER, multi: true, useExisting: ROUTER_INITIALIZER }
    ];
  }
  var VERSION6 = new Version("13.0.3");

  // node_modules/@angular/router/fesm2020/testing.mjs
  var EXTRA_ROUTER_TESTING_PROVIDERS = [];
  function isUrlHandlingStrategy(opts) {
    return "shouldProcessUrl" in opts;
  }
  function setupTestingRouter(urlSerializer, contexts, location2, compiler, injector, routes, opts, urlHandlingStrategy, routeReuseStrategy) {
    const router = new Router(null, urlSerializer, contexts, location2, injector, compiler, flatten4(routes));
    if (opts) {
      if (isUrlHandlingStrategy(opts)) {
        router.urlHandlingStrategy = opts;
      } else {
        assignExtraOptionsToRouter(opts, router);
      }
    }
    if (urlHandlingStrategy) {
      router.urlHandlingStrategy = urlHandlingStrategy;
    }
    if (routeReuseStrategy) {
      router.routeReuseStrategy = routeReuseStrategy;
    }
    return router;
  }
  var RouterTestingModule = class {
    static withRoutes(routes, config2) {
      return {
        ngModule: RouterTestingModule,
        providers: [
          provideRoutes(routes),
          { provide: ROUTER_CONFIGURATION, useValue: config2 ? config2 : {} }
        ]
      };
    }
  };
  RouterTestingModule.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: RouterTestingModule, deps: [], target: FactoryTarget.NgModule });
  RouterTestingModule.\u0275mod = \u0275\u0275ngDeclareNgModule({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: RouterTestingModule, exports: [RouterModule] });
  RouterTestingModule.\u0275inj = \u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: RouterTestingModule, providers: [
    ROUTER_PROVIDERS,
    EXTRA_ROUTER_TESTING_PROVIDERS,
    { provide: Location, useClass: SpyLocation },
    { provide: LocationStrategy, useClass: MockLocationStrategy },
    {
      provide: Router,
      useFactory: setupTestingRouter,
      deps: [
        UrlSerializer,
        ChildrenOutletContexts,
        Location,
        Compiler,
        Injector,
        ROUTES,
        ROUTER_CONFIGURATION,
        [UrlHandlingStrategy, new Optional()],
        [RouteReuseStrategy, new Optional()]
      ]
    },
    { provide: PreloadingStrategy, useExisting: NoPreloading },
    provideRoutes([])
  ], imports: [RouterModule] });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: RouterTestingModule, decorators: [{
    type: NgModule,
    args: [{
      exports: [RouterModule],
      providers: [
        ROUTER_PROVIDERS,
        EXTRA_ROUTER_TESTING_PROVIDERS,
        { provide: Location, useClass: SpyLocation },
        { provide: LocationStrategy, useClass: MockLocationStrategy },
        {
          provide: Router,
          useFactory: setupTestingRouter,
          deps: [
            UrlSerializer,
            ChildrenOutletContexts,
            Location,
            Compiler,
            Injector,
            ROUTES,
            ROUTER_CONFIGURATION,
            [UrlHandlingStrategy, new Optional()],
            [RouteReuseStrategy, new Optional()]
          ]
        },
        { provide: PreloadingStrategy, useExisting: NoPreloading },
        provideRoutes([])
      ]
    }]
  }] });

  // node_modules/@angular/common/fesm2020/http.mjs
  var HttpHandler = class {
  };
  var HttpBackend = class {
  };
  var HttpHeaders = class {
    constructor(headers) {
      this.normalizedNames = /* @__PURE__ */ new Map();
      this.lazyUpdate = null;
      if (!headers) {
        this.headers = /* @__PURE__ */ new Map();
      } else if (typeof headers === "string") {
        this.lazyInit = () => {
          this.headers = /* @__PURE__ */ new Map();
          headers.split("\n").forEach((line) => {
            const index = line.indexOf(":");
            if (index > 0) {
              const name = line.slice(0, index);
              const key = name.toLowerCase();
              const value = line.slice(index + 1).trim();
              this.maybeSetNormalizedName(name, key);
              if (this.headers.has(key)) {
                this.headers.get(key).push(value);
              } else {
                this.headers.set(key, [value]);
              }
            }
          });
        };
      } else {
        this.lazyInit = () => {
          this.headers = /* @__PURE__ */ new Map();
          Object.keys(headers).forEach((name) => {
            let values = headers[name];
            const key = name.toLowerCase();
            if (typeof values === "string") {
              values = [values];
            }
            if (values.length > 0) {
              this.headers.set(key, values);
              this.maybeSetNormalizedName(name, key);
            }
          });
        };
      }
    }
    has(name) {
      this.init();
      return this.headers.has(name.toLowerCase());
    }
    get(name) {
      this.init();
      const values = this.headers.get(name.toLowerCase());
      return values && values.length > 0 ? values[0] : null;
    }
    keys() {
      this.init();
      return Array.from(this.normalizedNames.values());
    }
    getAll(name) {
      this.init();
      return this.headers.get(name.toLowerCase()) || null;
    }
    append(name, value) {
      return this.clone({ name, value, op: "a" });
    }
    set(name, value) {
      return this.clone({ name, value, op: "s" });
    }
    delete(name, value) {
      return this.clone({ name, value, op: "d" });
    }
    maybeSetNormalizedName(name, lcName) {
      if (!this.normalizedNames.has(lcName)) {
        this.normalizedNames.set(lcName, name);
      }
    }
    init() {
      if (!!this.lazyInit) {
        if (this.lazyInit instanceof HttpHeaders) {
          this.copyFrom(this.lazyInit);
        } else {
          this.lazyInit();
        }
        this.lazyInit = null;
        if (!!this.lazyUpdate) {
          this.lazyUpdate.forEach((update) => this.applyUpdate(update));
          this.lazyUpdate = null;
        }
      }
    }
    copyFrom(other) {
      other.init();
      Array.from(other.headers.keys()).forEach((key) => {
        this.headers.set(key, other.headers.get(key));
        this.normalizedNames.set(key, other.normalizedNames.get(key));
      });
    }
    clone(update) {
      const clone = new HttpHeaders();
      clone.lazyInit = !!this.lazyInit && this.lazyInit instanceof HttpHeaders ? this.lazyInit : this;
      clone.lazyUpdate = (this.lazyUpdate || []).concat([update]);
      return clone;
    }
    applyUpdate(update) {
      const key = update.name.toLowerCase();
      switch (update.op) {
        case "a":
        case "s":
          let value = update.value;
          if (typeof value === "string") {
            value = [value];
          }
          if (value.length === 0) {
            return;
          }
          this.maybeSetNormalizedName(update.name, key);
          const base = (update.op === "a" ? this.headers.get(key) : void 0) || [];
          base.push(...value);
          this.headers.set(key, base);
          break;
        case "d":
          const toDelete = update.value;
          if (!toDelete) {
            this.headers.delete(key);
            this.normalizedNames.delete(key);
          } else {
            let existing = this.headers.get(key);
            if (!existing) {
              return;
            }
            existing = existing.filter((value2) => toDelete.indexOf(value2) === -1);
            if (existing.length === 0) {
              this.headers.delete(key);
              this.normalizedNames.delete(key);
            } else {
              this.headers.set(key, existing);
            }
          }
          break;
      }
    }
    forEach(fn2) {
      this.init();
      Array.from(this.normalizedNames.keys()).forEach((key) => fn2(this.normalizedNames.get(key), this.headers.get(key)));
    }
  };
  var HttpUrlEncodingCodec = class {
    encodeKey(key) {
      return standardEncoding(key);
    }
    encodeValue(value) {
      return standardEncoding(value);
    }
    decodeKey(key) {
      return decodeURIComponent(key);
    }
    decodeValue(value) {
      return decodeURIComponent(value);
    }
  };
  function paramParser(rawParams, codec) {
    const map2 = /* @__PURE__ */ new Map();
    if (rawParams.length > 0) {
      const params = rawParams.replace(/^\?/, "").split("&");
      params.forEach((param) => {
        const eqIdx = param.indexOf("=");
        const [key, val] = eqIdx == -1 ? [codec.decodeKey(param), ""] : [codec.decodeKey(param.slice(0, eqIdx)), codec.decodeValue(param.slice(eqIdx + 1))];
        const list = map2.get(key) || [];
        list.push(val);
        map2.set(key, list);
      });
    }
    return map2;
  }
  var STANDARD_ENCODING_REGEX = /%(\d[a-f0-9])/gi;
  var STANDARD_ENCODING_REPLACEMENTS = {
    "40": "@",
    "3A": ":",
    "24": "$",
    "2C": ",",
    "3B": ";",
    "2B": "+",
    "3D": "=",
    "3F": "?",
    "2F": "/"
  };
  function standardEncoding(v) {
    return encodeURIComponent(v).replace(STANDARD_ENCODING_REGEX, (s, t) => STANDARD_ENCODING_REPLACEMENTS[t] ?? s);
  }
  function valueToString(value) {
    return `${value}`;
  }
  var HttpParams = class {
    constructor(options = {}) {
      this.updates = null;
      this.cloneFrom = null;
      this.encoder = options.encoder || new HttpUrlEncodingCodec();
      if (!!options.fromString) {
        if (!!options.fromObject) {
          throw new Error(`Cannot specify both fromString and fromObject.`);
        }
        this.map = paramParser(options.fromString, this.encoder);
      } else if (!!options.fromObject) {
        this.map = /* @__PURE__ */ new Map();
        Object.keys(options.fromObject).forEach((key) => {
          const value = options.fromObject[key];
          this.map.set(key, Array.isArray(value) ? value : [value]);
        });
      } else {
        this.map = null;
      }
    }
    has(param) {
      this.init();
      return this.map.has(param);
    }
    get(param) {
      this.init();
      const res = this.map.get(param);
      return !!res ? res[0] : null;
    }
    getAll(param) {
      this.init();
      return this.map.get(param) || null;
    }
    keys() {
      this.init();
      return Array.from(this.map.keys());
    }
    append(param, value) {
      return this.clone({ param, value, op: "a" });
    }
    appendAll(params) {
      const updates = [];
      Object.keys(params).forEach((param) => {
        const value = params[param];
        if (Array.isArray(value)) {
          value.forEach((_value) => {
            updates.push({ param, value: _value, op: "a" });
          });
        } else {
          updates.push({ param, value, op: "a" });
        }
      });
      return this.clone(updates);
    }
    set(param, value) {
      return this.clone({ param, value, op: "s" });
    }
    delete(param, value) {
      return this.clone({ param, value, op: "d" });
    }
    toString() {
      this.init();
      return this.keys().map((key) => {
        const eKey = this.encoder.encodeKey(key);
        return this.map.get(key).map((value) => eKey + "=" + this.encoder.encodeValue(value)).join("&");
      }).filter((param) => param !== "").join("&");
    }
    clone(update) {
      const clone = new HttpParams({ encoder: this.encoder });
      clone.cloneFrom = this.cloneFrom || this;
      clone.updates = (this.updates || []).concat(update);
      return clone;
    }
    init() {
      if (this.map === null) {
        this.map = /* @__PURE__ */ new Map();
      }
      if (this.cloneFrom !== null) {
        this.cloneFrom.init();
        this.cloneFrom.keys().forEach((key) => this.map.set(key, this.cloneFrom.map.get(key)));
        this.updates.forEach((update) => {
          switch (update.op) {
            case "a":
            case "s":
              const base = (update.op === "a" ? this.map.get(update.param) : void 0) || [];
              base.push(valueToString(update.value));
              this.map.set(update.param, base);
              break;
            case "d":
              if (update.value !== void 0) {
                let base2 = this.map.get(update.param) || [];
                const idx = base2.indexOf(valueToString(update.value));
                if (idx !== -1) {
                  base2.splice(idx, 1);
                }
                if (base2.length > 0) {
                  this.map.set(update.param, base2);
                } else {
                  this.map.delete(update.param);
                }
              } else {
                this.map.delete(update.param);
                break;
              }
          }
        });
        this.cloneFrom = this.updates = null;
      }
    }
  };
  var HttpContext = class {
    constructor() {
      this.map = /* @__PURE__ */ new Map();
    }
    set(token, value) {
      this.map.set(token, value);
      return this;
    }
    get(token) {
      if (!this.map.has(token)) {
        this.map.set(token, token.defaultValue());
      }
      return this.map.get(token);
    }
    delete(token) {
      this.map.delete(token);
      return this;
    }
    keys() {
      return this.map.keys();
    }
  };
  function mightHaveBody(method) {
    switch (method) {
      case "DELETE":
      case "GET":
      case "HEAD":
      case "OPTIONS":
      case "JSONP":
        return false;
      default:
        return true;
    }
  }
  function isArrayBuffer(value) {
    return typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer;
  }
  function isBlob(value) {
    return typeof Blob !== "undefined" && value instanceof Blob;
  }
  function isFormData(value) {
    return typeof FormData !== "undefined" && value instanceof FormData;
  }
  function isUrlSearchParams(value) {
    return typeof URLSearchParams !== "undefined" && value instanceof URLSearchParams;
  }
  var HttpRequest = class {
    constructor(method, url, third, fourth) {
      this.url = url;
      this.body = null;
      this.reportProgress = false;
      this.withCredentials = false;
      this.responseType = "json";
      this.method = method.toUpperCase();
      let options;
      if (mightHaveBody(this.method) || !!fourth) {
        this.body = third !== void 0 ? third : null;
        options = fourth;
      } else {
        options = third;
      }
      if (options) {
        this.reportProgress = !!options.reportProgress;
        this.withCredentials = !!options.withCredentials;
        if (!!options.responseType) {
          this.responseType = options.responseType;
        }
        if (!!options.headers) {
          this.headers = options.headers;
        }
        if (!!options.context) {
          this.context = options.context;
        }
        if (!!options.params) {
          this.params = options.params;
        }
      }
      if (!this.headers) {
        this.headers = new HttpHeaders();
      }
      if (!this.context) {
        this.context = new HttpContext();
      }
      if (!this.params) {
        this.params = new HttpParams();
        this.urlWithParams = url;
      } else {
        const params = this.params.toString();
        if (params.length === 0) {
          this.urlWithParams = url;
        } else {
          const qIdx = url.indexOf("?");
          const sep = qIdx === -1 ? "?" : qIdx < url.length - 1 ? "&" : "";
          this.urlWithParams = url + sep + params;
        }
      }
    }
    serializeBody() {
      if (this.body === null) {
        return null;
      }
      if (isArrayBuffer(this.body) || isBlob(this.body) || isFormData(this.body) || isUrlSearchParams(this.body) || typeof this.body === "string") {
        return this.body;
      }
      if (this.body instanceof HttpParams) {
        return this.body.toString();
      }
      if (typeof this.body === "object" || typeof this.body === "boolean" || Array.isArray(this.body)) {
        return JSON.stringify(this.body);
      }
      return this.body.toString();
    }
    detectContentTypeHeader() {
      if (this.body === null) {
        return null;
      }
      if (isFormData(this.body)) {
        return null;
      }
      if (isBlob(this.body)) {
        return this.body.type || null;
      }
      if (isArrayBuffer(this.body)) {
        return null;
      }
      if (typeof this.body === "string") {
        return "text/plain";
      }
      if (this.body instanceof HttpParams) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      }
      if (typeof this.body === "object" || typeof this.body === "number" || typeof this.body === "boolean") {
        return "application/json";
      }
      return null;
    }
    clone(update = {}) {
      const method = update.method || this.method;
      const url = update.url || this.url;
      const responseType = update.responseType || this.responseType;
      const body = update.body !== void 0 ? update.body : this.body;
      const withCredentials = update.withCredentials !== void 0 ? update.withCredentials : this.withCredentials;
      const reportProgress = update.reportProgress !== void 0 ? update.reportProgress : this.reportProgress;
      let headers = update.headers || this.headers;
      let params = update.params || this.params;
      const context2 = update.context ?? this.context;
      if (update.setHeaders !== void 0) {
        headers = Object.keys(update.setHeaders).reduce((headers2, name) => headers2.set(name, update.setHeaders[name]), headers);
      }
      if (update.setParams) {
        params = Object.keys(update.setParams).reduce((params2, param) => params2.set(param, update.setParams[param]), params);
      }
      return new HttpRequest(method, url, body, {
        params,
        headers,
        context: context2,
        reportProgress,
        responseType,
        withCredentials
      });
    }
  };
  var HttpEventType;
  (function(HttpEventType2) {
    HttpEventType2[HttpEventType2["Sent"] = 0] = "Sent";
    HttpEventType2[HttpEventType2["UploadProgress"] = 1] = "UploadProgress";
    HttpEventType2[HttpEventType2["ResponseHeader"] = 2] = "ResponseHeader";
    HttpEventType2[HttpEventType2["DownloadProgress"] = 3] = "DownloadProgress";
    HttpEventType2[HttpEventType2["Response"] = 4] = "Response";
    HttpEventType2[HttpEventType2["User"] = 5] = "User";
  })(HttpEventType || (HttpEventType = {}));
  var HttpResponseBase = class {
    constructor(init, defaultStatus = 200, defaultStatusText = "OK") {
      this.headers = init.headers || new HttpHeaders();
      this.status = init.status !== void 0 ? init.status : defaultStatus;
      this.statusText = init.statusText || defaultStatusText;
      this.url = init.url || null;
      this.ok = this.status >= 200 && this.status < 300;
    }
  };
  var HttpHeaderResponse = class extends HttpResponseBase {
    constructor(init = {}) {
      super(init);
      this.type = HttpEventType.ResponseHeader;
    }
    clone(update = {}) {
      return new HttpHeaderResponse({
        headers: update.headers || this.headers,
        status: update.status !== void 0 ? update.status : this.status,
        statusText: update.statusText || this.statusText,
        url: update.url || this.url || void 0
      });
    }
  };
  var HttpResponse = class extends HttpResponseBase {
    constructor(init = {}) {
      super(init);
      this.type = HttpEventType.Response;
      this.body = init.body !== void 0 ? init.body : null;
    }
    clone(update = {}) {
      return new HttpResponse({
        body: update.body !== void 0 ? update.body : this.body,
        headers: update.headers || this.headers,
        status: update.status !== void 0 ? update.status : this.status,
        statusText: update.statusText || this.statusText,
        url: update.url || this.url || void 0
      });
    }
  };
  var HttpErrorResponse = class extends HttpResponseBase {
    constructor(init) {
      super(init, 0, "Unknown Error");
      this.name = "HttpErrorResponse";
      this.ok = false;
      if (this.status >= 200 && this.status < 300) {
        this.message = `Http failure during parsing for ${init.url || "(unknown url)"}`;
      } else {
        this.message = `Http failure response for ${init.url || "(unknown url)"}: ${init.status} ${init.statusText}`;
      }
      this.error = init.error || null;
    }
  };
  function addBody(options, body) {
    return {
      body,
      headers: options.headers,
      context: options.context,
      observe: options.observe,
      params: options.params,
      reportProgress: options.reportProgress,
      responseType: options.responseType,
      withCredentials: options.withCredentials
    };
  }
  var HttpClient = class {
    constructor(handler) {
      this.handler = handler;
    }
    request(first2, url, options = {}) {
      let req;
      if (first2 instanceof HttpRequest) {
        req = first2;
      } else {
        let headers = void 0;
        if (options.headers instanceof HttpHeaders) {
          headers = options.headers;
        } else {
          headers = new HttpHeaders(options.headers);
        }
        let params = void 0;
        if (!!options.params) {
          if (options.params instanceof HttpParams) {
            params = options.params;
          } else {
            params = new HttpParams({ fromObject: options.params });
          }
        }
        req = new HttpRequest(first2, url, options.body !== void 0 ? options.body : null, {
          headers,
          context: options.context,
          params,
          reportProgress: options.reportProgress,
          responseType: options.responseType || "json",
          withCredentials: options.withCredentials
        });
      }
      const events$ = of(req).pipe(concatMap((req2) => this.handler.handle(req2)));
      if (first2 instanceof HttpRequest || options.observe === "events") {
        return events$;
      }
      const res$ = events$.pipe(filter((event) => event instanceof HttpResponse));
      switch (options.observe || "body") {
        case "body":
          switch (req.responseType) {
            case "arraybuffer":
              return res$.pipe(map((res) => {
                if (res.body !== null && !(res.body instanceof ArrayBuffer)) {
                  throw new Error("Response is not an ArrayBuffer.");
                }
                return res.body;
              }));
            case "blob":
              return res$.pipe(map((res) => {
                if (res.body !== null && !(res.body instanceof Blob)) {
                  throw new Error("Response is not a Blob.");
                }
                return res.body;
              }));
            case "text":
              return res$.pipe(map((res) => {
                if (res.body !== null && typeof res.body !== "string") {
                  throw new Error("Response is not a string.");
                }
                return res.body;
              }));
            case "json":
            default:
              return res$.pipe(map((res) => res.body));
          }
        case "response":
          return res$;
        default:
          throw new Error(`Unreachable: unhandled observe type ${options.observe}}`);
      }
    }
    delete(url, options = {}) {
      return this.request("DELETE", url, options);
    }
    get(url, options = {}) {
      return this.request("GET", url, options);
    }
    head(url, options = {}) {
      return this.request("HEAD", url, options);
    }
    jsonp(url, callbackParam) {
      return this.request("JSONP", url, {
        params: new HttpParams().append(callbackParam, "JSONP_CALLBACK"),
        observe: "body",
        responseType: "json"
      });
    }
    options(url, options = {}) {
      return this.request("OPTIONS", url, options);
    }
    patch(url, body, options = {}) {
      return this.request("PATCH", url, addBody(options, body));
    }
    post(url, body, options = {}) {
      return this.request("POST", url, addBody(options, body));
    }
    put(url, body, options = {}) {
      return this.request("PUT", url, addBody(options, body));
    }
  };
  HttpClient.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HttpClient, deps: [{ token: HttpHandler }], target: FactoryTarget.Injectable });
  HttpClient.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HttpClient });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HttpClient, decorators: [{
    type: Injectable
  }], ctorParameters: function() {
    return [{ type: HttpHandler }];
  } });
  var HttpInterceptorHandler = class {
    constructor(next, interceptor) {
      this.next = next;
      this.interceptor = interceptor;
    }
    handle(req) {
      return this.interceptor.intercept(req, this.next);
    }
  };
  var HTTP_INTERCEPTORS = new InjectionToken("HTTP_INTERCEPTORS");
  var NoopInterceptor = class {
    intercept(req, next) {
      return next.handle(req);
    }
  };
  NoopInterceptor.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: NoopInterceptor, deps: [], target: FactoryTarget.Injectable });
  NoopInterceptor.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: NoopInterceptor });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: NoopInterceptor, decorators: [{
    type: Injectable
  }] });
  var nextRequestId = 0;
  var JSONP_ERR_NO_CALLBACK = "JSONP injected script did not invoke callback.";
  var JSONP_ERR_WRONG_METHOD = "JSONP requests must use JSONP request method.";
  var JSONP_ERR_WRONG_RESPONSE_TYPE = "JSONP requests must use Json response type.";
  var JsonpCallbackContext = class {
  };
  var JsonpClientBackend = class {
    constructor(callbackMap, document2) {
      this.callbackMap = callbackMap;
      this.document = document2;
      this.resolvedPromise = Promise.resolve();
    }
    nextCallback() {
      return `ng_jsonp_callback_${nextRequestId++}`;
    }
    handle(req) {
      if (req.method !== "JSONP") {
        throw new Error(JSONP_ERR_WRONG_METHOD);
      } else if (req.responseType !== "json") {
        throw new Error(JSONP_ERR_WRONG_RESPONSE_TYPE);
      }
      return new Observable((observer) => {
        const callback = this.nextCallback();
        const url = req.urlWithParams.replace(/=JSONP_CALLBACK(&|$)/, `=${callback}$1`);
        const node = this.document.createElement("script");
        node.src = url;
        let body = null;
        let finished = false;
        let cancelled = false;
        this.callbackMap[callback] = (data) => {
          delete this.callbackMap[callback];
          if (cancelled) {
            return;
          }
          body = data;
          finished = true;
        };
        const cleanup = () => {
          if (node.parentNode) {
            node.parentNode.removeChild(node);
          }
          delete this.callbackMap[callback];
        };
        const onLoad = (event) => {
          if (cancelled) {
            return;
          }
          this.resolvedPromise.then(() => {
            cleanup();
            if (!finished) {
              observer.error(new HttpErrorResponse({
                url,
                status: 0,
                statusText: "JSONP Error",
                error: new Error(JSONP_ERR_NO_CALLBACK)
              }));
              return;
            }
            observer.next(new HttpResponse({
              body,
              status: 200,
              statusText: "OK",
              url
            }));
            observer.complete();
          });
        };
        const onError = (error3) => {
          if (cancelled) {
            return;
          }
          cleanup();
          observer.error(new HttpErrorResponse({
            error: error3,
            status: 0,
            statusText: "JSONP Error",
            url
          }));
        };
        node.addEventListener("load", onLoad);
        node.addEventListener("error", onError);
        this.document.body.appendChild(node);
        observer.next({ type: HttpEventType.Sent });
        return () => {
          cancelled = true;
          node.removeEventListener("load", onLoad);
          node.removeEventListener("error", onError);
          cleanup();
        };
      });
    }
  };
  JsonpClientBackend.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: JsonpClientBackend, deps: [{ token: JsonpCallbackContext }, { token: DOCUMENT2 }], target: FactoryTarget.Injectable });
  JsonpClientBackend.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: JsonpClientBackend });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: JsonpClientBackend, decorators: [{
    type: Injectable
  }], ctorParameters: function() {
    return [{ type: JsonpCallbackContext }, { type: void 0, decorators: [{
      type: Inject,
      args: [DOCUMENT2]
    }] }];
  } });
  var JsonpInterceptor = class {
    constructor(jsonp) {
      this.jsonp = jsonp;
    }
    intercept(req, next) {
      if (req.method === "JSONP") {
        return this.jsonp.handle(req);
      }
      return next.handle(req);
    }
  };
  JsonpInterceptor.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: JsonpInterceptor, deps: [{ token: JsonpClientBackend }], target: FactoryTarget.Injectable });
  JsonpInterceptor.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: JsonpInterceptor });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: JsonpInterceptor, decorators: [{
    type: Injectable
  }], ctorParameters: function() {
    return [{ type: JsonpClientBackend }];
  } });
  var XSSI_PREFIX = /^\)\]\}',?\n/;
  function getResponseUrl(xhr) {
    if ("responseURL" in xhr && xhr.responseURL) {
      return xhr.responseURL;
    }
    if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
      return xhr.getResponseHeader("X-Request-URL");
    }
    return null;
  }
  var HttpXhrBackend = class {
    constructor(xhrFactory) {
      this.xhrFactory = xhrFactory;
    }
    handle(req) {
      if (req.method === "JSONP") {
        throw new Error(`Attempted to construct Jsonp request without HttpClientJsonpModule installed.`);
      }
      return new Observable((observer) => {
        const xhr = this.xhrFactory.build();
        xhr.open(req.method, req.urlWithParams);
        if (!!req.withCredentials) {
          xhr.withCredentials = true;
        }
        req.headers.forEach((name, values) => xhr.setRequestHeader(name, values.join(",")));
        if (!req.headers.has("Accept")) {
          xhr.setRequestHeader("Accept", "application/json, text/plain, */*");
        }
        if (!req.headers.has("Content-Type")) {
          const detectedType = req.detectContentTypeHeader();
          if (detectedType !== null) {
            xhr.setRequestHeader("Content-Type", detectedType);
          }
        }
        if (req.responseType) {
          const responseType = req.responseType.toLowerCase();
          xhr.responseType = responseType !== "json" ? responseType : "text";
        }
        const reqBody = req.serializeBody();
        let headerResponse = null;
        const partialFromXhr = () => {
          if (headerResponse !== null) {
            return headerResponse;
          }
          const status = xhr.status === 1223 ? 204 : xhr.status;
          const statusText = xhr.statusText || "OK";
          const headers = new HttpHeaders(xhr.getAllResponseHeaders());
          const url = getResponseUrl(xhr) || req.url;
          headerResponse = new HttpHeaderResponse({ headers, status, statusText, url });
          return headerResponse;
        };
        const onLoad = () => {
          let { headers, status, statusText, url } = partialFromXhr();
          let body = null;
          if (status !== 204) {
            body = typeof xhr.response === "undefined" ? xhr.responseText : xhr.response;
          }
          if (status === 0) {
            status = !!body ? 200 : 0;
          }
          let ok = status >= 200 && status < 300;
          if (req.responseType === "json" && typeof body === "string") {
            const originalBody = body;
            body = body.replace(XSSI_PREFIX, "");
            try {
              body = body !== "" ? JSON.parse(body) : null;
            } catch (error3) {
              body = originalBody;
              if (ok) {
                ok = false;
                body = { error: error3, text: body };
              }
            }
          }
          if (ok) {
            observer.next(new HttpResponse({
              body,
              headers,
              status,
              statusText,
              url: url || void 0
            }));
            observer.complete();
          } else {
            observer.error(new HttpErrorResponse({
              error: body,
              headers,
              status,
              statusText,
              url: url || void 0
            }));
          }
        };
        const onError = (error3) => {
          const { url } = partialFromXhr();
          const res = new HttpErrorResponse({
            error: error3,
            status: xhr.status || 0,
            statusText: xhr.statusText || "Unknown Error",
            url: url || void 0
          });
          observer.error(res);
        };
        let sentHeaders = false;
        const onDownProgress = (event) => {
          if (!sentHeaders) {
            observer.next(partialFromXhr());
            sentHeaders = true;
          }
          let progressEvent = {
            type: HttpEventType.DownloadProgress,
            loaded: event.loaded
          };
          if (event.lengthComputable) {
            progressEvent.total = event.total;
          }
          if (req.responseType === "text" && !!xhr.responseText) {
            progressEvent.partialText = xhr.responseText;
          }
          observer.next(progressEvent);
        };
        const onUpProgress = (event) => {
          let progress = {
            type: HttpEventType.UploadProgress,
            loaded: event.loaded
          };
          if (event.lengthComputable) {
            progress.total = event.total;
          }
          observer.next(progress);
        };
        xhr.addEventListener("load", onLoad);
        xhr.addEventListener("error", onError);
        xhr.addEventListener("timeout", onError);
        xhr.addEventListener("abort", onError);
        if (req.reportProgress) {
          xhr.addEventListener("progress", onDownProgress);
          if (reqBody !== null && xhr.upload) {
            xhr.upload.addEventListener("progress", onUpProgress);
          }
        }
        xhr.send(reqBody);
        observer.next({ type: HttpEventType.Sent });
        return () => {
          xhr.removeEventListener("error", onError);
          xhr.removeEventListener("abort", onError);
          xhr.removeEventListener("load", onLoad);
          xhr.removeEventListener("timeout", onError);
          if (req.reportProgress) {
            xhr.removeEventListener("progress", onDownProgress);
            if (reqBody !== null && xhr.upload) {
              xhr.upload.removeEventListener("progress", onUpProgress);
            }
          }
          if (xhr.readyState !== xhr.DONE) {
            xhr.abort();
          }
        };
      });
    }
  };
  HttpXhrBackend.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HttpXhrBackend, deps: [{ token: XhrFactory }], target: FactoryTarget.Injectable });
  HttpXhrBackend.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HttpXhrBackend });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HttpXhrBackend, decorators: [{
    type: Injectable
  }], ctorParameters: function() {
    return [{ type: XhrFactory }];
  } });
  var XSRF_COOKIE_NAME = new InjectionToken("XSRF_COOKIE_NAME");
  var XSRF_HEADER_NAME = new InjectionToken("XSRF_HEADER_NAME");
  var HttpXsrfTokenExtractor = class {
  };
  var HttpXsrfCookieExtractor = class {
    constructor(doc, platform, cookieName) {
      this.doc = doc;
      this.platform = platform;
      this.cookieName = cookieName;
      this.lastCookieString = "";
      this.lastToken = null;
      this.parseCount = 0;
    }
    getToken() {
      if (this.platform === "server") {
        return null;
      }
      const cookieString = this.doc.cookie || "";
      if (cookieString !== this.lastCookieString) {
        this.parseCount++;
        this.lastToken = parseCookieValue(cookieString, this.cookieName);
        this.lastCookieString = cookieString;
      }
      return this.lastToken;
    }
  };
  HttpXsrfCookieExtractor.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HttpXsrfCookieExtractor, deps: [{ token: DOCUMENT2 }, { token: PLATFORM_ID }, { token: XSRF_COOKIE_NAME }], target: FactoryTarget.Injectable });
  HttpXsrfCookieExtractor.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HttpXsrfCookieExtractor });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HttpXsrfCookieExtractor, decorators: [{
    type: Injectable
  }], ctorParameters: function() {
    return [{ type: void 0, decorators: [{
      type: Inject,
      args: [DOCUMENT2]
    }] }, { type: void 0, decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }] }, { type: void 0, decorators: [{
      type: Inject,
      args: [XSRF_COOKIE_NAME]
    }] }];
  } });
  var HttpXsrfInterceptor = class {
    constructor(tokenService, headerName) {
      this.tokenService = tokenService;
      this.headerName = headerName;
    }
    intercept(req, next) {
      const lcUrl = req.url.toLowerCase();
      if (req.method === "GET" || req.method === "HEAD" || lcUrl.startsWith("http://") || lcUrl.startsWith("https://")) {
        return next.handle(req);
      }
      const token = this.tokenService.getToken();
      if (token !== null && !req.headers.has(this.headerName)) {
        req = req.clone({ headers: req.headers.set(this.headerName, token) });
      }
      return next.handle(req);
    }
  };
  HttpXsrfInterceptor.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HttpXsrfInterceptor, deps: [{ token: HttpXsrfTokenExtractor }, { token: XSRF_HEADER_NAME }], target: FactoryTarget.Injectable });
  HttpXsrfInterceptor.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HttpXsrfInterceptor });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HttpXsrfInterceptor, decorators: [{
    type: Injectable
  }], ctorParameters: function() {
    return [{ type: HttpXsrfTokenExtractor }, { type: void 0, decorators: [{
      type: Inject,
      args: [XSRF_HEADER_NAME]
    }] }];
  } });
  var HttpInterceptingHandler = class {
    constructor(backend, injector) {
      this.backend = backend;
      this.injector = injector;
      this.chain = null;
    }
    handle(req) {
      if (this.chain === null) {
        const interceptors = this.injector.get(HTTP_INTERCEPTORS, []);
        this.chain = interceptors.reduceRight((next, interceptor) => new HttpInterceptorHandler(next, interceptor), this.backend);
      }
      return this.chain.handle(req);
    }
  };
  HttpInterceptingHandler.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HttpInterceptingHandler, deps: [{ token: HttpBackend }, { token: Injector }], target: FactoryTarget.Injectable });
  HttpInterceptingHandler.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HttpInterceptingHandler });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HttpInterceptingHandler, decorators: [{
    type: Injectable
  }], ctorParameters: function() {
    return [{ type: HttpBackend }, { type: Injector }];
  } });
  function jsonpCallbackContext() {
    if (typeof window === "object") {
      return window;
    }
    return {};
  }
  var HttpClientXsrfModule = class {
    static disable() {
      return {
        ngModule: HttpClientXsrfModule,
        providers: [
          { provide: HttpXsrfInterceptor, useClass: NoopInterceptor }
        ]
      };
    }
    static withOptions(options = {}) {
      return {
        ngModule: HttpClientXsrfModule,
        providers: [
          options.cookieName ? { provide: XSRF_COOKIE_NAME, useValue: options.cookieName } : [],
          options.headerName ? { provide: XSRF_HEADER_NAME, useValue: options.headerName } : []
        ]
      };
    }
  };
  HttpClientXsrfModule.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HttpClientXsrfModule, deps: [], target: FactoryTarget.NgModule });
  HttpClientXsrfModule.\u0275mod = \u0275\u0275ngDeclareNgModule({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HttpClientXsrfModule });
  HttpClientXsrfModule.\u0275inj = \u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HttpClientXsrfModule, providers: [
    HttpXsrfInterceptor,
    { provide: HTTP_INTERCEPTORS, useExisting: HttpXsrfInterceptor, multi: true },
    { provide: HttpXsrfTokenExtractor, useClass: HttpXsrfCookieExtractor },
    { provide: XSRF_COOKIE_NAME, useValue: "XSRF-TOKEN" },
    { provide: XSRF_HEADER_NAME, useValue: "X-XSRF-TOKEN" }
  ] });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HttpClientXsrfModule, decorators: [{
    type: NgModule,
    args: [{
      providers: [
        HttpXsrfInterceptor,
        { provide: HTTP_INTERCEPTORS, useExisting: HttpXsrfInterceptor, multi: true },
        { provide: HttpXsrfTokenExtractor, useClass: HttpXsrfCookieExtractor },
        { provide: XSRF_COOKIE_NAME, useValue: "XSRF-TOKEN" },
        { provide: XSRF_HEADER_NAME, useValue: "X-XSRF-TOKEN" }
      ]
    }]
  }] });
  var HttpClientModule = class {
  };
  HttpClientModule.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HttpClientModule, deps: [], target: FactoryTarget.NgModule });
  HttpClientModule.\u0275mod = \u0275\u0275ngDeclareNgModule({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HttpClientModule, imports: [HttpClientXsrfModule] });
  HttpClientModule.\u0275inj = \u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HttpClientModule, providers: [
    HttpClient,
    { provide: HttpHandler, useClass: HttpInterceptingHandler },
    HttpXhrBackend,
    { provide: HttpBackend, useExisting: HttpXhrBackend }
  ], imports: [[
    HttpClientXsrfModule.withOptions({
      cookieName: "XSRF-TOKEN",
      headerName: "X-XSRF-TOKEN"
    })
  ]] });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HttpClientModule, decorators: [{
    type: NgModule,
    args: [{
      imports: [
        HttpClientXsrfModule.withOptions({
          cookieName: "XSRF-TOKEN",
          headerName: "X-XSRF-TOKEN"
        })
      ],
      providers: [
        HttpClient,
        { provide: HttpHandler, useClass: HttpInterceptingHandler },
        HttpXhrBackend,
        { provide: HttpBackend, useExisting: HttpXhrBackend }
      ]
    }]
  }] });
  var HttpClientJsonpModule = class {
  };
  HttpClientJsonpModule.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HttpClientJsonpModule, deps: [], target: FactoryTarget.NgModule });
  HttpClientJsonpModule.\u0275mod = \u0275\u0275ngDeclareNgModule({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HttpClientJsonpModule });
  HttpClientJsonpModule.\u0275inj = \u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HttpClientJsonpModule, providers: [
    JsonpClientBackend,
    { provide: JsonpCallbackContext, useFactory: jsonpCallbackContext },
    { provide: HTTP_INTERCEPTORS, useClass: JsonpInterceptor, multi: true }
  ] });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HttpClientJsonpModule, decorators: [{
    type: NgModule,
    args: [{
      providers: [
        JsonpClientBackend,
        { provide: JsonpCallbackContext, useFactory: jsonpCallbackContext },
        { provide: HTTP_INTERCEPTORS, useClass: JsonpInterceptor, multi: true }
      ]
    }]
  }] });

  // node_modules/@angular/common/fesm2020/http/testing.mjs
  var HttpTestingController = class {
  };
  var TestRequest = class {
    constructor(request, observer) {
      this.request = request;
      this.observer = observer;
      this._cancelled = false;
    }
    get cancelled() {
      return this._cancelled;
    }
    flush(body, opts = {}) {
      if (this.cancelled) {
        throw new Error(`Cannot flush a cancelled request.`);
      }
      const url = this.request.urlWithParams;
      const headers = opts.headers instanceof HttpHeaders ? opts.headers : new HttpHeaders(opts.headers);
      body = _maybeConvertBody(this.request.responseType, body);
      let statusText = opts.statusText;
      let status = opts.status !== void 0 ? opts.status : 200;
      if (opts.status === void 0) {
        if (body === null) {
          status = 204;
          statusText = statusText || "No Content";
        } else {
          statusText = statusText || "OK";
        }
      }
      if (statusText === void 0) {
        throw new Error("statusText is required when setting a custom status.");
      }
      if (status >= 200 && status < 300) {
        this.observer.next(new HttpResponse({ body, headers, status, statusText, url }));
        this.observer.complete();
      } else {
        this.observer.error(new HttpErrorResponse({ error: body, headers, status, statusText, url }));
      }
    }
    error(error3, opts = {}) {
      if (this.cancelled) {
        throw new Error(`Cannot return an error for a cancelled request.`);
      }
      if (opts.status && opts.status >= 200 && opts.status < 300) {
        throw new Error(`error() called with a successful status.`);
      }
      const headers = opts.headers instanceof HttpHeaders ? opts.headers : new HttpHeaders(opts.headers);
      this.observer.error(new HttpErrorResponse({
        error: error3,
        headers,
        status: opts.status || 0,
        statusText: opts.statusText || "",
        url: this.request.urlWithParams
      }));
    }
    event(event) {
      if (this.cancelled) {
        throw new Error(`Cannot send events to a cancelled request.`);
      }
      this.observer.next(event);
    }
  };
  function _toArrayBufferBody(body) {
    if (typeof ArrayBuffer === "undefined") {
      throw new Error("ArrayBuffer responses are not supported on this platform.");
    }
    if (body instanceof ArrayBuffer) {
      return body;
    }
    throw new Error("Automatic conversion to ArrayBuffer is not supported for response type.");
  }
  function _toBlob(body) {
    if (typeof Blob === "undefined") {
      throw new Error("Blob responses are not supported on this platform.");
    }
    if (body instanceof Blob) {
      return body;
    }
    if (ArrayBuffer && body instanceof ArrayBuffer) {
      return new Blob([body]);
    }
    throw new Error("Automatic conversion to Blob is not supported for response type.");
  }
  function _toJsonBody(body, format = "JSON") {
    if (typeof ArrayBuffer !== "undefined" && body instanceof ArrayBuffer) {
      throw new Error(`Automatic conversion to ${format} is not supported for ArrayBuffers.`);
    }
    if (typeof Blob !== "undefined" && body instanceof Blob) {
      throw new Error(`Automatic conversion to ${format} is not supported for Blobs.`);
    }
    if (typeof body === "string" || typeof body === "number" || typeof body === "object" || typeof body === "boolean" || Array.isArray(body)) {
      return body;
    }
    throw new Error(`Automatic conversion to ${format} is not supported for response type.`);
  }
  function _toTextBody(body) {
    if (typeof body === "string") {
      return body;
    }
    if (typeof ArrayBuffer !== "undefined" && body instanceof ArrayBuffer) {
      throw new Error("Automatic conversion to text is not supported for ArrayBuffers.");
    }
    if (typeof Blob !== "undefined" && body instanceof Blob) {
      throw new Error("Automatic conversion to text is not supported for Blobs.");
    }
    return JSON.stringify(_toJsonBody(body, "text"));
  }
  function _maybeConvertBody(responseType, body) {
    if (body === null) {
      return null;
    }
    switch (responseType) {
      case "arraybuffer":
        return _toArrayBufferBody(body);
      case "blob":
        return _toBlob(body);
      case "json":
        return _toJsonBody(body);
      case "text":
        return _toTextBody(body);
      default:
        throw new Error(`Unsupported responseType: ${responseType}`);
    }
  }
  var HttpClientTestingBackend = class {
    constructor() {
      this.open = [];
    }
    handle(req) {
      return new Observable((observer) => {
        const testReq = new TestRequest(req, observer);
        this.open.push(testReq);
        observer.next({ type: HttpEventType.Sent });
        return () => {
          testReq._cancelled = true;
        };
      });
    }
    _match(match2) {
      if (typeof match2 === "string") {
        return this.open.filter((testReq) => testReq.request.urlWithParams === match2);
      } else if (typeof match2 === "function") {
        return this.open.filter((testReq) => match2(testReq.request));
      } else {
        return this.open.filter((testReq) => (!match2.method || testReq.request.method === match2.method.toUpperCase()) && (!match2.url || testReq.request.urlWithParams === match2.url));
      }
    }
    match(match2) {
      const results = this._match(match2);
      results.forEach((result) => {
        const index = this.open.indexOf(result);
        if (index !== -1) {
          this.open.splice(index, 1);
        }
      });
      return results;
    }
    expectOne(match2, description) {
      description = description || this.descriptionFromMatcher(match2);
      const matches = this.match(match2);
      if (matches.length > 1) {
        throw new Error(`Expected one matching request for criteria "${description}", found ${matches.length} requests.`);
      }
      if (matches.length === 0) {
        let message = `Expected one matching request for criteria "${description}", found none.`;
        if (this.open.length > 0) {
          const requests = this.open.map((testReq) => {
            const url = testReq.request.urlWithParams;
            const method = testReq.request.method;
            return `${method} ${url}`;
          }).join(", ");
          message += ` Requests received are: ${requests}.`;
        }
        throw new Error(message);
      }
      return matches[0];
    }
    expectNone(match2, description) {
      description = description || this.descriptionFromMatcher(match2);
      const matches = this.match(match2);
      if (matches.length > 0) {
        throw new Error(`Expected zero matching requests for criteria "${description}", found ${matches.length}.`);
      }
    }
    verify(opts = {}) {
      let open = this.open;
      if (opts.ignoreCancelled) {
        open = open.filter((testReq) => !testReq.cancelled);
      }
      if (open.length > 0) {
        const requests = open.map((testReq) => {
          const url = testReq.request.urlWithParams.split("?")[0];
          const method = testReq.request.method;
          return `${method} ${url}`;
        }).join(", ");
        throw new Error(`Expected no open requests, found ${open.length}: ${requests}`);
      }
    }
    descriptionFromMatcher(matcher) {
      if (typeof matcher === "string") {
        return `Match URL: ${matcher}`;
      } else if (typeof matcher === "object") {
        const method = matcher.method || "(any)";
        const url = matcher.url || "(any)";
        return `Match method: ${method}, URL: ${url}`;
      } else {
        return `Match by function: ${matcher.name}`;
      }
    }
  };
  HttpClientTestingBackend.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HttpClientTestingBackend, deps: [], target: FactoryTarget.Injectable });
  HttpClientTestingBackend.\u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HttpClientTestingBackend });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HttpClientTestingBackend, decorators: [{
    type: Injectable
  }] });
  var HttpClientTestingModule = class {
  };
  HttpClientTestingModule.\u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HttpClientTestingModule, deps: [], target: FactoryTarget.NgModule });
  HttpClientTestingModule.\u0275mod = \u0275\u0275ngDeclareNgModule({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HttpClientTestingModule, imports: [HttpClientModule] });
  HttpClientTestingModule.\u0275inj = \u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HttpClientTestingModule, providers: [
    HttpClientTestingBackend,
    { provide: HttpBackend, useExisting: HttpClientTestingBackend },
    { provide: HttpTestingController, useExisting: HttpClientTestingBackend }
  ], imports: [[
    HttpClientModule
  ]] });
  \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.3", ngImport: core_exports, type: HttpClientTestingModule, decorators: [{
    type: NgModule,
    args: [{
      imports: [
        HttpClientModule
      ],
      providers: [
        HttpClientTestingBackend,
        { provide: HttpBackend, useExisting: HttpClientTestingBackend },
        { provide: HttpTestingController, useExisting: HttpClientTestingBackend }
      ]
    }]
  }] });

  // src/app/app.component.html
  var app_component_default = '<div class="container mt-5">\r\n  <div class="row row-cols-1 row-cols-md-3 row-cols-lg-5">\r\n    <div *ngFor="let user of userList$ | async" class="col">\r\n      <div class="card mt-4 mb-1 pb-5" style="height: 90%;">\r\n        <div class="card-body">\r\n          <h4 class="card-title">{{ user.name }}</h4>\r\n          <p class="card-text">ID: {{ user.id }}</p>\r\n          <p class="card-text">Email: {{ user.email }}</p>\r\n          <p class="card-text">Cat.: {{ user.category }}</p>\r\n          <button (click)="onDelete(user)" class="btn btn-warning">\r\n            <i class="fa fa-trash"></i> Delete\r\n          </button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n';

  // src/app/service/user.service.ts
  var UserService = class {
    constructor(http) {
      this.http = http;
      this.apiUrl = "https://nettuts.hu/jms/lidiaCserko/users";
    }
    getAll() {
      return this.http.get(`${this.apiUrl}`);
    }
    get(id) {
      return this.http.get(`${this.apiUrl}/${id}`);
    }
    create(entity) {
      return this.http.post(`${this.apiUrl}`, entity);
    }
    update(entity) {
      return this.http.patch(`${this.apiUrl}/${entity.id}`, entity);
    }
    delete(id) {
      return this.http.delete(`${this.apiUrl}/${id}`);
    }
  };
  UserService = __decorateClass([
    Injectable({
      providedIn: "root"
    }),
    __decorateParam(0, Inject(HttpClient))
  ], UserService);

  // src/app/app.component.ts
  var AppComponent = class {
    constructor(userService) {
      this.userService = userService;
      this.title = "angular-users-project";
      this.userList$ = this.userService.getAll();
    }
    onDelete(user) {
      this.userService.delete(user.id).subscribe({
        next: () => this.userList$ = this.userService.getAll(),
        error: (err) => console.error(err),
        complete: () => {
        }
      });
    }
  };
  AppComponent = __decorateClass([
    Component({
      selector: "app-root",
      template: app_component_default || "",
      styles: [`

/* file: C:Usersevelin.szarkaDownloadskepesitostr2-state-exam-01angular-users-projectsrcappapp.component.scss */
.card {
  border-radius: 5px;
  border: 2px solid #b6b6e6;
  background-color: #cadbdb;
}
.card .btn-warning {
  position: absolute;
  bottom: 1em;
  left: 1em;
  right: 1em;
}`]
    }),
    __decorateParam(0, Inject(UserService))
  ], AppComponent);

  // src/tests/mock.users.ts
  var users = [{ "id": 1, "name": "Bedford", "email": "cbedford0@symantec.com", "category": "Guest" }, { "id": 2, "name": "Hasheem Wintle", "email": "hwintle1@ow.ly", "category": "Editor" }, { "id": 3, "name": "Amaleta Licence", "email": "alicence2@example.com", "category": "Guest" }, { "id": 4, "name": "Titus Boulding", "email": "tboulding3@jigsy.com", "category": "Guest" }, { "id": 5, "name": "Gerti Steffans", "email": "gsteffans4@slashdot.org", "category": "Admin" }, { "id": 6, "name": "Sylvester Baugh", "email": "sbaugh5@over-blog.com", "category": "Guest" }, { "id": 7, "name": "Benita McCusker", "email": "bmccusker63@jijij.ijij", "category": "Admin" }, { "id": 8, "name": "Cecelia Tarney", "email": "ctarney7@yandex.rull", "category": "Admin" }, { "id": 9, "name": "Trude Danser", "email": "tdanser8@omniture.com", "category": "Admin" }, { "id": 10, "name": "Burk Jeduch", "email": "bjeduch9@ezinearticles.com", "category": "Editor" }, { "id": 11, "name": "Roth Grenter", "email": "rgrentera@goo.ne.jp", "category": "Editor" }, { "id": 12, "name": "Donnell Sissons", "email": "dsissonsb@weather.com", "category": "Editor" }, { "id": 13, "name": "Hillary Withers", "email": "hwithersc@zdnet.com", "category": "Guest" }];

  // src/tests/test43.spec.ts
  getTestBed().initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting());
  var getPrivateProperty = (instance, propName) => {
    return Object.getOwnPropertyDescriptors(instance)[propName]?.value;
  };
  describe("AppComponent", () => {
    let fixture;
    let app;
    beforeEach(async () => {
      await TestBed.configureTestingModule({
        imports: [
          RouterTestingModule,
          HttpClientTestingModule
        ],
        declarations: [
          AppComponent
        ],
        providers: [
          {
            provide: UserService,
            useValue: {
              getAll() {
                return of(users);
              },
              delete() {
                return of(users[0]);
              }
            }
          }
        ]
      }).compileComponents();
    });
    beforeEach(() => {
      fixture = TestBed.createComponent(AppComponent);
      app = fixture.componentInstance;
      expect(app).toBeTruthy();
    });
    it("should create the app", () => {
      expect(app).toBeTruthy();
    });
    it("the borderRadius of cards should be correct", async () => {
      fixture.detectChanges();
      const card = fixture.debugElement.nativeElement.querySelector(".card");
      const cardStyles = window.getComputedStyle(card);
      await fixture.whenStable();
      expect(cardStyles.borderRadius).toBe("5px");
    });
    it("the border of cards should be correct", async () => {
      fixture.detectChanges();
      const card = fixture.debugElement.nativeElement.querySelector(".card");
      const cardStyles = window.getComputedStyle(card);
      await fixture.whenStable();
      expect(cardStyles.border).toBe("2px solid #b6b6e6");
    });
  });
})();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @license Angular v13.0.3
 * (c) 2010-2021 Google LLC. https://angular.io/
 * License: MIT
 */
/**
 * @license Angular v14.0.0-next.5
 * (c) 2010-2022 Google LLC. https://angular.io/
 * License: MIT
 */
